*** PROJECT PLAN for ROSE ***

   Subjects representing in this plan are taken from Table 6-1 on page 81
of McConnell's book "SOFTWARE PROJECT: Survival Guide"

I. CHANGE CONTROL PLAN:
     This is a description of the Change Control Plan for this project:

     Changes are checked in through final approval by Dan Quinlan.


II. TOP 10 RISKS:
     This document identifies the top 10 risks associated with this project:

     1) Support of SAGE

     2) Robustness of the distribution of binaries for the EDG C++ front end

     3) The extensibility of the abstraction recognition mechanism (based on generation of grammars)

     4) The design of the transformation specification mechanism

III. CHANGE PROPOSALS
     Change Proposals should be submitted by email to dquinlan@llnl.gov.  
     
     Currently the ROSE project is in the prototype stage and is incomplete.


IV.  VISION STATEMENT

     The principle vision is to provide a simple mechanism that library writers can use to develop
     an optimization tool that application writers can use to optimize the performance of their applications
     which use the libraries.  The need for such a mechanism as we propose stems from the inability of
     C++ compilers to optimized the interaction of user defined abstractions.  Meaningful scientific software
     in the future can be expected to only be of sufficient complexity as to be tractable only thoough
     the expression through the interaction of high level abstractions.

     This project is focused upon the development of a mechanism to permit any object-oriented
     application to be optimized in relatively abritrary ways.  The focus is:
     1) A general focus has been the optimization of scientific applications.  
     2) A particular focus has been the development of cache based transformations for scientific computing.  
     3) A specific focus is on the optimization of Overture and another object-oriented framework at LLNL.


V.   SOFTWARE DEVELOPMENT PLAN

     The development plan for ROSE addresses the 4 technically difficult areas associated the
     the development of an optimization tool for general use.

     1) Robustness:
          Must address the complete C++ language
          Must work with any application code
          Must permit a broad range for different types of transformations

     2) Ease of Use (Performance):
           Must be fast enough to use so that it is transparent to application development
           Must be able to specify an optimization and develop a coresponding preprocessor
           in a few hours.  I.e. is should be particularly simple to introduce optimizations.

     3) Optional:
           The use of any preprocessor built using ROSE should be completetly optional so that
           it does not interfere with the application development process.

     4) Research:
           The software development is firstmost a research project to define new approaches
           for the optimization of object-oriented applications.


VI.  USER INTERFACE PROTOTYPE

     The current version that can be checked out from the ROSE CVS repository represents the 
     expected interface for ROSE (for an application user).  The design of the interface for
     the development of the preprocessor by the library developer is the subject of current
     work (though mostly complete and well defined).

     Application developer interface:
        A++/P++ preprocessor serves as an example of the application interface.

     Library developer interface:
        Current work!

VII. User Manual/Requirements Specification

IX.  Quality Assurance Plan
     We insure quality in our research software by:
     1) Making gradual (incremental) internal releases
     2) Developing many test programs (commonly one per bug fix, or main feature within the project)
     3) Making it easy to test the releases against all test codes
     4) We fix bugs aggressively and test the fixes with the development of test codes

X.   Software Architecture
     The software architecture of ROSE is devided into two pieces:
        1) the development of a mechanism to recognise where a transformation can be introduced
        2) the specification of the transformation that will be introduced

XI.  Software Integration Plan   

     We will have to integrate newer releases of the EDG C++ front end into the SAGE source code.
     This step will be simplified since we generate the SAGE source code internally.  This step
     will be required to provide full C++ language support to ROSE.


XII. Staged Delivery Plan


XIII Individual Stage Plans
     This includes private milestone schedules

XIV  Coding Standard
     Follows Overture Coding Standard (an unwritten policy)

XV   Software Test Cases
     Several example programs are included in the current CVS distribution

XVI  Source Code
     All source code required to build the ROSE optimizing preprocessor infrastructure
     is included in the CVS repository.  However, both EDG and SAGE were developed separately.
     Future versions will not include a copy of SAGE since we now use a modified version of 
     SAGE (with permission) and generate the SAGE source code internally. EDG will remain
     an external piece of the ROSE infrastructure, we don't wish to duplicate this level of
     internal compiler infrastructure.  

XVII Software Build Instructions

     ROSE uses the AutoConf and AutoMake tools from GNU to control the build process and
     simplify this process across different architectures.

XVIII Detailed Design Document

     This is a separate document in this directory on in the document (docs) directory.

XIX  Software Project Log
     Automatically generated by CVS (once we figure this process out).

XX   Software Project History

This project was originally concieved by Dan Quinlan in 1994 as a
result of a talk at OON'SKI 94.  In this talk the SAGE I C++ and
FORTRAN source code restructuring tool was presented.  Further
collaboration with Beata ??? and Rebecca Parsons generated some
initial attempts at testing the preprocessor approach.  The
collaborations was short, but Quinlan continued to work on the details
of the approach and an implementation of a prototype code to
demonstrate the ideas.  Kei Davis formed a part of the collaboration
much later in 1998 while Quinlan was at Los Alamos.  ROSE mostly
benifeted from rich discussions over the goals and possible approaches
to numerous technical details.  Quinlan continued to work on ROSE
after moving to LLNL in late 1998.  Bobby Philps helped with the
implementation of lower level internal parts of ROSE early in 1999.
ROSE has benifited from much discussion over the approach and internal
design with Bill Henshaw over several years while at LANL and LLNL and
with Bobby Philips at LLNL (when we were not working on AMR++).




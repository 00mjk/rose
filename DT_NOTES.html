<html>
<head>
<title>NOTES -- Danny Thorne (1/31/2000 - 8/18/2000)</title>
</head>
<body>

<a name="TOP"><b>NOTES -- Danny Thorne (1/31/2000 - 8/18/2000)</b>
<br><br>
<i>Following is an outline and description of my activities
and accomplishments during the Spring and Summer of 2000.  The
descriptions will be as elaborate as I can manage.  I'm compiling
information into this document intermittently during the 
hectic last three days of my stay here.  Note that I've included 
quite a bit of commentary within the ROSE/SAGE/EDG codes themselves 
also.</i>

<ul>
<li> Index
  <ol> 
  <li> <a href="#TAG1">New functionality</a>
  <li> <a href="#TAG2">New #define directives</a>
  <li> <a href="#TAG3">New run-time options</a>
  <li> <a href="#TAG4">Bug fixes</a>
  <li> <a href="#TAG5">TODO</a>
  <li> <a href="#TAG6">Miscellany</a>
  </ol>
</ul>

<hr>

<ol>
<li><a name="TAG1"><pre>New functionality <a href="#TOP">[TOP]</a></pre>
  <ol>
  <li><pre>
Can link both the EDG C++ backend and SAGE backend simultaneously.  Added
run-time parameters (see below) to ROSE for enabling and disabling either
backend independently of the other. 
<a name="TAG11BACK">(See <a href="#TAG11">TAG11</a> below for more.)</pre>
  <li><pre>
Modified the unparser to unparse #included files.
<a name="TAG12BACK">(See <a href="#TAG12">TAG12</a> below for more.)</pre>
  <li><pre>
Developed a "preinit stage" in SAGE.  The purpose of the preinit stage is
to make sure all sage_symbol_ptr and sage_type_ptr fields in the IL tree
are initialized before the call to sage_back_end().
<a name="TAG13BACK">(See <a href="#TAG13">TAG13</a> below for more.)</pre>
  <li><pre>
Modified SAGE to included template arguments and parameters.  These are 
stored in the SgName class.  In order for SAGE to have access to the
template parameters, EDG had to be modified to store them in the IL tree.
Previously it was only storing template arguments in the IL tree.
<a name="TAG14BACK">(See <a href="#TAG14">TAG14</a> below for more.)</pre>
  <li><pre>
Made the following change in cmd_lind.h:

   EXTERN a_template_instantiation_mode
                   instantiation_mode
   #if VAR_INITIALIZERS
     #if BACK_END_IS_SAGE_GEN_BE
     /*
     // [DT] This will ensure that SAGE gets all the stuff that
     //      comes from templates and hence ROSE will then be
     //      able to unparse all the original template declaration
     //      stuff, even if some of it is not used by the given code.
     */
   			          = tim_all /* [DT] 4/21/2000 */
     #else /* !BACK_END_IS_SAGE_GEN_BE */
   			          = tim_none
     #endif /* BACK_END_IS_SAGE_GEN_BE */
   #endif /* VAR_INITIALIZERS */

where originally there was just this:

   EXTERN a_template_instantiation_mode
                   instantiation_mode
   #if VAR_INITIALIZERS
   			          = tim_none
   #endif /* VAR_INITIALIZERS */

This flag is referenced mainly in templates.c, particularly in the
function should_be_instantiated().</pre>
  </ol>

<li><a name="TAG2"><pre>New #define directives <a href="#TOP">[TOP]</a></pre>
  <ol>
  <li><pre>
PREINIT_IL
   Defined in 
      ROSE/EDG/src/sage_gen_be.C.</pre>
  <li><pre>
PREINIT_VERBOSE
   Defined in 
      ROSE/EDG/src/sage_gen_be.C.</pre>
  <li><pre>
MAX_PREINIT_PASSES
   Defined in
      ROSE/EDG/src/sage_gen_be.C.</pre>
  <li><pre>
END_PREINIT_ON_LACK_OF_PROGRESS
   Defined in
      ROSE/EDG/src/sage_gen_be.C.</pre>
  <li><pre>
TEMPLATE_INSTANTIATIONS_IN_SAGE
   Defined in 
      ROSE/EDG/src/sage_gen_be.C, and
      ROSE/EDG/src/sage_il_to_str.C.</pre>
  <li><pre>
FACILITATE_PREINIT_IN_EXISTING_SAGE_ROUTINES
   Defined in
      ROSE/EDG/src/sage_gen_be.C,
      ROSE/EDG/src/sage_il_to_str.C, and
      ROSE/EDG/src/il_to_str.h.</pre>
  <li><pre>
PREINITIALIZE_SAGE_ITEMS_IN_IL
   Defined in
      ROSE/EDG/src/cfe.c</pre>
  <li><pre>
UNPARSE_TEMPLATES
   Defined in 
      ROSE/src/unparser/unparser.h</pre>
  <li><pre>
UNPARSER_VERBOSE
   Defined in
      ROSE/src/unparser/unparser.h</pre>
  </ol>

<li><a name="TAG3"><pre>New run-time options <a href="#TOP">[TOP]</a></pre>
  <ol>
  <li><pre>
-enable_sage_backend     
   Have EDG call the sage backend.</pre>
  <li><pre>
-disable_sage_backend    
   Prevent EDG from calling the sage backend.</pre> 
  <li><pre>
-enable_cp_backend       
   Have EDG call the cp backend.</pre>
  <li><pre>
-disable_cp_backend      
   prevent EDG from calling the cp backend </pre>
  <li><pre>
-preinit_il              
   Do a preinit stage between the front-end and 
   the backend.  (See sage_preinit_il() in sage_gen_be.C.)  </pre>
  </ol>

<li><a name="TAG4"><pre>Bug fixes <a href="#TOP">[TOP]</a></pre>
  <ol>
  <li><pre>Unparsing of overloaded operators.</pre>
  <li><pre>
Accident in sage_gen_routine_decl() and sage_gen_variable_decl().
  if(sageAccessSpecifier!=0)
  {
    //
    // [DT] (3/2/2000) THE FOLLOWING IS A BIG PROBLEM !!
    //
    // XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
    // result->set_decl_attributes(sageAccessSpecifier); 
    // XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
    //
    // set_decl_attributes() will clobber anything else that is
    // currently stored in the p_decl_attributes field.
    // We really just want to turn on the one bit
    // associated with the access specifier.
    //
    // [DT] CORRECTION: 
    //
    result->setBit(sageAccessSpecifier);
  }
NOTE: We've commented out the set_decl_attributes() member
stuff from SgDeclarationStatement in ROSETTA.

Note, also, that the symptoms of this bug were seen when unparsing
class declarations.  All of the ROSE test codes in the repository 
at the time have class declarations only in ".h" files which, at 
that point in the development of ROSE, were ignored by the unparser, 
so it's not surprising that the bug went unnoticed until now.</pre>
  </ol>

<li><a name="TAG5"><pre>TODO <a href="#TOP">[TOP]</a></pre>
  <ol>
  <li><pre>
Modify type reuse in EDG so that the substituted_for_template_param
field will work.
<a name="TAG51BACK">(See <a href="#TAG51">TAG51</a> below for more.)</pre>
  <li><pre>
Centralize the #defines associated with the preinit stage and the
handling of templates in SAGE.</pre>
  <li><pre>
Move the preinit stage from sage_gen_be.C into a separate file --
probably, the file should be named sage_preinit_il.C. Following
are some issues relavent to that endeavour.</pre>
    <ol>
    <li><pre>
Static file-scope entities in sage_gen_be.C.  Need to change that
if we want the preinit stage to be able to access some of those
entities from sage_preinit_il.C (like curr_source_sequence_entry).  
Doing so gives rise to the next issue.</pre>
    <li><pre>
Naming convention.  File-scope entities in sage_gen_be.C (and
sage_preinit_il.C) may conflict with entities in cp_gen_be.C if
their static property is removed.  Need every file-scope entity 
in SAGE to be prefixed with "sage_", probably.  </pre>
    </ol>
  <li><pre>
Expressions (constants) as template args/params.</pre>
  <li><pre>
Function templates.</pre>
  <li><pre>
The global scope resolution operator isn't always handled correctly
in the unparser.</pre>
  <li><pre>
The unparser doesn't always unparse the "this" keyword when it
should.  NOTE: Both of these bugs (the "this" keyword and the
global scope resolution operator) are manifested when unparsing
iostream.h.</pre>
  </ol>
<li><a name="TAG6"><pre>Miscellany <a href="#TOP">[TOP]</a></pre>
  <ol>
  <li><pre>
Almost everywhere that I edited the ROSE/SAGE/EDG codes, I denoted
my presence with "[DT]" in a comment, and I often included a 
date-stamp as well.</pre>
  <li><pre>
A lot of makefiles in ROSE/SAGE/EDG don't specify sufficient
dependencies.  Particularly in EDG, I've gotten into the
habit of doing a "make clean; make" whenever I change a file
other than sage_xxx.{C,h}.</pre>
  <li><pre>
The way the EDG stuff is configured in the repository is with optimization
turned on (-xO3), so you can't step through the EDG codes in a debugger
(not dbx, anyway).  I'm in the habit of removing "-xO3" from the makefile
in EDG/src after doing a new build so that when I do a "make clean; make"
in there I get unoptimized codes that the debugger can see. 
</pre>
  <li><pre>
Tidbit: sage_gen_be.C contains mainly functions called "sage_gen_xxx" and 
sage_il_to_str.C contains mainly functions called "sage_form_xxx".  Well, 
currently sage_gen_be.C contains a lot of functions called "sage_preinit_xxx"
also, but those functions should probably be move to a file called 
sage_preinit_il.C.</pre>
  <li><pre>
There's a typo in ROSETTA:
   ROSE/ROSETTA/Grammar/grammarClassDeclatationMacros.macro
                                         ^</pre>
  </ol>
</ol>

<hr>

<ul>
  <li><pre>
<a name="TAG11">TAG11 <i>Can link both the EDG C++ backend and SAGE backend simultaneously.</i> [<a href="#TAG11BACK">Back</a>]

  I won't bother discussing the mechanics of adding run-time
  flags to ROSE.  I just reproduced what was already being
  done for other run-time flags.

  In cfe.c, the following booleans

     a_boolean call_sage_backend=TRUE; 
     a_boolean call_cp_backend=FALSE; 

  are set at the top as defaults then, depending on the
  run-time parameters, these flags may be changed in the
  call to proc_command_line().

  Previously both the EDG C++ backend and the SAGE backend
  were accessed by a call to back_end() which was located
  in cp_gen_be.c or sage_gen_be.C, respectively.  There was
  no ambiguity because it was enforced that cp_gen_be.o and
  sage_gen_be.o never were linked simultaneously. Now, I've
  had to allow both the backends to be linked simultaneously,
  and to accomodate this I've changed the back_end() routine
  in sage_gen_be.C to be called sage_back_end().  Another
  way that ambiguity is avoided is that many of the file-scope
  entities in cp_gen_be.c and sage_gen_be.C are declared as
  static.  I think that it would be nicer to just enforce that
  every file-scope entity in sage_gen_be.C be prefixed with
  "sage_".  This convention would allow for the static qualifiers
  to be removed and hence would facilitate separating the
  preinit stage from sage_gen_be.C in to its own file, something
  like sage_preinit_il.C.

  Depending on the value of call_sage_backend and call_cp_backend,
  one or the other or both of the EDG C++ backend and the SAGE backend
  will be called from cfe.c. 

  As documented in the code, it is important for the call to 
  the EDG C++ backend, back_end(), be made before the calle to
  the SAGE backend, sage_back_end().  Somehow, calling SAGE before
  the EDG C++ backend has the effect of causing the EDG C++ backend
  to fail to unmangle template names where it should.
  
  Changed C_output_file_name in sage_gen_be.C to have suffix ".sage.c"
  instead of ".int.C" so that it wouldn't clobbert the output from the
  EDG C++ backend.  Note that the suffix used by EDG C++ is stored
  in GEN_C_FILE_SUFFIX which is defined in host_envir.h. [<a href="#TAG11BACK">Back</a>]</pre>

  <li><pre><a name="TAG12">TAG12 <i>Modified the unparser to unparse #included files.</i> [<a href="#TAG12BACK">Back</a>]
The unparser is managed primarily from this loop:

  while (s_iter != globalScope->end()) 
  {
    s_iter++;   
  }  

Within the loop was a check:

  while (s_iter != globalScope->end()) 
  {
    if (!strcmp(getFileName(stmt), getFileName())) 
    { 
    }
    s_iter++;
  }  

to see whether the current statement was in the "primary"
file, and the statement was skipped if it was not.

I have added an else clause:

  while (s_iter != globalScope->end()) 
  {
    if (!strcmp(getFileName(stmt), getFileName())) 
    { 
    }
    else
    {
    }
    s_iter++;
  }

where statements from "secondary" files are handled.  Secondary files are 
files that are #included from the primary file.

Unparsing statements from secondary files is handled by storing the current 
output stream and filename for the primary file and then setting the output 
stream and filename associated with the statement from the secondary file and
unparsing that statement and then restoring the output stream and filename of 
the primary file.

There is also the issue of acquiring the directives from the secondary file and 
unparsing them where appropriate.  To facilitate this, I've created a container 
class for lists of directives.  The directives for an individual file are stored 
in a ROSEAttributesList, and there is now a ROSEAttributesListContainer class 
which stores a list of ROSEAttributesLists.  See ROSE/src/rose_attributes_list.C
and ROSE/include/rose_attributes_list.h.  [<a href="#TAG12BACK">Back</a>] </pre>

  <li><pre><a name="TAG13">TAG13 <i>Developed a "preinit stage" in SAGE.</i>[<a href="#TAG13BACK">Back</a>]

Other than for the "Special note" below, I'm not going to be able to get much
down about the preinit stage.  I'm running out of time (it's Friday night as
I write this, and I need to get it checked into the repository in time for
me to get home and sleep since my flight is tomorrow morning).  Of all the 
things I've done, I think the preinit stage is the thing that you (Dan) have
seen in the most detail, probably, and I think that I don't have anything
really important to note that we haven't already discussed.  I hope I've
augmented the documentation in the code itself sufficiently well, also.

Special note:  Just today (8/18/2000, my last day)I found a bug associated with 
the preinit stage.  It has to do with a side-effect of the preinit stage on 
member statements of class definitions, as I will explain in a moment.  I have 
almost fixed it, but one thing remains to be done in order to ensure the 
side-effect never manifests.

The problem is located in sage_gen_class_definition() where SAGE loops through 
the statements of the class definition and appends them to a list in the 
SgClassDefinition class.  We need to be careful when the preinit stage
has already appended these statements that SAGE doesn't also append them. That
would give rise to multiple declarations of stuff in the class definition.

To fix these I've introduced a flag before the relevant loop in 
sage_gen_class_definition().  This flag is called 
memberStmtsExistFromPreinitStage, and when it is true, the loop will not
append the statements again. 

There is a aspect of this implementation that needs to be fixed.  I'm setting
the memberStmtsExistFromPreinitStage to TRUE if there are *any* member
statements.  So in the preinit stage we need to make sure that *some* of 
the member statements are not appended if *all* of them are not.  This can
happen if, after a few statements are appended, the call to 
sage_gen_declaration() fails and that preinit task aborts.  When this happens
we need to remove any statements that were appended in order that the next
pass can start over from scratch and not append redundant statements.  I haven't
done this yet, although I've put a comment in the code (marked by "WARNING")
where it needs to be done.  There are also a couple of other elaborate comments
about this in the code.

Note that with the current partial fix, there is *not* a problem if:

  (a) The preinit stage is not run at all, or
  (b) The call to sage_gen_declaration() in this loop within 
      sage_gen_declaration() never fails during the preinit stage.

With the current partial fix, there *is* a problem if there are n statements
in a class definition and the call to sage_gen_declaration() works for k of
them, where 1&lt;k&lt;n, but fails for the k+1 statement, during the preinit
stage.  And this can be fixed by always making sure that the preinit stage
always appends exactly all or exactly none of the member statements.

There are other approaches to this problem, like just checking before appending
a statement to see whether that statement is already in the list, but it's not
clear to me that doing so would be sufficiently convenient or feasible. [<a href="#TAG13BACK">Back</a>]</pre>

  <li><pre><a name="TAG14">TAG14 <i>Modified SAGE to included template args and params.</i> [<a href="#TAG14BACK">Back</a>]
Accomodation of template arguments in SAGE is facilitated greatly by the
preinit stage.  Look at sage_form_template_args() in sage_il_to_str.C to see how
template arguments are inserted into SAGE.  Note that sage_form_template_args()
is called from one place in SAGE, and that is sage_gen_unqualified_name() in
sage_gen_be.C.

Look at find_template_class() in templates.c to see where I've inserted the 
template params into the IL tree.  The main trick here is to be careful to 
allocate space for the template params in a memory region that will be 
preserved after front end processing is complete.  There is a note with more 
information about that in the code, and there is an indication of how my 
implementation could be cleaned up in terms of memory management.

Look at sage_form_template_params() in sage_il_to_str.C to see how template
params are inserted into SAGE.  sage_form_template_params() is also called
only once in SAGE, the same place as sage_form_template_args().

When the flag substituted_for_template_param (aka substitutedForTemplateParam,
in SAGE) works correctly, information about exactly which parameter that's
being substituted for can be acquired from the template parameter coordinates
which are stored in "struct a_type" under 
variant.template_param.extra_info->coordinates.  
See struct a_template_param_coordinate in il_def.h for the definition of this
coordinates field.  It's a little disturbing to me that the template parameter
coordinates are in the IL tree but the template parameters are not.  I wonder
if the template parameters actually are already in the tree and I've just
somehow managed to over look them all this time.

NOTE: I'm unparsing information about the template params and args into comments 
in such a way that the unparsed code can have nested comments.  Of course, this 
is an intermediate stage.  The information in comments will eventually be 
formatted into compilable syntax.  Also, this only will happen when 
UNPARSE_TEMPLATES is TRUE (unparser.h).  [<a href="#TAG14BACK">Back</a>] </pre>

  <li><pre><a name="TAG51">TAG51 <i>Modify type reuse in EDG...</i> [<a href="#TAG51BACK">Back</a>]
The problem is that the types in the IL tree are getting the
substituted_for_template_param field turned on in cases where
it shouldn't, because it can happen that the same IL type node 
is used to represent, simultaneously, types that *do* substitute 
for template params and types that *don't* substitute for template 
params.  That's the way it appears to me, currently, at any rate.

I've tried to eliminate type reuse in EDG entirely as a first step,
but I can't get it to work.  In particular, I've put 

   #if 1
   /*
   ** [DT] 8/16/2000 -- Testing. In order for the substituted_for_template_param
   **      field to be useful, we need to eliminate type reuse.
   */
         goto make_new_type;
   #endif

in traverse_and_modify_type_tree() in types.c, and I've put

   #if 1
   /*
   ** [DT] 8/16/2000 -- Want to try to eliminate type reuse in order for the 
   **      substituted_for_template_param field to be useful.
   */
     a_boolean                      return_type1_as_comp_type = FALSE;
     a_boolean                      return_type2_as_comp_type = FALSE;
   #else
     a_boolean                      return_type1_as_comp_type = TRUE;
     a_boolean                      return_type2_as_comp_type = TRUE;
   #endif

in composite_routine_type() in types.c, where the #else clause is what
was originally there.

These are the only two routines that I've found in which type reuse is
being implemented, and the code that I've put there should prevent it
from doing type reuse at all.

Note that I've also put the following

   #if 1
   /*
   ** [DT] 8/16/2000 -- Testing.  Trying to get this field to work correctly.
   */
         new_type->substituted_for_template_param = 0;
   #endif

in the make_new_type section of traverse_and_modify_type_tree() just to
be sure that when the new type is created it doesn't keep the value of
this field from another type accidently. 

Final note:  In the latest repository, I've commented out the above
snippets of code that I added.[<a href="#TAG51BACK">Back</a>]</pre>
</ul>
    
</body>
</html>


"rgit" = "Robb's Git" or "ROSE Git"

rgit is a source management system that supports the distributed power
of Git while maintaining some centralized features of Subversion. It
contains a Git/Subversion gateway so that changes can be maintained
concurrently in both Git and Subversion repositories. It implements a
test and merge policy that insulates developers from each other's
mistakes.

==============================================================================
Features
==============================================================================

* Central repository using Git

  A combination of Git's distributed power and Subversion's
  centralized sharing.

* Each user has a local copy of the repository

  The full power of Git is available to each user.  This includes
  being able to make commits when off-line.

* Each developer has their own unique name space

  A developer is assigned one or more namespaces, typically their
  initials, and all tags and branches are created with this namespace
  prefix (like "aaa-master" where "aaa" is Albert A. Abbot's name
  space).  Users need not worry about trampling on each others' branch
  and tag names in the central repository.  Private branches and tags
  can be whatever suites your fancy.

* Certain branches are tested automatically

  Test results and output become pass/fail tags in the central repo and
  anyone can access these at any time (even when not online) from
  their work spaces.  The qgit GUI makes it very obvious what commits
  are passing or failing.

* Testing is distributed

  Anyone can run automated tests as long as they have password-less
  SSH access to the central repository machine. Tests can run on any
  machine and results are reported back to the central repository,
  including the full output of the test.  Different people can run
  different tests or a single test can be run by a pool of machines.

* Changes are automatically merged into the master branch

  Users check changes into their "*-master" branch (where "*" is their
  name space, like "aaa-master") and these changes get tested
  automatically by the distributed testing system.  When a "*-master"
  branch "passes" it is automatically checked into the "master"
  branch from which other developers typically merge.

* Testing is configurable

  The definition of "pass" is configurable.  For instance, it might
  mean that certain tests must have succeeded while other tests are
  allowed to fail.  Or it could mean that at least five tests pass.

  The test scripts and definition of "pass" can be stored in the
  source repository itself.

* Testing is scheduled

  With Subversion each user ran a lengthy test after they did an "svn
  up" and before they committed to the trunk.  It often happened that
  once the test completed the developer found out that someone else
  had already committed. In that case it was necessary to do an "svn
  up", which resulted in a revision that was neither what the other
  person tested nor what the developer just tested, and the whole
  process had to be repeated (or more likely the second guy just
  committed anyway if his test passed).

  The new framework offloads the testing from the developer to an
  automated system.  The developer no longer has to babysit a
  pre-commit test.

* Developers don't taint the main line with bad commits

  In the Subversion world developers were supposed to run a test
  before committing.  Whether that rule was followed, abbreviated, or
  outright skipped it was still a common occurrence that one
  developer's commit caused someone else's build to fail. Once that
  happened other developers became more likely to commit their own
  changes on top of a failing repository.

  This no longer happens because each user only commits to their own
  branches. Their changes only make their way into the master branch
  after they've been automatically verified to pass the prerequisite
  tests.  The system can be configured so that any developer's changes
  must pass every developer's test before it's automatically shared.

  Furthermore, the merge into master is always a fast-forward,
  which means that the new master revision is identical to what was
  verified to pass.

* Bug isolation by bisecting history

  A very useful tool for fixing bugs is to be able to narrow down
  which commit introduced the bug by doing a binary search through the
  revisions. We're unable to do that with the current Subversion setup
  because half the revisions that are checked in don't work anyway.

* Support for a single-branch Subversion repo

  A Subversion repo is treated like another user. There are a couple
  of branches in the "svn" name space (like "svn-master") that are
  used by cron jobs synchronize Git and Subversion.  Most of the time
  this can be fully automated--occassionally merge conflicts need to
  be resolved by hand.

  Subversion isn't able to represent any useful information about
  merge operations, yet the Git repository will support the full
  power of Git merging.  (The Git history is linearized before sending
  it to the less capable Subversion repository.)

* Subversion compatibility

  We have lots of scripts that assume they're operating inside a
  Subversion checkout. These scripts will continue to work since
  revisions will be copied into Subversion automatically.

  In fact, if no developers use Subversion for checkins then the
  copying between Git and Subversion becomes trivial (fast-forwards
  with no possibility of conflict).

* Subversion's trunk becomes more stable

  Since the "svn-master" is only updated from the "master" branch and
  the "master" branch always passes, it follows that the only changes
  that Git commits to Subversion will also pass. Git commits these
  changes in batches, so it's actually the last commit of every batch
  that's guaranteed to pass the tests.

* And all the power and speed of Git itself....

  Such as being able to easily undo a merge (try to undo an "svn update"
  sometime).

==============================================================================
Drawbacks
==============================================================================

* Developers will have to learn a new set of commands.

  Most developers tend to use only the most basic of revision control
  features which have similarly basic commands under Git:

      $ svn checkout URL DIR  ->  $ rgit clone --namespace=NS URL DIR

      $ svn up                ->  $ git fetch; git merge master

      $ svn commit            ->  $ git commit --all; git push

  The main difference you'll notice is that most Git commands operate
  only on your local copy of the repository. Therefore you'll
  occassionally need to synchronize your local repository with the
  central repository -- thus, "git fetch" and "git push".

* Developers should abandon their subversion work spaces

  Fortunately, developers can do this at their own pace since both Git
  and Subversion will be supported.  They'll still get some of the
  automated testing benefits even if they stick with Subversion
  permanently, but the Git/Subversion interface will work better if
  commits are made only into Git (because it eliminates the
  possibility of merge conflicts between Git and Subversion).

  Developers that continue to commit to Subversion will still
  experience the broken trunk revisions, but the breakage will only be
  from those developers that are committing to Subversion. The
  developers using Git will be insulated from broken "trunk"
  revisions.

* Subversion branches are not supported.

  This is because Subversion doesn't keep track of any useful
  information about how branches are merged, making it difficult to
  reconstruct the merge operations in Git -- the best Subversion can
  do is simply copy changes from one branch to another.  Fortunately,
  since Subversion makes it so hard to use branches, we tend to use
  only "trunk" anway.

* It takes a while to get used to working with branches

  Distributed revision control systems in general, and Git in
  particular, make very extensive use of branches.  Fortunately they
  also make them easier to use than Subversion.

  The "qgit --all" (or "qgit4 --all") GUI will help you visualize
  things.
     

==============================================================================
Operation for End User
==============================================================================

1. Initial checkout
-------------------

The user makes an initial checkout, or "clone", from the central
repository. Depending on your network speed, this could take a long
time. Fortunately you only need to clone one copy to your work
machine. If you want more than one copy on your work machine, you can
copy the directory (you could also clone your clone, which is not
quite the same as copying the directory).

If your name space is "aaa", the command to clone the central
repository is:

  rgit clone --namespace=aaa ssh://matzke@central/repo/projectname dest

This clones the specified URI and creates a directory "dest" that will
hold the clone.  It also creates (if necessary) an "aaa-master" branch
and places you on that branch.

It's roughly equivalent to the following git commands:
  git clone ssh://user@central/repo/projectname dest
  cd dest
  git push origin origin:refs/heads/aaa-master  # if necessary
  git checkout -b aaa-master origin/aaa-master

2. Working in your branch
-------------------------

You can work directly in your master branch (e.g., "aaa-master"),
editing files and committing changes.  See man pages for git-add and
git-commit. The changes you commit this way are local to your
repository until you sync up with the central repo.

To get well-tested commits from other people into your work space (the
rough equivalent of an "svn up" command) you would run these commands
from anywhere in your work space:

    $ git fetch  # update your repo's origin branches from the central repo
    $ git merge origin/master # merge master branch into your current branch

You don't need to do a "git fetch" every time you merge. All the fetch
does is grab changes from the central repo that your private repo
didn't already know about.

You can look at the changes before you merge. If you merge and don't
like the results you can back out (see git-reset).  The "qgit --all"
GUI is one way to look at the changes.

The "origin/master" refers to the "master" branch in the remote
repository from which your working repository was cloned.  You never
make changes to "origin/*" branches directly.  You will often have a
local branch and remote branch that have similar names, like
"aaa-master" and "origin/aaa-master" -- you can commit changes to
"aaa-master" but "origin/aaa-master" is used internally by Git for
synchronization witht the remote (central) repository.



3. Merging Subversion's "trunk" into your current branch
--------------------------------------------------------

Subversion's trunk (the "svn-master" branch) will be automatically tested
and tagged by rgit and, if the tests pass, will be merged into the
"master" branch.  So the previous instructions for merging from
"origin/master" would also merge the changes coming in from Subversion.

However, sometimes you might want to grab the subversion changes
before they pass the automated tests. You can do that with these
commands:

    $ git fetch  # make sure you're up-to-date with central repo
    $ git merge origin/svn-master


4. Sharing your changes
-----------------------

You can share any of your branches by pushing them to the central
repository. You can also share changes by formatting patch sets and
mailing them to other developers (see git-format-patch and git-am).
However, the usual way of sharing your changes under rgit will be to
push the contents of your master branch back to the central repository
where it will be automatically tested and merged into "master".
Here's how you do that:

    $ git fetch  # as usual, make sure you're up-to-date
    $ git push   # send changes to central

The "push" command might only operate on your current branch depending
on how you have things set up.  So you might need to do a "git
checkout aaa-master" if "aaa-master" is what you want to push back to
the central repo.  You could also use the extended syntax to
explicitly specify a branch:

    $ git push origin aaa-master


5. Merging into "master"
------------------------

When you worked in Subversion, every time you checked something in it
went straight into the main branch and everyone saw it immediately.
With rgit you never check in directly to "master" -- you only check
into your own "*-master" branch (e.g., "aaa-master").

The central repository will periodically test everyone's "*-master"
branches and tag them with the results. Other developers can grab your
changes by merging from any branch they want, whether it has been
tested or not (although typically they'll merge from only "master").

Once your "*-master" branch passes the prerequisite automated tests it
becomes eligible for automatic merging into the "master" branch.
However, it must also satisfy one other condition: it must contain
everything that "master" contains.  The way to satisfy this condition
is to simply merge "master" into your own "*-master" before you push
your "*-master" onto the central repo:

    $ git fetch   # make sure you're up-to-date with remotes
    $ git checkout aaa-master  # make your master current
    $ git merge origin/master  # merge from master
    $ git push    # push changes back to central repo

By merging from master you are incorporating well-tested changes from
other namespaces into your own "*-master" branch.

Git's merge command can always figure out what needs to be merged even
if you've merged some things from one branch and other things from
other branches. For instance, if you merge from my "rpm-master" branch
because you want some of my changes before they're tested, and then
later (after my work is merged into "master") you merge from "master",
Git will figure out that you've already got some of my stuff and won't
try to apply those changes a second time like Subversion would do.

6. Other branches
-----------------

You have the full power of Git when working in your local copy. Make
as many branches as you like, rebase them, rewrite history in other
ways, merge however you like, etc.  The only rule is that you should
not rewrite history that's shared with the central repository (people
don't like it when history changes unexpectedly).  See any Git
tutorial for how to do this.  Here's a couple of things that they
often fail to mention and that might be difficult to find:

In order to create a branch that should be shared with the central
repository, create the branch locally in the normal way but make sure
it has a name in your namespace (e.g., "git branch aaa-foobar"). Then
push it to the central repository:

    $ git push origin aaa-foobar

In order to delete a branch from the remote repository you would
execute the following push command. You can independently delete the
branch locally with the second command:

    $ git push origin :refs/heads/aaa-foobar
    $ git branch -D aaa-foobar      (aaa-foobar can't be your current branch)

If you have a branch you'd like to share and it doesn't begin with
your namespace, you can rename it before pushing it:

    $ git branch -M foobar aaa-foobar

7. Multiple work spaces
-----------------------

There are a number of options here.

If you tend to switch between tasks rather than work on two or more at
once, then it's probably easiest to use branches in a single
workspace. Otherwise...

You could also create multiple workspaces by "rgit clone" from the
central repository.  This requires that you're on-line and it takes a
few minutes over the network.

You could also just copy an existing workspace directory. Don't forget
to copy the top-level ".git" directory as well.  There are a variety
of ways to move changes between the two workspaces if necessary. (Note
that cloning is not the same as copying a directory.)

You could also clone your main workspace. Running "git fetch" and "git
push" in the clones will communicate with your main workspace rather
than the central repository.  Beware of "git push" to a branch that's
checked out in your main workspace -- it might not do what you expect.

You can also have mutliple namespaces assigned to you.


8. Deleting repositories
------------------------

Nothing special needs to be done to delete a repository on your work
machine. Just remove its directory like normal. Be aware that you'll
have to do a potentially time-consuming "clone" again later (I'm
working in a workspace that's about two years old).

Don't forget to run these two commands first if you want to make sure
that your local changes are reflected in the central repository:

    $ git fetch
    $ git push

==============================================================================
Automated Testing
==============================================================================

You can help keep the project bug free by providing your computing
resources for automatic testing. All you need is a password-less SSH
connection to the central repository, ample disk space, and an entry
in a crontab.

rgit continuously (through cron jobs) tests all the "*-master"
branches in all namespaces.  Passing these tests is one of the
requirements that a "*-master" branch must meet before it becomes a
candidate for automatic merging into the "master" branch (the other is
that it already contains everything in "master").

A "test" is a pair consisting of a shell script and a name.  Multiple
tests can share the same script, which is useful if a particular
script must pass on multiple platforms.  See the description of NAME
below for more details.

The command to run a test is:

    $ rgit test --script=SCRIPT --tag=NAME CENTRAL WORKSPACE

Where:
   SCRIPT is the name of the script run with the current working
   directory set to WORKSPACE.

   NAME is the name of the test. Only one instance of each
   unique name is attempted per revision. If the same name is used for
   multiple scripts then only one of those scripts will run; if the
   same name is used for a single script across multiple machines then
   only one machine will run the script.

   CENTRAL is the URI for the central repository.

   WORKSPACE is the name of a directory where the central repository
   will be cloned. This directory is not deleted on exit and may be
   reused for subsequent tests. Each NAME should have its own
   workspace.

There are other command-line switches as well, but these are the ones
you'll typically use.

The crontab entry can run the "rgit test" command as often as it
likes. If a test is running already then the command fails without
doing anything besides complaining that some other process owns the
lock.  However, no attempt is made to limit the number of different
tests that run at the same time.   Tests need not consume so many
resources that they're an impediment to your normal work: run them
with nice priority and serial compiling.

If you set things up in your ~/.bashrc file that are necessary for
building ROSE then you'll want your rgit command in the crontab to be
run inside an interactive shell. You can do that by running "/bin/bash
-login -c 'rgit......'

Here's a sample test script that makes sure the branch does not
contain binary EDG tarballs:

    #!/bin/sh
    set -e
    cd src/frontend/CxxFrontend
    for f in roseBinaryEDG-*.tar.gz; do
      if [ -f $f ]; then
        echo "Binary EDG tarballs should not be in the Git repository" >&2
        exit 1
      fi
    done
    exit 0


==============================================================================
Operations for central repository administrator
==============================================================================

1. Creating the git-svn repository
----------------------------------

This is the repository that tracks the Subversion repository. It can be
created with a command such as:

    $ git svn init --trunk=trunk/ROSE --tags=tags --branches=branches \
      svn+ssh://thunder/usr/casc/overture/ROSE/svn/ROSE \
      rose-gitsvn

The --trunk switch says that the trunk branch is stored in the rather
unorthodox directory while the --tags and --branches switches specify
the usual places for the tags and branches.  The last argument is the
name of the directory to contain the git-svn repository (it will be
created by this command).

Note that this command could take a very long time to run because
Subversion has no way to export its entire history -- it must be
recreated piecewise by checking out each revision from Subversion and
then committing it to Git.

It works best if this command can be run on a machine that is "close"
to the subversion repository. If you choose the Subversion URI
carefully then you can move the final git-svn repo to some other
machine if necessary.

2. Creating the central repository
----------------------------------

The central Git repository can be created on any machine that has
access (e.g., via passwordless ssh) to the git-svn repository.

    $ rgit svn-clone ssh://matzke@thunder/rose-gitsvn /repos/central

The final argument is the name of the directory that will contain the
central repository. It is a bare Git repository -- you won't see any
of the source files in that directory, but rather just Git meta data
files.

3. Synchronizing with Subversion
--------------------------------

This has two halves: pulling commits from Subversion into Git, and
pushing changes from Git into Subversion.  A push should only be
attempted after a recent pull. The rgit commands are "svn-push" and
"svn-pull".

A pull works as follows:
    1. Run "git svn fetch" in the git-svn repo. This makes the
       "trunk" branch in the git-svn repo up-to-date with the
       trunk of Subversion.
    2. Figure out what Subversion commits the central repo is
       missing and retrieve them, applying them to the "svn-trunk"
       branch of the central repo.
    3. Merge "svn-trunk" into "svn-master" in the central repository.
       This stages the new commits for automated testing.
    4. Merge "master" into "svn-master". This enables subversion
       commits to be merged back into "master" once they pass
       prerequisite tests.

Both merge steps could result in conflicts that need to be fixed by
hand.


A push is more complicated because Subversion is unable to represent
any useful information about merges between branches. Therefore we
must convert Git's history into a linear set of changes that can be
applied to the "trunk" in Subversion. We must also communicate
Subversion revision numbers back into Git.

4. Automatic merging
--------------------

You'll want to set up a crontab that runs this command to periodically
merge any "*-master" branches into "master".  A *-master branch must
satisfy two conditions for it to be merged into "master", namely:

   A. The branch must have passed all prerequisite tests
   B. The branch must contain everything on "master"

Condition B ensures that the merge will be a fast-forward and
therefore will not have any conflicts. It also means that if the
branch passes the prerequisites, then after the merge "master" will
also pass the prerequisites.

Condition A is tested by an executable (usually just a shell script)
that is invoked having arguments that are the names of the tests that
have completed and an indication of whether the test passed or failed.
For instance, if tests "t1", "t2", and "t3" passed, and tests "t4" and
"t5" failed, and tests "t6" and "t7" have not completed yet, the
executable would be invoked with arguments:

    t1=1 t2=1 t3=1 t4=0 t5=0

The name of the executable is given with the "--preconditions" switch
and is invoked with workspace as its current working directory (this
allows the executable to be contained in the repository).

The executable indicates that preconditions have been satisfied by
exiting with a zero status.  Here's a sample perl script that requires
five passing tests with no failing tests:

    #!/usr/bin/perl
    my $npass = grep {(split /=/)[1]} @ARGV;
    exit($npass<5 || $npass!=@ARGV ? 1 : 0);

5. Maintenance
--------------

The repository might eventually contain lots of pass/fail tags from
tests that we no longer care about.  Since these tags contain the full
output of each test the could be rather large.  An easy way to prune
these from the central repo is with the following command:

    rgit prune --pass=6m --fail=1w --run=1d /repos/central

This will delete any pass tag that is older than six months, any fail
tag older than one week, and any running tag older than one day.  The
--run switch is especially useful since stale "running" tags can be
left in the repo if a testing machine suddenly crashes.

This command can only be run directly inside the central repository,
and therefore must run on a machine where the central repo is a local
directory.

==============================================================================
Questions with Answers
==============================================================================

Q1. How do I get an emergency fix into Subversion without requiring
    that it pass the automated testing?

    Place the commit in the svn-master branch and push the change back
    to the central repo.  The next time the central repo synchronizes
    with subversion your change will propagate into subversion.

    Here's an example:

       $ git fetch
       $ git checkout -b svn-master origin/svn-master
       $ edit.....
       $ git commit -av
       $ git push
       $ git checkout aaa-master  # back to your original branch

Q2. If I have crontab testing set up, how do I know what tests are
    running and can I monitor their progress?

    For each running test, there will be a file in /var/tmp with a
    name like rgit-foobar.lock where "foobar" is the value specified
    for the "--tag" switch of the "rgit test" command in the crontab.
    The contents of that lock file will be some important information
    about what's being tested, including the name of a file where the
    output is being captured. You can watch that file to see the
    progress:

       $ cat /var/tmp/rgit-foobar.lock
       18662
       tag: foobar
       script: /home/matzke/GS-CAD/ROSE/tests/thorough
       branch: remotes/origin/svn-master
       output: /tmp/tmp.Kh8pEtjIjY

       $ tail -f /tmp/tmp.Kh8pEtjIjY

    The beginning of the output file will contain lots of information
    about the environment.

Q3. How do I know whether a test is running on some other machine?

    At one time the "rgit test" command tagged the central repo
    whenever a test started.  I removed that feature because there's
    better ways to communicate transient events. The tags in the repo
    should be used to hold information that would be of historical
    relevance.  The final status of a test satisfies this, but the
    mere fact that a test started to run does not.

    A better way to communicate that a test has started is to send an
    email to some address list.  This can be incorporated into the
    test script itself.

Q4. Why doesn't Git send an email when someone checks something in?

    We could easily make it do so.  However, it would be pointless to
    email the actual diff like our Subversion setup does because diffs
    are readily available from your working repository.

    Also, since we're all working in our own name spaces, an email
    would really only be useful when someone's namespace "*-master"
    branch was automatically merged into "master".

Q5. Can I merge things into "master" before they're tested.

    Sure, but it would be a violation of our policy that everything on
    "master" is well tested.  We'd just be back to the Subversion
    world where the main branch was a free-for-all.

Q6. Why does testing take so long?

    With subversion testing was run at full bore because it needed to
    happen as fast as possible -- other people were waiting to check
    things in on our single branch.

    Speed is no longer an issue because each developer can have as
    many public branches as they like (though typically just their
    "*-master"). Nobody is held up waiting for someone else's work to
    pass tests.

    On the other hand, if Alice makes some changes that Bob needs
    right away, then she has multiple options:  She could push her
    changes back to one of her own branches on the central repo and
    Bob could merge from that; she could email patches to Bob
    generated with "git format-patch" and applied with "git am"; Bob
    could pull directly from Alice's machine; etc.

Q7. What happened to all the EDG tarballs? Why are binary EDG tarballs
    not allowed?

    One of the features of rgit is that when it creates a central
    repository it rewrites history to remove all references to the
    binary EDG tarballs.  Another feature, depending on how testing is
    set up, is that the presence of a new EDG tarball will cause the
    automated tests to fail.

    A few reasons we don't want EDG tarballs in the source repo:

    * They are not source code--they are generated from source
      code. So why should they be in a "source" repository?

    * Each tarball has a unique name, so it's not necessary to use a
      revision management system to control which tarballs are
      visible.

    * It does not make sense to compute diffs of an individual
      tarball. Either the file contains one tarball or it contains a
      different tarball. Therefore, revision control of a particular
      tarball is pointless.

    * The tarballs are large and do not compress. In a distributed
      revision control system like Git, every developer has a complete
      copy of the repository. Why should I have to download gigabytes
      of tarballs if I'm editing source code?

    * The tarballs are for use by the release system, not for use
      during source code development. Therefore they should be
      computed by the release system and not present during
      development.

    * It would be equally easy to store binary EDG tarballs in a plain
      old directory since the only operation we perform on the
      directory is to add or remove entire files.  The directory could
      be served up via ftp or http.  We should keep the script that
      tells us which tarball is applicable for a particular source
      revision.

    Beware of accidently committing a binary EDG tarball and pushing
    it to the central repo. You can revert the change, but the only
    way to truly get the tarball out of the repo is to rewrite
    history. People don't like it when history changes, but it's
    easier to change recent history than ancient history! (Rewriting
    history is an advanced topic that should not be undertaken
    lightly.)

Q8. What's wrong with ChangeLog2?

    It's pointless to have ChangeLog2 be under revision control:

    * It contains the same information that's available from the
      revision control system itself (e.g., "git log")

    * It linearizes the history, which wasn't much of a problem in
      Subversion since we just had one branch.

    * Its level of detail is too fine for end users.  Instead of
      repeating every single commit message it should only show
      "important" commits.

    The "important" commits from a release standpoint are the merges
    of developer features into the "master" branch once they pass the
    prerequisite tests.  In rgit this is roughly the first-parent
    ancestors of the "master" branch, which are available from outside
    the repository when we make a release.

    Having said that, I have no plans to port ChangeLog2 generation to
    the Git repository and the file will probably eventually need to
    be removed.

Q9. The merge lattice is complex. How can I tell what changes are on
    my "*-master" branch that are not yet in the "master" branch?

    The "git whatchanged" is the easiest command-line tool for doing
    just that.  It shows information in a form like "git log" and
    takes many of the same command-line switches.

    For example, the following command will list what commits are
    reachable from the "origin/master" branch but not ("^") reachable
    from your "*-master" branch (assuming "aaa" is your namespace):

    $ git whatchanged origin/master ^aaa-master

    Useful command-line switches are:

        --pretty=oneline  Show one line per commit
        --p               Show a diff for each commit

Q10. When using a ROSE source tree for more than one platform, I
   occassionally get lots of errors mentioning "X--mode" from
   libtool. What is going on and how can I avoid them?

   You have a mismatch between cached autoconf files between
   the two architectures. The best way to remove all the crud
   that accumulates in a source tree is:

       $ git clean -f -x -q  # delete all crud but directories
       $ git clean -f -x -n  # show crud directories not deleted
       $ rm -rf ...          # optionally remove crud directories
       $ ./build             # rerun the build scripts

   Where "..." is replaced with the names of any directories you don't
   need to save which were printed by the second command.  If you want
   to make the source tree look exactly like what's checked into the
   repository then do this:

       $ git clean -f -d -x -q  # delete everything not in Git
       $ git reset --hard HEAD  # revert files to last checkin

Q11. How can I determine why a test failed?

   If a test fails there will be a "*-fail-N" tag placed on the commit
   that failed, where "*" is the tag name supplied when the test was
   run and "N" is a serial number.

   First, fetch the most recent changes from the central repository in
   order to get the latest tags:

       $ git fetch

   Then use qgit or qgit4 with the "--all" switch to show the
   association between branches and tags.  Or if you know the name of
   the test, say "rat-gentoo", you can list the most recent failures
   with:

       $ git tag -l rat-gentoo-fail-*

   Then show the entire test output with:

       $ git show rat-gentoo-fail-00123

   The beginning of the output should contain information about where
   and when the test was run and the version numbers of important
   software packages.  A search for "^commit" will get you to the end
   of the test output where the error is finally reported.

Q12. Why does the rgit script fail during the "git filter-branch"?

   The rgit script uses "git filter-branch" to rewrite history and
   remove binary EDG tarballs.  If you get an error during this step
   then you probably don't have a recent enough version of Git. I've
   seen this error with 1.5.4.5 on LC machines but not 1.6.5.2.

   Note that "git filter-branch" is only run by the rgit
   administrative commands that interact with Subversion; developers
   probably wouldn't ever see this.

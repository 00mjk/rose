#!/usr/bin/perl
my $help = <<EOF;
Mostly like plain old git, except recurses into one level of submodules.

There's not really anything magic about this script. For the most part,
it just executes the given command in each submodule directory and then
in the top-level ROSE repository. It can be invoked from any directory
under ROSE (either in the ROSE repository or one of the submodules).

A few git commands get special handling by this script:
   clone          Takes the same arguments and switches as for Git
                  but also initializes and updates submodules. The
                  user is given a chance to change the URLs for the
                  submodules before they're updated if the --edit
                  switch is specified.

   checkout       Checks out a branch in the main repo and all
                  submodules, taking the same arguments and switches
                  as for Git.  If the "-b" switch is specified then
                  the branch is created in the same way as the "branch"
                  command described below.

   branch         Lists, creates, or deletes branches taking the
                  same arguments and switches as Git.  When creating
                  a new branch the specified branch head (if any)
                  is the one defined in the main ROSE repository.
                  The head of the new branch in the submodules will
                  be chosen according to the commit registered in
                  the branch head of the main ROSE repository.

All other commands are identical to Git and are executed first in
the submodules and then in the main ROSE repository.
EOF

use Cwd;
use File::Temp 'tempfile';
use Getopt::Long 'GetOptionsFromArray';
use Term::ReadLine;
use strict;

my($arg0) = $0 =~ /([^\/]+)$/; # just the base name of this script

Getopt::Long::Configure(qw/no_permute bundling/);

# Print usage message and exit
sub usage {
  open GIT, "-|", "git --help" or die;
  while (<GIT>) {
    s/\bgit\b/$arg0/;
    s/^usage: $arg0.*/usage: $arg0 COMMAND [ARGS]\n$help/;
    print;
  }
  close GIT;
  exit 1;
}

# Prints message from GetOptions about an unsupported switch.
sub unsupported {
  my($switch) = "-$_[0]";
  $switch = "-$switch" if length $switch > 2;
  die "$arg0: unsupported switch: $switch\n";
}

# Returns true if specified directory looks like it's the top of ROSE
sub is_top_of_rose {
  my($dir) = @_;
  return unless -d $dir && -d "$dir/.git";
  return unless open MODULES, "$dir/.gitmodules";
  my $has_edg = grep {m(^\[\s*submodule\s+\"src/frontend/CxxFrontend/EDG\"\s*]\s*$)} <MODULES>;
  close MODULES;
  return $has_edg;
}

# Returns absolute directory name for top of ROSE repo.  Your CWD must be somewhere inside ROSE to start with.
sub top_of_rose {
  my @comps = split /\//, getcwd;
  while (@comps) {
    my $s = join "/", @comps;
    return $s if is_top_of_rose $s;
    pop @comps;
  }
  die "$arg0: cannot find top of ROSE source tree (cwd=@{[getcwd]})";
}

# Rewrite the .git/config file for submodule URLs
sub rewrite_submodule_configs {
  my($edit) = @_;
  local $_;
  my @content; # rewritten content of .git/config file.
  open CONF, ".git/config" or die "$arg0: .git/config: $!";
  my($sectype,$secname,$origin_url); # set when we encounter a "[...]" line.
  while (<CONF>) {
    if (/^\s*\[\s*(\w+)\s+"(.*)"\s*\]/) {
      ($sectype,$secname) = ($1,$2);
    } elsif (my($key,$val) = /^\s*(\w+)\s*=\s*(.*?)\s*$/) {
      if ($key eq "url" && $sectype eq "remote" && $secname eq "origin") {
	$origin_url = $val;
	$origin_url =~ s/\/+$//;
      } elsif ($key eq "url" && $sectype eq "submodule") {
	die unless $origin_url;
	my($base) = $val =~ /([^\/]+)$/;
	my($path) = $origin_url =~ /^(.*)\//;
	my($url) = "$path/$base";
	if ($edit) {
	  print "Submodule $secname\n    Default: $url\n";
	  my($term) = Term::ReadLine->new($arg0);
	  $term->addhistory($url);
	  my($response) = $term->readline("  New Value: ");
	  $url = $response if $response ne "";
	}
	$_ = "\t$key = $url\n";
      }
    }
    push @content, $_;
  }
  close CONF;
  system "cp .git/config .git/config~"; #ignore status
  open CONF, ">.git/config" or die "$arg0: .git/config: $!\n";
  print CONF join "", @content;
  close CONF;
}

# Returns submodule info. Each return value is an array ref with two elements: the path of the submodule with respect
# to the supermodule, and the SHA1 as recorded in the supermodule.
sub submodules {
  my $cmd = "cd @{[top_of_rose]} && git submodule --quiet foreach 'echo \$sha1 \$path'";
  open F, "-|", $cmd or die "$arg0:cannot obtain submodule names";
  my @retval = map {chomp;[(split /\s+/, $_)[1,0]]} <F>;
  close F or die "$arg0: cannot obtain submodule names";
  return @retval;
}

# Like submodules, but return references instead.
sub refs {
  open F, "-|", "git show-ref" or die "$arg0:cannot obtain references";
  my @retval = map {chomp;[(split /\s+/, $_)[1,0]]} <F>;
  close F or die "$arg0: cannot obtain references";
  return @retval;
}

# Run arbitrary git command in CWD and optionally return all stdout as an array of chomped lines. Returns true
# on success, false on failure.
sub git {
  my($output) = shift @_ if 'ARRAY' eq ref $_[0];
  my($opts) = 'HASH' eq ref $_[0] ? shift @_ : {};
  my(@cmd,$cmd) = ("git", @_);

  $cmd = "(cd $opts->{cd} && " . join(" ", @cmd) . ")" if $opts->{cd};
  unless ($opts->{quiet}) {
    if ($cmd ne "") {
      print "+ $cmd\n";
    } else {
      print "+", (map {" $_"} @cmd), "\n";
    }
  }

  if ($output) {
    $cmd = join " ", @cmd if $cmd eq "";
    open F, "-|", $cmd or return;
    while (<F>) {
      chomp;
      push @$output, $_;
    }
    close F or return;
  } else {
    system @cmd and return;
  }
  return 1;
}

# Wrappers around git commands that return a single line. Return undef on failure rather than die.
sub git1 { my @output; git \@output, @_; return $output[0] }
sub rev_parse { git1 {quiet=>1}, "rev-parse -q --verify", ($_[0]||"HEAD") }
sub symbolic_ref { git1 {quiet=>1}, "symbolic-ref -q", ($_[0]||"HEAD") }
sub merge_base { git1 {quiet=>1}, "merge-base", @_ }


# Try to find a branch that matches the current (possibly detached) HEAD, and switch to it.
#   (1) Prefer the supplied name if specified
#   (2) Otherwise, create or fast forward a local branch with the same name as the remote branch if found
#   (3) Otherwise, consider all local and remote branches
#   (4) Otherwise, leave things as they are
sub switch_to_branch {
  my($branch) = @_;
  my $HEAD = rev_parse or die;
  my %refs = map {@$_} refs; # hash indexed by ref name
  if ($refs{"refs/heads/$branch"} eq $HEAD) {
    # Local branch exists and matches $HEAD, so use it.
    git "checkout", "--quiet", $branch or die "$0: could not checkout $branch";
    return;
  } elsif ($refs{"refs/remotes/origin/$branch"} eq $HEAD) {
    if ($refs{"refs/heads/$branch"}) {
      if (merge_base("refs/heads/$branch", "refs/remotes/origin/$branch") eq $refs{"refs/heads/$branch"}) {
        # Remote branch matches HEAD and local branch can be fast-forwarded.
	git "checkout", "--quiet", $branch or die "$arg0: could not check out $branch";
        git "merge", "refs/remotes/origin/$branch" or die "$arg0: could not merge origin/$branch";
        return;
      }
    } elsif ($branch) {
      # Remote branch matches head and local branch does not exist; create it.
      git "checkout", "--quiet", "-b", $branch, "refs/remotes/origin/$branch" or die;
      return;
    }
  }

  # Choose any other local or remote branch that points to HEAD
  ($branch) = map {/([^\/]+)$/} grep {m(^refs/(heads|remotes/origin)/) && $refs{$_} eq $HEAD} keys %refs;
  switch_to_branch($branch) if $branch;
}

# Execute the supplied code for each submodule. The list of submodules are the same format as returned by &submodules.
# To execute code in the top-level ROSE repo use undef (or an empty @modules).  CODE is called with two args: the sha1 and
# the path. All code is run with its CWD at the top of the module.
my($prev_path);
sub execute {
  my($code,@modules) = @_;
  push @modules, undef unless @modules;
  for my $module (@modules) {
    my($path,$sha1) = $module ? @$module : (".","HEAD");
    print "==== In ROSE $path ====\n" unless $path eq $prev_path;
    $prev_path = $path;
    chdir(top_of_rose . "/$path") or die "$arg0: cannot chdir: $!";
    &{$code}($path,$sha1);
  }
}

# Saves the commit message in a temporary file and returns its name.
sub save_commit_message {
  my($commit) = @_;
  my($tmp,$tmpname) = tempfile();
  open GIT, "-|", "git cat-file -p $commit" or die;
  1 while <GIT> =~ /\S/;
  print $tmp join "", <GIT>;
  close GIT;
  close $tmp;
  return $tmpname;
}

# Returns true if a commit would have an effect. First arg is true for "commit -a", false otherwise.
# If the only change is in a submodule then "git diff" won't report any changes, but "git status" will.
sub commit_has_effect {
  my($allflag) = @_;
  my $cmd = "git diff --quiet" . ($allflag ? "" : " --cached");
  `$cmd`; return 1 if $?;
  `git status`; return !$?;
}

###############################################################################################################################
#                                  Functions implementing Git subcommands
###############################################################################################################################

# If we're creating a new branch then also create a new branch in the submodules.  Otherwise just have Git run
# the specified command at the top of the ROSE repo and then in each submodule.
sub do_branch {
  my(@allargs) = @_;
  my($delete,$create_reflog,$force,$move,$color,$remote,$all,$verbose,$abbrev,$track,$contains,$merged,$no_merged);
  GetOptionsFromArray(\@_,
		      d=>\$delete, D=>sub{$delete=2}, l=>\$create_reflog, f=>\$force, m=>\$move, M=>sub{$move=2},
		      "color!"=>\$color, r=>\$remote, a=>\$all, "v|verbose+"=>\$verbose, "abbrev=i"=>\$abbrev,
		      "t|track!"=>\$track, "contains=s"=>\$contains, "merged:s"=>\$merged, "no-merged:s"=>\$no_merged)
    or exit 1;

  execute sub {git "branch", @allargs or die};

  if ($delete || $move) {
    execute sub {git "branch", @allargs or die}, submodules;
  } elsif (@_>=1) {
    # branch creation
    my($newbranch,$branchhead) = ($_[0], $_[1]||"HEAD");
    my($head_sha1) = rev_parse $branchhead;

    execute sub {
      my($path) = @_;
      my($rev) = git1 {cd=>".."}, "rev-parse $head_sha1:$path" or die;
      my(@gitargs) = ($newbranch, $rev);
      unshift @gitargs, "--track" if $track;
      unshift @gitargs, "--no-track" if defined($track) && !$track;
      unshift @gitargs, "-l" if $create_reflog;
      unshift @gitargs, "-f" if $force;
      git "branch", @gitargs or die;
    }, submodules;
  } else {
    # branch query
    execute sub {git "branch", @allargs or die}, submodules;
  }
}

# A checkout with the "-b" switch also create similar branches in the submodules.  Regardless of presence of "-b",
# we also run "git submodule update". Otherwise just run the git command in the top of the ROSE repo.
sub do_checkout {
  my($quiet,$mkbranch,$track,$create_reflog) = (1);
  GetOptionsFromArray(\@_,
		      "q|quiet!"=>\$quiet, "f|force"=>\&unsupported, ours=>\&unsupported, theirs=>\&unsupported,
		      "b=s"=>\$mkbranch, "t|track!"=>\$track, l=>\$create_reflog,
		      "m|merge"=>\&unsupported, "conflict=s"=>\&unsupported, "p|patch"=>\&unsupported)
    or exit 1;
  die "$arg0: incorrect usage\n" unless @_<=1;
  my($startpoint) = @_>0 ? $_[0] : "HEAD";

  my $checkout = sub {
    my($path) = @_;
    my(@gitargs);
    push @gitargs, "--quiet" if $quiet;
    push @gitargs, "-b", $mkbranch if $mkbranch;
    push @gitargs, "--no-track" if !$track && defined $track;
    push @gitargs, "--track" if $track;
    push @gitargs, "-l" if $create_reflog;
    if ($path eq ".") {
      push @gitargs, $startpoint;
    } else {
      my($sha1) = git1 {cd=>".."}, "rev-parse $startpoint:$path" or die;
      push @gitargs, $sha1;
    }
    git "checkout", @gitargs or die;
  };

  execute $checkout;
  execute $checkout, submodules if $mkbranch;
  execute sub {git "submodule", "--quiet", "update", "--no-fetch" or die};
  execute sub {switch_to_branch($mkbranch||$startpoint)}, submodules;
}

# Run a "clone" command. Arguments are the same as the real Git "clone" command.  This is the only command we
# support that's run *outside* the git repository. It does the following:
#    (1) git clone ....
#    (2) git submodule init
#    (3) $EDITOR .git/config # give user chance to edit submodule URLs before submodule update
#    (4) git submodule update
sub do_clone {
  my($edit,$local,$no_hardlinks,$quiet,$verbose,$branch,$upload_pack,$template,$recursive);
  GetOptionsFromArray(\@_, "edit"=>\$edit, # not a git-clone switch
		      "l|local"=>\$local, "no-hardlinks"=>\$no_hardlinks, "shared"=>\&unsupported,
		      "reference"=>\&unsupported, "q|quiet"=>\$quiet, "v|verbose"=>\$verbose,
		      "n|no-checkout"=>\&unsupported, "bare"=>\&unsupported, "mirror"=>\&unsupported,
		      "o|origin"=>\&unsupported, "b|branch=s"=>\$branch, "u|upload-pack=s"=>\$upload_pack,
		      "template=s"=>\$template, "depth"=>\&unsupported, "recursive"=>\$recursive)
    or exit 1;
  die "$arg0: clone: incorrect usage\n" if $@>2;
  my($repo,$dir) = @_;

  # supermodule clone
  my @gitargs;
  push @gitargs, "--local" if $local;
  push @gitargs, "--no-hardlinks" if $no_hardlinks;
  push @gitargs, "--verbose" if $verbose; # do not pass "--quiet"
  push @gitargs, "--branch", $branch if $branch;
  push @gitargs, "--upload-pack", $upload_pack if $upload_pack;
  push @gitargs, "--template", $template if $template;
  push @gitargs, $repo;
  push @gitargs, $dir if $dir;
  open GIT, "-|", "git clone @{[join ' ', @gitargs]}" or die "$arg0: git clone failed";
  my($dirline) = <GIT>;
  close GIT or die "$arg0: git clone failed";

  # Find the local repository
  die "$arg0: where's the local repository?!?" unless $dirline =~ /^Initialized empty Git repository in\s+(.*?)\/.git\/?$/;
  $dir = $1;
  chdir $dir or die "$arg0: cannot find Git repository at $dir: $!\n";

  # set up and clone submodules
  git "submodule", "--quiet", "init" or die;
  rewrite_submodule_configs($edit);
  git "submodule", "update" or
    die "$arg0: submodule update failed.  Fix your .git/config file and run \"git submodule update\" by hand.\n";

  # Switch to a branch of the submodule
  execute sub {switch_to_branch symbolic_ref}, submodules;
  print "Repository cloned to $dir\n";
}

# Commits changes in the main ROSE repo and in the submodules.
# FIXME: Some of Git's commit switches are not handled here; the "-a" and "-m" switches are the only ones that are.
sub do_commit {
  my($all,$reuse,$reedit,$reset_author,$msgfile,$author,$message,$template,$signoff,$no_verify,$cleanup,$edit);
  my($untracked,$verbose,$quiet);
  GetOptionsFromArray(\@_,
		      "a|all"=>\$all, "C|reuse-message=s"=>\$reuse, "c|reedit-message=s"=>\$reedit,
		      "reset-author"=>\$reset_author, "F|file=s"=>\$msgfile, "author=s"=>\$author,
		      "m|message=s"=>\$message, "t|template=s"=>\$template, "s|signoff"=>\$signoff,
		      "n|no-verify"=>\$no_verify, "allow-empty"=>\&unsupported, "cleanup=s"=>\$cleanup,
		      "e|edit"=>\$edit, "amend"=>\&unsupported, "i|include"=>\&unsupported, "o|only"=>\&unsupported,
		      "u|untracked-files=s"=>\$untracked, "v|verbose"=>\$verbose, "q|quiet"=>\$quiet,
		      "dry-run"=>\&unsupported) or exit 1;
  die "$arg0: commit: incorrect usage\n" if @_;

  my $git_commit = sub {
    my($path,$sha1) = @_;
    unless (commit_has_effect($all)) {
      print "Nothing to commit.\n";
      return;
    }
    my @gitargs;
    push @gitargs, "--all" if $all;
    push @gitargs, "--reuse-message", $reuse if $reuse && $path eq ".";
    push @gitargs, "--reedit-message", $reedit if $reedit && $path eq ".";
    if ($msgfile) {
      push @gitargs, "--file", $msgfile;
    } elsif ($message) {
      push @gitargs, "--message", $message;
    }
    push @gitargs, "--template", $template if $template;
    push @gitargs, "--signoff" if $signoff;
    push @gitargs, "--no-verify" if $no_verify;
    push @gitargs, "--cleanup", $cleanup if $cleanup;
    push @gitargs, "--edit" if $edit;
    push @gitargs, "--untracked-files", $untracked if $untracked;
    push @gitargs, "--verbose" if $verbose;
    push @gitargs, "--quiet" if $quiet;
    git "commit", @gitargs or die "$arg0: commit failed\n";
    $msgfile = save_commit_message("HEAD"); #remember mesg so we don't have to retype it
  };

  execute $git_commit, submodules;                          # commit in submodules
  execute sub {git "add", map {$_->[0]} submodules or die}; # add submodule paths in top of ROSE
  execute $git_commit, undef;                               # commit in top of ROSE
  unlink $msgfile;
}

# Merges some branch into the current branch using the following algorithm:
#       (1) Merge (but do not commit) in the supermodule, ignoring conflicts for now
#       (2) Do merges in the submodules
#       (3) Add new submodule versions to supermodule, probably fixing most conflicts
#       (4) Commit the merge from step 1, checking for and failing if conflicts remain
sub do_merge {
  my(@args) = @_;
  my($unused,$allow_ff,$log,$diffstat,$ff_only,$quiet,$verbose,$message);
  GetOptionsFromArray(\@_,
		      "commit!"=>\&unsupported, "ff!"=>\$allow_ff, "log!"=>\$log, "stat!"=>\$diffstat,
		      "n"=>sub {$diffstat=0}, "squash"=>\&unsupported, "no-squash"=>\$unused,
		      "ff-only"=>\$ff_only, "s|strategy"=>\&unsupported, "q|quiet"=>\$quiet,
		      "v|verbose"=>\$verbose, "m=s"=>\$message) or exit 1;
  die "$arg0: merge: incorrect usage\n" unless @_;
  die "$arg0: merge: octopuses are not allowed\n" if @_>1;
  my $remote = $_[0];

  # Merge (but do not commit) in the supermodule, ignoring conflicts for now.
  my $merge = sub {
    my($path) = @_;
    my($rev) = $remote;
    if ($path ne ".") {
      $rev = git1 {cd=>".."}, "rev-parse $remote:$path" or die;
    }
    my @gitargs;
    push @gitargs, "--no-commit" if $path eq ".";
    push @gitargs, "--ff" if $allow_ff;
    push @gitargs, "--no-ff" if !$allow_ff && defined $allow_ff;
    push @gitargs, "--log" if $log;
    push @gitargs, "--no-log" if !$log && defined $log;
    push @gitargs, "--stat" if $diffstat;
    push @gitargs, "--no-stat" if !$diffstat && defined $diffstat;
    push @gitargs, "--ff-only" if $ff_only;
    push @gitargs, "--quiet" if $quiet;
    push @gitargs, "--verbose" if $verbose;
    my $ok = git "merge", @gitargs, $rev;
    die "$arg0: merge failed\n" unless $ok || $path eq ".";
  };

  execute $merge unless -f "@{[top_of_rose]}/.git/MERGE_HEAD";
  execute $merge, submodules;
  execute sub {git "add", map {$_->[0]} submodules or die};

  if (commit_has_effect) {
    execute sub {
      my @gitargs;
      push @gitargs, "-F", ".git/MERGE_MSG" if -f ".git/MERGE_MSG";
      git "commit", @gitargs or die;
    } or die "Fix conflicts, add to cache, and rerun $arg0 merge command (or commit manually).\n";
  }
}

# Executes a command in every submodule and then the top ROSE repo regardless of whether any command fails. Exits
# nonzero if any command exited with nonzero status.
sub postorder {
  my @args = @_; # for closures
  my $exit;
  for my $sm (submodules, undef) {
    eval { execute sub {git @args}, $sm };
    $exit ||= $@;
  }
  exit 1 if $exit;
}

###############################################################################################################################
# MAIN PROGRAM
###############################################################################################################################

# Make sure we're using Git version 1.6.4 or later (we need the "git submodule foreach" command with the ability to pass
# the submodule name to the script.
my @gvers = `git --version` =~ /(\d+)\.(\d+)\.(\d+)/;
die "$arg0: requires Git version 1.6.4 or later\n"
  unless $gvers[0]>1 || ($gvers[0]==1 && ($gvers[1]>6 || ($gvers[1]==6 && $gvers[2]>=4)));

my %cmds = (branch      => \&do_branch,
            checkout    => \&do_checkout,
            clone       => \&do_clone,
            commit      => \&do_commit,
            help        => sub {execute ["git", "help", @_]}, # no need to execute in submodules
            merge       => \&do_merge,
           );

my $cmd = shift @ARGV;
usage if $cmd =~ /^-/ || !$cmd;
$cmds{$cmd} ? &{$cmds{$cmd}}(@ARGV) : postorder $cmd, @ARGV;

% !TEX root = codethorn.tex
\section{Verifying LTL formul\ae}

\newcommand{\ffalse}{\ensuremath{\mathit{false}}}
\newcommand{\ttrue}{\ensuremath{\mathit{true}}}

At its heart CodeThorn uses a dataflow-based approach to verify LTL
formul\ae\ on the State Transition Graph. The algorithm consists of
two layers. At the outer layer, the abstract syntax tree of the
formula is traversed in bottom-up order. Every sub-expression of the
LTL formula found by the traversal is reduced to a single value in the
Boolean lattice (\cf Fig.~\ref{fig:bool_lattice}) for each state in
the State Transition Graph. This evaluation is performed using a
dataflow analysis, which represents the inner layer of the algorithm.

\begin{figure}
  \centering
   \begin{tikzpicture}[scale=.9]
    \small
    \node (top) {$\top$} 
    child {node (-1)    {\ffalse}}
    child {node (0)     {}
      edge from parent[draw=none]
      child {node (bot) {$\bot$} 
      edge from parent[draw=none]
      }
    }
    child {node (1)    {\ttrue}} 
    ; 
    \draw (-1)    -- (bot);
    \draw (1)     -- (bot);
  \end{tikzpicture} 
  \caption{Boolean lattice the LTL formul\ae\ are reduced to}
  \label{fig:bool_lattice}
\end{figure}

\newcommand{\lub}{\ensuremath{\sqcup}\xspace}
\newcommand{\Lub}{\ensuremath{\bigsqcup}\xspace}
\newcommand{\state}{\ensuremath{\mathit{s}}\xspace}
\newcommand{\STG}{\ensuremath{\mathrm{STG}}\xspace}
\newcommand{\States}{\ensuremath{\mathit{States}}\xspace}
\newcommand{\prop}[1]{\ensuremath{p_{\state,#1}}\xspace} 
\newcommand{\propp}[1]{\ensuremath{p_{\state',#1}}\xspace} 
\newcommand{\G}{\ensuremath{\mathrm{G}}\ }
\newcommand{\F}{\ensuremath{\mathrm{F}}\ }
\newcommand{\X}{\ensuremath{\mathrm{X}}\ }
\newcommand{\R}{\ensuremath{\mathrm{R}}\ }
\newcommand{\U}{\ensuremath{\mathrm{U}}\ }
\newcommand{\WU}{\ensuremath{\mathrm{WU}\ }}

\subsection{A minimum-fixpoint approximation for all-quantified LTL expressions}
The approach we are using is extremely fast, but it computes only an
approximation (a safe upper bound in the Boolean lattice) of the
precise verification result. The approximation happens whenever
multiple paths join at a state, in which case the least upper bound
\lub\ of the results from the individual paths is propagated.

The remainder of this section will discuss how the transfer functions
for each element of the LTL grammar are defined. We are using the
following notational conventions. The
$\STG={\mathit{States},\mathit{Transitions},\mathit{Start}}$ is the
(reduced) State Transition Graph (or Kripke Model
\citep[pg. 27ff]{Clarke1999}). For each state \state\ we have an array of $n$
properties \prop{i}, $i \in [0\dots n]$, where $n+1$ is the number of
sub-expressions in the LTL formula.

\subsubsection{Boolean Operators: \texttt{!}, \texttt{\&}, \texttt{|}}
The Boolean operators over LTL expressions have the least
computationally complex transfer functions as their effect is only
local to each state.
\begin{align*}
e &= !a  & \forall\state\in\States\colon\prop{e} &:= \neg\prop{a}\\
e &= a \& b & \forall\state\in\States\colon\prop{e} &:= \prop{a} \cap \prop{b}\\
e &= a | b & \forall\state\in\States\colon\prop{e} &:= \prop{a} \cup \prop{b}\\
\end{align*}

\subsubsection{The G operator}
The global operator $\G a$ yields true iff the sub-expression $a$ is
true at all states. The transfer function is defined as follows:

\[ e = \G a\colon\qquad\forall\state\in\States\colon\prop{e}
:=\Lub_{\state\prime\in succ(\state)}{\propp{a}} \]

Since we only want to handle all-quantified LTL expressions, it is
safe to join the information from multiple paths using the \lub
operator: If all successors of a node share the yield the same result,
by induction, all paths starting at \state have identical results at
every node, thus we can merge their heads at \state. If the results of
the successors diverge, \state will go to $\top$, (the safe
approximation) and the result at \state is unknown.

Due to the way the logical operations on Boolean lattice are defined,
not all is lost for these states. For example, $\top \vee \ttrue
\equiv \ttrue$ and $\top \wedge \ffalse \equiv \ffalse$, so it is
possible for these unknown states to still be overruled by other
states for which we do have a precise result.

\subsubsection{The X operator}
The next operator $X a$ yields true iff $a$ is true in the next state.
\[ e = \X a \qquad\forall\state\in\States\colon\prop{e}:=\bigcap_{\state\prime\in succ(\state)}{\propp{a}} \]

\subsubsection{The operators F, R, U, and WU}
These operators are computationally more intensive, since we need to
perform a fix point search over the entire state transition graph. Backward.
\begin{tabular}{rlllll}
\toprule
operator & $\mathit{init}$ & $\mathit{start}$ & $\mathit{join}$ &
$\mathit{calc}$ & $\mathit{otherwise}$ \\\midrule

$e = \F a$  & $\ffalse$ & $(\prop{a}==true)$ & $\cup$ & 
$\prop{a}\cup\bigcup_{\state\prime\in succ(\state)}{\prop{e}}$ &\\

$e = a \R b$ & $\bot$ & $(\prop{b}==true)$ & $\cap$ &
$\prop{b} \cap \prop{a} \cup \bigcap_{\state\prime\in succ(\state)}{\prop{e}}$\\

$e = a \U b$ & $\ffalse$ & $(\neg\prop{b}==bot)$ &
$\cup$ & $\prop{a} \cup\bigcap_{\state\prime\in succ(\state)}{\prop{e}}$ & $\ffalse$\\

$e = a \WU b$ & $\bot$ & $(\prop{a}==true)$ & $\cup$ &
$\prop{a} \cup \bigcup_{\state\prime\in succ(\state)}{\prop{e}}$\\\bottomrule
\end{tabular}


\subsubsection{Handling I/O nodes}
\begin{itemize}
\item are propagated to the next I/O state of the same type
\end{itemize}

\subsection{Reducing the State Transition Graph}

\subsection{Debugging: Finding counterexamples}
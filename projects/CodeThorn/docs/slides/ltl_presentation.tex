\newcommand{\lub}{\ensuremath{\sqcup}\xspace}
\newcommand{\Lub}{\ensuremath{\bigsqcup}\xspace}
\newcommand{\state}{\ensuremath{\mathit{s}}\xspace}
\newcommand{\STG}{\ensuremath{\mathrm{STG}}\xspace}
\newcommand{\States}{\ensuremath{\mathit{States}}\xspace}
\newcommand{\prop}[1]{\ensuremath{p_{\state,#1}}\xspace} 
\newcommand{\propp}[1]{\ensuremath{p_{\state',#1}}\xspace} 
\newcommand{\G}{\ensuremath{\mathrm{G}}\xspace}
\newcommand{\F}{\ensuremath{\mathrm{F}}\xspace}
\newcommand{\X}{\ensuremath{\mathrm{X}}\xspace}
\newcommand{\R}{\ensuremath{\mathrm{R}}\xspace}
\newcommand{\U}{\ensuremath{\mathrm{U}}\xspace}
\newcommand{\WU}{\ensuremath{\mathrm{WU}\xspace}}
\newcommand{\comb}{\ensuremath{\mathit{succs}}\xspace}


\begin{frame}{Linear Time Logic Formul\ae\ Verification}

  \begin{block}{Data-flow based approach}
    \begin{itemize}
    \item[-] lossy approximation (upper bound in Boolean lattice)
    \item[+] Very fast
    \end{itemize}
  \end{block}

  \begin{block}{Algorithm 1/2}
    \footnotesize
    \begin{algorithm}[H]
      \SetLine
      \KwIn{State Transition Graph}
      \KwOut{Formulae true, false, or unknown.}

      $G_1$=collapse(STG) \Comment{remove all non-I/O nodes and all exit (=assert) nodes}\\
      eval(LTL, $G_1$) \Comment{Evaluate all LTL sub-expressions bottom-up}
    \end{algorithm}
  \end{block}
\end{frame}

\begin{frame}{Linear Time Logic Formul\ae\ Verification 2}
  \begin{block}{LTL evaluation function}

    \scriptsize
  \begin{algorithm}[H]
    \SetLine
    \KwIn{LTL expression, State Transition Graph}
    \KwOut{$\state\in\States\rightarrow$ BoolLattice}
    \textbf{function} eval(LTL, G)\\
    \Begin{
        \Switch{LTL}{
          \lCase{a \& b}{$\colon\quad\forall\state\in\States\colon$ eval(a) $\cap$ eval(b)}\\
          \lCase{a $|$ b}{$\colon\quad\forall\state\in\States\colon$ eval(a) $\cup$ eval(b)}\\
          \lCase{!a}{$\colon\quad\forall\state\in\States\colon \neg$ eval(a)}\\
          \lCase{\X a}{$\colon\quad\forall\state\in\States\colon\Lub_{\state\prime\in succ(\state)}$eval(a)}\\
          \lCase{\G a}{$\colon\quad$fix($\bot$, \lub, eval(a) $\cap$ \comb)}\\
          \lCase{\F a}{$\colon\quad$fix($\bot$, \lub, eval(a) $\cup$ \comb)}\\
          \lCase{a \R b}{$\colon\quad $fix($\bot$, \lub, eval(b)$\cap$(eval(a)$\cup\comb$))}\\
          \lCase{a \U b}{$\colon\quad $fix($\bot$, \lub, eval(b)$\cup$(eval(a)$\cap\comb$))}\\
          \lCase{a \WU\ b}{eval(G a $|$ (a \U b))}\\
        }
      }
      
      \caption{eval}
    \end{algorithm}

    \medskip

    worklist/fixpoint:  fix(\emph{init}, \emph{join}, \emph{transfer})
  \end{block}
\end{frame}
\newcommand{\ffalse}{\ensuremath{\mathit{false}}}
\newcommand{\ttrue}{\ensuremath{\mathit{true}}}

\begin{frame}{Backup slide: Operators}
  \begin{block}{Boolean lattice the LTL formul\ae\ are reduced to}
    \begin{columns}
      \begin{column}{4cm}
   \begin{tikzpicture}[scale=.9]
    \small
    \node (top) {$\top$} 
    child {node (-1)    {\ffalse}}
    child {node (0)     {}
      edge from parent[draw=none]
      child {node (bot) {$\bot$} 
      edge from parent[draw=none]
      }
    }
    child {node (1)    {\ttrue}} 
    ; 
    \draw (-1)    -- (bot);
    \draw (1)     -- (bot);
  \end{tikzpicture} 
\end{column}
\begin{column}{6cm}
  \scriptsize
  \begin{tabular}{r|llll}
    \lub   & $\bot$ & \ffalse & \ttrue & $\top$ \\ \hline
    $\bot$ & $\bot$ & \ffalse & \ttrue & $\top$ \\
    \ffalse& \ffalse& $\top$  & $\top$ & $\top$ \\
    \ttrue & \ttrue & $\top$  & $\top$ & $\top$ \\
    $\top$ & $\top$ & $\top$  & $\top$ & $\top$ \\
  \end{tabular}\\
  \medskip
  \begin{tabular}{r|llll}
    $\cap$ & $\bot$ & \ffalse & \ttrue & $\top$ \\ \hline
    $\bot$ & $\bot$ & \ffalse & \ttrue & $\top$ \\
    \ffalse& \ffalse& \ffalse & \ffalse& \ffalse \\
    \ttrue & \ttrue & \ffalse & \ttrue & $\top$ \\
    $\top$ & $\top$ & \ffalse & $\top$ & $\top$ \\
  \end{tabular}\\
  \medskip
  \begin{tabular}{r|llll}
    $\cup$ & $\bot$ & \ffalse & \ttrue & $\top$ \\ \hline
    $\bot$ & $\bot$ & \ffalse & \ttrue & $\top$ \\
    \ffalse& \ffalse& \ffalse & \ttrue & $\top$ \\
    \ttrue & \ttrue & \ttrue  & \ttrue & \ttrue \\
    $\top$ & $\top$ & $\top$  & \ttrue & $\top$ \\
  \end{tabular}

\end{column}
    \end{columns}
  \end{block}
\end{frame}

\begin{frame}{Finding Counterexamples with QuickCheck 1/2}
  \begin{block}{Motivation}
    \begin{itemize}
    \item Needed a way to verify verification results
    \item Idea: use the executable to find concrete counterexamples
    \item Intended to verify correctness of \emph{false} results
    \item But turned out to be quite effective!
    \end{itemize}
  \end{block}

  \begin{block}{Idea}
    \begin{itemize}
    \item Use QuickCheck to generate random inputs
    \item Execute program to generate a specific output sequence
    \item verify LTL on I/O sequence $\ffalse \rightarrow$ counterexample!
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]{Finding Counterexamples with QuickCheck 2/2}
  \begin{block}{Implementation}
    \begin{itemize}
    \item $\sim$ 200 lines of Haskell
    \item ignores runs that fail (RERS requirement)
    % Problem: we get only a finite I/O sequence from a run
    % how can we ensure that the result is correct?
    \item operates on Bool lattice to deal with finite I/O sequences:\\
      $\neq\top\rightarrow$ later states cannot influence result 
    \end{itemize}
  \end{block}

  \begin{lstlisting}[language=Haskell,basicstyle=\tiny]
holds :: LTL -> [State] -> BoolLattice
holds (In  c) ((StIn  stc):_) = lift (c == stc)
holds (Out c) ((StOut stc):_) = lift (c == stc)
holds (In  c) ((StOut stc):states) = holds (In  c) states
holds (Out c) ((StIn  stc):states) = holds (Out c) states
holds       (X a) (_:states) = holds a states
holds       (F a) states = (holds a states) ||| (holds (X (F a)) states)
holds       (G a) states = (holds a states) &&& (holds (X (G a)) states)
holds     (Not a) states = nnot (holds a states)
holds (a `And` b) states = (holds a states) &&& (holds b states)
holds (a `Or`  b) states = (holds a states) ||| (holds b states)
holds (a `U`   b) states = (holds b states) ||| ((holds a states) &&& (holds (X (a `U` b)) states))
holds (a `R`   b) states = (holds b states) &&& ((holds a states) ||| (holds (X (a `R` b)) states))
holds (a `WU`  b) states = holds ((G a) `Or` (a `U` b)) states
holds _ _ = Top
  \end{lstlisting}

\end{frame}

\begin{frame}{Work-in-progress:}
  \begin{block}{Motivation}
    Currently precision is lost when two paths merge at a state,
    because we join the information using \lub\ (least upper bound).
  \end{block}
  \begin{block}{Idea}
    \begin{itemize}
    \item Create a new (LTL-)State, instead of joining the two paths.
    \item Identical (LTL-)States will be merged, because they (by
      definition) share the same future/state/successors.
    \end{itemize} 
    Hope to have results by the end of the week!
  \end{block}
\end{frame}
// -*- mode: C++; coding: utf-8; -*-
// Parser for LTL formulae 
%{
#include <cstdio>
#include <cstdlib>
#include <sstream>
#include <iostream>
#include <string>
#include <cassert>
#include "LTL.h"

// Scanner function
int ltl_lex(void);
void ltl_error (char const *msg);

// Parser return type
#define YYSTYPE ltl::Expr*

// Scanner variables
bool ltl_eof = false;
static int ltl_pos = 0;
static int ltl_line = 1;
static int ltl_next_char = EOF;
static std::stringstream debug_line;
ltl::Formula* ltl_val;
FILE* ltl_input = NULL;

%}
     
%token IN_SYMBOL OUT_SYMBOL WU
%left  NOT
%left  X
%left  F
%left  G
%left  '&'
%left  '|'
%left  'U'
%left  WU
%left  'R'

%% /* Grammar rules and actions follow.  */

// In the LTL formulae, the atomic propositions correspond to input
// and output symbols, where the prefix i is used for input and o is
// used for output symbols, to allow a clear distinction.

// The LTL formulae are given in a standard syntax, making use of the
// following temporal operators:

// X φ (next): φ has to hold after the next step
// F φ (eventually): φ has to hold at some point in the future (or now)
// G φ (globally): φ has to hold always (including now)
// φ U ψ (until): φ has to hold until ψ holds (which eventually occurs)
// φ WU ψ (weak until): φ has to hold until ψ holds (which does not necessarily occur)
// φ R ψ (release): φ has to hold until ψ held in the previous step.
// Additionally, the boolean operators & (conjunction), | (disjunction) and ! (negation) are used.

// Example:
//
// (G (! ((oY & ! iC) & (F iC)) | (! oW U iC)))
// output W does never occur between output Y and input C

start: expr     { assert($1); ltl_val = new ltl::Formula(*$1); return 0; }

expr:
'(' expr ')'    { $$ = $2; }
| IN_SYMBOL     { $$ = new ltl::InputSymbol(ltl_next_char); }
| OUT_SYMBOL    { $$ = new ltl::OutputSymbol(ltl_next_char); }
| op_expr       { $$ = $1; }

op_expr:
  '!' expr %prec NOT { $$ = new ltl::Not($2); }
| 'X' expr %prec X   { $$ = new ltl::Next($2); }
| 'F' expr %prec F   { $$ = new ltl::Eventually($2); }
| 'G' expr %prec G   { $$ = new ltl::Globally($2); }
| expr '&' expr      { $$ = new ltl::And($1, $3); }
| expr '|' expr      { $$ = new ltl::Or($1, $3); }
| expr 'U' expr      { $$ = new ltl::Until($1, $3); }
| expr WU  expr      { $$ = new ltl::WeakUntil($1, $3); }
| expr 'R' expr      { $$ = new ltl::Release($1, $3); }

%%


int ltl_lex(void) {
  if (!ltl_input) ltl_input = stdin;
  ltl_next_char = getc(ltl_input);
  debug_line << (char)ltl_next_char;
  ltl_pos++;
  switch (ltl_next_char) {
  case EOF:   ltl_eof = true; return 0;
  case 'i':   ltl_next_char = getc(ltl_input);
              debug_line << (char)ltl_next_char;
              return IN_SYMBOL;
  case 'o':   ltl_next_char = getc(ltl_input);
              debug_line << (char)ltl_next_char;
              return OUT_SYMBOL;
  case 'W':   ltl_next_char = getc(ltl_input);
              if (ltl_next_char == 'U') {
		debug_line << (char)ltl_next_char;
		return WU;
              } else {
                ltl_pos--;
                ungetc(ltl_next_char, ltl_input);
                return ltl_next_char;
              }
  case '\r':
  case '\n':  ltl_line++; 
              ltl_pos=1;
              debug_line.clear();
              return 0;
  case ' ':
  case '\t':  return ltl_lex();
  default:    return ltl_next_char;
  }
}

void ltl_error (char const *msg) {
  if (ltl_eof) {
    // std::cerr << "unexpected end of file" << std::endl;
    return;
  }
  std::string remainder;
  int c;
  while (1) {
    c = fgetc(ltl_input);
    if (c == '\r' || c == '\n' || c == EOF)
      break;
    debug_line << (char)c;
  }
  std::cerr << debug_line.str() << remainder << std::endl;
  std::cerr << std::string(ltl_pos-1, '-') << "^"<< std::endl;
  fprintf(stderr, "%d:%d: %s\n", ltl_line, ltl_pos, msg);
  exit(1);
}

#ifdef LTL_PARSER_DEBUG
int main (void)
{
  while (ltl_parse() == 0) {
    if (ltl_eof) break;
    if (ltl_val)
      std::cout << std::string(*ltl_val) << std::endl;
    ltl_val = NULL;
  }
}
#endif


// -*- mode: C++; coding: utf-8; -*-
// Parser for LTL formulae 
%{
#include <cstdio>
#include <cstdlib>
#include <sstream>
#include <iostream>
#include <string>
#include <cassert>
#include "ltl.h"

// Scanner function
int ltl_lex(void);
void ltl_error (char const *msg);

// Parser return type
#define YYSTYPE ltl::Expr*

// Scanner variables
static int ltl_pos = 0;
static int ltl_line = 1;
static int ltl_next_char = EOF;
static std::stringstream debug_line;
static YYSTYPE ltl_val;

%}
     
%token IN_SYMBOL OUT_SYMBOL WU
%left  NOT
%left  X
%left  F
%left  G
%left  '&'
%left  '|'
%left  'U'
%left  WU
%left  'R'

%% /* Grammar rules and actions follow.  */

// In the LTL formulae, the atomic propositions correspond to input
// and output symbols, where the prefix i is used for input and o is
// used for output symbols, to allow a clear distinction.

// The LTL formulae are given in a standard syntax, making use of the
// following temporal operators:

// X φ (next): φ has to hold after the next step
// F φ (eventually): φ has to hold at some point in the future (or now)
// G φ (globally): φ has to hold always (including now)
// φ U ψ (until): φ has to hold until ψ holds (which eventually occurs)
// φ WU ψ (weak until): φ has to hold until ψ holds (which does not necessarily occur)
// φ R ψ (release): φ has to hold until ψ held in the previous step.
// Additionally, the boolean operators & (conjunction), | (disjunction) and ! (negation) are used.

// Example:
//
// (G (! ((oY & ! iC) & (F iC)) | (! oW U iC)))
// output W does never occur between output Y and input C

start: expr { ltl_val = $1; }

expr:
'(' op_expr ')' { $$ = $2; }
| IN_SYMBOL     { $$ = new ltl::InputSymbol(ltl_next_char); }
| OUT_SYMBOL    { $$ = new ltl::OutputSymbol(ltl_next_char); }
| op_expr       { $$ = $1; }

op_expr:
  '!' expr %prec NOT { $$ = new ltl::Not($2); }
| 'X' expr %prec X   { $$ = new ltl::Next($2); }
| 'F' expr %prec F   { $$ = new ltl::Eventually($2); }
| 'G' expr %prec G   { $$ = new ltl::Globally($2); }
| expr '&' expr      { $$ = new ltl::And($1, $3); }
| expr '|' expr      { $$ = new ltl::Or($1, $3); }
| expr 'U' expr      { $$ = new ltl::Until($1, $3); }
| expr WU  expr      { $$ = new ltl::WeakUntil($1, $3); }
| expr 'R' expr      { $$ = new ltl::Release($1, $3); }

%%


int ltl_lex(void) {
  ltl_next_char = getc(stdin);
  debug_line << (char)ltl_next_char;
  ltl_pos++;
  switch (ltl_next_char) {
  case EOF:   return 0;
  case 'i':   ltl_next_char = getc(stdin);
              debug_line << (char)ltl_next_char;
              return IN_SYMBOL;
  case 'o':   ltl_next_char = getc(stdin);
              debug_line << (char)ltl_next_char;
              return OUT_SYMBOL;
  case 'W':   ltl_next_char = getc(stdin);
              if (ltl_next_char == 'U') return WU;
	      else {
		ltl_pos--;
		ungetc(ltl_next_char, stdin);
		return ltl_next_char;
	      }
  case '\r':
  case '\n':  ltl_line++; 
              ltl_pos=1;
              debug_line.clear();
              return ltl_lex();
  case ' ':
  case '\t':  return ltl_lex();
  default:    return ltl_next_char;
  }
}

void ltl_error (char const *msg) {
  std::string remainder;
  std::getline(std::cin, remainder);
  std::cerr << debug_line.str() << remainder << std::endl;
  std::cerr << std::string(ltl_pos-1, '-') << "^"<< std::endl;
  fprintf(stderr, "%d:%d: %s\n", ltl_line, ltl_pos, msg);
  exit(1);
}

int main (void)
{
  ltl_parse();
  assert(ltl_val);
  std::cout << std::string(*ltl_val) << std::endl;
}


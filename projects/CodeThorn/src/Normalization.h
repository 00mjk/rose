#ifndef LOWERING_H
#define LOWERING_H

// Author: Markus Schordan 2018.

#include <list>
#include <utility>

class SgNode;
class SgWhileStmt;
class SgDoWhileStmt;
class SgForStatement;
class SgSwitchStatement;

#include "NormalizationOp.h"

namespace SPRAY {

  class Normalization {
    // Not supported yet: 
    // 1. condition hoisting in do-while (into the block, not before the loop)
    // 2. transformation of continue in while, do-while

  public:
    struct Options {
      // only normalize expressions with function calls
      bool restrictToFunCallExpressions=true;
      // turns single statements into blocks with one statement
      bool normalizeSingleStatements=true;
      // replace for with while
      bool eliminateForStatements=true;
      // replace while with if/goto
      bool eliminateWhileStatements=true; 
      // eliminate operators '||', '&&' (not supported yet)
      const bool eliminateShortCircuitOperators=false;
      // eliminate operator '?' (not supported yet)
      const bool eliminateConditionalExpressionOp=false;
      bool hoistConditionExpressions=true;
      bool normalizeExpressions=true;
      bool normalizeVariableDeclarations=false;

      // transforms break in switch to gotos. This can cause unparsed
      // code to not compile because of special C++ rules of
      // by-passing initializaitons with gotos. It is not a problem
      // for the analysis, but for unparsing. Therefore this is off by
      // default.
      bool transformBreakToGotoInSwitchStmt=false;

      // This is not necessary for normalization. Only interesting for
      // lowering. Applies to {for, do, do-while}
      bool transformBreakToGotoInLoopStmts=false;

      // not supported yet - required for normalization of while when
      // condition is hoisted). This transformation is applied to
      // while and do-while, not to for-loops.
      bool transformContinueToGotoInWhileStmts=false;

      // using SgInterface inlining (to be replaced)
      bool inlining=false;
    } options;

    // applies all available lowering operations
    void normalizeAst(SgNode* root);

    static void setLabelPrefix(std::string prefix);
    static std::string newLabelName();
    bool hasFunctionCall(SgExpression* expr);
    static SgLabelStatement* createLabel(SgStatement* target);
    static void createGotoStmtAtEndOfBlock(SgLabelStatement* newLabel, SgBasicBlock* block, SgStatement* target);
    static SgGotoStatement* createGotoStmtAndInsertLabel(SgLabelStatement* newLabel, SgStatement* target);

    // enable/disable inling. By default off.
    void setInliningOption(bool flag);
    bool getInliningOption();
    // calls ROSE SageInterface function for inlining
    size_t inlineFunctions(SgNode* root);
    // default value, can be overwritten
    int inlineDepth=10; 

  private:
    /* normalize all Expressions in AST. The original variables remain
     * in the program and are assign the last value of the sequence of
     * operations of an expression. */
    void normalizeExpressionsInAst(SgNode* node, bool onlyNormalizeFunctionCallExpressions=false);

    // moves conditions out of if and switch constructs
    void hoistConditionsInAst(SgNode* node, bool onlyNormalizeFunctionCallExpressions=false);
    // moves conditions out of if and switch constructs. Declares new
    // variable for intermediate result
    void hoistCondition(SgStatement* node);

    // converts for-stmts to while-stmts (uses SageInterface function)
    void convertAllForStmtsToWhileStmts(SgNode* top);

    // normalizes all single statements in if-statements to blocks (sage version)
    void normalizeSingleStatementsToBlocks(SgNode* node);

    // normalizes variable declarations T x=init to T x; x=init; 
    void normalizeAllVariableDeclarations(SgNode* node);
    /* Given 'Type x=init;' is transformed into 'Type x;' and returns 'x=init;'
       return nullptr if provided declaration is in global scope (cannot be normalized) */
    SgStatement* buildNormalizedVariableDeclaration(SgVariableDeclaration* varDecl);
    // create a lowering sequence of NormalizationOp objects

    void createLoweringSequence(SgNode* root);
    // apply lowering sequence generated by createLoweringSequence
    void applyLoweringSequence();

    // transform expression with root ExprStatement into a list of separate assignments
    void normalizeExpression(SgExprStatement* stmt, SgExpression* node);

    void generateTmpVarAssignment(SgExprStatement* stmt, SgExpression* expr);
    // Finds needle in haystack and returns true if found.  Needle is a single node (possibly an invalid pointer and will not be
    // dereferenced) and haystack is the root of an abstract syntax (sub)tree.
    static bool isAstContaining(SgNode *haystack, SgNode *needle);
    /* If the given statement contains any break statements in its body,
       add a new label below the statement and change the breaks into
       gotos to that new label. Addresses for,while,switch stmts.
       Transforms continue to gotos in while-loops (not for-loops).
    */
    void normalizeBreakAndContinueStmts(SgNode *ast);
    void transformContinueToGotoStmts(SgWhileStmt* whileStmt);
    void transformContinueToGotoStmts(SgDoWhileStmt* whileStmt);

    // counter for generating new variable names (currently not used)
    static int32_t tmpVarNr;
    // counter for generating new label names
    static int labelNr;
    static std::string labelPrefix;

    typedef std::list<std::pair<SgStatement*,SgExpression*> > TransformationList;
    TransformationList transformationList;
    std::list<NormalizationOp*> loweringSequence;
  };
  
} // end of namespace SPRAY

#endif

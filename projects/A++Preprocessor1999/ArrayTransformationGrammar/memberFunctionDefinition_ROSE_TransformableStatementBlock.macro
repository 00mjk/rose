CLASSNAME::~CLASSNAME ()
   {
   }

CLASSNAME::CLASSNAME ( ROSE_StatementBlock* roseStatementBlock )
   : BASECLASSNAME(roseStatementBlock)
   {
  // This function is a virtual member function 
     recognizeRoseSubTree (roseStatementBlock);
   }

ROSE_TransformableNode* CLASSNAME::transform()
   {
  // printf ("Sorry not implemented, CLASSNAME::Tranform() \n");
  // ROSE_ABORT();

     ROSE_ASSERT (!error());

     ROSE_Statement* roseStmt = (ROSE_Statement*) getRoseSubTree();
     ROSE_ASSERT (roseStmt != NULL);
     SgStatement* stmt = (SgStatement*) roseStmt->getSageSubTree();
     ROSE_ASSERT (stmt != NULL);

     if ( (ROSE_DEBUG > 0) || (ROSE::verbose == TRUE) )
          printf ("In CLASSNAME::transform(): (file name = %s line number = %d)  roseStatementList.getLength() = %d \n",
               ROSE::getFileName(stmt),ROSE::getLineNumber(stmt),transformableStatementList.getLength());

  // ROSE_TransformableStatementBlock* roseTransformableStatementBlock = new ROSE_TransformableStatementBlock (roseStatementBlock);
  // ROSE_ASSERT (roseTransformableStatementBlock != NULL);
  // ROSE_ASSERT (!roseTransformableStatementBlock->error());

#if 1
  // if ( isSgScopeStatement(stmt) == NULL )
  //      showSgStatement (cout, stmt,"Called from CLASSNAME::transform()");

     ROSE_ASSERT (isSgScopeStatement(stmt) != NULL);
     SgScopeStatement *sageScopeStmt = isSgScopeStatement(stmt);
     ROSE_ASSERT (sageScopeStmt != NULL);
  // printf ("Push a new scope ON the stack! \n");
     globalArrayAssignmentUsingTransformationGrammar->pushCurrentScope (sageScopeStmt);
#endif
     for (int i=0; i < transformableStatementList.getLength(); i++)
        {
       // Not clear if we want to put this into another ROSE_TransformableStatementBlock
          ROSE_TransformableStatement* transformableStatement = 
               (ROSE_TransformableStatement*) transformableStatementList[i].transform();
          ROSE_ASSERT (transformableStatement != NULL);
        }
#if 1
  // printf ("Pop an existing scope OFF the stack! \n");
     ROSE_ASSERT (sageScopeStmt != NULL);
     globalArrayAssignmentUsingTransformationGrammar->popCurrentScope (sageScopeStmt);
#endif

#if 1
  // return roseTransformableStatementBlock;
#endif

  // Return the "this" pointer for now
     return this;
   }

void CLASSNAME::recognizeRoseSubTree ( ROSE_StatementBlock* roseStatementBlock )
   {
  // printf ("Sorry, not implemented: CLASSNAME::recognizeSageSubTree(SgBasicBlock*) \n");
     ROSE_TransformableNode::setUp (CLASSNAME_TAG,roseStatementBlock);
   }

int CLASSNAME::getNumberOfStatements ()
   {
     return transformableStatementList.getLength();
   }

void CLASSNAME::addTransformableStatementToBlock ( ROSE_TransformableStatement* transformableStatement )
   {
  // printf ("Sorry, not implemented: CLASSNAME::addArrayStatementToBlock(ROSE_Statement*) \n");
     transformableStatementList.addElement (*transformableStatement);
   }

ROSE_TransformableStatement* CLASSNAME::operator[](int i)
   {
     return &transformableStatementList[i];
   }

CLASSNAME::~CLASSNAME ()
   {
   }

#if 0
CLASSNAME::CLASSNAME ()
   {
     ROSE_TransformableNode::setUp (CLASSNAME_TAG,NULL);
   }
#endif

CLASSNAME::CLASSNAME ( ROSE_Expression* expr )
   : BASECLASSNAME(expr)
   {
     ROSE_ASSERT (expr != NULL);
     ROSE_TransformableNode::setUp (CLASSNAME_TAG,expr);
   }

ROSE_TransformableNode* CLASSNAME::transform()
   {
  // printf ("Sorry not implemented, CLASSNAME::Tranform() \n");
  // ROSE_ABORT();

     ROSE_TransformableExpression* localLhsTransformableExpression = 
          getLhsTransformableExpression();
     ROSE_TransformableExpression* localRhsTransformableExpression = 
          getRhsTransformableExpression();
     ROSE_ASSERT (localLhsTransformableExpression != NULL);
     ROSE_ASSERT (localRhsTransformableExpression != NULL);

     ROSE_ASSERT (!localLhsTransformableExpression->error());
     ROSE_ASSERT (!localLhsTransformableExpression->getRoseExpression()->error());
     ROSE_ASSERT (!localRhsTransformableExpression->error());
     ROSE_ASSERT (!localRhsTransformableExpression->getRoseExpression()->error());

  // Call tranform() member function of the lhs and rhs expressions
     ROSE_NonTransformableExpression* localLhsNonTransformableExpression = 
          (ROSE_NonTransformableExpression*) localLhsTransformableExpression->transform();
     ROSE_NonTransformableExpression* localRhsNonTransformableExpression = 
          (ROSE_NonTransformableExpression*) localRhsTransformableExpression->transform();
     ROSE_ASSERT (localLhsNonTransformableExpression != NULL);
     ROSE_ASSERT (localRhsNonTransformableExpression != NULL);

     ROSE_ASSERT (!localLhsNonTransformableExpression->error());
     ROSE_ASSERT (!localLhsNonTransformableExpression->getRoseExpression()->error());
     ROSE_ASSERT (!localRhsNonTransformableExpression->error());
     ROSE_ASSERT (!localRhsNonTransformableExpression->getRoseExpression()->error());

  // The transform(expr,expr) is a virtual function and we have to cast the return pointer
  // virtual functions must have the same return type from all classes (a C++ rule).
     ROSE_NonTransformableExpression* nonTransformableExpression = (ROSE_NonTransformableExpression*)
          assembleTransform (localLhsNonTransformableExpression,localRhsNonTransformableExpression);
     ROSE_ASSERT (nonTransformableExpression != NULL);

#if 0
     printf ("Exiting at base of CLASSNAME::transform() \n");
     ROSE_ABORT();
#endif

     return nonTransformableExpression;
   }

#if 0
ROSE_TransformableNode* CLASSNAME::transform (
     ROSE_NonTransformableExpression* lhs,
     ROSE_NonTransformableExpression* rhs )
   {
  // The role of this function is the take the ROSE_Transformable grammar objects and
  // use them from the tranformations of the lhs and rhs to assemble the transformation
  // for the CLASSNAME object.

     ROSE_Expression* roseLhsExpression = lhs->getRoseExpression ();
     ROSE_ASSERT (roseLhsExpression != NULL);

     ROSE_Expression* roseRhsExpression = rhs->getRoseExpression ();
     ROSE_ASSERT (roseRhsExpression != NULL);
     
     ROSE_ASSERT (!roseLhsExpression->error());
     ROSE_ASSERT (!roseRhsExpression->error());

     ROSE_BinaryArrayOperator* roseLocalExpression = (ROSE_BinaryArrayOperator*) getRoseExpression();
     ROSE_ASSERT (roseLocalExpression != NULL);
     ROSE_C_Expression* roseRootExpression =
          (ROSE_C_Expression*) (roseLocalExpression->assembleTransform (roseLhsExpression,roseRhsExpression));
     ROSE_ASSERT (roseRootExpression != NULL);

  // Return a ROSE_NonTransformableExpression object
     ROSE_NonTransformableExpression* nonTransformableExpression = new ROSE_NonTransformableExpression (roseRootExpression);
     ROSE_ASSERT (nonTransformableExpression != NULL);

     return nonTransformableExpression;
   }
#endif





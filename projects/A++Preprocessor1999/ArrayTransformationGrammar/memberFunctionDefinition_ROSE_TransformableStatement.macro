CLASSNAME::~CLASSNAME ()
   {
  // Nothing to do here!
   }

CLASSNAME::CLASSNAME ( ROSE_Statement* stmt )
   : BASECLASSNAME (stmt)
   {
     ROSE_ASSERT (stmt != NULL);

  // setVariant ( CLASSNAME_TAG );
  // setParseError(FALSE);
     ROSE_TransformableNode::setUp (CLASSNAME_TAG,stmt);

     localDataBase = NULL;
     setRoseStatement (stmt);
   }

ROSE_TransformableNode*
CLASSNAME::transform()
   {
     ROSE_ASSERT (!error());

     ROSE_Statement* roseStmt = (ROSE_Statement*) getRoseSubTree();
     ROSE_ASSERT (roseStmt != NULL);
     SgStatement* originalStatement = (SgStatement*) roseStmt->getSageSubTree();
     ROSE_ASSERT (originalStatement != NULL);

     if ( (ROSE_DEBUG > 0) || (ROSE::verbose == TRUE) )
          printf ("In CLASSNAME::transform(): (file name = %s line number = %d) \n",
               ROSE::getFileName(originalStatement),ROSE::getLineNumber(originalStatement));

  // Call the transform member function (it will recursively traverse the ROSE Transformation Tree)
     ROSE_NonTransformableExpression* nonTransformableExpression = (ROSE_NonTransformableExpression*) getExpression()->transform();
     ROSE_ASSERT (nonTransformableExpression != NULL);

  // Get the ROSE_C_Expression out of the ROSE_NonTransformableExpression
     ROSE_C_Expression* roseTransformedExpression = (ROSE_C_Expression*) nonTransformableExpression->getRoseSubTree();
     ROSE_ASSERT (roseTransformedExpression != NULL);

  // get the Sage Expression object out of the ROSE_C_Expression
     SgExpression* sageTransformedExpression = (SgExpression*) roseTransformedExpression->getSageSubTree();
     ROSE_ASSERT (sageTransformedExpression != NULL);

  // Now put the sageTransformedExpression into a SgExprStatement
     SgExprStatement* sageTransformedStatement = new SgExprStatement (ROSE_Node::buildSageFileInfo(),sageTransformedExpression);
     ROSE_ASSERT (sageTransformedStatement != NULL);

#if 0
     printf ("\n\n");
     showSgStatement (cout, sageTransformedStatement , "sageTransformedStatement inside of CLASSNAME::transform()");

     printf ("\n\n");
     printf ("Now unparse the statement: \n");
     sageTransformedStatement->logical_unparse(NO_UNPARSE_INFO,cout);
     printf ("\n\n");
     cout << endl << endl;
#endif

  // This is the function which uses the newly built Sage Statement as the inner loop body of the a for loop
  // and supporting variable declarations that are also introduced into the Sage Tree. This completes the 
  // transformation for a single statement.  Later we might want to locate this modification of the Sage Tree
  // within another location within ROSE, so that the final editing of the Sage tree is abstracted from the
  // definition of what ever transformation we do.

  // This was the old way of calling the buildForLoopStructureAndModifySageTree 
  // function, now it is a member function!
  // ROSE_ASSERT (globalArrayAssignmentUsingTransformationGrammar != NULL);
  // globalArrayAssignmentUsingTransformationGrammar->buildForLoopStructureAndModifySageTree ( originalStatement, sageTransformedStatement );
     buildForLoopStructureAndModifySageTree ( originalStatement, sageTransformedStatement );

#if 0
     printf ("\n\n");
     printf ("Exiting after first transformation! ( In CLASSNAME::transform() ) \n");
     ROSE_ABORT();
#endif
     return this;
   }

ROSE_Statement* 
CLASSNAME::getRoseStatement ()
   {
  // ROSE_ASSERT (!error());
     return (ROSE_Statement*) getRoseSubTree(); 
   }

void 
CLASSNAME::setRoseStatement ( ROSE_Statement* stmt )
   {
     ROSE_ASSERT (stmt != NULL);
     setRoseSubTree(stmt);
   }

ROSE_TransformableBinaryOperatorEquals* 
CLASSNAME::getExpression ()
   {
     ROSE_ASSERT (transformableBinaryOperatorEquals != NULL);
     return transformableBinaryOperatorEquals;
   }

void 
CLASSNAME::setExpression ( ROSE_TransformableBinaryOperatorEquals* expr )
   {
     ROSE_ASSERT (expr != NULL);
     transformableBinaryOperatorEquals = expr;
   }

#if 0
void
CLASSNAME::setUpDataBase()
   {
  // This function calls the data base mechanism on the 
  // ArrayAssignmentUsingTransformationGrammar object.

     localDataBase = setUpDataBase();
   }
#endif

int CLASSNAME::numberOfRhsOperands()
   {
  // This function searches the tree and counts the number of operands on the Rhs
  // This could be part of a function that searches the statement and identifies
  // all the data that we require to know about a statement and puts it into a small
  // data base.

  // We want to access the data from the data base build locally

  // return ZERO for now until this is implemented!
  // printf ("Sorry, not implemented CLASSNAME::numberOfRhsOperands() \n");
  // ROSE_ABORT();

     ROSE_ASSERT (localDataBase != NULL);
     return localDataBase->getNumberOfRhsOperands();
   }

// These are located in the ROSE_TransformableStatement object
void
CLASSNAME::oncePerScopeSubtransformation ( SgStatement *currentStatement )
   {
  // This subtransformation is introduced once for every scope where a statement is found and transformed
  // Later we want to return a modified SgStatementPtrList object so that the modifiecation of the
  // Sage tree is separated from the development of the transformation.

     if ( (ROSE_DEBUG > 0) || (ROSE::verbose == TRUE) )
          printf ("Introduce UNIQUE LOCAL SCOPE subtransformation! \n");

     ROSE_ASSERT (currentStatement != NULL);
     SgStatementPtrList & localUniqueList = 
          ArrayAssignmentUsingTransformationGrammar::getTransformationTemplateData()->uniqueStatementList;

  // printf ("localUniqueList.size() = %d \n",localUniqueList.size());
     ROSE_ASSERT (localUniqueList.size() > 0);

  // Loop though the statements which represent the Lhs subtransformation
     SgStatementPtrList::iterator i;
     for (i = localUniqueList.begin(); i != localUniqueList.end(); i++)
        {
          Boolean inFront = TRUE;
#ifdef USE_SAGE3
          SgStatement* supportingStatement = *i;
#else
          SgStatement* supportingStatement = (*i).irep();
#endif
          char* indexName = "rose_index";
          SgStatement* copyOfSupportingStatement =
               ArrayAssignmentUsingTransformationGrammar::copy(supportingStatement,"GLOBAL_INDEX_NAME",indexName);

          ROSE_ASSERT (copyOfSupportingStatement->get_parent() == NULL);

          currentStatement->get_parent()->insert_statement(currentStatement,copyOfSupportingStatement,inFront);

#if 0
          ROSE_ASSERT (copyOfSupportingStatement->get_parent() == NULL);
          copyOfSupportingStatement->set_parent(newVariableDeclaration);
#endif
          ROSE_ASSERT (copyOfSupportingStatement->get_parent() != NULL);
        }
   }

void
CLASSNAME::oncePerTransformationSubtransformation ( SgStatement *currentStatement )
   {
  // printf ("Introduce Lhs subtransformation! \n");

     SgStatementPtrList & lhsList =
          ArrayAssignmentUsingTransformationGrammar::getTransformationTemplateData()->lhsStatementList;

  // printf ("lhsList.size() = %d \n",lhsList.size());
     ROSE_ASSERT (lhsList.size() > 0);

     ROSE_ASSERT (localDataBase != NULL);
     ROSE_ASSERT (localDataBase->lhsOperand != NULL);
     SgName lhsName        = localDataBase->lhsOperand->getVariableName();
     SgName lhsNamePointer = localDataBase->lhsOperand->getVariableNamePointer();

     SgStatementPtrList::iterator i;
     for (i = lhsList.begin(); i != lhsList.end(); i++)
        {
       // Make a copy of the statement from the header file (since we 
       // will edit it to make it have the correct names)
#ifdef USE_SAGE3
          SgStatement* supportingStatement = *i;
#else
          SgStatement* supportingStatement = (*i).irep();
#endif

#if 0
          SgScopeStatement* originalOuterScope = isSgScopeStatement (supportingStatement->get_parent());
          ROSE_ASSERT (originalOuterScope != NULL);
          printf ("Now unparse the original whole scope \n");
          originalOuterScope->logical_unparse(NO_UNPARSE_INFO,cout);
          cout << endl << endl;
#endif

          SgStatement *newStatement = ArrayAssignmentUsingTransformationGrammar::copy (supportingStatement,"LHS_ARRAY",lhsName.str());
          ROSE_ASSERT (newStatement != NULL);
          newStatement = ArrayAssignmentUsingTransformationGrammar::copy (newStatement,"LHS_ARRAY_DATA_POINTER",lhsNamePointer.str());
          ROSE_ASSERT (newStatement != NULL);

       // Since we know what we want to see here we can make this specific
       // to statement "double* RESTRICT a = A.getDataPointer();"
       // editLhsSpecificSubTransformation ((*i).irep(),"lhs","LHS");
       // editLhsSpecificSubTransformation (newStatement,"A_rosePrimativeVariable","A");
#if 0
          printf ("########################################################## \n");
          printf ("########################################################## \n");
          printf ("Original Lhs Statement: \n");
       // showSgStatement (cout,(*i).irep(), "Called from CLASSNAME::oncePerTransformationSubtransformation" );
          printf ("########################################################## \n");
          printf ("########################################################## \n");

          printf ("########################################################## \n");
          printf ("########################################################## \n");
          printf ("New Lhs Statement: \n");
       // showSgStatement (cout,newStatement, "Called from CLASSNAME::oncePerTransformationSubtransformation" );
          printf ("########################################################## \n");
          printf ("########################################################## \n");
#endif
          Boolean inFront = TRUE;
          currentStatement->get_parent()->insert_statement(currentStatement,newStatement,inFront);

#if 0
          SgScopeStatement* newOuterScope = isSgScopeStatement (newStatement->get_parent());
          ROSE_ASSERT (newOuterScope != NULL);
          printf ("Now unparse the whole scope \n");
          newOuterScope->logical_unparse(NO_UNPARSE_INFO,cout);
          cout << endl << endl;
#endif
#if 0
          printf ("Exiting after editing Lhs Statement! \n");
          ROSE_ABORT();
#endif
        }
   }

void
CLASSNAME::repeatedForEachTransformationSubtransformation ( SgStatement *currentStatement )
   {
  // printf ("Introduce Rhs substransformation! \n");

     ROSE_ASSERT (localDataBase != NULL);
     List<SgName>* uniqueNamesList = localDataBase->computeUniqueOperands();
     ROSE_ASSERT (uniqueNamesList != NULL);

#if 0
     printf ("uniqueNamesList->getLength() = %d \n",uniqueNamesList->getLength());
     for (int i=0; i < uniqueNamesList->getLength(); i++)
        {
          printf ("Introduce Rhs Operand substransformation: i = %d name = %s \n",i,(*uniqueNamesList)[i].str());
        }
#endif

  // Since the Lhs has already been setup we start the index into the list at 1 (instead of 0)!
  // for (int rhsOperandIndex = 0; rhsOperandIndex < numberOfRhsOperands(); rhsOperandIndex++)
     for (int rhsOperandIndex = 1; rhsOperandIndex < uniqueNamesList->getLength(); rhsOperandIndex++)
        {
       // printf ("Introduce Rhs Operand substransformation: name = %s \n",(*uniqueNamesList)[rhsOperandIndex].str());

#if 0
          ROSE_ASSERT (localDataBase != NULL);
          ROSE_ASSERT (localDataBase->rhsOperand[rhsOperandIndex] != NULL);
          ROSE_ASSERT (localDataBase->rhsOperand[rhsOperandIndex]->getVariableName() != NULL);
          char* rhsName        = localDataBase->rhsOperand[rhsOperandIndex]->getVariableName();
          char* rhsNamePointer = localDataBase->rhsOperand[rhsOperandIndex]->getVariableNamePointer();
#else
          SgName rhsName        = (*uniqueNamesList)[rhsOperandIndex];

      //  printf ("@@@@@@@@@@@@@@@@@ rhsName = %s \n",rhsName.str());

      //  char* rhsNamePointer = (*uniqueNamesList)[rhsOperandIndex]->getVariableNamePointer();
      //  char* rhsNamePointer = "DEFAULT_RHS_POINTER";
          SgName rhsNamePointer = ROSE::concatenate((*uniqueNamesList)[rhsOperandIndex],OperandDataBase::transformationVariableSuffix());
#endif

          SgStatementPtrList & rhsList = ArrayAssignmentUsingTransformationGrammar::getTransformationTemplateData()->rhsStatementList;

       // printf ("rhsList.size() = %d \n",rhsList.size());
          ROSE_ASSERT (rhsList.size() > 0);

          SgStatementPtrList::iterator i;
          for (i = rhsList.begin(); i != rhsList.end(); i++)
             {
            // Make a copy of the statement from the header file (since we
            // will edit it to make it have the correct names)
#ifdef USE_SAGE3
               SgStatement* supportingStatement = *i;
#else
               SgStatement* supportingStatement = (*i).irep();
#endif
            // SgStatement *newStatement = copy (supportingStatment,"","");
            // ROSE_ASSERT (newStatement != NULL);

            // Fix up later to avoid repeated names (best to put into separate transformation)
            // if (nameNotRepeated(rhsName) == TRUE)
               if (TRUE)
                  {
                 // SgStatement *newStatement = ArrayAssignmentUsingTransformationGrammar::copy (supportingStatement,"RHS_ARRAY","default_rhs_array");
                    SgStatement *newStatement = ArrayAssignmentUsingTransformationGrammar::copy (supportingStatement,"RHS_ARRAY",rhsName);
                    ROSE_ASSERT (newStatement != NULL);
                 // newStatement = ArrayAssignmentUsingTransformationGrammar::copy (newStatement,"RHS_ARRAY_DATA_POINTER","default_rhs_data_pointer");
                    newStatement = ArrayAssignmentUsingTransformationGrammar::copy (newStatement,"RHS_ARRAY_DATA_POINTER",rhsNamePointer);
                    ROSE_ASSERT (newStatement != NULL);

                 // Since we know what we want to see here we can make this specific
                 // to statement "double* RESTRICT b = B.getDataPointer();"
                 // editLhsSpecificSubTransformation ((*i).irep(),"lhs","LHS");
                 // editRhsSpecificSubTransformation (newStatement,"B_rosePrimativeVariable","B");
#if 0
                    printf ("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n");
                    printf ("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n");
                    printf ("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n");
                    printf ("NewStatement AFTER editRhsSpecificSubTransformation \n");
                    printf ("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n");
                    printf ("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n");
                    printf ("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ \n");
                    showSgStatement (cout,newStatement,"newStatement AFTER editRhsSpecificSubTransformation");
#endif
#if 1
                    Boolean inFront = TRUE;
                    currentStatement->get_parent()->insert_statement(currentStatement,newStatement,inFront);
#endif
                  }
             }
        }

#if 0
     printf ("Exiting in CLASSNAME::repeatedForEachTransformationSubtransformation() \n");
     ROSE_ABORT();
#endif
   }


void
CLASSNAME::outerLoopStructureSubtransformation ( 
     SgStatement *currentStatement, 
     SgStatement* transformedStatement )
   {
  // printf ("Introduce Outer Loop Structure substransformation! \n");

  // CW: get the dimension from the data base.
  // for now I hope that it is correctly specified.
  // eventually I should take the dimension of the
  // lhs operand instead!
     ROSE_ASSERT(localDataBase!=NULL);
     int dimension=localDataBase->statementDimension;
  
     SgStatementPtrList & loopStructureList =
          ArrayAssignmentUsingTransformationGrammar::
               getTransformationTemplateData()->outerLoopStatementList[dimension-1];

  // Get a pointer to the body of the inner loop (a SgBasicBlock which is derived from a SgStatement)
     SgStatement* innerLoopBody = NULL;

  // printf ("loopStructureList.size() = %d \n",loopStructureList.size());
     ROSE_ASSERT (loopStructureList.size() > 0);

     SgStatementPtrList::iterator i=loopStructureList.begin();
     for (i; i != loopStructureList.end(); i++)
        {
       // One of the statements in the loopStructureList is a "for" loop so we
       // just want the innerLoopBody from that statement
#ifdef USE_SAGE3
          SgStatement* supportingStatement = *i;
#else
          SgStatement* supportingStatement = (*i).irep();
#endif

#if 0
          printf ("Now unparse the supportingStatement \n");
          supportingStatement->logical_unparse(NO_UNPARSE_INFO,cout);
          cout << endl << endl;
#endif
    
          ROSE_ASSERT (localDataBase != NULL);
          ROSE_ASSERT (localDataBase->lhsOperand != NULL);
       // ROSE_ASSERT (localDataBase->lhsOperand->getVariableName() != NULL);
          SgName lhsName = localDataBase->lhsOperand->getVariableName();
          SgName lhsNamePointer = localDataBase->lhsOperand->getVariableNamePointer();

          SgStatement *newStatement = 
               ArrayAssignmentUsingTransformationGrammar::copy (supportingStatement,"LHS_ARRAY",lhsName);
          ROSE_ASSERT (newStatement != NULL);
          newStatement = ArrayAssignmentUsingTransformationGrammar::copy (newStatement,"LHS_ARRAY_DATA_POINTER",lhsNamePointer);
          ROSE_ASSERT (newStatement != NULL);
          newStatement = ArrayAssignmentUsingTransformationGrammar::copy (newStatement,"GLOBAL_INDEX_NAME","rose_index");
#if 0
          printf ("Now unparse the supportingStatement 3 \n");
          newStatement->logical_unparse(NO_UNPARSE_INFO,cout);
          cout << endl << endl;
#endif
          ROSE_ASSERT (newStatement != NULL);

       // Save a reference to the innerloop body if this is a for loop!
          if (innerLoopBody == NULL)
               innerLoopBody = ArrayAssignmentUsingTransformationGrammar::getInnerLoopBody(newStatement);

          Boolean inFront = TRUE;
       // This causes an error internally in Sage (not sure why it does not work)
       // currentStatement->get_parent()->replace_statement(currentStatement,newStatement);
          currentStatement->get_parent()->insert_statement(currentStatement,newStatement,inFront);
        }

  // Now we have a reference to the inner loop body (where we will insert the transformedStatement)
     ROSE_ASSERT (innerLoopBody != NULL);

  // Now replace the innerloop body with the transformedStatement
     ArrayAssignmentUsingTransformationGrammar::editInnerLoopBodyToMatchCurrentStatement (innerLoopBody, transformedStatement);

#ifdef USE_SAGE3
  // The original statement is turned into a NULL statement since we could not replace it directly
  // we should be abel to fix this correctly using SAGE3! (but we have not done so yet!)
     ArrayAssignmentUsingTransformationGrammar::makeStatementNullStatement (currentStatement);
#else
  // The original statement is turned into a NULL statement since we could not replace it directly
  // (I could only get the inset function to work properly) 
     ArrayAssignmentUsingTransformationGrammar::makeStatementNullStatement (currentStatement);
#endif

#if 0
     SgStatementPtrList& tempLoopStructureList = ArrayAssignmentUsingTransformationGrammar::getTransformationTemplateData()->outerLoopStatementList;

  // Get a pointer to the body of the inner loop (a SgBasicBlock which is derived from a SgStatement)
  // SgStatement* innerLoopBody = NULL;

     printf ("tempLoopStructureList.size() = %d \n",loopStructureList.size());
     ROSE_ASSERT (tempLoopStructureList.size() > 0);
     ROSE_ASSERT (tempLoopStructureList.size() == 3);  // temp error checking code

     for (i = tempLoopStructureList.begin(); i != tempLoopStructureList.end(); i++)
        {
       // One of the statements in the loopStructureList is a "for" loop so we 
       // just want the innerLoopBody from that statement
#ifdef USE_SAGE3
          SgStatement* supportingStatement = *i;
#else
          SgStatement* supportingStatement = (*i).irep();
#endif
    
          printf ("Now unparse the original TransformationTemplateData() \n");
          supportingStatement->logical_unparse(NO_UNPARSE_INFO,cout);
          cout << endl << endl;
        }
#endif

#if 0
     printf ("Exiting in CLASSNAME::outerLoopStructureSubtransformation() after validation and transformation of statement! \n");
     ROSE_ABORT();
#endif
   }


void
CLASSNAME::buildForLoopStructureAndModifySageTree ( 
     SgStatement* sageStatement,
     SgStatement* transformedStatement )
   {
  // OK, now we have an "Expression Statement" that we want to transform
  // The strategy is to look in teh outer scope and find the statement within that 
  // scope so we can insert the new statements (there is often more than one) into 
  // the correct scope (the outer scope) ahead of the original statement (which is 
  // set to a NULL statement).
     ROSE_ASSERT (sageStatement != NULL);

     SgExprStatement* exprStmt = isSgExprStatement(sageStatement);
     ROSE_ASSERT (exprStmt != NULL);

     if (ROSE_DEBUG > 0)
        {
       // printf ("In ArrayAssignmentUsingTransformationGrammar::buildForLoopStructure(SgStatement,SgStatement) \n");
          printf ("Statement from File Name %s -- Line Number %d -- FOUND AN A++ STATEMENT (simple assignment) to transform! \n",
               ROSE::getFileName(exprStmt), ROSE::getLineNumber(exprStmt) );
        }

     ROSE_ASSERT (ArrayAssignmentUsingTransformationGrammar::templatesDataSetup() == TRUE);

  // Get current scope of statement (We keep the currrent scope on a stack so we can see everything in that scope)
  // SgBasicBlock *basicBlock = (SgBasicBlock*) (*currentSgBasicBlockStack.begin()).irep();
     SgBasicBlock *basicBlock = (SgBasicBlock*) ArrayAssignmentUsingTransformationGrammar::getCurrentScope();
     ROSE_ASSERT ( basicBlock != NULL);

  // cout << "Number of statements in block = " << basicBlock->get_statements().size() << endl;

  // Now iterate through the current scope (SgBasicBlock) to find the location of the current statement
  // (and the surrounding ones)
  // SgStatement *previousStatement = (*basicBlock->get_statements().begin()).irep();
     SgStatement *previousStatement = NULL;
     SgStatementPtrList::iterator statementIterator;
     for (statementIterator = basicBlock->get_statements().begin(); 
          statementIterator != basicBlock->get_statements().end();
          statementIterator++)
        {
       // Get the SgStatement from the SgStatementPrt using the irep() member function
#ifdef USE_SAGE3
          SgStatement* currentStatement = *statementIterator;
#else
          SgStatement *currentStatement = (*statementIterator).irep();
#endif
          ROSE_ASSERT (currentStatement != NULL);

       // Turn on and off internal ROSE debugging!
       // ROSE_DEBUG = (ROSE::getLineNumber(exprStmt) == 12) ? ROSE_DEBUG : ROSE_DEBUG;

       // How Transformations are organized:
       // We address the requirements of a general transformation which may be
       // broken up into multiple parts (subtransformations): 
       //    a) Global Unique Subtransformation: (one time) sections of the transformation program 
       //       tree which must be introduced into the user application's program tree (global 
       //       variables required, global functions that need be introduced), our current transformation 
       //       has none of these.
       //    b) Local Scope Unique Subtransformations: parts of the transformation common to each use 
       //       of the transformation but which are local in scope.
       //    c) Lhs Operand Specific Subtransformation: parts of the transformation which are specific to the Lhs
       //    d) Rhs Operand Specific Subtransformation: Parts which are specific to each Rhs operand
       //    e) Loop Structure Subtransformation:
       //    f) Loop Body

       // Things to do (subtransformations to address):
       //
       // 1) Global Unique Subtransformations (the current array assignment transformation 
       //    does not have a globally unique subtransformation).
       //     a) check if this transformation has been done previously
       // 2) Local Scope Unique Subtransformations
       //     a) check if this transformation has been done in this block
       //     b) introduce the transformations (edit the source subtransformation tree as required)
       // 3) Lhs Operand Specific Subtransformation (edit the source subtransformation tree as required)
       // 4) Rhs Operand Specific Subtransformation (edit the source subtransformation tree as required)

          if (currentStatement == exprStmt)
             {
            // printf ("SWAP STATEMENTS TO DO THE TRANSFORMATION! \n");

               SgStatement* seedStatement = ArrayAssignmentUsingTransformationGrammar::buildNullStatement();
	       ROSE_ASSERT (seedStatement != NULL);

               Sg_File_Info* fileInfo = ArrayAssignmentUsingTransformationGrammar::buildSageFileInfo();
               SgBasicBlock* newBasicBlock = new SgBasicBlock(fileInfo);
	       ROSE_ASSERT (newBasicBlock != NULL);
               newBasicBlock->append_statement(seedStatement);

               Boolean inFront = TRUE;
               currentStatement->get_parent()->insert_statement(currentStatement,newBasicBlock,inFront);
               SgStatement* originalArrayStatement = currentStatement;
               currentStatement = seedStatement;

            // The original statement is turned into a NULL statement since we could not replace it directly
            // (I could only get the inset function to work properly)
               ArrayAssignmentUsingTransformationGrammar::makeStatementNullStatement (originalArrayStatement);

            // We use this in many of the subtransformations
               SgStatementPtrList::iterator i;

               if ( ArrayAssignmentUsingTransformationGrammar::transformationIntroducedInGlobalScope() == FALSE )
                  {
                 // Nothing to introduce since this transformation has no globally scoped 
                 // required subtransformation

                    if ( (ROSE_DEBUG > 0) || (ROSE::verbose == TRUE) )
                         printf ("Introduce GLOBAL substransformation! \n");
                  }

               if ( ArrayAssignmentUsingTransformationGrammar::transformationIntroducedInThisScope() == FALSE )
                  {
                 // uniqueSubTransformation(currentStatement);
                    oncePerScopeSubtransformation(currentStatement);
                  }

               oncePerTransformationSubtransformation (currentStatement);

               repeatedForEachTransformationSubtransformation (currentStatement);

               outerLoopStructureSubtransformation (currentStatement, transformedStatement);

#if 0
               SgScopeStatement* outerScope = isSgScopeStatement (currentStatement->get_parent());
               ROSE_ASSERT (outerScope != NULL);

	       printf ("Now unparse the previous scope \n");
               outerScope->logical_unparse(NO_UNPARSE_INFO,cout);
               cout << endl << endl;
#endif

               if ( (ROSE_DEBUG > 0) || (ROSE::verbose == TRUE) )
                    printf ("FINISHED TRANSFORMATION FOR THIS STATEMENT! \n");
             }

       // Save the previous Statement (I forget why I'm doing this)
       // I think it is because there is no way to see the previous statement 
       // because the iterator is not a bidirectional iterator!
          previousStatement = currentStatement;
        }

#if 0
     printf ("Exiting in CLASSNAME::buildForLoopStructureAndModifySageTree() after validation and transformation of statement! \n");
     ROSE_ABORT();
#endif
   }




\documentstyle{article}
%
\oddsidemargin   0.40in
\evensidemargin  0.40in
\leftmargin  0.0in
\rightmargin 0.0in
\textwidth   5.32in              % Originally 345pt
\topmargin   0.30in              % Originally 27pt
\headheight  0.1in               % Originally 12pt
\headsep     0.1in               % Originally 25pt
\textheight  8.0in               % Originally 528pt
\topskip     0.0in               % Originally same as BASELINESKIP
\footheight  0.1in               % Originally 12pt
\footskip    0.3in               % Originally 30pt
%
\begin{document}
%\bibliographystyle{plain}
%
%

\begin{center}
   {\Large {\bf Template List Class -- Quick Reference Card } } \\
                    {\bf (version 0.91) }\\
\end{center}

\section{Introduction}
{\em List} is a template list class.  This allows one to make a list of objects.  A list is also called a container class since it holds objects for later use.  Below the "tlist.h" header file is included for the list template, the structure genericObject is defined,  and a list of objects is instantiated in the main program.  Then some genericObject objects are instantiated and added and deleted from the list.

\begin{verbatim}
  #include <tlist.h>
	
  class genericObject {
    private:
      int array[10];
      float farray[10];
      double darray[10];
    private:
      genericObject();
      genericObject(const genericObject&)
     ~genericObject();

      genericObject& operator=(const genericObject&);
	      .
	      .
	      .
  };
	
  main(){
    List<genericObject> GL;

    genericObject G, H;

    GL.addElement(G);
    GL.addElement(H);
	   
    GL.deleteElement(G);
    GL.deleteElement(H);
	   
    return(0);
  }
	
\end{verbatim}

One can use any object within the ``$<\ >$''s of the {\em List} template.  The following reference section lists the available member functions to {\em List}.

\section{Reference}

The following table summarizes the member functions in {\em List}.  T is the type of object that {\em List} holds.

\begin{center}
\begin{tabular}{|l|l|} \hline
\multicolumn{1}{|c|}{\bf Member Function} &  \multicolumn{1}{c|}{\bf Purpose} \\ \hline \hline
List() & Default Constructor. \\ \hline
List(const List\&) & Copy Constructor. \\ \hline
\~List() & Destructor \\ \hline
List\& operator=(const List\&) & Equal Operator. \\ \hline \hline
void addElement(T \&)  & Add an element T to the list.\\ \hline
void addElement(T \&, int)  & Add an element T to the list at a given location.\\ \hline
int getLength()  & Get the length of the list.\\ \hline
T* getElementPtr(int)  & Get the pointer to an element of \\
 & the list at a given location. \\ \hline
T\& getElement(int)  & Get the element by reference to an element of \\ 
 & a list at a given location.\\ \hline
T\& operator[](int)  & Get the element by reference of an element at a  \\
 & given location.\\ \hline
void deleteElement(T \&)  & Delete element T of the list.\\ \hline
void deleteElement(int)  & Delete an element at a given location.\\ \hline
void setElementPtr(T *, int)  & Set the pointer to an element of \\
 & the list to a given pointer. \\ \hline
void swapElements(int, int)  & Swap locations in list given by arguments.\\ \hline 
\hline
void clean()  & Remove all elements from the list.\\ \hline
void deepClean()  & Destroy elements in list.\\ \hline
\end{tabular}
\end{center}

The way to think about {\em List} is as a dynamic array of objects.  This is exactly how {\em List} is implemented.  An array of pointers to the desired objects is kept.  The objects are maintained contiguously within the array but can be inserted or deleted within the array range.  The array grows as more objects are added.  The most efficient operations are to add an element at the end of the array (addElement(T \&T)) and to access the elements by an index value.

\subsection{Constructors}
Constructors are defined for default creation, copying and deleting of lists.  The constructors take no arguments.

\subsection{Equal Operation}
The equal operation copies pointers of the objects and not the objects themselves.  The order
of each list will be identical after the equal operation.  The lists will diverge in character once insertion or deletion takes place.

\subsection{Add Elements}
Elements are added by passing a reference to the member function {\bf addElement}.  {\bf addElement} can be called with a single element reference or and additional integer specifying where in the array the element pointer is to be placed.  The index must be within the range of the array.  This can be found using {\bf getLength}.  The value returned minus 1 is the upper bound on the range while zero is the lower bound.

\subsection{Access Elements}
There are several ways to access elements from the list.  {\bf getElement} comes in two flavors.  Both versions access the list through an index value but one returns the pointer to an element while the other returns a reference.  The ``[] '' operator is overloaded to access a reference to an element.  Stroustrup thinks this is too cute.

\subsection{Delete Elements}
There are two ways to delete elements.  {\bf deleteElement} comes in two flavors as well.  One way to delete an object is by its location in the array.  The other is to give {\bf deleteElement} the object to delete so that it can search by comparison to delete the element.  This does not clean up the object.

\subsection{Replace an Element}
To replace an element on a list use {\bf setElementPtr}.  SetElementPtr takes a pointer to an object
and replaces the pointer of the object at the given index with the passed object.  This could cause
a memory leak unless the old object is handled elsewhere.

\subsection{Swap Elements}
Two elements can be swapped on the list by specifying their indices as arguments to {\bf swapElements}.  The pointers to these objects are simply swapped.

\subsection{Clean Up Lists}
There are two levels of {\em List} house cleaning.  The first, {\bf clean}, simply deallocates the memory for the list of pointers to the elements and sets its own length to zero.  {\bf deepClean} deletes all the objects in the list as well as the memory for the list of pointers.

\section{Bugs}
{\em List} cannot have integers as elements.  This is because of ambiguity problems with various operators within the list template class.  A++ array classes seem to be too complex for templates to figure out but Dan is working on making the templates ``see'' the array class.  If templates are too brain damaged to
understand the array class objects then we will make list object explicity for
the class objects.

\end{document}














CLASSNAME::~CLASSNAME ()
   {
   }

#if 0
CLASSNAME::CLASSNAME ()
   {
     ROSE_Node::setUp (CLASSNAME_TAG,NULL);
   }
#endif

CLASSNAME::CLASSNAME ( SgExpression* expr )
   : BASECLASSNAME(expr)
   {
     ROSE_ASSERT (expr != NULL);
     ROSE_Node::setUp (CLASSNAME_TAG,expr);

     ROSE_ASSERT (getVariant() == CLASSNAME_TAG);
   }


ROSE_Node* CLASSNAME::transform()
   {

  // Later we will initialize the name using the CLASSNAME::getOperandName()
  // and add a suffix from CLASSNAME::transformationVariableSuffix()
     SgName arrayName = getOperandPointerName();

  // We need a double array type (note not a "doubleArray")
     variant_type_enum arrayType = DOUBLE_VAL;

     SgName            indexName;
     SgExpression*     scalarExpression   [ROSE_MAX_ARRAY_DIMENSION];
     variant_type_enum indexOperator      [ROSE_MAX_ARRAY_DIMENSION];
     Boolean           normalOperandOrder [ROSE_MAX_ARRAY_DIMENSION]; // The default is true (i.e I+1 or I-1 instead of 1+I or 1-I)

	 // CW: find out the dimension of the statement using
	 // the virtual function getNumberOfDimensions
     int statementDimension = getNumberOfDimensions();

     for (int dim =0; dim < statementDimension; dim++)
	 {
		  // Initialization of default values
          scalarExpression   [dim] = NULL;
          indexOperator      [dim] = LAST_TAG;
          normalOperandOrder [dim] = TRUE;
	 }

	 indexName = getIndexName(0);

     SgPntrArrRefExp* sagePntrArrRefExpression = 
          buildOperand(arrayName,arrayType,indexName,indexOperator,scalarExpression,statementDimension,normalOperandOrder);
     ROSE_ASSERT (sagePntrArrRefExpression != NULL);

#if 0
     printf ("\n\n");
     printf ("Now SHOW the OPERAND EXPRESSION! \n\n");
     showSgExpression (cout, sagePntrArrRefExpression, "Called from CLASSNAME::transform()");

     printf ("\n\n");
     printf ("Now UNPARSE the OPERAND EXPRESSION! \n\n");
     sagePntrArrRefExpression->unparse(NO_UNPARSE_INFO,cout);
     cout << endl << endl;
     printf ("\n\n");

  // printf ("Exiting after construction of operand in Sage \n");
  // ROSE_ABORT();
#endif

#if 1
  // Since we are holding the transformation of the array expression (which is a C
  // expression by definition) we can wrap it into a ROSE_C_Expression, alternatively
  // we could define a new grammar terminal to hold the transformed SAGE program tree.
     ROSE_C_Expression* roseExpression = new ROSE_C_Expression (sagePntrArrRefExpression);
     ROSE_ASSERT (roseExpression != NULL);
     ROSE_ASSERT (!roseExpression->error());

     return roseExpression;
#else
     return this;
#endif
   }


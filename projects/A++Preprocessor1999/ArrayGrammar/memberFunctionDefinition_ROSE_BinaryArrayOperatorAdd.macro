CLASSNAME::~CLASSNAME ()
   {
   }

#if 0
CLASSNAME::CLASSNAME ()
   {
     ROSE_Node::setUp (CLASSNAME_TAG,NULL);
   }
#endif

CLASSNAME::CLASSNAME ( SgExpression* expr )
   : BASECLASSNAME(expr)
   {
  // ArrayOperators are implemented as member functions or friend functions and so this function
  // looks for array operators by looking for either array friend functions or array member functions
  // the function name is required to be from a specific set of qualified names as well.

     ROSE_ASSERT (expr != NULL);
     ROSE_Node::setUp (CLASSNAME_TAG,expr);

  // showSgExpression (cout, expr, "Called from CLASSNAME::CLASSNAME ( SgExpression* expr )");

     SgFunctionCallExp* functionCallExp = isSgFunctionCallExp( expr );
     ROSE_ASSERT (functionCallExp != NULL);

  // We should call the derived class get_type function
     SgType* type = functionCallExp->get_type();
     ROSE_ASSERT (ArrayClassSageInterface::isArrayClassType(type) == TRUE);

     SgExpression *functionExpr = functionCallExp->get_function();
     ROSE_ASSERT (functionExpr != NULL);
     SgExprListExp* exprListExp = functionCallExp->get_args();
     ROSE_ASSERT (exprListExp != NULL);

  // Set this so that we can access it directly later to get the arguments
     setSageExpressionListExpression (exprListExp);
   }

ROSE_Node* CLASSNAME::transform()
   {
     ROSE_ASSERT (!error());
     printf ("In CLASSNAME::transform(): roseExpressionList.getLength() = %d \n",
          getRoseExpressionList().getLength());
     ROSE_ASSERT (getRoseExpressionList().getLength() == 2);

     ROSE_Expression* roseLhsExpression = (ROSE_Expression*) getRoseExpressionList()[0].transform();
     ROSE_Expression* roseRhsExpression = (ROSE_Expression*) getRoseExpressionList()[1].transform();
     ROSE_ASSERT (roseLhsExpression != NULL);
     ROSE_ASSERT (roseRhsExpression != NULL);

  // return transform (roseLhsExpression,roseRhsExpression);

  // ROSE_C_Expression* returnExpression = new ROSE_C_Expression ( node, roseLhsExpression, roseRhsExpression );
  // ROSE_ASSERT (returnExpression != NULL);
  // return returnExpression;

     return ROSE_C_Expression::build_ROSE_C_Expression ( this, roseLhsExpression, roseRhsExpression );
   }


SgType* CLASSNAME::getType()
   {
  // we make the type double by default, we should really look at if this
  // is a doubleArray, floatArray, or intArray but we will fix that later
  // SgType* returnType = NULL;
  // returnType = buildTypeDouble();
     return buildTypeDouble();
   }

ROSE_Node* CLASSNAME::transform( ROSE_Expression* roseLhsExpression, ROSE_Expression* roseRhsExpression )
   {
     return ROSE_C_Expression::build_ROSE_C_Expression (this, roseLhsExpression, roseRhsExpression );
   }

SgExpression* CLASSNAME::buildExpression ( ROSE_Expression* node, SgExpression* sageLhsExpression, SgExpression* sageRhsExpression )
   {
  // This function 
     SgExpression* returnExpression = NULL;
     ROSE_ASSERT (node != NULL);

     returnExpression = new SgAddOp (node->buildSageFileInfo(),sageLhsExpression,sageRhsExpression,node->getType());
     ROSE_ASSERT (returnExpression != NULL);
     return returnExpression;
   }

#if 0
ROSE_Node* CLASSNAME::transform( ROSE_Expression* roseLhsExpression, ROSE_Expression* roseRhsExpression )
   {
     return ROSE_C_Expression ( this, roseLhsExpression, roseRhsExpression );
   }

ROSE_Node* CLASSNAME::transform ( ROSE_Node*, ROSE_Expression* roseLhsExpression, ROSE_Expression* roseRhsExpression )
   {
     if ( (ROSE_DEBUG > 0) || (ROSE::verbose == TRUE) )
          printf ("In CLASSNAME::transform(ROSE_Expression*,ROSE_Expression*): roseExpressionList.getLength() = %d \n",
               getRoseExpressionList().getLength());

     ROSE_ASSERT (ROSE_Node != NULL);
     ROSE_ASSERT (roseLhsExpression != NULL);
     ROSE_ASSERT (roseRhsExpression != NULL);

     ROSE_ASSERT (!error());
     ROSE_ASSERT (getRoseExpressionList().getLength() == 2);

     SgExpression* sageLhsExpression = (SgExpression*) roseLhsExpression->getSageSubTree();
     ROSE_ASSERT (sageLhsExpression != NULL);
     SgExpression* sageRhsExpression = (SgExpression*) roseRhsExpression->getSageSubTree();
     ROSE_ASSERT (sageRhsExpression != NULL);

     SgExpression* sageOperator = ROSE_C_Expression::buildExpression (sageLhsExpression,sageRhsExpression);
     ROSE_ASSERT (sageOperator != NULL);

  // Since we are holding the transformation of the array expression (which is a C
  // expression by definition) we can wrap it into a ROSE_C_Expression, alternatively
  // we could define a new grammar terminal to hold the transformed SAGE program tree.
     ROSE_C_Expression* roseExpression = new ROSE_C_Expression (sageOperator);

  // This is the simplest way to build the transformation!!!
  // This can be placed into the binary operator and then be called from each of the leaves.
  // ROSE_C_Expression ( node, sageLhsExpression, sageRhsExpression );

     ROSE_ASSERT (roseExpression != NULL);
     ROSE_ASSERT (!roseExpression->error());

     return roseExpression;
   }
#endif

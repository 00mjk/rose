CLASSNAME::~CLASSNAME ()
   {
   }

CLASSNAME::CLASSNAME ( SgExpression* expr )
   : BASECLASSNAME(expr)
   {
     recognizeSageSubTree (expr);
     ROSE_Node::setUp (CLASSNAME_TAG,expr);
   }

#if 0
// Let this be a leaf of our grammar for now, but later
// we need to be more specific and recognize references and double, float, int
ROSE_Node* 
CLASSNAME::transform()
   {
     printf ("Sorry not implemented, CLASSNAME::Tranform() \n");
  // ROSE_ABORT();

     return this;
   }
#endif

SgExpression* CLASSNAME::getExpression()
   {
     return (SgExpression*) getSageSubTree();
   }

void 
CLASSNAME::recognizeSageSubTree ( SgExpression* expr )
   {
  // This is code which verifies the Sage Tree as being a valid array operand

     if ( (ROSE_DEBUG > 0) || (ROSE::verbose == TRUE) )
          printf ("Sorry, not implemented: CLASSNAME::recognizeSageSubTree ( SgExpression* expr ) \n");
   }

// Stuff about the indexing of array operands
Boolean
CLASSNAME::isAnIndexedOperand()
   {
     if ( (ROSE_DEBUG > 0) || (ROSE::verbose == TRUE) )
          printf ("returned default in CLASSNAME::isAnIndexedOperand() = FALSE \n");
     return FALSE;
   }

SgDeclarationStatement *
CLASSNAME::getDeclarationStatement(SgVarRefExp *variableRefExp)
{
// CW: The function gets the declaration statement of the variable reference
// expression and returns it.

	SgVariableSymbol* variableSymbol = variableRefExp->get_symbol();
	ROSE_ASSERT(variableSymbol != NULL);
	SgInitializedName* variableName = variableSymbol->get_declaration();
	ROSE_ASSERT(variableName != NULL);
	SgDeclarationStatement *declarationStmt = variableName->get_declaration();
	ROSE_ASSERT(declarationStmt != NULL); // CW: this ASSERT might be to strict	
	
#if 0
	// CW: debug
	showSgDeclarationStatement(cout,declarationStmt,"Inside CLASSNAME::getDeclarationStatement():");
#endif

	return declarationStmt;
}


int
CLASSNAME::getNumberOfDimensions(SgVarRefExp *variableRefExp)
   {
  // CW: internal function is called from getNumberOfDimensions()
  // The function tries to find out the dimension from the variable
  // declaration. Unfortunatelly, this is not always possible.
  // E.g. for variable which are passed as function parameters.
  // function returns the dimension if it was able to find it out or
  // otherwise -1

  // CW: get the declaration from the reference
     SgDeclarationStatement *declarationStmt=getDeclarationStatement(variableRefExp);

     if(declarationStmt->variant()==VAR_DECL_STMT)
        {
       // CW: if it is indeed a variable declaration we can try
       // to find out the number of dimensions by counting the constructor
       // arguments:
          SgVariableDeclaration *variableDeclaration=isSgVariableDeclaration(declarationStmt);
          SgInitializedNameList & variableList = variableDeclaration->get_variables();
          ROSE_ASSERT(variableList.size()==1); // CW: I dont know what to do if there
       // is more than one variable name

          SgInitializedNameList::iterator i = variableList.begin();

       // CW: do we have an initializer?
          ROSE_ASSERT((*i).get_named_item()!=NULL);
          SgInitializer *varInitializer = (*i).get_named_item()->get_initializer();

          SgConstructorInitializer *varConstructor = isSgConstructorInitializer(varInitializer);
          if(varConstructor!=NULL)
             {
            // CW: if there is a constructor initializer we have a chance
            // to find out the number of dimensions of the variable
               SgExprListExp* constructorArgs=varConstructor->get_args();
               ROSE_ASSERT(constructorArgs!=NULL);

               SgExpressionPtrList & argumentPtrList = constructorArgs->get_expressions();
            // CW: if more than one argument is specified we know the
            // number of dimensions. If one argument is specified we have
            // to look at the type of the argument. If no arguments are specified
            // we are not able to get the dimension from the declaration.
               if(argumentPtrList.size()==1)
                  {
                    SgExpressionPtrList::iterator i = argumentPtrList.begin();
#ifdef USE_SAGE3
                    if (isSgValueExp(*i) != NULL)
#else
                    if (isSgValueExp((*i).irep()) != NULL)
#endif
                       {
                      // CW: If it is a value expression then we know the dimension
                         return 1;
                       }
                      else
#ifdef USE_SAGE3
                         if (isSgVarRefExp(*i) != NULL)
#else
                         if (isSgVarRefExp((*i).irep()) != NULL)
#endif
                            {
                           // CW: o.k. it is a single variable...
#ifdef USE_SAGE3
                              SgVarRefExp *varArgument = isSgVarRefExp(*i);
#else
                              SgVarRefExp *varArgument = isSgVarRefExp((*i).irep());
#endif
                              SgType *varArgType=varArgument->get_type();
                              switch(varArgType->variant())
                                 {
                                   case T_INT:
                                   case T_SIGNED_INT:
                                   case T_UNSIGNED_INT:
                                   case T_SIGNED_SHORT:
                                   case T_UNSIGNED_SHORT:
                                   case T_SHORT:
                                   case T_LONG:
                                   case T_SIGNED_LONG:
                                   case T_UNSIGNED_LONG:
                                   case T_LONG_LONG:
                                   case T_UNSIGNED_LONG_LONG:
                                   case T_FLOAT:
                                   case T_DOUBLE:
                                      {
                                        return 1;
                                        break;
                                      }
                                   case T_CLASS:
                                      {
                                     // CW: get class type of new and old variable
                                        SgClassType *newClassType = isSgClassType(varArgType);
                                        SgClassType *oldClassType = isSgClassType(variableRefExp->get_type());
                                        ROSE_ASSERT((newClassType!=NULL)&& (oldClassType!=NULL));

                                        if(newClassType->get_name()==oldClassType->get_name())
                                           {
                                          // CW: o.k. it is initialized with a copy constructor
                                          // so, call the function recursively to get the dimension
                                             return getNumberOfDimensions(varArgument);
                                           }
                                          else
                                           {
                                          // CW: i don't know what to do if it initialized with an
                                          // object of another class. 
                                             return -1;
                                           }
                                        break;
                                      }
                                   default:
                                      {
                                     // CW: i give up, somebody else can implement this
                                     // case
                                        return -1;
                                        break;
                                      }
                                 }
                            }
                           else
                            {
                           // CW: It might be possible to get the number of dimensions
                           // from the expression (e.g. recursivelly) but I will not implement
                           // this at the moment.
                              return -1;
                            }
                  }
                 else
                    if(argumentPtrList.size() > 1)
                       {
                         return argumentPtrList.size();
                       }
                      else
                       {
                         ROSE_ASSERT(argumentPtrList.size()==0);
                         return -1;
                       }
             }
            else
             {
            // CW: I can only handle the case of a constructor initializer
               return -1;
             }
        }
       else
        {
       // CW: I cannot handle this case. If I have call graph analysis I
       // might be able to do more.
          return -1;
        }
   }


int
CLASSNAME::getNumberOfDimensions()
{
	// CW: this function tries to find out the dimension of the expression
	// This function is defined as a virtual function. So, if there is a
	// better possibility to find out the dimension of the expression for
	// some expression types than we will use this throught the virtual method
	// mechanism. What we can do here is a default case handeling which might
	// not result in optimal dimension detection.


	// CW: we try to figure out the dimension from the variable
	// declaration. Unfortunatelly, this is not always possible.
	// E.g. for variable which are passed as function parameters.
	SgVarRefExp *variableRef = isSgVarRefExp((SgNode*)getSageSubTree());
	ROSE_ASSERT(variableRef!=NULL);
	int dimension = getNumberOfDimensions(variableRef);

	// CW: have we found the dimension of the expression?
	if(dimension==-1){
		// CW: if we don't have a better guess, we use the worst case
		// Hence, we depend on A++ handling this case correctly.
		// A++ is only able to handle this case correctly if MAX_ARRAY_DIMENSION
		// from A++ is equal to ROSE_MAX_ARRAY_DIMENSION
		dimension = ROSE_MAX_ARRAY_DIMENSION;
	}

	// CW: make sure that we support that dimension
	ROSE_ASSERT(dimension<=ROSE_MAX_ARRAY_DIMENSION);
	
	return dimension;
}

// Rules on how we modify variable names (unique names are required)
SgName
CLASSNAME::transformationVariablePrefix()
   {
     return "_rose_default_prefix_";
   }

SgName
CLASSNAME::transformationVariableSuffix()
   {
     return "_rose_pointer";
   }

// get the names of the different parts
SgName
CLASSNAME::getOperandName ()
   {
     char* returnString = "defaultOperandNameFrom_ArrayOperandExpression_getOperandName";

  // showSgExpression (cout, getExpression(), "Called from CLASSNAME::getOperandName()" );

     printf ("Exiting inside of CLASSNAME::getOperandName() (called base class by mistake) \n");
     ROSE_ABORT();

     return returnString;
   }

SgName
CLASSNAME::getIndexName (int dimension)
   {
     return "rose_index";
   }

SgName
CLASSNAME::getOperandPointerName ()
   {
     printf ("Exiting inside of CLASSNAME::getOperandName() (called base class by mistake) \n");
     ROSE_ABORT();

     return "null_string";
   }

// CW: private utility function which builds a array reference expr for
// integer arrays only and a constant integer value as index expression.
SgPntrArrRefExp* CLASSNAME::buildIntValArrayRefExp(const SgName &name, int intVal)
   {
  // CW: here we only build reference expressions to int arrays
     SgTypeInt *intType=buildTypeInt();
     ROSE_ASSERT(intType!=NULL);

     Sg_File_Info *fileInfo = buildSageFileInfo();

  // CW: building "array name" (part of expression which is on the left side of [..]:
     SgInitializedName *arrayName = new SgInitializedName(name,intType);
     ROSE_ASSERT(arrayName!=NULL);
     SgVariableSymbol *arraySymbol = new SgVariableSymbol(arrayName);
     ROSE_ASSERT(arraySymbol!=NULL);
     SgVarRefExp *arrayVarExpr = new SgVarRefExp(fileInfo,arraySymbol);
     ROSE_ASSERT(arrayVarExpr!=NULL);

  // CW: building index expression:
     SgIntVal *indexExpr = new SgIntVal(fileInfo, intVal);
     ROSE_ASSERT(indexExpr!=NULL);

  // CW: now building arrayRefExpr:
     SgPntrArrRefExp *arrayRefExpr= new SgPntrArrRefExp(fileInfo, arrayVarExpr, indexExpr ,intType);
     ROSE_ASSERT(arrayRefExpr!=NULL);

#if 0
  // CW: debug code
     showSgExpression(cout,arrayRefExpr,"xxxx");
     arrayRefExpr->logical_unparse(NO_UNPARSE_INFO,cout);
#endif

     return arrayRefExpr;
   }

// Old return type was SgExpression*
SgPntrArrRefExp*
CLASSNAME::buildOperand (
   SgName arrayName,             // variable name
   variant_type_enum arrayType,  // Type for the array pointer
   SgName indexName,             // CW: variable name of index array
   variant_type_enum indexOperator     [ROSE_MAX_ARRAY_DIMENSION],  // ADD_OP, SUBT_OP, etc. (semantics of A++/P++ Index and Range objects only)
   SgExpression* indexScalarExpression [ROSE_MAX_ARRAY_DIMENSION],  // integer expression for the rhs of the indexOperator
   int statementDimension,                                          // Dimention of the entire statement (not just this operand!)
   Boolean normalOrderOfOperands       [ROSE_MAX_ARRAY_DIMENSION] ) // I+1 is the normal order, but 1+I is also handled properly
   {
  // This function builds "<arrayName>[<indexName>]" as an expression for use in transformations
  // For the moment we ignore the manipulation of the index (so "lhs[i+1]" would be built as "lhs[i]")

     ROSE_ASSERT (!arrayName.is_null());

  // printf ("In CLASSNAME::buildOperand (,,,,,,) statementDimension = %d \n",statementDimension);
  // Use this to temporarily check while we debug the case of 2D array operand transformations
  // ROSE_ASSERT (statementDimension == 2);

  // This is the type of object that we will return
     SgPntrArrRefExp* returnExpression = NULL;

  // Use the default constructor for now
     Sg_File_Info *fileInfo = buildSageFileInfo();

  // We really should use a virtual function or key off of the arrayType! (these functions check for NULL pointers)
     SgTypeDouble* doubleType = buildTypeDouble();

  // subscript indexing is always done with integers (these functions check for NULL pointers)
     SgTypeInt *intType = buildTypeInt();

  // I'm not sure if this is important but it seemed that random data was being 
  // assigned to the field_size, I don't even know what the field_size variable does!
     intType->set_field_size(0);

#if 0
     printf ("Show intType program tree! \n");
     showSgType (cout,intType,"SimpleArrayAssignment::buildLhsOperand()");
#endif

     SgPointerType *pointerTypeArray = new SgPointerType (doubleType);
     ROSE_ASSERT (pointerTypeArray != NULL);

     SgName* nameArray = new SgName (arrayName);
     ROSE_ASSERT (nameArray != NULL);

#if 0
     printf ("BEFORE -- Modified name is: nameArray->str() = %s \n",nameArray->str());
     *nameArray = SgName ("Quinlan");
     printf ("AFTER -- Modified name is: nameArray->str() = %s \n",nameArray->str());
#endif

     SgInitializedName* initializedNameArray = new SgInitializedName (*nameArray,pointerTypeArray);
     ROSE_ASSERT (initializedNameArray != NULL);

     SgVariableSymbol* arrayPointerSymbol = new SgVariableSymbol(initializedNameArray);
     ROSE_ASSERT (arrayPointerSymbol != NULL);

  // Here is where the multidimensional arrays would be added ("x[i][j][k]"), 
  // but for our work we treat all arrays as 1D arrays.
     SgExpression* lhsOperand = new SgVarRefExp (fileInfo,arrayPointerSymbol);
     ROSE_ASSERT (lhsOperand != NULL);

	// CW: Assemble expression list for function/macro call into:
	SgExprListExp* argsExprListExp = new SgExprListExp(buildSageFileInfo());	
	ROSE_ASSERT (argsExprListExp != NULL);
	
	for(int dim = 0; dim < statementDimension; dim++)
	{
        // CW: I want an array of indices rather then several different
        // names for each dimension. Basetype of the array is integer.
        // The index expression depends on the dimension since it
        // is an integer value which is equal to the dimension
		SgPntrArrRefExp *arrayRefExpr=buildIntValArrayRefExp(indexName,dim);
		SgExpression* indexOperand;
				
		if (indexScalarExpression[dim] == NULL)
		{
			// CW: If the indexScalarExpression[dim] == NULL then we do not have subscript expressions.
			// Hence the index is the arrayRefExpr.
			indexOperand = arrayRefExpr;
        }
        else
		{
			// If the indexScalarExpression != NULL then we have to reproduce the 
            // correct index expression (the substript computation)
			Sg_File_Info* fileInfo = buildSageFileInfo();
			SgExpression* lhsExpr = NULL;
			SgExpression* rhsExpr = NULL;
			if (normalOrderOfOperands){
				lhsExpr = arrayRefExpr;
				rhsExpr = ArrayAssignmentUsingGrammar::copy(indexScalarExpression[dim],"","");
			}
			else{
				lhsExpr = ArrayAssignmentUsingGrammar::copy(indexScalarExpression[dim],"","");
				rhsExpr = arrayRefExpr;
			}
			ROSE_ASSERT (lhsExpr != NULL);
			ROSE_ASSERT (rhsExpr != NULL);
			switch (indexOperator[dim])
			{
				case ADD_OP:
				{
					indexOperand = new SgAddOp (fileInfo,lhsExpr,rhsExpr,intType);
					break;
				}
				case SUBT_OP:
				{
					indexOperand = new SgSubtractOp (fileInfo,lhsExpr,rhsExpr,intType);
					break;
				}
				default:
					printf ("Default reached in CLASSNAME::buildOperand() \n");
					ROSE_ABORT();
			}
			ROSE_ASSERT (indexOperand!=NULL);
		}
		
		// CW: first add loop index
		ROSE_ASSERT (indexOperand!= NULL);
		argsExprListExp->append_expression(indexOperand);

		// CW: Build base and bound array reference expression and add it to 
		// function call args. They are needed for the linearization of the
		// array access
		argsExprListExp->append_expression(buildIntValArrayRefExp("rose_base",dim));
		argsExprListExp->append_expression(buildIntValArrayRefExp("rose_bound",dim));
		
	// CW: continue with next dimension
	}

	// CW: Check the number of arguments for the subscript function
	ROSE_ASSERT (argsExprListExp->get_expressions().size() == 3*statementDimension);

	// CW: we now have to get ther correct array subscript function.
	// Then we replace the arguments of the function call and use this
	// as the index of a array reference expression

  // CW: We have to make a copy of the function call expression which we are using as a code template
     ROSE_ASSERT(ArrayAssignmentUsingGrammar::subscriptFunctionDeclarationExpression[statementDimension-1]!= NULL);
     SgExpression* subScriptFunctionExpression = 
          ArrayAssignmentUsingGrammar::copy(
               ArrayAssignmentUsingGrammar::subscriptFunctionDeclarationExpression[statementDimension-1],"","");
     ROSE_ASSERT (subScriptFunctionExpression != NULL);
     SgFunctionCallExp* subScriptFunction = isSgFunctionCallExp(subScriptFunctionExpression);
     ROSE_ASSERT (subScriptFunction != NULL);

  // replace argument expression list through our generated expression list
     subScriptFunction->set_args(argsExprListExp);

     returnExpression = new SgPntrArrRefExp (fileInfo, lhsOperand, subScriptFunction, doubleType );
     ROSE_ASSERT(returnExpression != NULL);

     return returnExpression;
   }


#if 0
SgExpression*
CLASSNAME::buildOperand (
   SgVariableSymbol* arraySymbol,      // array variable symbol
   variant_type_enum indexOperator,    // ADD_OP, SUBT_OP, etc. (semantics of A++/P++ Index and Range objects only)
   SgExpression*     rhsExpression )   // integer expression for the rhs of the indexOperator
   {
 // This function builds "<arrayName>[<indexName>]" as an expression for use in transformations
 // For the moment we ignore the manipulation of the index (so "lhs[i+1]" would be built as "lhs[i]")
 // We also ignore the case of multidimensional arrays (assuming everything is 1D for now).

     ROSE_ASSERT (arraySymbol != NULL);

     char* indexName = "i_rose_index";
     ROSE_ASSERT (indexName != NULL);

     SgExpression* returnExpression = NULL;

  // Use the default constructor for now
     Sg_File_Info *fileInfo =  new Sg_File_Info("ROSE-buildOperand",1,1);
     ROSE_ASSERT (fileInfo != NULL);

     SgTypeDouble* doubleType = new SgTypeDouble();
     ROSE_ASSERT (doubleType != NULL);
     
     SgTypeInt *intType = new SgTypeInt (0);
     ROSE_ASSERT (intType != NULL);

  // I'm not sure if this is important but it seemed that random data was being 
  // assigned to the field_size, I don't even know what the field_size variable does!
     intType->set_field_size(0);

     printf ("Show intType program tree! \n");
     showSgType (cout,intType,"SimpleArrayAssignment::buildOperand()");

     SgName* nameIndex = new SgName (indexName);
     ROSE_ASSERT (nameIndex != NULL);

     SgInitializedName* initializedNameIndex = new SgInitializedName (*nameIndex,intType);
     ROSE_ASSERT (initializedNameIndex != NULL);

     SgVariableSymbol* arrayPointerSymbol = arraySymbol;
     ROSE_ASSERT (arrayPointerSymbol != NULL);
     SgVariableSymbol* indexSymbol        = new SgVariableSymbol(initializedNameIndex);
     ROSE_ASSERT (indexSymbol != NULL);

     SgExpression* lhsOperand = new SgVarRefExp (fileInfo,arrayPointerSymbol);
     ROSE_ASSERT (lhsOperand != NULL);
     SgExpression* rhsOperand = new SgVarRefExp (fileInfo,indexSymbol);
     ROSE_ASSERT (rhsOperand != NULL);

     SgPntrArrRefExp *operandRef = new SgPntrArrRefExp (fileInfo, lhsOperand, rhsOperand, doubleType );
     ROSE_ASSERT (operandRef != NULL);

     returnExpression = operandRef;

  // showSgExpression (cout,returnExpression);

     return returnExpression;
   }
#endif

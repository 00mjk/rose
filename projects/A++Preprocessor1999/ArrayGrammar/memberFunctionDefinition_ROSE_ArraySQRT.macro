CLASSNAME::~CLASSNAME ()
   {
   }

#if 0
CLASSNAME::CLASSNAME ()
   {
     ROSE_Node::setUp (CLASSNAME_TAG,NULL);
   }
#endif

CLASSNAME::CLASSNAME ( SgExpression* expr )
   : BASECLASSNAME(expr)
   {
  // ArrayOperators are implemented as member functions or friend functions and so this function
  // looks for array operators by looking for either array friend functions or array member functions
  // the function name is required to be from a specific set of qualified names as well.

     ROSE_ASSERT (expr != NULL);
     ROSE_Node::setUp (CLASSNAME_TAG,expr);

     showSgExpression (cout, expr, "Called from CLASSNAME::CLASSNAME ( SgExpression* expr )");

     SgFunctionCallExp* functionCallExp = isSgFunctionCallExp( expr );
     ROSE_ASSERT (functionCallExp != NULL);

  // We should call the derived class get_type function
     SgType* type = functionCallExp->get_type();
     ROSE_ASSERT (ArrayClassSageInterface::isArrayClassType(type) == TRUE);

     SgExpression *functionExpr = functionCallExp->get_function();
     ROSE_ASSERT (functionExpr != NULL);
     SgExprListExp* exprListExp = functionCallExp->get_args();
     ROSE_ASSERT (exprListExp != NULL);

  // Set this so that we can access it directly later to get the arguments
     setSageExpressionListExpression (exprListExp);
   }

ROSE_Node* CLASSNAME::transform()
   {
  // printf ("Sorry not implemented, CLASSNAME::Tranform() \n");
  // ROSE_ABORT();

     ROSE_ASSERT (!error());

     if ( (ROSE_DEBUG > 0) || (ROSE::verbose == TRUE) )
          printf ("In CLASSNAME::transform(): roseExpressionList.getLength() = %d \n",
               getRoseExpressionList().getLength());

     for (int i=0; i < getRoseExpressionList().getLength(); i++)
        {
          getRoseExpressionList()[i].transform();
        }

     return this;
   }

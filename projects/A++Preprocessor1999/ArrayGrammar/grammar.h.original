// MACHINE GENERATED HEADER FILE --- DO NOT MODIFY! 

#ifndef ARRAY_GRAMMAR_H
#define ARRAY_GRAMMAR_H


enum ROSE_GrammarVariants 
   {
// Variants used to identify the grammar used in ROSE 

     ROSE_NodeTag, 
     ROSE_IndexArgumentListTag, 
     ROSE_IndexExpressionTag, 
     ROSE_IndexExpressionBinaryOperatorCExpressionTag, 
     ROSE_CExpressionBinaryOperatorIndexExpressionTag, 
     ROSE_UnaryOperatorIndexOperandTag, 
     ROSE_IndexOperandTag, 
     ROSE_IndexingVariableTag, 
     ROSE_IndexVariableTag, 
     ROSE_RangeVariableTag, 
     ROSE_IndexingVariableReferenceTag, 
     ROSE_IndexVariableReferenceTag, 
     ROSE_RangeVariableReferenceTag, 
     ROSE_IndexingVariablePointerTag, 
     ROSE_IndexVariablePointerTag, 
     ROSE_RangeVariablePointerTag, 
     ROSE_IndexingVariableDereferencedPointerTag, 
     ROSE_IndexVariableDereferencedPointerTag, 
     ROSE_RangeVariableDereferencedPointerTag, 
     ROSE_TypeTag, 
     ROSE_ArrayTypeTag, 
     ROSE_RealArrayTypeTag, 
     ROSE_doubleArrayTypeTag, 
     ROSE_floatArrayTypeTag, 
     ROSE_intArrayTypeTag, 
     ROSE_IndexingTypeTag, 
     ROSE_IndexTypeTag, 
     ROSE_RangeTypeTag, 
     ROSE_ArgumentListTag, 
     ROSE_StatementTag, 
     ROSE_VariableDeclarationTag, 
     ROSE_C_VariableDeclarationTag, 
     ROSE_ArrayVariableDeclarationTag, 
     ROSE_IndexingVariableDeclarationTag, 
     ROSE_StatementBlockTag, 
     ROSE_C_StatementTag, 
     ROSE_ArrayStatementTag, 
     ROSE_ExpressionStatementTag, 
     ROSE_ReturnStatementTag, 
     ROSE_WhereStatementTag, 
     ROSE_ElseWhereStatementTag, 
     ROSE_DoWhileStatementTag, 
     ROSE_WhileStatementTag, 
     ROSE_ForStatementTag, 
     ROSE_IfStatementTag, 
     ROSE_ExpressionTag, 
     ROSE_C_ExpressionTag, 
     ROSE_UserFunctionTag, 
     ROSE_ArrayExpressionTag, 
     ROSE_ArrayOperatorTag, 
     ROSE_UnaryArrayOperatorTag, 
     ROSE_UnaryArrayOperatorMinusTag, 
     ROSE_UnaryArrayOperatorPlusTag, 
     ROSE_UnaryArrayOperatorPrefixPlusPlusTag, 
     ROSE_UnaryArrayOperatorPostfixPlusPlusTag, 
     ROSE_UnaryArrayOperatorPrefixMinusMinusTag, 
     ROSE_UnaryArrayOperatorPostfixMinusMinusTag, 
     ROSE_UnaryArrayLogicalOperatorTag, 
     ROSE_UnaryArrayOperatorNOTTag, 
     ROSE_BinaryArrayOperatorTag, 
     ROSE_BinaryArrayOperatorEqualsTag, 
     ROSE_BinaryArrayOperatorAddTag, 
     ROSE_BinaryArrayOperatorAddEqualsTag, 
     ROSE_BinaryArrayOperatorMinusTag, 
     ROSE_BinaryArrayOperatorMinusEqualsTag, 
     ROSE_BinaryArrayOperatorMultiplyTag, 
     ROSE_BinaryArrayOperatorMultiplyEqualsTag, 
     ROSE_BinaryArrayOperatorDivideTag, 
     ROSE_BinaryArrayOperatorDivideEqualsTag, 
     ROSE_BinaryArrayOperatorModuloTag, 
     ROSE_BinaryArrayOperatorModuloEqualsTag, 
     ROSE_BinaryArrayTestingOperatorTag, 
     ROSE_BinaryArrayOperatorLTTag, 
     ROSE_BinaryArrayOperatorLTEqualsTag, 
     ROSE_BinaryArrayOperatorGTTag, 
     ROSE_BinaryArrayOperatorGTEqualsTag, 
     ROSE_BinaryArrayLogicalOperatorTag, 
     ROSE_BinaryArrayOperatorEquivalenceTag, 
     ROSE_BinaryArrayOperatorNOTEqualsTag, 
     ROSE_BinaryArrayOperatorLogicalANDTag, 
     ROSE_BinaryArrayOperatorLogicalORTag, 
     ROSE_NumericExpressionTag, 
     ROSE_ArrayOperandBinaryArrayOperatorArrayOperandTag, 
     ROSE_ArrayOperandBinaryArrayOperatorArrayExpressionTag, 
     ROSE_UnaryArrayOperatorArrayOperandTag, 
     ROSE_UnaryArrayOperatorArrayExpressionTag, 
     ROSE_TestingExpressionTag, 
     ROSE_ArrayOperandBinaryArrayTestingOperatorArrayOperandTag, 
     ROSE_ArrayOperandBinaryArrayTestingOperatorArrayExpressionTag, 
     ROSE_LogicalExpressionTag, 
     ROSE_ArrayOperandBinaryArrayLogicalOperatorArrayOperandTag, 
     ROSE_ArrayOperandBinaryArrayLogicalOperatorArrayExpressionTag, 
     ROSE_ArrayOperandExpressionTag, 
     ROSE_ArrayVariableExpressionTag, 
     ROSE_RealArrayVariableExpressionTag, 
     ROSE_doubleArrayVariableExpressionTag, 
     ROSE_floatArrayVariableExpressionTag, 
     ROSE_intArrayVariableExpressionTag, 
     ROSE_ArrayVariableReferenceExpressionTag, 
     ROSE_RealArrayVariableReferenceExpressionTag, 
     ROSE_doubleArrayVariableReferenceExpressionTag, 
     ROSE_floatArrayVariableReferenceExpressionTag, 
     ROSE_intArrayVariableReferenceExpressionTag, 
     ROSE_ArrayVariablePointerExpressionTag, 
     ROSE_RealArrayVariablePointerExpressionTag, 
     ROSE_doubleArrayVariablePointerExpressionTag, 
     ROSE_floatArrayVariablePointerExpressionTag, 
     ROSE_intArrayVariablePointerExpressionTag, 
     ROSE_ArrayVariableDereferencedPointerExpressionTag, 
     ROSE_RealArrayVariableDereferencedPointerExpressionTag, 
     ROSE_doubleArrayVariableDereferencedPointerExpressionTag, 
     ROSE_floatArrayVariableDereferencedPointerExpressionTag, 
     ROSE_intArrayVariableDereferencedPointerExpressionTag, 
     ROSE_ArrayParenthesisOperatorTag, 
     ROSE_ArrayFunctionExpressionTag, 
     ROSE_ArrayCOSTag, 
     ROSE_ArraySINTag, 
     ROSE_ArrayTANTag, 
     ROSE_ArrayMINTag, 
     ROSE_ArrayMAXTag, 
     ROSE_ArrayFMODTag, 
     ROSE_ArrayMODTag, 
     ROSE_ArrayPOWTag, 
     ROSE_ArraySIGNTag, 
     ROSE_ArrayLOGTag, 
     ROSE_ArrayLOG10Tag, 
     ROSE_ArrayEXPTag, 
     ROSE_ArraySQRTTag, 
     ROSE_ArrayFABSTag, 
     ROSE_ArrayCEILTag, 
     ROSE_ArrayFLOORTag, 
     ROSE_ArrayABSTag, 
     ROSE_ArrayTRANSPOSETag, 
     ROSE_ArrayACOSTag, 
     ROSE_ArrayASINTag, 
     ROSE_ArrayATANTag, 
     ROSE_ArrayCOSHTag, 
     ROSE_ArraySINHTag, 
     ROSE_ArrayTANHTag, 
     ROSE_ArrayACOSHTag, 
     ROSE_ArrayASINHTag, 
     ROSE_ArrayATANHTag, 
     ROSE_UNKNOWN_GRAMMAR, 
     ROSE_LAST_TAG 
   };




// Forward Declarations used to represent the grammar used in ROSE 
class ROSE_Node;
class ROSE_IndexArgumentList;
class ROSE_IndexExpression;
class ROSE_IndexExpressionBinaryOperatorCExpression;
class ROSE_CExpressionBinaryOperatorIndexExpression;
class ROSE_UnaryOperatorIndexOperand;
class ROSE_IndexOperand;
class ROSE_IndexingVariable;
class ROSE_IndexVariable;
class ROSE_RangeVariable;
class ROSE_IndexingVariableReference;
class ROSE_IndexVariableReference;
class ROSE_RangeVariableReference;
class ROSE_IndexingVariablePointer;
class ROSE_IndexVariablePointer;
class ROSE_RangeVariablePointer;
class ROSE_IndexingVariableDereferencedPointer;
class ROSE_IndexVariableDereferencedPointer;
class ROSE_RangeVariableDereferencedPointer;
class ROSE_Type;
class ROSE_ArrayType;
class ROSE_RealArrayType;
class ROSE_doubleArrayType;
class ROSE_floatArrayType;
class ROSE_intArrayType;
class ROSE_IndexingType;
class ROSE_IndexType;
class ROSE_RangeType;
class ROSE_ArgumentList;
class ROSE_Statement;
class ROSE_VariableDeclaration;
class ROSE_C_VariableDeclaration;
class ROSE_ArrayVariableDeclaration;
class ROSE_IndexingVariableDeclaration;
class ROSE_StatementBlock;
class ROSE_C_Statement;
class ROSE_ArrayStatement;
class ROSE_ExpressionStatement;
class ROSE_ReturnStatement;
class ROSE_WhereStatement;
class ROSE_ElseWhereStatement;
class ROSE_DoWhileStatement;
class ROSE_WhileStatement;
class ROSE_ForStatement;
class ROSE_IfStatement;
class ROSE_Expression;
class ROSE_C_Expression;
class ROSE_UserFunction;
class ROSE_ArrayExpression;
class ROSE_ArrayOperator;
class ROSE_UnaryArrayOperator;
class ROSE_UnaryArrayOperatorMinus;
class ROSE_UnaryArrayOperatorPlus;
class ROSE_UnaryArrayOperatorPrefixPlusPlus;
class ROSE_UnaryArrayOperatorPostfixPlusPlus;
class ROSE_UnaryArrayOperatorPrefixMinusMinus;
class ROSE_UnaryArrayOperatorPostfixMinusMinus;
class ROSE_UnaryArrayLogicalOperator;
class ROSE_UnaryArrayOperatorNOT;
class ROSE_BinaryArrayOperator;
class ROSE_BinaryArrayOperatorEquals;
class ROSE_BinaryArrayOperatorAdd;
class ROSE_BinaryArrayOperatorAddEquals;
class ROSE_BinaryArrayOperatorMinus;
class ROSE_BinaryArrayOperatorMinusEquals;
class ROSE_BinaryArrayOperatorMultiply;
class ROSE_BinaryArrayOperatorMultiplyEquals;
class ROSE_BinaryArrayOperatorDivide;
class ROSE_BinaryArrayOperatorDivideEquals;
class ROSE_BinaryArrayOperatorModulo;
class ROSE_BinaryArrayOperatorModuloEquals;
class ROSE_BinaryArrayTestingOperator;
class ROSE_BinaryArrayOperatorLT;
class ROSE_BinaryArrayOperatorLTEquals;
class ROSE_BinaryArrayOperatorGT;
class ROSE_BinaryArrayOperatorGTEquals;
class ROSE_BinaryArrayLogicalOperator;
class ROSE_BinaryArrayOperatorEquivalence;
class ROSE_BinaryArrayOperatorNOTEquals;
class ROSE_BinaryArrayOperatorLogicalAND;
class ROSE_BinaryArrayOperatorLogicalOR;
class ROSE_NumericExpression;
class ROSE_ArrayOperandBinaryArrayOperatorArrayOperand;
class ROSE_ArrayOperandBinaryArrayOperatorArrayExpression;
class ROSE_UnaryArrayOperatorArrayOperand;
class ROSE_UnaryArrayOperatorArrayExpression;
class ROSE_TestingExpression;
class ROSE_ArrayOperandBinaryArrayTestingOperatorArrayOperand;
class ROSE_ArrayOperandBinaryArrayTestingOperatorArrayExpression;
class ROSE_LogicalExpression;
class ROSE_ArrayOperandBinaryArrayLogicalOperatorArrayOperand;
class ROSE_ArrayOperandBinaryArrayLogicalOperatorArrayExpression;
class ROSE_ArrayOperandExpression;
class ROSE_ArrayVariableExpression;
class ROSE_RealArrayVariableExpression;
class ROSE_doubleArrayVariableExpression;
class ROSE_floatArrayVariableExpression;
class ROSE_intArrayVariableExpression;
class ROSE_ArrayVariableReferenceExpression;
class ROSE_RealArrayVariableReferenceExpression;
class ROSE_doubleArrayVariableReferenceExpression;
class ROSE_floatArrayVariableReferenceExpression;
class ROSE_intArrayVariableReferenceExpression;
class ROSE_ArrayVariablePointerExpression;
class ROSE_RealArrayVariablePointerExpression;
class ROSE_doubleArrayVariablePointerExpression;
class ROSE_floatArrayVariablePointerExpression;
class ROSE_intArrayVariablePointerExpression;
class ROSE_ArrayVariableDereferencedPointerExpression;
class ROSE_RealArrayVariableDereferencedPointerExpression;
class ROSE_doubleArrayVariableDereferencedPointerExpression;
class ROSE_floatArrayVariableDereferencedPointerExpression;
class ROSE_intArrayVariableDereferencedPointerExpression;
class ROSE_ArrayParenthesisOperator;
class ROSE_ArrayFunctionExpression;
class ROSE_ArrayCOS;
class ROSE_ArraySIN;
class ROSE_ArrayTAN;
class ROSE_ArrayMIN;
class ROSE_ArrayMAX;
class ROSE_ArrayFMOD;
class ROSE_ArrayMOD;
class ROSE_ArrayPOW;
class ROSE_ArraySIGN;
class ROSE_ArrayLOG;
class ROSE_ArrayLOG10;
class ROSE_ArrayEXP;
class ROSE_ArraySQRT;
class ROSE_ArrayFABS;
class ROSE_ArrayCEIL;
class ROSE_ArrayFLOOR;
class ROSE_ArrayABS;
class ROSE_ArrayTRANSPOSE;
class ROSE_ArrayACOS;
class ROSE_ArrayASIN;
class ROSE_ArrayATAN;
class ROSE_ArrayCOSH;
class ROSE_ArraySINH;
class ROSE_ArrayTANH;
class ROSE_ArrayACOSH;
class ROSE_ArrayASINH;
class ROSE_ArrayATANH;



// class ROSE_TreeBaseClass
class ROSE_Node
   {
     public:
         ~ROSE_Node ();
          ROSE_Node ();

       // How do we want to build this?
       // ROSE_Node ( ROSE_GrammarVariants id, SgNode* subTree );
          ROSE_Node ( SgNode* subTree );

          void setUp ( ROSE_GrammarVariants newId, SgNode* newSubTree );
          ROSE_GrammarVariants getVariant() const;
          void setVariant ( const ROSE_GrammarVariants id );

       // This make this class an abstract base class
          virtual ROSE_Node* transform() = 0;

       // Error recovery mechanism (for the parser)
          Boolean error() const;
          void setParseError ( Boolean X );

          const SgNode* getSageSubTree();
          void setSageSubTree ( const SgNode* node );

          static Sg_File_Info* buildSageFileInfo ( char* filename = "default_file_name" );

          static SgTypeDouble* buildTypeDouble();
          static SgTypeFloat*  buildTypeFloat();
          static SgTypeInt*    buildTypeInt();

          virtual SgType*      getType();

     private:
	  ROSE_GrammarVariants id;
          SgNode* sageSubTree;
          Boolean parseError;  // error recovery mechanism for parser

  // We don't want to have these be used within the interface
     private:
          ROSE_Node ( const ROSE_Node & X );
          ROSE_Node & operator= ( const ROSE_Node & X );
   };


// Class Definition for ROSE_IndexArgumentList
class ROSE_IndexArgumentList : public ROSE_Node
   {
     public:
         ~ROSE_IndexArgumentList ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_IndexArgumentList ();
          ROSE_IndexArgumentList ( const ROSE_IndexArgumentList & X );
          ROSE_IndexArgumentList & operator= ( const ROSE_IndexArgumentList & X );
   };



// Class Definition for ROSE_IndexExpression
class ROSE_IndexExpression : public ROSE_Node
   {
     public:
         ~ROSE_IndexExpression ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_IndexExpression ();
          ROSE_IndexExpression ( const ROSE_IndexExpression & X );
          ROSE_IndexExpression & operator= ( const ROSE_IndexExpression & X );
   };



// Class Definition for ROSE_IndexOperand
class ROSE_IndexOperand : public ROSE_Node
   {
     public:
         ~ROSE_IndexOperand ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_IndexOperand ();
          ROSE_IndexOperand ( const ROSE_IndexOperand & X );
          ROSE_IndexOperand & operator= ( const ROSE_IndexOperand & X );
   };



// Class Definition for ROSE_Type
class ROSE_Type : public ROSE_Node
   {
     public:
         ~ROSE_Type ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_Type ();
          ROSE_Type ( const ROSE_Type & X );
          ROSE_Type & operator= ( const ROSE_Type & X );
   };



// Class Definition for ROSE_ArgumentList
class ROSE_ArgumentList : public ROSE_Node
   {
     public:
         ~ROSE_ArgumentList ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_ArgumentList ();
          ROSE_ArgumentList ( const ROSE_ArgumentList & X );
          ROSE_ArgumentList & operator= ( const ROSE_ArgumentList & X );
   };



// Class Definition for ROSE_Statement
class ROSE_Statement : public ROSE_Node
   {
     public:
         ~ROSE_Statement ();

       // Special constructor for ROSE_Statement;
          ROSE_Statement ( SgStatement* stmt );

       // Make this class an abstract base class so that we can be certain that
       // we will not ever try to build one of these directly.
          virtual ROSE_Node* transform () = 0;

          SgStatement* getSageStatement ();
          void setSageStatement ( SgStatement* stmt );


     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_Statement ();
          ROSE_Statement ( const ROSE_Statement & X );
          ROSE_Statement & operator= ( const ROSE_Statement & X );
   };



// Class Definition for ROSE_Expression
class ROSE_Expression : public ROSE_Node
   {
     public:
         ~ROSE_Expression ();

       // Special constructor for this class
          ROSE_Expression ( SgExpression* expr );

       // Make this class an abstract base class so that we can be certain that
       // we will not ever try to build one of these directly.
          virtual ROSE_Node* transform() = 0;

          void setSageTransformedExpression ( SgExpression* );
          SgExpression* getSageTransformation ();

          virtual SgExpression* buildExpression ( ROSE_Expression* node, SgExpression* sageLhsExpression, SgExpression* sageRhsExpression );

     private:
          SgExpression* transformedExpression;



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_Expression ();
          ROSE_Expression ( const ROSE_Expression & X );
          ROSE_Expression & operator= ( const ROSE_Expression & X );
   };



// Class Definition for ROSE_IndexExpressionBinaryOperatorCExpression
class ROSE_IndexExpressionBinaryOperatorCExpression : public ROSE_IndexExpression
   {
     public:
         ~ROSE_IndexExpressionBinaryOperatorCExpression ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_IndexExpressionBinaryOperatorCExpression ();
          ROSE_IndexExpressionBinaryOperatorCExpression ( const ROSE_IndexExpressionBinaryOperatorCExpression & X );
          ROSE_IndexExpressionBinaryOperatorCExpression & operator= ( const ROSE_IndexExpressionBinaryOperatorCExpression & X );
   };



// Class Definition for ROSE_CExpressionBinaryOperatorIndexExpression
class ROSE_CExpressionBinaryOperatorIndexExpression : public ROSE_IndexExpression
   {
     public:
         ~ROSE_CExpressionBinaryOperatorIndexExpression ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_CExpressionBinaryOperatorIndexExpression ();
          ROSE_CExpressionBinaryOperatorIndexExpression ( const ROSE_CExpressionBinaryOperatorIndexExpression & X );
          ROSE_CExpressionBinaryOperatorIndexExpression & operator= ( const ROSE_CExpressionBinaryOperatorIndexExpression & X );
   };



// Class Definition for ROSE_UnaryOperatorIndexOperand
class ROSE_UnaryOperatorIndexOperand : public ROSE_IndexExpression
   {
     public:
         ~ROSE_UnaryOperatorIndexOperand ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_UnaryOperatorIndexOperand ();
          ROSE_UnaryOperatorIndexOperand ( const ROSE_UnaryOperatorIndexOperand & X );
          ROSE_UnaryOperatorIndexOperand & operator= ( const ROSE_UnaryOperatorIndexOperand & X );
   };



// Class Definition for ROSE_IndexingVariable
class ROSE_IndexingVariable : public ROSE_IndexOperand
   {
     public:
         ~ROSE_IndexingVariable ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_IndexingVariable ();
          ROSE_IndexingVariable ( const ROSE_IndexingVariable & X );
          ROSE_IndexingVariable & operator= ( const ROSE_IndexingVariable & X );
   };



// Class Definition for ROSE_IndexingVariableReference
class ROSE_IndexingVariableReference : public ROSE_IndexOperand
   {
     public:
         ~ROSE_IndexingVariableReference ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_IndexingVariableReference ();
          ROSE_IndexingVariableReference ( const ROSE_IndexingVariableReference & X );
          ROSE_IndexingVariableReference & operator= ( const ROSE_IndexingVariableReference & X );
   };



// Class Definition for ROSE_IndexingVariablePointer
class ROSE_IndexingVariablePointer : public ROSE_IndexOperand
   {
     public:
         ~ROSE_IndexingVariablePointer ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_IndexingVariablePointer ();
          ROSE_IndexingVariablePointer ( const ROSE_IndexingVariablePointer & X );
          ROSE_IndexingVariablePointer & operator= ( const ROSE_IndexingVariablePointer & X );
   };



// Class Definition for ROSE_IndexingVariableDereferencedPointer
class ROSE_IndexingVariableDereferencedPointer : public ROSE_IndexOperand
   {
     public:
         ~ROSE_IndexingVariableDereferencedPointer ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_IndexingVariableDereferencedPointer ();
          ROSE_IndexingVariableDereferencedPointer ( const ROSE_IndexingVariableDereferencedPointer & X );
          ROSE_IndexingVariableDereferencedPointer & operator= ( const ROSE_IndexingVariableDereferencedPointer & X );
   };



// Class Definition for ROSE_IndexVariable
class ROSE_IndexVariable : public ROSE_IndexingVariable
   {
     public:
         ~ROSE_IndexVariable ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_IndexVariable ();
          ROSE_IndexVariable ( const ROSE_IndexVariable & X );
          ROSE_IndexVariable & operator= ( const ROSE_IndexVariable & X );
   };



// Class Definition for ROSE_RangeVariable
class ROSE_RangeVariable : public ROSE_IndexingVariable
   {
     public:
         ~ROSE_RangeVariable ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_RangeVariable ();
          ROSE_RangeVariable ( const ROSE_RangeVariable & X );
          ROSE_RangeVariable & operator= ( const ROSE_RangeVariable & X );
   };



// Class Definition for ROSE_IndexVariableReference
class ROSE_IndexVariableReference : public ROSE_IndexingVariableReference
   {
     public:
         ~ROSE_IndexVariableReference ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_IndexVariableReference ();
          ROSE_IndexVariableReference ( const ROSE_IndexVariableReference & X );
          ROSE_IndexVariableReference & operator= ( const ROSE_IndexVariableReference & X );
   };



// Class Definition for ROSE_RangeVariableReference
class ROSE_RangeVariableReference : public ROSE_IndexingVariableReference
   {
     public:
         ~ROSE_RangeVariableReference ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_RangeVariableReference ();
          ROSE_RangeVariableReference ( const ROSE_RangeVariableReference & X );
          ROSE_RangeVariableReference & operator= ( const ROSE_RangeVariableReference & X );
   };



// Class Definition for ROSE_IndexVariablePointer
class ROSE_IndexVariablePointer : public ROSE_IndexingVariablePointer
   {
     public:
         ~ROSE_IndexVariablePointer ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_IndexVariablePointer ();
          ROSE_IndexVariablePointer ( const ROSE_IndexVariablePointer & X );
          ROSE_IndexVariablePointer & operator= ( const ROSE_IndexVariablePointer & X );
   };



// Class Definition for ROSE_RangeVariablePointer
class ROSE_RangeVariablePointer : public ROSE_IndexingVariablePointer
   {
     public:
         ~ROSE_RangeVariablePointer ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_RangeVariablePointer ();
          ROSE_RangeVariablePointer ( const ROSE_RangeVariablePointer & X );
          ROSE_RangeVariablePointer & operator= ( const ROSE_RangeVariablePointer & X );
   };



// Class Definition for ROSE_ArrayType
class ROSE_ArrayType : public ROSE_Type
   {
     public:
         ~ROSE_ArrayType ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_ArrayType ();
          ROSE_ArrayType ( const ROSE_ArrayType & X );
          ROSE_ArrayType & operator= ( const ROSE_ArrayType & X );
   };



// Class Definition for ROSE_IndexingType
class ROSE_IndexingType : public ROSE_Type
   {
     public:
         ~ROSE_IndexingType ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_IndexingType ();
          ROSE_IndexingType ( const ROSE_IndexingType & X );
          ROSE_IndexingType & operator= ( const ROSE_IndexingType & X );
   };



// Class Definition for ROSE_IndexType
class ROSE_IndexType : public ROSE_IndexingType
   {
     public:
         ~ROSE_IndexType ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_IndexType ();
          ROSE_IndexType ( const ROSE_IndexType & X );
          ROSE_IndexType & operator= ( const ROSE_IndexType & X );
   };



// Class Definition for ROSE_RangeType
class ROSE_RangeType : public ROSE_IndexingType
   {
     public:
         ~ROSE_RangeType ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_RangeType ();
          ROSE_RangeType ( const ROSE_RangeType & X );
          ROSE_RangeType & operator= ( const ROSE_RangeType & X );
   };



// Class Definition for ROSE_RealArrayType
class ROSE_RealArrayType : public ROSE_ArrayType
   {
     public:
         ~ROSE_RealArrayType ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_RealArrayType ();
          ROSE_RealArrayType ( const ROSE_RealArrayType & X );
          ROSE_RealArrayType & operator= ( const ROSE_RealArrayType & X );
   };



// Class Definition for ROSE_intArrayType
class ROSE_intArrayType : public ROSE_ArrayType
   {
     public:
         ~ROSE_intArrayType ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_intArrayType ();
          ROSE_intArrayType ( const ROSE_intArrayType & X );
          ROSE_intArrayType & operator= ( const ROSE_intArrayType & X );
   };



// Class Definition for ROSE_doubleArrayType
class ROSE_doubleArrayType : public ROSE_RealArrayType
   {
     public:
         ~ROSE_doubleArrayType ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_doubleArrayType ();
          ROSE_doubleArrayType ( const ROSE_doubleArrayType & X );
          ROSE_doubleArrayType & operator= ( const ROSE_doubleArrayType & X );
   };



// Class Definition for ROSE_floatArrayType
class ROSE_floatArrayType : public ROSE_RealArrayType
   {
     public:
         ~ROSE_floatArrayType ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_floatArrayType ();
          ROSE_floatArrayType ( const ROSE_floatArrayType & X );
          ROSE_floatArrayType & operator= ( const ROSE_floatArrayType & X );
   };



// Class Definition for ROSE_UserFunction
class ROSE_UserFunction : public ROSE_Expression
   {
     public:
         ~ROSE_UserFunction ();

       // Special constructor for this class
          ROSE_UserFunction ( SgExpression* expr );

          virtual ROSE_Node* transform();

       // static ROSE_UserFunction* build_ROSE_C_Expression ( ROSE_Expression* node, ROSE_Expression* roseLhsExpression, ROSE_Expression* roseRhsExpression );


     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_UserFunction ();
          ROSE_UserFunction ( const ROSE_UserFunction & X );
          ROSE_UserFunction & operator= ( const ROSE_UserFunction & X );
   };



// Class Definition for ROSE_C_Expression
class ROSE_C_Expression : public ROSE_Expression
   {
     public:
         ~ROSE_C_Expression ();

       // Special constructor for this class
          ROSE_C_Expression ( SgExpression* expr );

          virtual ROSE_Node* transform();

       // ROSE_C_Expression ( ROSE_Node* node, ROSE_Expression* roseLhsExpression, ROSE_Expression* roseRhsExpression );
          static ROSE_C_Expression* build_ROSE_C_Expression ( ROSE_Expression* node, ROSE_Expression* roseLhsExpression, ROSE_Expression* roseRhsExpression );


     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_C_Expression ();
          ROSE_C_Expression ( const ROSE_C_Expression & X );
          ROSE_C_Expression & operator= ( const ROSE_C_Expression & X );
   };



// Class Definition for ROSE_ArrayExpression
class ROSE_ArrayExpression : public ROSE_Expression
   {
     public:
         ~ROSE_ArrayExpression ();

       // Special constructor for this class
          ROSE_ArrayExpression ( SgExpression* expr );

       // Make this class an abstract base class so that we can be certain that
       // we will not ever try to build one of these directly.
          virtual ROSE_Node* transform() = 0;

          SgType* getType();


     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_ArrayExpression ();
          ROSE_ArrayExpression ( const ROSE_ArrayExpression & X );
          ROSE_ArrayExpression & operator= ( const ROSE_ArrayExpression & X );
   };



// Class Definition for ROSE_NumericExpression
class ROSE_NumericExpression : public ROSE_ArrayExpression
   {
     public:
         ~ROSE_NumericExpression ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_NumericExpression ();
          ROSE_NumericExpression ( const ROSE_NumericExpression & X );
          ROSE_NumericExpression & operator= ( const ROSE_NumericExpression & X );
   };



// Class Definition for ROSE_TestingExpression
class ROSE_TestingExpression : public ROSE_ArrayExpression
   {
     public:
         ~ROSE_TestingExpression ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_TestingExpression ();
          ROSE_TestingExpression ( const ROSE_TestingExpression & X );
          ROSE_TestingExpression & operator= ( const ROSE_TestingExpression & X );
   };



// Class Definition for ROSE_LogicalExpression
class ROSE_LogicalExpression : public ROSE_ArrayExpression
   {
     public:
         ~ROSE_LogicalExpression ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_LogicalExpression ();
          ROSE_LogicalExpression ( const ROSE_LogicalExpression & X );
          ROSE_LogicalExpression & operator= ( const ROSE_LogicalExpression & X );
   };



// Class Definition for ROSE_ArrayOperandExpression
class ROSE_ArrayOperandExpression : public ROSE_ArrayExpression
   {
     public:
         ~ROSE_ArrayOperandExpression ();

       // Special constructor for ROSE_ArrayOperandExpression;
          ROSE_ArrayOperandExpression ( SgExpression* expr );

       // Define the abstractBaseClass function
       // We later want to make this a pure virtual function (making this class and abstract base class)
#if 0
          virtual ROSE_Node* transform();
#else
          virtual ROSE_Node* transform() = 0;
#endif
          void recognizeSageSubTree ( SgExpression* expr );

          SgExpression* getExpression();

       // Stuff about the indexing of array operands
          virtual Boolean isAnIndexedOperand();
          virtual int getNumberOfDimensions() = 0;

       // Rules on how we modify variable names (unique names are required)
          static SgName transformationVariablePrefix();
          static SgName transformationVariableSuffix();

       // get the names of the different parts
          virtual SgName getOperandName();
          virtual SgName getOperandPointerName();
          SgName getIndexName (int dimension);

#define ROSE_MAX_ARRAY_DIMENSION 8

       // Build a new operand as a SgExpression*
          SgPntrArrRefExp* buildOperand (
               SgName arrayName,                                             // variable name
               variant_type_enum arrayType,                                  // Type for the array pointer
               SgName indexName                [ROSE_MAX_ARRAY_DIMENSION],   // variable name
               variant_type_enum indexOperator [ROSE_MAX_ARRAY_DIMENSION],   // ADD_OP, SUBT_OP, etc. (semantics of A++/P++ Index and Range objects only)
               SgExpression* rhsExpression     [ROSE_MAX_ARRAY_DIMENSION],   // integer expression for the rhs of the indexOperator
               int statementDimension,                                       // Dimention of the entire statement (not just this operand!)
               Boolean normalOrderOfOperands   [ROSE_MAX_ARRAY_DIMENSION] ); // I+1 is the normal order, but 1-I is handled properly




     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_ArrayOperandExpression ();
          ROSE_ArrayOperandExpression ( const ROSE_ArrayOperandExpression & X );
          ROSE_ArrayOperandExpression & operator= ( const ROSE_ArrayOperandExpression & X );
   };



// Class Definition for ROSE_ArrayOperator
class ROSE_ArrayOperator : public ROSE_ArrayExpression
   {
     public:
         ~ROSE_ArrayOperator ();

       // Special constructor for this class
          ROSE_ArrayOperator ( SgExpression* expr );

       // Make this class an abstract base class so that we can be certain that
       // we will not ever try to build one of these directly.
          virtual ROSE_Node* transform() = 0;

          void           setSageExpressionListExpression ( SgExprListExp* exprListExp );
          SgExprListExp* getSageExpressionListExpression();

          void addArgumentExpression ( ROSE_Expression* roseExpression );
          int  numberOfArguments();

       // I don't know if using the operator[] is really required (too cute for now!)
       // ROSE_Expression & operator[](int i);
          void resetArgumentExpression ( ROSE_Expression* expr, int index );
          void addArgumentExpression   ( ROSE_Expression* expr, int index );
          ROSE_Expression* getArgumentExpression ( int index );

       // Or the user can get the list and manipulate it more directly (as a backup mechanism)
          List<ROSE_Expression> & getRoseExpressionList ();

     private:
          SgExprListExp* sageExpressionListExpression;
          List<ROSE_Expression> roseExpressionList;

          

     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_ArrayOperator ();
          ROSE_ArrayOperator ( const ROSE_ArrayOperator & X );
          ROSE_ArrayOperator & operator= ( const ROSE_ArrayOperator & X );
   };



// Class Definition for ROSE_ArrayFunctionExpression
class ROSE_ArrayFunctionExpression : public ROSE_ArrayExpression
   {
     public:
         ~ROSE_ArrayFunctionExpression ();

       // Special constructor for this class
          ROSE_ArrayFunctionExpression ( SgExpression* expr );

       // Make this class an abstract base class so that we can be certain that
       // we will not ever try to build one of these directly.
          virtual ROSE_Node* transform() = 0;

          void addArgumentExpression ( ROSE_Expression* roseExpression );
          int  numberOfArguments();

          void           setSageExpressionListExpression ( SgExprListExp* exprListExp );
          SgExprListExp* getSageExpressionListExpression();

          List<ROSE_Expression> & getRoseExpressionList ();

     private:
          SgExprListExp* sageExpressionListExpression;
          List<ROSE_Expression> roseExpressionList;



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_ArrayFunctionExpression ();
          ROSE_ArrayFunctionExpression ( const ROSE_ArrayFunctionExpression & X );
          ROSE_ArrayFunctionExpression & operator= ( const ROSE_ArrayFunctionExpression & X );
   };



// Class Definition for ROSE_UnaryArrayOperator
class ROSE_UnaryArrayOperator : public ROSE_ArrayOperator
   {
     public:
         ~ROSE_UnaryArrayOperator ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_UnaryArrayOperator ();
          ROSE_UnaryArrayOperator ( const ROSE_UnaryArrayOperator & X );
          ROSE_UnaryArrayOperator & operator= ( const ROSE_UnaryArrayOperator & X );
   };



// Class Definition for ROSE_BinaryArrayOperator
class ROSE_BinaryArrayOperator : public ROSE_ArrayOperator
   {
     public:
         ~ROSE_BinaryArrayOperator ();

       // Special constructor for this class
          ROSE_BinaryArrayOperator ( SgExpression* expr );

       // Make this class an abstract base class so that we can be certain that
       // we will not ever try to build one of these directly.
          virtual ROSE_Node* transform() = 0;

       // Member functions specific to ROSE_BinaryArrayOperator
          virtual SgExpression* getLhsSageExpression();
          virtual SgExpression* getRhsSageExpression();

          virtual void setLhsSageExpression ( SgExpression* expr );
          virtual void setRhsSageExpression ( SgExpression* expr );

          virtual void setLhsRoseExpression ( ROSE_Expression* lhsExpr );
          virtual void setRhsRoseExpression ( ROSE_Expression* rhsExpr );

          virtual ROSE_Expression* getLhsRoseExpression ();
          virtual ROSE_Expression* getRhsRoseExpression ();

          void setSageBinaryOperator ( SgBinaryOp* newBinaryOperator );
          SgBinaryOp* getSageBinaryOperator ();

       // Make this a pure virtual function after we have it debugged!
       // Also it might make more sense for this function to return a ROSE_Expression
          virtual ROSE_Node* transform ( ROSE_Expression* lhs, ROSE_Expression* rhs );

     protected:
          SgBinaryOp* sageBinaryOperator;

       // We should use the List mechanism in the base class ROSE_ArrayOperator
       // ROSE_ArrayOperandExpression* roseLhsOperand;
       // ROSE_ArrayExpression*        roseRhsExpression;





     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_BinaryArrayOperator ();
          ROSE_BinaryArrayOperator ( const ROSE_BinaryArrayOperator & X );
          ROSE_BinaryArrayOperator & operator= ( const ROSE_BinaryArrayOperator & X );
   };



// Class Definition for ROSE_UnaryArrayOperatorMinus
class ROSE_UnaryArrayOperatorMinus : public ROSE_UnaryArrayOperator
   {
     public:
         ~ROSE_UnaryArrayOperatorMinus ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_UnaryArrayOperatorMinus ();
          ROSE_UnaryArrayOperatorMinus ( const ROSE_UnaryArrayOperatorMinus & X );
          ROSE_UnaryArrayOperatorMinus & operator= ( const ROSE_UnaryArrayOperatorMinus & X );
   };



// Class Definition for ROSE_UnaryArrayOperatorPlus
class ROSE_UnaryArrayOperatorPlus : public ROSE_UnaryArrayOperator
   {
     public:
         ~ROSE_UnaryArrayOperatorPlus ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_UnaryArrayOperatorPlus ();
          ROSE_UnaryArrayOperatorPlus ( const ROSE_UnaryArrayOperatorPlus & X );
          ROSE_UnaryArrayOperatorPlus & operator= ( const ROSE_UnaryArrayOperatorPlus & X );
   };



// Class Definition for ROSE_UnaryArrayOperatorPrefixPlusPlus
class ROSE_UnaryArrayOperatorPrefixPlusPlus : public ROSE_UnaryArrayOperator
   {
     public:
         ~ROSE_UnaryArrayOperatorPrefixPlusPlus ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_UnaryArrayOperatorPrefixPlusPlus ();
          ROSE_UnaryArrayOperatorPrefixPlusPlus ( const ROSE_UnaryArrayOperatorPrefixPlusPlus & X );
          ROSE_UnaryArrayOperatorPrefixPlusPlus & operator= ( const ROSE_UnaryArrayOperatorPrefixPlusPlus & X );
   };



// Class Definition for ROSE_UnaryArrayOperatorPrefixMinusMinus
class ROSE_UnaryArrayOperatorPrefixMinusMinus : public ROSE_UnaryArrayOperator
   {
     public:
         ~ROSE_UnaryArrayOperatorPrefixMinusMinus ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_UnaryArrayOperatorPrefixMinusMinus ();
          ROSE_UnaryArrayOperatorPrefixMinusMinus ( const ROSE_UnaryArrayOperatorPrefixMinusMinus & X );
          ROSE_UnaryArrayOperatorPrefixMinusMinus & operator= ( const ROSE_UnaryArrayOperatorPrefixMinusMinus & X );
   };



// Class Definition for ROSE_UnaryArrayOperatorPostfixPlusPlus
class ROSE_UnaryArrayOperatorPostfixPlusPlus : public ROSE_UnaryArrayOperator
   {
     public:
         ~ROSE_UnaryArrayOperatorPostfixPlusPlus ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_UnaryArrayOperatorPostfixPlusPlus ();
          ROSE_UnaryArrayOperatorPostfixPlusPlus ( const ROSE_UnaryArrayOperatorPostfixPlusPlus & X );
          ROSE_UnaryArrayOperatorPostfixPlusPlus & operator= ( const ROSE_UnaryArrayOperatorPostfixPlusPlus & X );
   };



// Class Definition for ROSE_UnaryArrayOperatorPostfixMinusMinus
class ROSE_UnaryArrayOperatorPostfixMinusMinus : public ROSE_UnaryArrayOperator
   {
     public:
         ~ROSE_UnaryArrayOperatorPostfixMinusMinus ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_UnaryArrayOperatorPostfixMinusMinus ();
          ROSE_UnaryArrayOperatorPostfixMinusMinus ( const ROSE_UnaryArrayOperatorPostfixMinusMinus & X );
          ROSE_UnaryArrayOperatorPostfixMinusMinus & operator= ( const ROSE_UnaryArrayOperatorPostfixMinusMinus & X );
   };



// Class Definition for ROSE_UnaryArrayLogicalOperator
class ROSE_UnaryArrayLogicalOperator : public ROSE_UnaryArrayOperator
   {
     public:
         ~ROSE_UnaryArrayLogicalOperator ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_UnaryArrayLogicalOperator ();
          ROSE_UnaryArrayLogicalOperator ( const ROSE_UnaryArrayLogicalOperator & X );
          ROSE_UnaryArrayLogicalOperator & operator= ( const ROSE_UnaryArrayLogicalOperator & X );
   };



// Class Definition for ROSE_BinaryArrayOperatorEquals
class ROSE_BinaryArrayOperatorEquals : public ROSE_BinaryArrayOperator
   {
     public:
         ~ROSE_BinaryArrayOperatorEquals ();

       // Special constructor for ROSE_BinaryArrayOperatorEquals
          ROSE_BinaryArrayOperatorEquals ( SgExpression* expr );

       // I think that the case of a operator= is a special case and not the same 
       // as the more general (common) binary operators (since it is a member function 
       // in A++/P++ instead of a friend function as the rest of the operators are, 
       // like +,-,*,/,%.
          void recognizeSageSubTree ( SgExpression* expr );

       // Define this function on the leaves of the tree representing our grammar
          virtual ROSE_Node* transform();

       // Member functions specific to ROSE_BinaryArrayOperatorEquals
          virtual SgExpression* getLhsSageExpression();
          virtual SgExpression* getRhsSageExpression();

          virtual void setLhsSageExpression ( SgExpression* expr );
          virtual void setRhsSageExpression ( SgExpression* expr );

       // Build the ROSE_C_Expression containing the sage assignment operator
          virtual ROSE_Node* transform ( ROSE_Expression* roseLhsExpression, ROSE_Expression* roseRhsExpression );

       // Build the Sage assignment operator
          SgExpression* buildExpression ( ROSE_Expression* node, SgExpression* sageLhsExpression, SgExpression* sageRhsExpression );

       // SgType* getType();
#if 0
     private:
          SgBinaryOp* sageBinaryOperator;
#endif


     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_BinaryArrayOperatorEquals ();
          ROSE_BinaryArrayOperatorEquals ( const ROSE_BinaryArrayOperatorEquals & X );
          ROSE_BinaryArrayOperatorEquals & operator= ( const ROSE_BinaryArrayOperatorEquals & X );
   };



// Class Definition for ROSE_BinaryArrayOperatorAdd
class ROSE_BinaryArrayOperatorAdd : public ROSE_BinaryArrayOperator
   {
     public:
         ~ROSE_BinaryArrayOperatorAdd ();

       // Special constructor for this class
          ROSE_BinaryArrayOperatorAdd ( SgExpression* expr );

       // This class is a leaf of our grammar, so we want to define this function here
          virtual ROSE_Node* transform();
          virtual ROSE_Node* transform( ROSE_Expression* lhs, ROSE_Expression* rhs );

          virtual SgExpression* buildExpression ( ROSE_Expression* node, SgExpression* sageLhsExpression, SgExpression* sageRhsExpression );

          virtual SgType* getType();




     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_BinaryArrayOperatorAdd ();
          ROSE_BinaryArrayOperatorAdd ( const ROSE_BinaryArrayOperatorAdd & X );
          ROSE_BinaryArrayOperatorAdd & operator= ( const ROSE_BinaryArrayOperatorAdd & X );
   };



// Class Definition for ROSE_BinaryArrayOperatorAddEquals
class ROSE_BinaryArrayOperatorAddEquals : public ROSE_BinaryArrayOperator
   {
     public:
         ~ROSE_BinaryArrayOperatorAddEquals ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_BinaryArrayOperatorAddEquals ();
          ROSE_BinaryArrayOperatorAddEquals ( const ROSE_BinaryArrayOperatorAddEquals & X );
          ROSE_BinaryArrayOperatorAddEquals & operator= ( const ROSE_BinaryArrayOperatorAddEquals & X );
   };



// Class Definition for ROSE_BinaryArrayOperatorMinus
class ROSE_BinaryArrayOperatorMinus : public ROSE_BinaryArrayOperator
   {
     public:
         ~ROSE_BinaryArrayOperatorMinus ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_BinaryArrayOperatorMinus ();
          ROSE_BinaryArrayOperatorMinus ( const ROSE_BinaryArrayOperatorMinus & X );
          ROSE_BinaryArrayOperatorMinus & operator= ( const ROSE_BinaryArrayOperatorMinus & X );
   };



// Class Definition for ROSE_BinaryArrayOperatorMinusEquals
class ROSE_BinaryArrayOperatorMinusEquals : public ROSE_BinaryArrayOperator
   {
     public:
         ~ROSE_BinaryArrayOperatorMinusEquals ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_BinaryArrayOperatorMinusEquals ();
          ROSE_BinaryArrayOperatorMinusEquals ( const ROSE_BinaryArrayOperatorMinusEquals & X );
          ROSE_BinaryArrayOperatorMinusEquals & operator= ( const ROSE_BinaryArrayOperatorMinusEquals & X );
   };



// Class Definition for ROSE_BinaryArrayOperatorMultiply
class ROSE_BinaryArrayOperatorMultiply : public ROSE_BinaryArrayOperator
   {
     public:
         ~ROSE_BinaryArrayOperatorMultiply ();

       // Special constructor for this class
          ROSE_BinaryArrayOperatorMultiply ( SgExpression* expr );

       // This class is a leaf of our grammar, so we want to define this function here
          virtual ROSE_Node* transform();
          virtual ROSE_Node* transform( ROSE_Expression* lhs, ROSE_Expression* rhs );

          virtual SgExpression* buildExpression ( ROSE_Expression* node, SgExpression* sageLhsExpression, SgExpression* sageRhsExpression );


     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_BinaryArrayOperatorMultiply ();
          ROSE_BinaryArrayOperatorMultiply ( const ROSE_BinaryArrayOperatorMultiply & X );
          ROSE_BinaryArrayOperatorMultiply & operator= ( const ROSE_BinaryArrayOperatorMultiply & X );
   };



// Class Definition for ROSE_BinaryArrayOperatorMultiplyEquals
class ROSE_BinaryArrayOperatorMultiplyEquals : public ROSE_BinaryArrayOperator
   {
     public:
         ~ROSE_BinaryArrayOperatorMultiplyEquals ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_BinaryArrayOperatorMultiplyEquals ();
          ROSE_BinaryArrayOperatorMultiplyEquals ( const ROSE_BinaryArrayOperatorMultiplyEquals & X );
          ROSE_BinaryArrayOperatorMultiplyEquals & operator= ( const ROSE_BinaryArrayOperatorMultiplyEquals & X );
   };



// Class Definition for ROSE_BinaryArrayOperatorDivide
class ROSE_BinaryArrayOperatorDivide : public ROSE_BinaryArrayOperator
   {
     public:
         ~ROSE_BinaryArrayOperatorDivide ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_BinaryArrayOperatorDivide ();
          ROSE_BinaryArrayOperatorDivide ( const ROSE_BinaryArrayOperatorDivide & X );
          ROSE_BinaryArrayOperatorDivide & operator= ( const ROSE_BinaryArrayOperatorDivide & X );
   };



// Class Definition for ROSE_BinaryArrayOperatorDivideEquals
class ROSE_BinaryArrayOperatorDivideEquals : public ROSE_BinaryArrayOperator
   {
     public:
         ~ROSE_BinaryArrayOperatorDivideEquals ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_BinaryArrayOperatorDivideEquals ();
          ROSE_BinaryArrayOperatorDivideEquals ( const ROSE_BinaryArrayOperatorDivideEquals & X );
          ROSE_BinaryArrayOperatorDivideEquals & operator= ( const ROSE_BinaryArrayOperatorDivideEquals & X );
   };



// Class Definition for ROSE_BinaryArrayOperatorModulo
class ROSE_BinaryArrayOperatorModulo : public ROSE_BinaryArrayOperator
   {
     public:
         ~ROSE_BinaryArrayOperatorModulo ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_BinaryArrayOperatorModulo ();
          ROSE_BinaryArrayOperatorModulo ( const ROSE_BinaryArrayOperatorModulo & X );
          ROSE_BinaryArrayOperatorModulo & operator= ( const ROSE_BinaryArrayOperatorModulo & X );
   };



// Class Definition for ROSE_BinaryArrayOperatorModuloEquals
class ROSE_BinaryArrayOperatorModuloEquals : public ROSE_BinaryArrayOperator
   {
     public:
         ~ROSE_BinaryArrayOperatorModuloEquals ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_BinaryArrayOperatorModuloEquals ();
          ROSE_BinaryArrayOperatorModuloEquals ( const ROSE_BinaryArrayOperatorModuloEquals & X );
          ROSE_BinaryArrayOperatorModuloEquals & operator= ( const ROSE_BinaryArrayOperatorModuloEquals & X );
   };



// Class Definition for ROSE_BinaryArrayTestingOperator
class ROSE_BinaryArrayTestingOperator : public ROSE_BinaryArrayOperator
   {
     public:
         ~ROSE_BinaryArrayTestingOperator ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_BinaryArrayTestingOperator ();
          ROSE_BinaryArrayTestingOperator ( const ROSE_BinaryArrayTestingOperator & X );
          ROSE_BinaryArrayTestingOperator & operator= ( const ROSE_BinaryArrayTestingOperator & X );
   };



// Class Definition for ROSE_BinaryArrayLogicalOperator
class ROSE_BinaryArrayLogicalOperator : public ROSE_BinaryArrayOperator
   {
     public:
         ~ROSE_BinaryArrayLogicalOperator ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_BinaryArrayLogicalOperator ();
          ROSE_BinaryArrayLogicalOperator ( const ROSE_BinaryArrayLogicalOperator & X );
          ROSE_BinaryArrayLogicalOperator & operator= ( const ROSE_BinaryArrayLogicalOperator & X );
   };



// Class Definition for ROSE_VariableDeclaration
class ROSE_VariableDeclaration : public ROSE_Statement
   {
     public:
         ~ROSE_VariableDeclaration ();

        // Special constructor for ROSE_VariableDeclaration;
          ROSE_VariableDeclaration ( SgStatement* stmt );

       // Make this class an abstract base class so that we can be certain that
       // we will not ever try to build one of these directly.
          virtual ROSE_Node* transform () = 0;


     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_VariableDeclaration ();
          ROSE_VariableDeclaration ( const ROSE_VariableDeclaration & X );
          ROSE_VariableDeclaration & operator= ( const ROSE_VariableDeclaration & X );
   };



// Class Definition for ROSE_StatementBlock
class ROSE_StatementBlock : public ROSE_Statement
   {
     public:
         ~ROSE_StatementBlock ();

       // Special constructor for ROSE_StatementBlock;
       // ROSE_StatementBlock ( SgBasicBlock* basicBlock );
          ROSE_StatementBlock ( SgScopeStatement* scopeStatement );

       // Define the abstractBaseClass function
          virtual ROSE_Node* transform();

          void recognizeSageSubTree ( SgBasicBlock* basicBlock );

          int  getNumberOfStatements ();
          void addArrayStatementToBlock ( ROSE_Statement* roseStatement );
          ROSE_Statement* operator[](int i);

     private:
       // We are using the List<T> list class here because we can't use STL 
       // (SAGE II causes multiple defines when used with STL, not clear if this is fixable)
          List<ROSE_Statement> roseStatementList;



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_StatementBlock ();
          ROSE_StatementBlock ( const ROSE_StatementBlock & X );
          ROSE_StatementBlock & operator= ( const ROSE_StatementBlock & X );
   };



// Class Definition for ROSE_C_Statement
class ROSE_C_Statement : public ROSE_Statement
   {
     public:
         ~ROSE_C_Statement ();

       // Special constructor for ROSE_C_Statement;
          ROSE_C_Statement ( SgStatement* stmt );

       // Make this class an abstract base class so that we can be certain that
       // we will not ever try to build one of these directly.
          virtual ROSE_Node* transform ();

          friend ROSE_C_Statement* isRose_C_Statement (ROSE_Node* node);

          void recognizeSageSubTree ( SgStatement* stmt );

          void setRoseExpression ( ROSE_C_Expression* expr );
          ROSE_C_Expression* getRoseExpression ();

     private:
          ROSE_C_Expression* roseExpr;


     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_C_Statement ();
          ROSE_C_Statement ( const ROSE_C_Statement & X );
          ROSE_C_Statement & operator= ( const ROSE_C_Statement & X );
   };



// Class Definition for ROSE_ArrayStatement
class ROSE_ArrayStatement : public ROSE_Statement
   {
     public:
         ~ROSE_ArrayStatement ();

       // Special constructor for ROSE_ArrayStatement;
          ROSE_ArrayStatement ( SgStatement* stmt );

       // Make this class an abstract base class so that we can be certain that
       // we will not ever try to build one of these directly.
          virtual ROSE_Node* transform () = 0;


     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_ArrayStatement ();
          ROSE_ArrayStatement ( const ROSE_ArrayStatement & X );
          ROSE_ArrayStatement & operator= ( const ROSE_ArrayStatement & X );
   };



// Class Definition for ROSE_C_VariableDeclaration
class ROSE_C_VariableDeclaration : public ROSE_VariableDeclaration
   {
     public:
         ~ROSE_C_VariableDeclaration ();

        // Special constructor for ROSE_C_VariableDeclaration;
          ROSE_C_VariableDeclaration ( SgStatement* stmt );

       // Make this class an abstract base class so that we can be certain that
       // we will not ever try to build one of these directly.
          virtual ROSE_Node* transform ();


     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_C_VariableDeclaration ();
          ROSE_C_VariableDeclaration ( const ROSE_C_VariableDeclaration & X );
          ROSE_C_VariableDeclaration & operator= ( const ROSE_C_VariableDeclaration & X );
   };



// Class Definition for ROSE_ArrayVariableDeclaration
class ROSE_ArrayVariableDeclaration : public ROSE_VariableDeclaration
   {
     public:
         ~ROSE_ArrayVariableDeclaration ();

        // Special constructor for ROSE_ArrayVariableDeclaration;
          ROSE_ArrayVariableDeclaration ( SgStatement* stmt );

       // Make this class an abstract base class so that we can be certain that
       // we will not ever try to build one of these directly.
          virtual ROSE_Node* transform ();


     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_ArrayVariableDeclaration ();
          ROSE_ArrayVariableDeclaration ( const ROSE_ArrayVariableDeclaration & X );
          ROSE_ArrayVariableDeclaration & operator= ( const ROSE_ArrayVariableDeclaration & X );
   };



// Class Definition for ROSE_IndexingVariableDeclaration
class ROSE_IndexingVariableDeclaration : public ROSE_VariableDeclaration
   {
     public:
         ~ROSE_IndexingVariableDeclaration ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_IndexingVariableDeclaration ();
          ROSE_IndexingVariableDeclaration ( const ROSE_IndexingVariableDeclaration & X );
          ROSE_IndexingVariableDeclaration & operator= ( const ROSE_IndexingVariableDeclaration & X );
   };



// Class Definition for ROSE_ExpressionStatement
class ROSE_ExpressionStatement : public ROSE_ArrayStatement
   {
     public:
         ~ROSE_ExpressionStatement ();

       // Special constructor for ROSE_ExpressionStatement;
          ROSE_ExpressionStatement ( SgStatement* stmt );

       // Define the abstractBaseClass function
          virtual ROSE_Node* transform();

          friend ROSE_ExpressionStatement* isRoseExpressionStatement (ROSE_Node* node);

          void recognizeSageSubTree ( SgStatement* stmt );

          void setRoseExpression ( ROSE_Expression* expr );
          ROSE_Expression* getRoseExpression ();

     private:
          ROSE_Expression* roseExpr;


     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_ExpressionStatement ();
          ROSE_ExpressionStatement ( const ROSE_ExpressionStatement & X );
          ROSE_ExpressionStatement & operator= ( const ROSE_ExpressionStatement & X );
   };



// Class Definition for ROSE_WhereStatement
class ROSE_WhereStatement : public ROSE_ArrayStatement
   {
     public:
         ~ROSE_WhereStatement ();

       // Special constructor for ROSE_WhereStatement;
          ROSE_WhereStatement ( SgForStatement* whereStatement );

       // Define the abstractBaseClass function
          virtual ROSE_Node* transform();

          void recognizeSageSubTree ( SgForStatement* whereStatement );

          void setRoseConditionalStatement ( ROSE_Statement*      roseStatement );
          void setRoseWhereStatementBlock  ( ROSE_StatementBlock* roseStatementBlock );
          void setRoseElseWhereStatement   ( ROSE_ElseWhereStatement* roseElseWhereStatement );

          ROSE_Statement*          getRoseConditionalStatement();
          ROSE_StatementBlock*     getRoseWhereStatementBlock ();
          ROSE_ElseWhereStatement* getRoseElseWhereStatement  ();

     private:
       // The different parts of a "where" statement
       // later we have to connect the where and elsewhere statements
          ROSE_Statement* roseConditionalStatement;
          ROSE_StatementBlock* roseWhereStatementBlock;

       // Connection to the Elsewhere statement (part of our grammar)
          ROSE_ElseWhereStatement* roseElseWhereStatement;


     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_WhereStatement ();
          ROSE_WhereStatement ( const ROSE_WhereStatement & X );
          ROSE_WhereStatement & operator= ( const ROSE_WhereStatement & X );
   };



// Class Definition for ROSE_ElseWhereStatement
class ROSE_ElseWhereStatement : public ROSE_ArrayStatement
   {
     public:
         ~ROSE_ElseWhereStatement ();

       // Special constructor for ROSE_ElseWhereStatement;
          ROSE_ElseWhereStatement ( SgForStatement* whereStatement );

       // Define the abstractBaseClass function
          virtual ROSE_Node* transform();

          void recognizeSageSubTree ( SgForStatement* whereStatement );

          void setRoseConditionalStatement     ( ROSE_Statement*      roseStatement );
          void setRoseElseWhereStatementBlock  ( ROSE_StatementBlock* roseStatementBlock );
          void setRoseNextElseWhereStatement   ( ROSE_ElseWhereStatement* roseStatement );

          ROSE_Statement*          getRoseConditionalStatement    ();
          ROSE_StatementBlock*     getRoseElseWhereStatementBlock ();
          ROSE_ElseWhereStatement* getRoseNextElseWhereStatement  ();

     private:
       // The different parts of a "where" statement
       // later we have to connect the where and elsewhere statements
          ROSE_Statement* roseConditionalStatement;
          ROSE_StatementBlock* roseElseWhereStatementBlock;

       // A pointer to yet another (the next one in a cascading 
       // series) ROSE_ElseWhereStatement statement block
          ROSE_ElseWhereStatement* roseNextElseWhereStatement;


     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_ElseWhereStatement ();
          ROSE_ElseWhereStatement ( const ROSE_ElseWhereStatement & X );
          ROSE_ElseWhereStatement & operator= ( const ROSE_ElseWhereStatement & X );
   };



// Class Definition for ROSE_DoWhileStatement
class ROSE_DoWhileStatement : public ROSE_ArrayStatement
   {
     public:
         ~ROSE_DoWhileStatement ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_DoWhileStatement ();
          ROSE_DoWhileStatement ( const ROSE_DoWhileStatement & X );
          ROSE_DoWhileStatement & operator= ( const ROSE_DoWhileStatement & X );
   };



// Class Definition for ROSE_WhileStatement
class ROSE_WhileStatement : public ROSE_ArrayStatement
   {
     public:
         ~ROSE_WhileStatement ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_WhileStatement ();
          ROSE_WhileStatement ( const ROSE_WhileStatement & X );
          ROSE_WhileStatement & operator= ( const ROSE_WhileStatement & X );
   };



// Class Definition for ROSE_ForStatement
class ROSE_ForStatement : public ROSE_ArrayStatement
   {
     public:
         ~ROSE_ForStatement ();

       // Special constructor for ROSE_ForStatement;
          ROSE_ForStatement ( SgForStatement* forStatement );

       // Define the abstractBaseClass function
          virtual ROSE_Node* transform();

          void recognizeSageSubTree ( SgForStatement* forStatement );

       // void setRoseConditionalStatement ( ROSE_Statement*      roseStatement );
          void setRoseForStatementBlock   ( ROSE_StatementBlock* roseForStatementBlock );

       // ROSE_Statement*      getRoseConditionalStatement  ();
          ROSE_StatementBlock* getRoseForStatementBlock  ();

     private:
       // The different parts of a "for" loop statement
       // for now we only include the main body
       // ROSE_Statement* roseInitializerStatementBlock;
       // ROSE_Statement* roseConditionalStatement;
       // ROSE_Statement* roseIncrementStatementBlock;
          ROSE_StatementBlock* roseForStatementBlock;


     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_ForStatement ();
          ROSE_ForStatement ( const ROSE_ForStatement & X );
          ROSE_ForStatement & operator= ( const ROSE_ForStatement & X );
   };



// Class Definition for ROSE_IfStatement
class ROSE_IfStatement : public ROSE_ArrayStatement
   {
     public:
         ~ROSE_IfStatement ();

       // Special constructor for ROSE_IfStatement;
          ROSE_IfStatement ( SgIfStmt* ifStatement );

       // Define the abstractBaseClass function
          virtual ROSE_Node* transform();

          void recognizeSageSubTree ( SgIfStmt* ifStatement );

          void setRoseConditionalStatement ( ROSE_Statement*      roseStatement );
          void setTrueRoseStatementBlock   ( ROSE_StatementBlock* roseStatementBlock );
          void setFalseRoseStatementBlock  ( ROSE_StatementBlock* roseStatementBlock );

          ROSE_Statement*      getRoseConditionalStatement  ();
          ROSE_StatementBlock* getTrueRoseStatementBlock  ();
          ROSE_StatementBlock* getFalseRoseStatementBlock ();

     private:
       // The different parts of an "if" statement
          ROSE_Statement* roseConditionalStatement;
          ROSE_StatementBlock* trueRoseStatementBlock;
          ROSE_StatementBlock* falseRoseStatementBlock;



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_IfStatement ();
          ROSE_IfStatement ( const ROSE_IfStatement & X );
          ROSE_IfStatement & operator= ( const ROSE_IfStatement & X );
   };



// Class Definition for ROSE_ReturnStatement
class ROSE_ReturnStatement : public ROSE_ArrayStatement
   {
     public:
         ~ROSE_ReturnStatement ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_ReturnStatement ();
          ROSE_ReturnStatement ( const ROSE_ReturnStatement & X );
          ROSE_ReturnStatement & operator= ( const ROSE_ReturnStatement & X );
   };



// Class Definition for ROSE_ArrayOperandBinaryArrayOperatorArrayOperand
class ROSE_ArrayOperandBinaryArrayOperatorArrayOperand : public ROSE_NumericExpression
   {
     public:
         ~ROSE_ArrayOperandBinaryArrayOperatorArrayOperand ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_ArrayOperandBinaryArrayOperatorArrayOperand ();
          ROSE_ArrayOperandBinaryArrayOperatorArrayOperand ( const ROSE_ArrayOperandBinaryArrayOperatorArrayOperand & X );
          ROSE_ArrayOperandBinaryArrayOperatorArrayOperand & operator= ( const ROSE_ArrayOperandBinaryArrayOperatorArrayOperand & X );
   };



// Class Definition for ROSE_ArrayOperandBinaryArrayOperatorArrayExpression
class ROSE_ArrayOperandBinaryArrayOperatorArrayExpression : public ROSE_NumericExpression
   {
     public:
         ~ROSE_ArrayOperandBinaryArrayOperatorArrayExpression ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_ArrayOperandBinaryArrayOperatorArrayExpression ();
          ROSE_ArrayOperandBinaryArrayOperatorArrayExpression ( const ROSE_ArrayOperandBinaryArrayOperatorArrayExpression & X );
          ROSE_ArrayOperandBinaryArrayOperatorArrayExpression & operator= ( const ROSE_ArrayOperandBinaryArrayOperatorArrayExpression & X );
   };



// Class Definition for ROSE_UnaryArrayOperatorArrayOperand
class ROSE_UnaryArrayOperatorArrayOperand : public ROSE_NumericExpression
   {
     public:
         ~ROSE_UnaryArrayOperatorArrayOperand ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_UnaryArrayOperatorArrayOperand ();
          ROSE_UnaryArrayOperatorArrayOperand ( const ROSE_UnaryArrayOperatorArrayOperand & X );
          ROSE_UnaryArrayOperatorArrayOperand & operator= ( const ROSE_UnaryArrayOperatorArrayOperand & X );
   };



// Class Definition for ROSE_UnaryArrayOperatorArrayExpression
class ROSE_UnaryArrayOperatorArrayExpression : public ROSE_NumericExpression
   {
     public:
         ~ROSE_UnaryArrayOperatorArrayExpression ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_UnaryArrayOperatorArrayExpression ();
          ROSE_UnaryArrayOperatorArrayExpression ( const ROSE_UnaryArrayOperatorArrayExpression & X );
          ROSE_UnaryArrayOperatorArrayExpression & operator= ( const ROSE_UnaryArrayOperatorArrayExpression & X );
   };



// Class Definition for ROSE_ArrayOperandBinaryArrayTestingOperatorArrayOperand
class ROSE_ArrayOperandBinaryArrayTestingOperatorArrayOperand : public ROSE_TestingExpression
   {
     public:
         ~ROSE_ArrayOperandBinaryArrayTestingOperatorArrayOperand ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_ArrayOperandBinaryArrayTestingOperatorArrayOperand ();
          ROSE_ArrayOperandBinaryArrayTestingOperatorArrayOperand ( const ROSE_ArrayOperandBinaryArrayTestingOperatorArrayOperand & X );
          ROSE_ArrayOperandBinaryArrayTestingOperatorArrayOperand & operator= ( const ROSE_ArrayOperandBinaryArrayTestingOperatorArrayOperand & X );
   };



// Class Definition for ROSE_ArrayOperandBinaryArrayTestingOperatorArrayExpression
class ROSE_ArrayOperandBinaryArrayTestingOperatorArrayExpression : public ROSE_TestingExpression
   {
     public:
         ~ROSE_ArrayOperandBinaryArrayTestingOperatorArrayExpression ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_ArrayOperandBinaryArrayTestingOperatorArrayExpression ();
          ROSE_ArrayOperandBinaryArrayTestingOperatorArrayExpression ( const ROSE_ArrayOperandBinaryArrayTestingOperatorArrayExpression & X );
          ROSE_ArrayOperandBinaryArrayTestingOperatorArrayExpression & operator= ( const ROSE_ArrayOperandBinaryArrayTestingOperatorArrayExpression & X );
   };



// Class Definition for ROSE_ArrayOperandBinaryArrayLogicalOperatorArrayOperand
class ROSE_ArrayOperandBinaryArrayLogicalOperatorArrayOperand : public ROSE_LogicalExpression
   {
     public:
         ~ROSE_ArrayOperandBinaryArrayLogicalOperatorArrayOperand ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_ArrayOperandBinaryArrayLogicalOperatorArrayOperand ();
          ROSE_ArrayOperandBinaryArrayLogicalOperatorArrayOperand ( const ROSE_ArrayOperandBinaryArrayLogicalOperatorArrayOperand & X );
          ROSE_ArrayOperandBinaryArrayLogicalOperatorArrayOperand & operator= ( const ROSE_ArrayOperandBinaryArrayLogicalOperatorArrayOperand & X );
   };



// Class Definition for ROSE_ArrayOperandBinaryArrayLogicalOperatorArrayExpression
class ROSE_ArrayOperandBinaryArrayLogicalOperatorArrayExpression : public ROSE_LogicalExpression
   {
     public:
         ~ROSE_ArrayOperandBinaryArrayLogicalOperatorArrayExpression ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_ArrayOperandBinaryArrayLogicalOperatorArrayExpression ();
          ROSE_ArrayOperandBinaryArrayLogicalOperatorArrayExpression ( const ROSE_ArrayOperandBinaryArrayLogicalOperatorArrayExpression & X );
          ROSE_ArrayOperandBinaryArrayLogicalOperatorArrayExpression & operator= ( const ROSE_ArrayOperandBinaryArrayLogicalOperatorArrayExpression & X );
   };



// Class Definition for ROSE_ArrayVariableExpression
class ROSE_ArrayVariableExpression : public ROSE_ArrayOperandExpression
   {
     public:
         ~ROSE_ArrayVariableExpression ();

       // Special constructor for this class
          ROSE_ArrayVariableExpression ( SgExpression* expr );

          virtual ROSE_Node* transform() = 0;

       // get the names of the different parts
          virtual SgName getOperandName ();
          virtual SgName getOperandPointerName();

          virtual int getNumberOfDimensions();


     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_ArrayVariableExpression ();
          ROSE_ArrayVariableExpression ( const ROSE_ArrayVariableExpression & X );
          ROSE_ArrayVariableExpression & operator= ( const ROSE_ArrayVariableExpression & X );
   };



// Class Definition for ROSE_ArrayVariableReferenceExpression
class ROSE_ArrayVariableReferenceExpression : public ROSE_ArrayOperandExpression
   {
     public:
         ~ROSE_ArrayVariableReferenceExpression ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_ArrayVariableReferenceExpression ();
          ROSE_ArrayVariableReferenceExpression ( const ROSE_ArrayVariableReferenceExpression & X );
          ROSE_ArrayVariableReferenceExpression & operator= ( const ROSE_ArrayVariableReferenceExpression & X );
   };



// Class Definition for ROSE_ArrayVariablePointerExpression
class ROSE_ArrayVariablePointerExpression : public ROSE_ArrayOperandExpression
   {
     public:
         ~ROSE_ArrayVariablePointerExpression ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_ArrayVariablePointerExpression ();
          ROSE_ArrayVariablePointerExpression ( const ROSE_ArrayVariablePointerExpression & X );
          ROSE_ArrayVariablePointerExpression & operator= ( const ROSE_ArrayVariablePointerExpression & X );
   };



// Class Definition for ROSE_ArrayVariableDereferencedPointerExpression
class ROSE_ArrayVariableDereferencedPointerExpression : public ROSE_ArrayOperandExpression
   {
     public:
         ~ROSE_ArrayVariableDereferencedPointerExpression ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_ArrayVariableDereferencedPointerExpression ();
          ROSE_ArrayVariableDereferencedPointerExpression ( const ROSE_ArrayVariableDereferencedPointerExpression & X );
          ROSE_ArrayVariableDereferencedPointerExpression & operator= ( const ROSE_ArrayVariableDereferencedPointerExpression & X );
   };



// Class Definition for ROSE_ArrayParenthesisOperator
class ROSE_ArrayParenthesisOperator : public ROSE_ArrayOperandExpression
   {
     public:
         ~ROSE_ArrayParenthesisOperator ();

       // Special constructor for ROSE_ArrayParenthesisOperator;
          ROSE_ArrayParenthesisOperator ( SgExpression* expr );

       // Define this function on the leaves of the tree representing our grammar
          virtual ROSE_Node* transform ();

          SgName getOperandName ();
          SgName getOperandPointerName ();

       // SgExpression* getIndexExpression ();

          variant_type_enum getOperatorInIndexExpression ( SgExpression* indexExpression );
          SgExpression*     getScalar_C_Expression ( SgExpression* indexExpression );
          virtual int       getNumberOfDimensions ();
          SgExpression*     getIndexExpression ( int n );

          SgExpression*     filterAwayCopyConstructor ( SgExpression* inputExpression );

       // Stuff about the indexing of array operands
          virtual Boolean isAnIndexedOperand();





     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_ArrayParenthesisOperator ();
          ROSE_ArrayParenthesisOperator ( const ROSE_ArrayParenthesisOperator & X );
          ROSE_ArrayParenthesisOperator & operator= ( const ROSE_ArrayParenthesisOperator & X );
   };



// Class Definition for ROSE_RealArrayVariableExpression
class ROSE_RealArrayVariableExpression : public ROSE_ArrayVariableExpression
   {
     public:
         ~ROSE_RealArrayVariableExpression ();

       // Special constructor for this class
          ROSE_RealArrayVariableExpression ( SgExpression* expr );


     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_RealArrayVariableExpression ();
          ROSE_RealArrayVariableExpression ( const ROSE_RealArrayVariableExpression & X );
          ROSE_RealArrayVariableExpression & operator= ( const ROSE_RealArrayVariableExpression & X );
   };



// Class Definition for ROSE_intArrayVariableExpression
class ROSE_intArrayVariableExpression : public ROSE_ArrayVariableExpression
   {
     public:
         ~ROSE_intArrayVariableExpression ();

       // Special constructor for this class
          ROSE_intArrayVariableExpression ( SgExpression* expr );

          virtual ROSE_Node* transform();


     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_intArrayVariableExpression ();
          ROSE_intArrayVariableExpression ( const ROSE_intArrayVariableExpression & X );
          ROSE_intArrayVariableExpression & operator= ( const ROSE_intArrayVariableExpression & X );
   };



// Class Definition for ROSE_doubleArrayVariableExpression
class ROSE_doubleArrayVariableExpression : public ROSE_RealArrayVariableExpression
   {
     public:
         ~ROSE_doubleArrayVariableExpression ();

       // Special constructor for this class
          ROSE_doubleArrayVariableExpression ( SgExpression* expr );

          virtual ROSE_Node* transform();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_doubleArrayVariableExpression ();
          ROSE_doubleArrayVariableExpression ( const ROSE_doubleArrayVariableExpression & X );
          ROSE_doubleArrayVariableExpression & operator= ( const ROSE_doubleArrayVariableExpression & X );
   };



// Class Definition for ROSE_floatArrayVariableExpression
class ROSE_floatArrayVariableExpression : public ROSE_RealArrayVariableExpression
   {
     public:
         ~ROSE_floatArrayVariableExpression ();

       // Special constructor for this class
          ROSE_floatArrayVariableExpression ( SgExpression* expr );

          virtual ROSE_Node* transform();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_floatArrayVariableExpression ();
          ROSE_floatArrayVariableExpression ( const ROSE_floatArrayVariableExpression & X );
          ROSE_floatArrayVariableExpression & operator= ( const ROSE_floatArrayVariableExpression & X );
   };



// Class Definition for ROSE_RealArrayVariableReferenceExpression
class ROSE_RealArrayVariableReferenceExpression : public ROSE_ArrayVariableReferenceExpression
   {
     public:
         ~ROSE_RealArrayVariableReferenceExpression ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_RealArrayVariableReferenceExpression ();
          ROSE_RealArrayVariableReferenceExpression ( const ROSE_RealArrayVariableReferenceExpression & X );
          ROSE_RealArrayVariableReferenceExpression & operator= ( const ROSE_RealArrayVariableReferenceExpression & X );
   };



// Class Definition for ROSE_intArrayVariableReferenceExpression
class ROSE_intArrayVariableReferenceExpression : public ROSE_ArrayVariableReferenceExpression
   {
     public:
         ~ROSE_intArrayVariableReferenceExpression ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_intArrayVariableReferenceExpression ();
          ROSE_intArrayVariableReferenceExpression ( const ROSE_intArrayVariableReferenceExpression & X );
          ROSE_intArrayVariableReferenceExpression & operator= ( const ROSE_intArrayVariableReferenceExpression & X );
   };



// Class Definition for ROSE_doubleArrayVariableReferenceExpression
class ROSE_doubleArrayVariableReferenceExpression : public ROSE_RealArrayVariableReferenceExpression
   {
     public:
         ~ROSE_doubleArrayVariableReferenceExpression ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_doubleArrayVariableReferenceExpression ();
          ROSE_doubleArrayVariableReferenceExpression ( const ROSE_doubleArrayVariableReferenceExpression & X );
          ROSE_doubleArrayVariableReferenceExpression & operator= ( const ROSE_doubleArrayVariableReferenceExpression & X );
   };



// Class Definition for ROSE_floatArrayVariableReferenceExpression
class ROSE_floatArrayVariableReferenceExpression : public ROSE_RealArrayVariableReferenceExpression
   {
     public:
         ~ROSE_floatArrayVariableReferenceExpression ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_floatArrayVariableReferenceExpression ();
          ROSE_floatArrayVariableReferenceExpression ( const ROSE_floatArrayVariableReferenceExpression & X );
          ROSE_floatArrayVariableReferenceExpression & operator= ( const ROSE_floatArrayVariableReferenceExpression & X );
   };



// Class Definition for ROSE_RealArrayVariablePointerExpression
class ROSE_RealArrayVariablePointerExpression : public ROSE_ArrayVariablePointerExpression
   {
     public:
         ~ROSE_RealArrayVariablePointerExpression ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_RealArrayVariablePointerExpression ();
          ROSE_RealArrayVariablePointerExpression ( const ROSE_RealArrayVariablePointerExpression & X );
          ROSE_RealArrayVariablePointerExpression & operator= ( const ROSE_RealArrayVariablePointerExpression & X );
   };



// Class Definition for ROSE_intArrayVariablePointerExpression
class ROSE_intArrayVariablePointerExpression : public ROSE_ArrayVariablePointerExpression
   {
     public:
         ~ROSE_intArrayVariablePointerExpression ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_intArrayVariablePointerExpression ();
          ROSE_intArrayVariablePointerExpression ( const ROSE_intArrayVariablePointerExpression & X );
          ROSE_intArrayVariablePointerExpression & operator= ( const ROSE_intArrayVariablePointerExpression & X );
   };



// Class Definition for ROSE_doubleArrayVariablePointerExpression
class ROSE_doubleArrayVariablePointerExpression : public ROSE_RealArrayVariablePointerExpression
   {
     public:
         ~ROSE_doubleArrayVariablePointerExpression ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_doubleArrayVariablePointerExpression ();
          ROSE_doubleArrayVariablePointerExpression ( const ROSE_doubleArrayVariablePointerExpression & X );
          ROSE_doubleArrayVariablePointerExpression & operator= ( const ROSE_doubleArrayVariablePointerExpression & X );
   };



// Class Definition for ROSE_floatArrayVariablePointerExpression
class ROSE_floatArrayVariablePointerExpression : public ROSE_RealArrayVariablePointerExpression
   {
     public:
         ~ROSE_floatArrayVariablePointerExpression ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_floatArrayVariablePointerExpression ();
          ROSE_floatArrayVariablePointerExpression ( const ROSE_floatArrayVariablePointerExpression & X );
          ROSE_floatArrayVariablePointerExpression & operator= ( const ROSE_floatArrayVariablePointerExpression & X );
   };



// Class Definition for ROSE_ArrayCOS
class ROSE_ArrayCOS : public ROSE_ArrayFunctionExpression
   {
     public:
         ~ROSE_ArrayCOS ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_ArrayCOS ();
          ROSE_ArrayCOS ( const ROSE_ArrayCOS & X );
          ROSE_ArrayCOS & operator= ( const ROSE_ArrayCOS & X );
   };



// Class Definition for ROSE_ArraySIN
class ROSE_ArraySIN : public ROSE_ArrayFunctionExpression
   {
     public:
         ~ROSE_ArraySIN ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_ArraySIN ();
          ROSE_ArraySIN ( const ROSE_ArraySIN & X );
          ROSE_ArraySIN & operator= ( const ROSE_ArraySIN & X );
   };



// Class Definition for ROSE_ArrayTAN
class ROSE_ArrayTAN : public ROSE_ArrayFunctionExpression
   {
     public:
         ~ROSE_ArrayTAN ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_ArrayTAN ();
          ROSE_ArrayTAN ( const ROSE_ArrayTAN & X );
          ROSE_ArrayTAN & operator= ( const ROSE_ArrayTAN & X );
   };



// Class Definition for ROSE_ArrayMIN
class ROSE_ArrayMIN : public ROSE_ArrayFunctionExpression
   {
     public:
         ~ROSE_ArrayMIN ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_ArrayMIN ();
          ROSE_ArrayMIN ( const ROSE_ArrayMIN & X );
          ROSE_ArrayMIN & operator= ( const ROSE_ArrayMIN & X );
   };



// Class Definition for ROSE_ArrayMAX
class ROSE_ArrayMAX : public ROSE_ArrayFunctionExpression
   {
     public:
         ~ROSE_ArrayMAX ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_ArrayMAX ();
          ROSE_ArrayMAX ( const ROSE_ArrayMAX & X );
          ROSE_ArrayMAX & operator= ( const ROSE_ArrayMAX & X );
   };



// Class Definition for ROSE_ArrayFMOD
class ROSE_ArrayFMOD : public ROSE_ArrayFunctionExpression
   {
     public:
         ~ROSE_ArrayFMOD ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_ArrayFMOD ();
          ROSE_ArrayFMOD ( const ROSE_ArrayFMOD & X );
          ROSE_ArrayFMOD & operator= ( const ROSE_ArrayFMOD & X );
   };



// Class Definition for ROSE_ArrayMOD
class ROSE_ArrayMOD : public ROSE_ArrayFunctionExpression
   {
     public:
         ~ROSE_ArrayMOD ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_ArrayMOD ();
          ROSE_ArrayMOD ( const ROSE_ArrayMOD & X );
          ROSE_ArrayMOD & operator= ( const ROSE_ArrayMOD & X );
   };



// Class Definition for ROSE_ArrayPOW
class ROSE_ArrayPOW : public ROSE_ArrayFunctionExpression
   {
     public:
         ~ROSE_ArrayPOW ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_ArrayPOW ();
          ROSE_ArrayPOW ( const ROSE_ArrayPOW & X );
          ROSE_ArrayPOW & operator= ( const ROSE_ArrayPOW & X );
   };



// Class Definition for ROSE_ArraySIGN
class ROSE_ArraySIGN : public ROSE_ArrayFunctionExpression
   {
     public:
         ~ROSE_ArraySIGN ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_ArraySIGN ();
          ROSE_ArraySIGN ( const ROSE_ArraySIGN & X );
          ROSE_ArraySIGN & operator= ( const ROSE_ArraySIGN & X );
   };



// Class Definition for ROSE_ArrayLOG
class ROSE_ArrayLOG : public ROSE_ArrayFunctionExpression
   {
     public:
         ~ROSE_ArrayLOG ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_ArrayLOG ();
          ROSE_ArrayLOG ( const ROSE_ArrayLOG & X );
          ROSE_ArrayLOG & operator= ( const ROSE_ArrayLOG & X );
   };



// Class Definition for ROSE_ArrayLOG10
class ROSE_ArrayLOG10 : public ROSE_ArrayFunctionExpression
   {
     public:
         ~ROSE_ArrayLOG10 ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_ArrayLOG10 ();
          ROSE_ArrayLOG10 ( const ROSE_ArrayLOG10 & X );
          ROSE_ArrayLOG10 & operator= ( const ROSE_ArrayLOG10 & X );
   };



// Class Definition for ROSE_ArrayEXP
class ROSE_ArrayEXP : public ROSE_ArrayFunctionExpression
   {
     public:
         ~ROSE_ArrayEXP ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_ArrayEXP ();
          ROSE_ArrayEXP ( const ROSE_ArrayEXP & X );
          ROSE_ArrayEXP & operator= ( const ROSE_ArrayEXP & X );
   };



// Class Definition for ROSE_ArraySQRT
class ROSE_ArraySQRT : public ROSE_ArrayFunctionExpression
   {
     public:
         ~ROSE_ArraySQRT ();

       // Special constructor for this class
          ROSE_ArraySQRT ( SgExpression* expr );

       // This class is a leaf of our grammar, so we want to define this function here
          virtual ROSE_Node* transform();


     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_ArraySQRT ();
          ROSE_ArraySQRT ( const ROSE_ArraySQRT & X );
          ROSE_ArraySQRT & operator= ( const ROSE_ArraySQRT & X );
   };



// Class Definition for ROSE_ArrayFABS
class ROSE_ArrayFABS : public ROSE_ArrayFunctionExpression
   {
     public:
         ~ROSE_ArrayFABS ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_ArrayFABS ();
          ROSE_ArrayFABS ( const ROSE_ArrayFABS & X );
          ROSE_ArrayFABS & operator= ( const ROSE_ArrayFABS & X );
   };



// Class Definition for ROSE_ArrayCEIL
class ROSE_ArrayCEIL : public ROSE_ArrayFunctionExpression
   {
     public:
         ~ROSE_ArrayCEIL ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_ArrayCEIL ();
          ROSE_ArrayCEIL ( const ROSE_ArrayCEIL & X );
          ROSE_ArrayCEIL & operator= ( const ROSE_ArrayCEIL & X );
   };



// Class Definition for ROSE_ArrayFLOOR
class ROSE_ArrayFLOOR : public ROSE_ArrayFunctionExpression
   {
     public:
         ~ROSE_ArrayFLOOR ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_ArrayFLOOR ();
          ROSE_ArrayFLOOR ( const ROSE_ArrayFLOOR & X );
          ROSE_ArrayFLOOR & operator= ( const ROSE_ArrayFLOOR & X );
   };



// Class Definition for ROSE_ArrayABS
class ROSE_ArrayABS : public ROSE_ArrayFunctionExpression
   {
     public:
         ~ROSE_ArrayABS ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_ArrayABS ();
          ROSE_ArrayABS ( const ROSE_ArrayABS & X );
          ROSE_ArrayABS & operator= ( const ROSE_ArrayABS & X );
   };



// Class Definition for ROSE_ArrayTRANSPOSE
class ROSE_ArrayTRANSPOSE : public ROSE_ArrayFunctionExpression
   {
     public:
         ~ROSE_ArrayTRANSPOSE ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_ArrayTRANSPOSE ();
          ROSE_ArrayTRANSPOSE ( const ROSE_ArrayTRANSPOSE & X );
          ROSE_ArrayTRANSPOSE & operator= ( const ROSE_ArrayTRANSPOSE & X );
   };



// Class Definition for ROSE_ArrayACOS
class ROSE_ArrayACOS : public ROSE_ArrayFunctionExpression
   {
     public:
         ~ROSE_ArrayACOS ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_ArrayACOS ();
          ROSE_ArrayACOS ( const ROSE_ArrayACOS & X );
          ROSE_ArrayACOS & operator= ( const ROSE_ArrayACOS & X );
   };



// Class Definition for ROSE_ArrayASIN
class ROSE_ArrayASIN : public ROSE_ArrayFunctionExpression
   {
     public:
         ~ROSE_ArrayASIN ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_ArrayASIN ();
          ROSE_ArrayASIN ( const ROSE_ArrayASIN & X );
          ROSE_ArrayASIN & operator= ( const ROSE_ArrayASIN & X );
   };



// Class Definition for ROSE_ArrayATAN
class ROSE_ArrayATAN : public ROSE_ArrayFunctionExpression
   {
     public:
         ~ROSE_ArrayATAN ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_ArrayATAN ();
          ROSE_ArrayATAN ( const ROSE_ArrayATAN & X );
          ROSE_ArrayATAN & operator= ( const ROSE_ArrayATAN & X );
   };



// Class Definition for ROSE_ArrayCOSH
class ROSE_ArrayCOSH : public ROSE_ArrayFunctionExpression
   {
     public:
         ~ROSE_ArrayCOSH ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_ArrayCOSH ();
          ROSE_ArrayCOSH ( const ROSE_ArrayCOSH & X );
          ROSE_ArrayCOSH & operator= ( const ROSE_ArrayCOSH & X );
   };



// Class Definition for ROSE_ArraySINH
class ROSE_ArraySINH : public ROSE_ArrayFunctionExpression
   {
     public:
         ~ROSE_ArraySINH ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_ArraySINH ();
          ROSE_ArraySINH ( const ROSE_ArraySINH & X );
          ROSE_ArraySINH & operator= ( const ROSE_ArraySINH & X );
   };



// Class Definition for ROSE_ArrayTANH
class ROSE_ArrayTANH : public ROSE_ArrayFunctionExpression
   {
     public:
         ~ROSE_ArrayTANH ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_ArrayTANH ();
          ROSE_ArrayTANH ( const ROSE_ArrayTANH & X );
          ROSE_ArrayTANH & operator= ( const ROSE_ArrayTANH & X );
   };



// Class Definition for ROSE_ArrayACOSH
class ROSE_ArrayACOSH : public ROSE_ArrayFunctionExpression
   {
     public:
         ~ROSE_ArrayACOSH ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_ArrayACOSH ();
          ROSE_ArrayACOSH ( const ROSE_ArrayACOSH & X );
          ROSE_ArrayACOSH & operator= ( const ROSE_ArrayACOSH & X );
   };



// Class Definition for ROSE_ArrayASINH
class ROSE_ArrayASINH : public ROSE_ArrayFunctionExpression
   {
     public:
         ~ROSE_ArrayASINH ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_ArrayASINH ();
          ROSE_ArrayASINH ( const ROSE_ArrayASINH & X );
          ROSE_ArrayASINH & operator= ( const ROSE_ArrayASINH & X );
   };



// Class Definition for ROSE_ArrayATANH
class ROSE_ArrayATANH : public ROSE_ArrayFunctionExpression
   {
     public:
         ~ROSE_ArrayATANH ();



     public:
       // We want to make this a pure virtual function in the base 
       // classes and a virtual function in the leaf classes
       // virtual ROSE_Node* transform() = 0;

       // Member function defined similarly across all array grammar objects
       // this MUST be a virtual function
          virtual Boolean error();

  // We don't want to have these be used within the interface
     private:
          ROSE_ArrayATANH ();
          ROSE_ArrayATANH ( const ROSE_ArrayATANH & X );
          ROSE_ArrayATANH & operator= ( const ROSE_ArrayATANH & X );
   };



#endif // ifndef ARRAY_GRAMMAR_H 

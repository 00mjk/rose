CLASSNAME::~CLASSNAME ()
   {
   }

#if 0
CLASSNAME::CLASSNAME ( SgBasicBlock* basicBlock )
   : BASECLASSNAME(basicBlock)
   {
  // This function is a virtual member function 
     recognizeSageSubTree (basicBlock);
   }
#endif

CLASSNAME::CLASSNAME ( SgScopeStatement* scopeStatement )
   : BASECLASSNAME(scopeStatement)
   {
  // This function is a virtual member function 
  // recognizeSageSubTree (scopeStatement);

     ROSE_Node::setUp (CLASSNAME_TAG,scopeStatement);
   }

#if 0
// Define the abstractBaseClass function
void CLASSNAME::forceToBeAbstractBaseClass ()
   {
   }
#endif

ROSE_Node* CLASSNAME::transform()
   {
  // printf ("Sorry not implemented, CLASSNAME::Tranform() \n");
  // ROSE_ABORT();

     ROSE_ASSERT (!error());

     SgStatement* stmt = (SgStatement*) getSageSubTree();

     if ( (ROSE_DEBUG > 0) || (ROSE::verbose == TRUE) )
          printf ("In CLASSNAME::transform(): (file name = %s line number = %d)  roseStatementList.getLength() = %d \n",
               ROSE::getFileName(stmt),ROSE::getLineNumber(stmt),roseStatementList.getLength());

     for (int i=0; i < roseStatementList.getLength(); i++)
        {
          roseStatementList[i].transform();
        }

  // Return the "this" pointer for now
     return this;
   }

void CLASSNAME::recognizeSageSubTree ( SgBasicBlock* basicBlock )
   {
  // printf ("Sorry, not implemented: CLASSNAME::recognizeSageSubTree(SgBasicBlock*) \n");
     ROSE_Node::setUp (CLASSNAME_TAG,basicBlock);
   }

int CLASSNAME::getNumberOfStatements ()
   {
     return roseStatementList.getLength();
   }

void CLASSNAME::addArrayStatementToBlock ( ROSE_Statement* roseStatement )
   {
  // printf ("Sorry, not implemented: CLASSNAME::addArrayStatementToBlock(ROSE_Statement*) \n");
     roseStatementList.addElement (*roseStatement);
   }

ROSE_Statement* CLASSNAME::operator[](int i)
   {
     return &roseStatementList[i];
   }



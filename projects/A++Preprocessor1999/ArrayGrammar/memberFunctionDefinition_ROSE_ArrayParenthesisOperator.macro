CLASSNAME::~CLASSNAME ()
   {
   }

#if 0
CLASSNAME::CLASSNAME ()
   {
     ROSE_Node::setUp (CLASSNAME_TAG,NULL);
   }
#endif

CLASSNAME::CLASSNAME ( SgExpression* expr )
   : BASECLASSNAME(expr)
   {
     ROSE_Node::setUp (CLASSNAME_TAG,expr);
   }

#if 0
ROSE_Node* CLASSNAME::transform()
   {
     printf ("Sorry not implemented, CLASSNAME::Tranform() \n");
     ROSE_ABORT();

     return this;
   }
#endif


SgExpression* CLASSNAME::filterAwayCopyConstructor ( SgExpression* inputExpression )
   {
  // Need to talk to bobby about using his version of this function!

  // We have to filter out the constructor initializer because the it obscures the
  // call to the Internal_Index::operator+() and Internal_Index::operator-()

     SgExpression* outputExpression = NULL;
     ROSE_ASSERT (inputExpression != NULL);
     SgConstructorInitializer* constructorInitializer = isSgConstructorInitializer(inputExpression);
  // ROSE_ASSERT (constructorInitializer != NULL);

     if (constructorInitializer != NULL)
        {
          SgExprListExp* exprListExp = constructorInitializer->get_args();
          ROSE_ASSERT (exprListExp != NULL);

          SgExpressionPtrList & expressionPtrList = exprListExp->get_expressions();
          ROSE_ASSERT (expressionPtrList.size() == 1);

          SgExpressionPtrList::iterator i = expressionPtrList.begin();
          ROSE_ASSERT ( i != expressionPtrList.end() );

#if USE_SAGE3
          SgExpression* expressionPtr = *i;
          outputExpression = expressionPtr;
#else
          SgExpressionPtr expressionPtr = *i;
          outputExpression = expressionPtr.operator->();
#endif
        }
       else
        {
       // The filtering process was not required
          outputExpression = inputExpression;
        }

     ROSE_ASSERT (outputExpression != NULL);
     return outputExpression;
   }

SgExpression* CLASSNAME::getScalar_C_Expression ( SgExpression* indexExpression )
   {
     SgExpression* C_Expression = NULL;
     SgExpression* indexExpressionFunction = filterAwayCopyConstructor(indexExpression);

  // Now we have the Internal_Index::operator+() or Internal_Index::operator-()
     SgFunctionCallExp* functionCallExp = isSgFunctionCallExp(indexExpressionFunction);
     ROSE_ASSERT (functionCallExp != NULL);

  // NOW GET THE ARGUMENT LIST AND FIND THE C EXPRESSION!!!
     SgExprListExp* argsExprListExp = functionCallExp->get_args();
     ROSE_ASSERT (argsExprListExp != NULL);

     SgExpressionPtrList & expressionPtrList = argsExprListExp->get_expressions();
     ROSE_ASSERT (expressionPtrList.size() == 2);

  // Now get the two operands in the Internal_Index::operator+ (or operator-)
     SgExpressionPtrList::iterator j = expressionPtrList.begin();
#if USE_SAGE3
     SgExpression* firstExpression  = (*j);
     SgExpression* secondExpression = (*(++j));
#else
     SgExpression* firstExpression  = (*j).operator->();
     SgExpression* secondExpression = (*(++j)).operator->();
#endif

  // showSgExpression (cout, firstExpression, "firstExpression: Called from CLASSNAME::getScalar_C_Expression()" );
  // showSgExpression (cout, secondExpression, "secondExpression: Called from CLASSNAME::getScalar_C_Expression()" );

     SgVarRefExp* firstExpr_varRefExp = isSgVarRefExp(firstExpression);

     SgType* firstExpressionType  = ArrayClassSageInterface::getType(firstExpression);
     SgType* secondExpressionType = ArrayClassSageInterface::getType(secondExpression);

     Boolean firstExpressionIsSectionType  = ArrayClassSageInterface::isArraySectionType (firstExpressionType);
     Boolean secondExpressionIsSectionType = ArrayClassSageInterface::isArraySectionType (secondExpressionType);

  // printf ("firstExpressionIsSectionType  = %s \n",firstExpressionIsSectionType  ? "TRUE" : "FALSE");
  // printf ("secondExpressionIsSectionType = %s \n",secondExpressionIsSectionType ? "TRUE" : "FALSE");

  // Actually we need to figure out if it is the first or second parameter (we do that next!)
     if (firstExpressionIsSectionType == TRUE)
        {
          ROSE_ASSERT (secondExpressionIsSectionType == FALSE);
       // printf ("Selecting the SECOND operand! \n");
          C_Expression = secondExpression;
        }
       else
        {
          ROSE_ASSERT (firstExpressionIsSectionType  == FALSE);
          ROSE_ASSERT (secondExpressionIsSectionType == TRUE);
       // printf ("Selecting the FIRST operand! \n");
          C_Expression = firstExpression;
        }

     return C_Expression;
   }

#if USE_SAGE3
Cxx_GrammarVariants CLASSNAME::getOperatorInIndexExpression ( SgExpression* indexExpression )
#else
variant_type_enum CLASSNAME::getOperatorInIndexExpression ( SgExpression* indexExpression )
#endif
   {
  // This function should be replaced by the work that bobby has done, but we have to use this
  // over the weekend until I can talk to Bobby!

#if USE_SAGE3
     Cxx_GrammarVariants indexOperator = LAST_TAG;
#else
     variant_type_enum indexOperator = LAST_TAG;
#endif

#if 0
  // We have to filter out the constructor initializer because the it obscures the 
  // call to the Internal_Index::operator+() and Internal_Index::operator-()
     SgConstructorInitializer* constructorInitializer = isSgConstructorInitializer(indexExpression);
     ROSE_ASSERT (constructorInitializer != NULL);

     SgExprListExp* exprListExp = constructorInitializer->get_args();
     ROSE_ASSERT (exprListExp != NULL);

     SgExpressionPtrList & expressionPtrList = exprListExp->get_expressions();
     ROSE_ASSERT (expressionPtrList.size() == 1);

  // printf ("expressionPtrList.size() = %d \n",expressionPtrList.size());

     SgExpressionPtrList::iterator i = expressionPtrList.begin();
     ROSE_ASSERT ( i != expressionPtrList.end() );

     SgExpressionPtr expressionPtr = *i;
#if USE_SAGE3
     SgExpression* indexExpressionFunction = expressionPtr;
#else
     SgExpression* indexExpressionFunction = expressionPtr.operator->();
#endif

#else
     SgExpression* indexExpressionFunction = filterAwayCopyConstructor(indexExpression);
#endif

  // Now we have the Internal_Index::operator+() or Internal_Index::operator-()
     SgFunctionCallExp* functionCallExp = isSgFunctionCallExp(indexExpressionFunction);
  // ROSE_ASSERT (functionCallExp != NULL);

     if (functionCallExp != NULL)
       {
      // Then this is an function call like: I+1, I-1, etc.
         SgExpression *functionExpr = functionCallExp->get_function();
         ROSE_ASSERT (functionExpr != NULL);

         SgFunctionRefExp* functionRefExpr = isSgFunctionRefExp(functionExpr);
         ROSE_ASSERT (functionRefExpr != NULL);

         SgFunctionSymbol *functionSymbol = functionRefExpr->get_symbol();
         ROSE_ASSERT (functionSymbol != NULL);

         SgFunctionDeclaration* functionDeclaration = functionSymbol->get_declaration();
         ROSE_ASSERT (functionDeclaration != NULL);

         SgName sageName = functionDeclaration->get_name();
         const char* nameString = sageName.str();

         if ( ROSE::isSameName(nameString,"operator+") == TRUE )
            {
              if ( (ROSE_DEBUG > 0) || (ROSE::verbose == TRUE) )
                  printf ("Found the Internal_Index::operator+() \n");

              indexOperator = ADD_OP;
            }
           else
            {
              if ( ROSE::isSameName(nameString,"operator-") == TRUE )
                 {
                   if ( (ROSE_DEBUG > 0) || (ROSE::verbose == TRUE) )
                        printf ("Found the Internal_Index::operator-() \n");

                   indexOperator = SUBT_OP;
                 }
            }
       }
      else
       {
      // This is just a simple reference to an Index or Range object
         indexOperator = VAR_REF;
       }

     return indexOperator;
   }

Boolean CLASSNAME::isAnIndexedOperand()
   {
  // if we are calling this function from the parenthesis operator then of course it is used!
     return TRUE;
   }

int CLASSNAME::getNumberOfDimensions ()
   {
  // The input paramter indecated the dimension of the index parameter
     SgExpression* returnExpression = NULL;
     SgConstructorInitializer* constructorInitializer = isSgConstructorInitializer(getExpression());
     ROSE_ASSERT (constructorInitializer != NULL);

     SgExprListExp* exprListExp = constructorInitializer->get_args();
     ROSE_ASSERT (exprListExp != NULL);

     SgExpressionPtrList & constructorExpressionPtrList = exprListExp->get_expressions();
     ROSE_ASSERT (constructorExpressionPtrList.size() == 1);

  // printf ("constructorExpressionPtrList.size() = %d \n",constructorExpressionPtrList.size());

     SgExpressionPtrList::iterator i = constructorExpressionPtrList.begin();
     ROSE_ASSERT (i != constructorExpressionPtrList.end());

     SgExpressionPtr expressionPtr = *i;

#if USE_SAGE3
     SgFunctionCallExp* functionCallExpr = isSgFunctionCallExp(expressionPtr);
#else
     SgFunctionCallExp* functionCallExpr = isSgFunctionCallExp(expressionPtr.operator->());
#endif
     ROSE_ASSERT (functionCallExpr != NULL);

  // Here is how to get the Index objects that were used (NO, THESE ARE THE CONSTRUCTOR OPERANDS!!)
     SgExprListExp* argsExprListExp = functionCallExpr->get_args();
     ROSE_ASSERT (argsExprListExp != NULL);

  // showSgExpression (cout, functionCallExpr->get_args(), "Called from CLASSNAME::getNumberOfDimensions()" );

     SgExpressionPtrList & expressionPtrList = argsExprListExp->get_expressions();
  // ROSE_ASSERT (expressionPtrList.size() == 1);

  // printf ("Exiting in CLASSNAME::getNumberOfDimensions () \n");
  // ROSE_ABORT();

     int numberOfDimensions = expressionPtrList.size();

     if ( (ROSE_DEBUG > 0) || (ROSE::verbose == TRUE) )
          printf ("In CLASSNAME::getNumberOfDimensions(): numberOfDimensions = %d \n",numberOfDimensions);

  // printf ("Exiting in CLASSNAME::getNumberOfDimensions () \n");
  // ROSE_ABORT();

     return numberOfDimensions;
   }

SgExpression* CLASSNAME::getIndexExpression ( int n )
   {
  // The input paramter indecated the dimension of the index parameter
     SgExpression* returnExpression = NULL;
     SgConstructorInitializer* constructorInitializer = isSgConstructorInitializer(getExpression());
     ROSE_ASSERT (constructorInitializer != NULL);

     SgExprListExp* exprListExp = constructorInitializer->get_args();
     ROSE_ASSERT (exprListExp != NULL);

     SgExpressionPtrList & constructorExpressionPtrList = exprListExp->get_expressions();
     ROSE_ASSERT (constructorExpressionPtrList.size() == 1);

  // printf ("constructorExpressionPtrList.size() = %d \n",constructorExpressionPtrList.size());

     SgExpressionPtrList::iterator i = constructorExpressionPtrList.begin();
     ROSE_ASSERT (i != constructorExpressionPtrList.end());

     SgExpressionPtr expressionPtr = *i;

#if USE_SAGE3
     SgFunctionCallExp* functionCallExpr = isSgFunctionCallExp(expressionPtr);
#else
     SgFunctionCallExp* functionCallExpr = isSgFunctionCallExp(expressionPtr.operator->());
#endif
     ROSE_ASSERT (functionCallExpr != NULL);

  // Here is how to get the Index objects that were used (NO, THESE ARE THE CONSTRUCTOR OPERANDS!!)
     SgExprListExp* argsExprListExp = functionCallExpr->get_args();
     ROSE_ASSERT (argsExprListExp != NULL);

  // SgDotExp* dotExp = isSgDotExp(functionExpr);
  // ROSE_ASSERT (dotExp != NULL);

  // showSgExpression (cout, functionCallExpr->get_args(), "Called from CLASSNAME::getIndexExpression()" );

     SgExpressionPtrList & expressionPtrList = argsExprListExp->get_expressions();
  // ROSE_ASSERT (expressionPtrList.size() == 1);

     if ( (ROSE_DEBUG > 0) || (ROSE::verbose == TRUE) )
          printf ("In CLASSNAME::getIndexExpression(int): expressionPtrList.size() = %d \n",expressionPtrList.size());

     SgExpressionPtrList::iterator j = expressionPtrList.begin();
     int counter = 0;
     while (j != expressionPtrList.end() && (counter <= n)) 
        {
          if ( (ROSE_DEBUG > 0) || (ROSE::verbose == TRUE) )
               cout << "Expression List Element #" << counter << endl;

          SgExpressionPtr expressionPtr = *j;
#if USE_SAGE3
          returnExpression = expressionPtr;
#else
          returnExpression = expressionPtr.operator->();
#endif
          counter++;
          // CW: fixed bug here! We have to go to the next expression!
          j++;
        }

     ROSE_ASSERT (counter-1 == n);

  // printf ("Exiting after showSgExpression in CLASSNAME::getIndexExpression(int) \n");
  // ROSE_ABORT();

     return returnExpression;
   }


ROSE_Node* CLASSNAME::transform()
   {
  // printf ("Sorry not implemented, CLASSNAME::Tranform() \n");
  // ROSE_ABORT();

  // SgExpression* CLASSNAME::buildOperand (
  //      char* arrayName,                 // variable name
  //      variant_type_enum arrayType,     // Type for the array pointer
  //      char* indexName,                 // variable name
  //      variant_type_enum indexOperator, // ADD_OP, SUBT_OP, etc. (semantics of A++/P++ Index and Range objects only)
  //      SgExpression* rhsExpression )    // integer expression for the rhs of the indexOperator

  // Later we will initialize the name using the CLASSNAME::getOperandName()
  // and add a suffix from CLASSNAME::transformationVariableSuffix()
     SgName arrayName = getOperandPointerName();

  // We need a double array type (note not a "doubleArray")
#if USE_SAGE3
     Cxx_GrammarVariants arrayType = DOUBLE_VAL;
#else
     variant_type_enum arrayType = DOUBLE_VAL;
#endif

  // This contains the integer expression used for the indexing of the array
  // SgExpression* rhsExpression = NULL;

     int statementDimension = getNumberOfDimensions();

  // printf ("In CLASSNAME::transform() statementDimension = %d \n",statementDimension);
  // ROSE_ASSERT (statementDimension == 1);
  // ROSE_ASSERT (statementDimension == 2);

     SgName            indexName;
     SgExpression*     scalarExpression   [ROSE_MAX_ARRAY_DIMENSION];
     SgExpression*     indexExpression    [ROSE_MAX_ARRAY_DIMENSION];
#if USE_SAGE3
     Cxx_GrammarVariants indexOperator    [ROSE_MAX_ARRAY_DIMENSION];
#else
     variant_type_enum indexOperator      [ROSE_MAX_ARRAY_DIMENSION];
#endif
     Boolean           normalOperandOrder [ROSE_MAX_ARRAY_DIMENSION]; // The default is true (i.e I+1 or I-1 instead of 1+I or 1-I)

     int dim = 0;
     for (dim=0; dim < statementDimension; dim++)
        {
       // Initialization of default values
          scalarExpression   [dim] = NULL;
          indexExpression    [dim] = NULL;
          indexOperator      [dim] = LAST_TAG;
          normalOperandOrder [dim] = TRUE;
        }

     Sg_File_Info *fileInfo = buildSageFileInfo();
     SgExprListExp* argsExprListExp = new SgExprListExp(fileInfo);
     ROSE_ASSERT (argsExprListExp != NULL);

	 // Now we want to find a representative function call and swap out the parameters
	 // then put it into the buildOperand() function as a parameter so it will build
	 // the correct index.

	 // CW: MUST change the getIndexName function
	 // there is only one name for indices. Dimensions are handled through
	 // an array access
	 indexName = getIndexName(0);

	 for(dim=0; dim < statementDimension; dim++)
	 {
		// In this loop we assemble the index parameters into a SgExprListExp in preparation to
		// the construction of a funcation call which will be use as the index in the array 
		// indexing (inside of the []).  The function call will really be a call to a MACRO 
		// in the final user application.
		
          indexExpression[dim] = getIndexExpression(dim);

       // showSgExpression (cout,indexExpression[dim],"Call CLASSNAME::transform()");

       // This has to be made more programmable (at the moment we assume ???)
          indexOperator[dim] = getOperatorInIndexExpression (indexExpression[dim]);

          scalarExpression   [dim] = NULL;
          normalOperandOrder [dim] = TRUE;     // The default is true (i.e I+1 or I-1 instead of 1+I or 1-I)
          if (indexOperator[dim] == ADD_OP || indexOperator[dim] == SUBT_OP)
             {
            // printf ("scalarExpression[%d] in index expression set to VALID EXPRESSION \n",dim);
               scalarExpression[dim]  = getScalar_C_Expression (indexExpression[dim]);
               ROSE_ASSERT (scalarExpression[dim] != NULL);
             }
            else
             {
               if ( (ROSE_DEBUG > 0) || (ROSE::verbose == TRUE) )
                    printf ("scalarExpression[%d] in index expression set to NULL \n",dim);

               scalarExpression[dim]  = NULL;
             }
        }

     SgPntrArrRefExp* sagePntrArrRefExpression =
          buildOperand(arrayName,arrayType,indexName,indexOperator,
                       scalarExpression,statementDimension,normalOperandOrder);
     ROSE_ASSERT (sagePntrArrRefExpression != NULL);

#if 0
     printf ("\n\n");
     printf ("Now SHOW the OPERAND EXPRESSION! \n\n");
     showSgExpression (cout, sagePntrArrRefExpression, "Called from CLASSNAME::transform()");

     printf ("\n\n");
     printf ("Now UNPARSE the OPERAND EXPRESSION! \n\n");
     sagePntrArrRefExpression->unparse(NO_UNPARSE_INFO,cout);
     cout << endl << endl;
     printf ("\n\n");

     printf ("Exiting after construction of operand in Sage \n");
     ROSE_ABORT();
#endif

#if 1
  // Since we are holding the transformation of the array expression (which is a C
  // expression by definition) we can wrap it into a ROSE_C_Expression, alternatively
  // we could define a new grammar terminal to hold the transformed SAGE program tree.
     ROSE_C_Expression* roseExpression = new ROSE_C_Expression (sagePntrArrRefExpression);
     ROSE_ASSERT (roseExpression != NULL);
     ROSE_ASSERT (!roseExpression->error());

     return roseExpression;
#else
     return this;
#endif
   }

SgName
CLASSNAME::getOperandName ()
   {
  // We need to get the name from the operand hidden within the parenthesis operator!

     char* returnString = "defaultOperandNameFrom_ArrayParenthesisOperator_getOperandName";

  // showSgExpression (cout, getExpression(), "Called from CLASSNAME::getOperandName()" );

     SgConstructorInitializer* constructorInitializer = isSgConstructorInitializer(getExpression());
     ROSE_ASSERT (constructorInitializer != NULL);

     SgExprListExp* exprListExp = constructorInitializer->get_args();
     ROSE_ASSERT (exprListExp != NULL);

     SgExpressionPtrList & expressionPtrList = exprListExp->get_expressions();
     ROSE_ASSERT (expressionPtrList.size() == 1);

     if ( (ROSE_DEBUG > 0) || (ROSE::verbose == TRUE) )
          printf ("expressionPtrList.size() = %d \n",expressionPtrList.size());

     SgExpressionPtrList::iterator i = expressionPtrList.begin();
     int counter = 0;
     while (i != expressionPtrList.end()) 
        {
          if ( (ROSE_DEBUG > 0) || (ROSE::verbose == TRUE) )
               cout << "Expression List Element #" << counter << endl;

          SgExpressionPtr expressionPtr = *i;
       // showSgExpression( cout, expressionPtr.operator->(), "Called from CLASSNAME::getOperandName()" );      

#if USE_SAGE3
          SgFunctionCallExp* functionCallExpr = isSgFunctionCallExp(expressionPtr);
#else
          SgFunctionCallExp* functionCallExpr = isSgFunctionCallExp(expressionPtr.operator->());
#endif
          ROSE_ASSERT (functionCallExpr != NULL);

          SgExpression *functionExpr = functionCallExpr->get_function();
          ROSE_ASSERT (functionExpr != NULL);

       // Here is how to get the Index objects that were used!
          SgExprListExp* argsExprListExp = functionCallExpr->get_args();
          ROSE_ASSERT (argsExprListExp != NULL);

          SgDotExp* dotExp = isSgDotExp(functionExpr);
          ROSE_ASSERT (dotExp != NULL);

          SgVarRefExp* varRefExp = isSgVarRefExp(dotExp->get_lhs_operand());
          ROSE_ASSERT (varRefExp != NULL);

          SgVariableSymbol* variableSymbol = varRefExp->get_symbol();
          ROSE_ASSERT (variableSymbol != NULL);

          SgInitializedName* name = variableSymbol->get_declaration();
          ROSE_ASSERT (name != NULL);

       // cout << "variable name: ";
          SgName n = name->get_name();
       // cout << n.str() << endl;

       // We should verify that this is an array type!
          SgType* type = name->get_type();

       // Build some space for the copy to take place
          returnString = new char [256];
          strcpy (returnString,n.str());
       // returnString = n.str();

          i++;
          counter++;
        }

  // printf ("Exting inside of CLASSNAME::getOperandName() \n");
  // ROSE_ABORT();

     return returnString;
   }

SgName
CLASSNAME::getOperandPointerName ()
   {
#if 0
  // Build some space for the copy to take place
     char* returnString = getOperandName();
     strcat (returnString,transformationVariableSuffix());

  // printf ("Exting inside of CLASSNAME::getOperandName() \n");
  // ROSE_ABORT();

     return returnString;
#else
     return ROSE::concatenate(getOperandName(),transformationVariableSuffix());
#endif
   }












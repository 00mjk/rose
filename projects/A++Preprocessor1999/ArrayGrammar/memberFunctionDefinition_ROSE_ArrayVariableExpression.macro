CLASSNAME::~CLASSNAME ()
   {
   }

#if 0
CLASSNAME::CLASSNAME ()
   {
     ROSE_Node::setUp (CLASSNAME_TAG,NULL);
   }
#endif

CLASSNAME::CLASSNAME ( SgExpression* expr )
   : BASECLASSNAME(expr)
   {
     ROSE_ASSERT (expr != NULL);
     ROSE_Node::setUp (CLASSNAME_TAG,expr);
   }

SgName
CLASSNAME::getOperandName()
   {
     char* returnString = "defaultOperandNameFrom_ArrayOperandExpression_getOperandName";
  // showSgExpression (cout, getExpression(), "Called from CLASSNAME::getOperandName()" );

     SgVarRefExp* varRefExp = isSgVarRefExp(getExpression());
     ROSE_ASSERT (varRefExp != NULL);

     SgVariableSymbol* variableSymbol = varRefExp->get_symbol();
     ROSE_ASSERT (variableSymbol != NULL);

     SgInitializedName* name = variableSymbol->get_declaration();
     ROSE_ASSERT (name != NULL);

     return name->get_name();

#if 0
  // cout << "variable name: ";
     SgName n = name->get_name();
  // cout << n.str() << endl;

  // We should verify that this is an array type!
     SgType* type = name->get_type();

  // Build some space for the copy to take place
     returnString = new char [256];
     strcpy (returnString,n.str());
  // strcat (returnString,transformationVariableSuffix());
  // returnString = n.str();

  // printf ("Exting inside of CLASSNAME::getOperandName() \n");
  // ROSE_ABORT();

     return returnString;
#endif
   }

SgName
CLASSNAME::getOperandPointerName()
   {
#if 0
  // Build some space for the copy to take place
     char* returnString = getOperandName();
     strcat (returnString,transformationVariableSuffix());

  // printf ("Exting inside of CLASSNAME::getOperandName() \n");
  // ROSE_ABORT();

     return returnString;
#else
     return ROSE::concatenate(getOperandName(),transformationVariableSuffix());
#endif
   }



CLASSNAME::~CLASSNAME ()
   {
   }

CLASSNAME::CLASSNAME ( SgExpression* expr )
   : BASECLASSNAME(expr)
   {
     ROSE_ASSERT (ArrayClassSageInterface::getVariant(expr) == CLASSNAME_TAG);

// This function is a virtual member function 
     recognizeSageSubTree (expr);
   }

ROSE_Node* CLASSNAME::transform()
   {
  // We want to avoid having the transform(void) function call the transform functions on the leaves
  // since this is done in the transformation grammar!

     printf ("ERROR: default transform(void) member function called! \n");
     ROSE_ABORT();

  // printf ("Sorry not implemented, CLASSNAME::Tranform() \n");
  // ROSE_ABORT();

  // printf ("Calling getLhsRoseExpression()->transform(); \n");
     ROSE_Expression* roseLhsExpression = (ROSE_Expression*) getLhsRoseExpression()->transform();

  // printf ("Calling getRhsRoseExpression()->transform(); \n");
     ROSE_Expression* roseRhsExpression = (ROSE_Expression*) getRhsRoseExpression()->transform();

     SgExpression* sageLhsExpression = (SgExpression*) roseLhsExpression->getSageSubTree();
     ROSE_ASSERT (sageLhsExpression != NULL);
     SgExpression* sageRhsExpression = (SgExpression*) roseRhsExpression->getSageSubTree();
     ROSE_ASSERT (sageRhsExpression != NULL);

     showSgExpression (cout, sageLhsExpression , "sageLhsExpression inside of CLASSNAME::transform()");
     showSgExpression (cout, sageRhsExpression , "sageRhsExpression inside of CLASSNAME::transform()");

  // Build and return a binary operator with the binary operator using the 
  // lhs and rhs expressions just built (dig the SgExpression object out of 
  // the ROSE_Expression containers!).

#if 0
  // cout << "ARRAY_FUNC_EQUALS_OP " << "implemented" << endl;
     SgExpression *functionExpr = functionCallExp->get_function();
     ROSE_ASSERT (functionExpr != NULL);
     SgDotExp *dotExp = isSgDotExp (functionExpr);
     ROSE_ASSERT (dotExp);

     SgExpression *lhsOperand = dotExp->get_lhs_operand();
     ROSE_ASSERT (lhsOperand != NULL);

  // We don't really need the Rhs (I think)
  // SgExpression *rhsOperand = dotExp->get_rhs_operand();
  // ROSE_ASSERT (rhsOperand != NULL);

     SgExprListExp* exprListExp = functionCallExp->get_args();
     ROSE_ASSERT (exprListExp != NULL);

     SgExpressionPtrList & expressionPtrList = exprListExp->get_expressions();
     SgExpressionPtrList::iterator i = expressionPtrList.begin();
     ROSE_ASSERT (expressionPtrList.size() == 1);
     SgExpression *rhsOperand = (*i).operator->();
     ROSE_ASSERT (rhsOperand != NULL);
#endif

  // We can put any string here and line number but line# = 0 triggers
  // SAGE to not unparse the #<line number> "<file name>" line.
  // Sg_File_Info *fileInfo =  new Sg_File_Info("CUSTOM_BUILT_BY_ROSE",0,0);
  // Sg_File_Info *fileInfo =  new Sg_File_Info("CUSTOM BUILT BY ROSE",1,0); 
     Sg_File_Info *fileInfo =  buildSageFileInfo();
     ROSE_ASSERT (fileInfo != NULL);

  // We have to build the correct type later (or maybe it makes no different to the unparser???)
     SgTypeDouble* doubleType = new SgTypeDouble ();
     ROSE_ASSERT (doubleType != NULL);

     SgAssignOp *assignOp = new SgAssignOp (fileInfo,sageLhsExpression,sageRhsExpression,doubleType);
     ROSE_ASSERT (assignOp != NULL);

#if 0
     printf ("#################################################################### \n");
     printf ("#####################  NEW EXPRESSION (assignOp)  ################## \n");
     printf ("#################################################################### \n");

     showSgExpression (cout, assignOp , "Called inside of CLASSNAME::transform()");

     printf ("#################################################################### \n");
     printf ("################  CALL UNPARSE  #################################### \n");
     printf ("#################################################################### \n");

     assignOp->logical_unparse(NO_UNPARSE_INFO,cout);

     cout << endl << endl;
     cout << "####################################################################" << endl;
     cout << "####################################################################" << endl;
#endif
#if 0
     printf ("Exiting after showSgExpression (cout, assignOp ); in SimpleArrayAssignment::modifyFunction \n");
     ROSE_ABORT();
#endif

  // Since we are holding the transformation of the array expression (which is a C
  // expression by definition) we can wrap it into a ROSE_C_Expression, alternatively
  // we could define a new grammar terminal to hold the transformed SAGE program tree.
     ROSE_C_Expression* roseExpression = new ROSE_C_Expression (assignOp);
     ROSE_ASSERT (roseExpression != NULL);
     ROSE_ASSERT (!roseExpression->error());

     return roseExpression;
  // return this;
   }

ROSE_Node* CLASSNAME::transform( ROSE_Expression* roseLhsExpression, ROSE_Expression* roseRhsExpression )
   {
     ROSE_ASSERT (roseLhsExpression != NULL);
     ROSE_ASSERT (roseRhsExpression != NULL);
     ROSE_ASSERT (!roseLhsExpression->error());
     ROSE_ASSERT (!roseRhsExpression->error());   
     return ROSE_C_Expression::build_ROSE_C_Expression (this, roseLhsExpression, roseRhsExpression );
   }

SgExpression* CLASSNAME::buildExpression ( ROSE_Expression* node, SgExpression* sageLhsExpression, SgExpression* sageRhsExpression )
   {
  // This function 
     SgExpression* returnExpression = NULL;
     ROSE_ASSERT (node != NULL);

     returnExpression = new SgAssignOp (node->buildSageFileInfo(),sageLhsExpression,sageRhsExpression,node->getType());
     ROSE_ASSERT (returnExpression != NULL);
     return returnExpression;
   }

void CLASSNAME::recognizeSageSubTree ( SgExpression* expr )
   {
     ROSE_ASSERT (getSageSubTree() != NULL);
     SgFunctionCallExp *functionCallExpr = isSgFunctionCallExp( (SgExpression*) getSageSubTree() );
     ROSE_ASSERT (functionCallExpr != NULL);

  // Now test the return type
     SgType* type = functionCallExpr->get_expression_type();   
     ROSE_ASSERT (type != NULL);
     ROSE_ASSERT (ArrayClassSageInterface::isArrayClassType(type) == TRUE);

     SgExpression *functionExpr = functionCallExpr->get_function();
     ROSE_ASSERT (functionExpr != NULL);

     SgDotExp *dotExpression = isSgDotExp(functionExpr);
     ROSE_ASSERT (dotExpression != NULL);

     SgBinaryOp *binaryOperator = isSgBinaryOp(dotExpression);
     ROSE_ASSERT (binaryOperator != NULL);

     setSageBinaryOperator (binaryOperator);
     ROSE_Node::setUp(CLASSNAME_TAG,expr);
   }

// Member functions specific to CLASSNAME
// Get/Set for the SAGE subtrees
SgExpression* CLASSNAME::getLhsSageExpression()
   {
  // To get the Lhs we need only get it directly from the 
  // binary operator (the LHS is the easy case).

     SgExpression* returnExpression = NULL;

  // returnExpression = ((SgBinaryOp*) getSageSubTree())->get_lhs_operand();
     returnExpression = getSageBinaryOperator()->get_lhs_operand();

  // showSgExpression (cout, returnExpression, "CALLED FROM CLASSNAME::getLhsSageExpression(): AT BASE returnExpression is:");

     ROSE_ASSERT (returnExpression != NULL);
     return returnExpression;
   }

SgExpression* CLASSNAME::getRhsSageExpression()
   {
// To get the Rhs we have to:
//    1) find the function call expression
//    2) get the argument list
//    3) get the expression out of the argument
// In the case of a binary operator equals there should be ONLY one argument!

     SgExpression* returnExpression = NULL;

     SgExpression* subTreeRoot = (SgExpression*) getSageSubTree();
     ROSE_ASSERT (subTreeRoot != NULL);

     SgFunctionCallExp* functionCallExp = isSgFunctionCallExp( subTreeRoot );
     ROSE_ASSERT (functionCallExp != NULL);

     SgExprListExp* exprListExp              = functionCallExp->get_args();
     SgExpressionPtrList & expressionPtrList = exprListExp->get_expressions();

  // There is onlt a single argument representing the RHS in a binary operator equals!
     ROSE_ASSERT (expressionPtrList.size() == 1);
     ROSE_ASSERT (expressionPtrList.begin() != expressionPtrList.end());

#if USE_SAGE3
     SgExpression* expressionPtr = *(expressionPtrList.begin());

  // This is how we get the SgExpression from the SgExpressionPtrList element
     returnExpression = expressionPtr;
#else
     SgExpressionPtr expressionPtr = *(expressionPtrList.begin());

  // This is how we get the SgExpression from the SgExpressionPtrList element
     returnExpression = expressionPtr.operator->();
#endif

     ROSE_ASSERT (returnExpression != NULL);
     return returnExpression;
   }

void CLASSNAME::setLhsSageExpression ( SgExpression* expr )
   {
  // This function is implemented similarly to the "get" functions
  // in that they have to trace through the tree to the correct location
  // of the Lhs and Rhs.

     ROSE_ASSERT (expr != NULL);

  // ((SgBinaryOp*) getSageSubTree())->set_lhs_operand(expr);

     printf ("Sorry not implemented CLASSNAME::setLhsSageExpression \n");
     ROSE_ABORT();
   }

void CLASSNAME::setRhsSageExpression ( SgExpression* expr )
   {
  // This function is implemented similarly to the "get" functions
  // in that they have to trace through the tree to the correct location
  // of the Lhs and Rhs.

     ROSE_ASSERT (expr != NULL);

  // We can't just call the set_rhs_operand member function since the depth of the
  // Sage subtree representing a CLASSNAME is greater then 1!
  // so we have to find the leaft of the subtree representing the CLASSNAME
  // and call its set_rhs_operand member function!!!
  // ((SgBinaryOp*) getSageSubTree())->set_rhs_operand(expr);

     printf ("Sorry not implemented CLASSNAME::setRhsSageExpression \n");
     ROSE_ABORT();
   }

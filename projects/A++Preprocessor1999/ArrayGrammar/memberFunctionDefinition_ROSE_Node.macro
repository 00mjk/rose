
ROSE_Node::~ROSE_Node ()
   {
  // delete subTree;
     sageSubTree = NULL;
   }

void ROSE_Node::setUp ( ROSE_GrammarVariants newId, SgNode* newSubTree )
   {
     ROSE_ASSERT (newId != ROSE_LAST_TAG);
  // ROSE_ASSERT (newId != ROSE_NodeTag);
     setVariant(newId);      // Default value until reset properly
     ROSE_ASSERT (newSubTree != NULL);
     setSageSubTree(newSubTree); // Pointer to Sage Tree (is it the copy?)
     setParseError(FALSE);   // The current state will generate an error

     ROSE_ASSERT (!error());
   }

ROSE_Node::ROSE_Node ()
   {
  // The default constructor is not useful in the sense that more 
  // information is required to properly setup the ROSE_Node base class
#if 0
     setUp (ROSE_LAST_TAG,NULL);
#else
     id          = ROSE_LAST_TAG;  // Default value until reset properly
     sageSubTree = NULL;           // Pointer to Sage Tree (is it the copy?)
     parseError  = TRUE;        // The current state will generate an error
#endif
   }

#if 0
ROSE_Node::ROSE_Node ( ROSE_GrammarVariants newId, SgNode* newSubTree )
   {
     setUp (newId,newSubTree);
   }
#endif

ROSE_Node::ROSE_Node ( SgNode* newSubTree )
   {
     setUp (ROSE_NodeTag,newSubTree);
   }

ROSE_GrammarVariants ROSE_Node::getVariant() const
   {
     ROSE_ASSERT (!error());
     return id;
   }

void ROSE_Node::setVariant ( const ROSE_GrammarVariants newId )
   {
     id = newId;
   }

#if 0
// This is a pure virtual function and so it should not be defined
ROSE_Node* ROSE_Node::transform()
   {
     printf ("ERROR: Base class ROSE_Node::transform() called \n");
     ROSE_ABORT();

     return NULL;
   }
#endif

Boolean ROSE_Node::error() const
   {
  // Error recovery mechanism (for the parser)
     return parseError;
   }

void ROSE_Node::setParseError ( Boolean X )
   {
     parseError = X;
   }

const SgNode* ROSE_Node::getSageSubTree()
   {
     ROSE_ASSERT (!error());
     return sageSubTree;
   }

void ROSE_Node::setSageSubTree ( const SgNode* node )
   {
  // I think we want to avoid letting the input be a NULL pointer
  // ROSE_ASSERT (node != NULL);
     sageSubTree = (SgNode*) node;
   }


Sg_File_Info* ROSE_Node::buildSageFileInfo ( char* filename )
   {
  // The second and third parameters are the line number and column number of the statement
  // if the line number is zero then the "#line filename" is not output by the unparser!
  // Sg_File_Info *fileInfo = new Sg_File_Info("CUSTOM BUILT BY ROSE",1,0);
     Sg_File_Info *fileInfo = new Sg_File_Info(filename,0,0);
     ROSE_ASSERT (fileInfo != NULL);

     return fileInfo;
   }

SgTypeDouble* ROSE_Node::buildTypeDouble ()
   {
     SgTypeDouble* doubleType = new SgTypeDouble ();
     ROSE_ASSERT (doubleType != NULL);

     return doubleType;
   }

SgTypeFloat* ROSE_Node::buildTypeFloat ()
   {
     SgTypeFloat* floatType = new SgTypeFloat ();
     ROSE_ASSERT (floatType != NULL);

     return floatType;
   }

SgTypeInt* ROSE_Node::buildTypeInt ()
   {
     SgTypeInt* intType = new SgTypeInt ();
     ROSE_ASSERT (intType != NULL);

     return intType;
   }

SgType* ROSE_Node::getType()
   {
     printf ("Calling virtual function in base class where it does not make sense! \n");
     ROSE_ABORT();

     return NULL;
   }










CLASSNAME::~CLASSNAME ()
   {
   }

CLASSNAME::CLASSNAME ( SgExpression* expr )
   : BASECLASSNAME(expr)
   {
     ROSE_ASSERT (expr != NULL);
     ROSE_Node::setUp (CLASSNAME_TAG,expr);

  // showSgExpression (cout, expr, "Called from CLASSNAME::CLASSNAME ( SgExpression* expr )");
   }

#if 0
// This is a pure virtual function at this level in the hierarchy of the grammar
ROSE_Node* CLASSNAME::transform()
   {
     printf ("Sorry not implemented, CLASSNAME::Tranform() \n");
     ROSE_ABORT();

     return NULL;
   }
#endif

// Member functions specific to CLASSNAME

// Get/Set for the SAGE subtrees
SgExpression* CLASSNAME::getLhsSageExpression()
   {
     SgExpression* returnExpression = NULL;

     printf ("We should get these from the expressionListExpr in the ROSE_ArrayOperator base class! \n");
     ROSE_ABORT();

  // Error checking to verify we have a correctly set binary operator
     SgBinaryOp* binaryOp = (SgBinaryOp*) getSageSubTree();
     ROSE_ASSERT (binaryOp != NULL);
     ROSE_ASSERT (isSgBinaryOp(binaryOp) != NULL);

  // returnExpression = ((SgBinaryOp*) getSageSubTree())->get_lhs_operand();
     returnExpression = binaryOp->get_lhs_operand();
     ROSE_ASSERT (returnExpression != NULL);

     return returnExpression;
   }

void CLASSNAME::setLhsSageExpression ( SgExpression* expr )
   {
     ROSE_ASSERT (expr != NULL);

     printf ("We should get these from the expressionListExpr in the ROSE_ArrayOperator base class! \n");
     ROSE_ABORT();

  // Error checking to verify we have a correctly set binary operator
     SgBinaryOp* binaryOp = (SgBinaryOp*) getSageSubTree();
     ROSE_ASSERT (binaryOp != NULL);
     ROSE_ASSERT (isSgBinaryOp(binaryOp) != NULL);

  // ((SgBinaryOp*) getSageSubTree())->set_lhs_operand(expr);
     binaryOp->set_lhs_operand(expr);
   }

SgExpression* CLASSNAME::getRhsSageExpression()
   {
     SgExpression* returnExpression = NULL;

     printf ("We should get these from the expressionListExpr in the ROSE_ArrayOperator base class! \n");
     ROSE_ABORT();

     showSgExpression (cout, (SgExpression*) getSageSubTree(), "CALLED FROM CLASSNAME::getRhsSageExpression()");

  // We can't just call the set_rhs_operand member function since the depth of the
  // Sage subtree representing a CLASSNAME is greater then 1!
  // so we have to find the leaft of the subtree representing the CLASSNAME
  // and call its set_rhs_operand member function!!!

  // returnExpression = ((SgBinaryOp*) getSageSubTree())->get_rhs_operand();
  // ROSE_ASSERT (returnExpression != NULL);
  // printf ("Sorry not implemented CLASSNAME::getRhsSageExpression \n");
  // ROSE_ABORT();

  // Error checking to verify we have a correctly set binary operator
     SgBinaryOp* binaryOp = (SgBinaryOp*) getSageSubTree();
     ROSE_ASSERT (binaryOp != NULL);
     ROSE_ASSERT (isSgBinaryOp(binaryOp) != NULL);

     ROSE_ASSERT (getSageSubTree() != NULL);
     SgFunctionCallExp *functionCallExpr = isSgFunctionCallExp( (SgExpression*) getSageSubTree() );
     ROSE_ASSERT (functionCallExpr != NULL);

  // Now test the return type
     SgType* type = functionCallExpr->get_expression_type();   
     ROSE_ASSERT (type != NULL);
     ROSE_ASSERT (ArrayClassSageInterface::isArrayClassType(type) == TRUE);

     SgExpression *functionExpr = functionCallExpr->get_function();
     ROSE_ASSERT (functionExpr != NULL);

     SgDotExp *dotExpression = isSgDotExp(functionExpr);
     ROSE_ASSERT (dotExpression != NULL);

     SgBinaryOp *binaryOperator = isSgBinaryOp(dotExpression);
     ROSE_ASSERT (binaryOperator != NULL);

     returnExpression = binaryOperator->get_rhs_operand();

     showSgExpression (cout, returnExpression, "CALLED FROM CLASSNAME::getRhsSageExpression(): AT BASE returnExpression is:");

     ROSE_ASSERT (returnExpression != NULL);
     return returnExpression;
   }

void CLASSNAME::setRhsSageExpression ( SgExpression* expr )
   {
     ROSE_ASSERT (expr != NULL);

     printf ("We should get these from the expressionListExpr in the ROSE_ArrayOperator base class! \n");
     ROSE_ABORT();

  // We can't just call the set_rhs_operand member function since the depth of the
  // Sage subtree representing a CLASSNAME is greater then 1!
  // so we have to find the leaft of the subtree representing the CLASSNAME
  // and call its set_rhs_operand member function!!!

  // Error checking to verify we have a correctly set binary operator
     SgBinaryOp* binaryOp = (SgBinaryOp*) getSageSubTree();
     ROSE_ASSERT (binaryOp != NULL);
     ROSE_ASSERT (isSgBinaryOp(binaryOp) != NULL);

  // ((SgBinaryOp*) getSageSubTree())->set_rhs_operand(expr);

     printf ("Sorry not implemented CLASSNAME::setRhsSageExpression \n");
     ROSE_ABORT();
   }

// Get/Set for the ROSE subtrees
void CLASSNAME::setLhsRoseExpression ( ROSE_Expression* lhsExpr )
   {
     ROSE_ASSERT (lhsExpr != NULL);
     ROSE_ASSERT (numberOfArguments() <= 2);

     addArgumentExpression(lhsExpr,0);
     ROSE_ASSERT (numberOfArguments() <= 2);
   }

ROSE_Expression* CLASSNAME::getLhsRoseExpression ()
   {
  // ROSE_ASSERT (roseLhsOperand != NULL);
  // return roseLhsOperand;
     ROSE_ASSERT (numberOfArguments() <= 2);
     ROSE_ASSERT (numberOfArguments() >= 1);

     ROSE_Expression* roseExpression = getArgumentExpression (0);
     ROSE_ASSERT (roseExpression != NULL);
  // printf ("roseExpression->getVariant() = %d \n",roseExpression->getVariant());

     return roseExpression;
  // return getArgumentExpression (0);  // The Lhs is at index position 0 and the Rhs is at index position 1
   }

void CLASSNAME::setRhsRoseExpression ( ROSE_Expression* rhsExpr )
   {
     ROSE_ASSERT (rhsExpr != NULL);
     ROSE_ASSERT (numberOfArguments() <= 2);

     addArgumentExpression(rhsExpr,1);
     ROSE_ASSERT (numberOfArguments() <= 2);
   }

ROSE_Expression* CLASSNAME::getRhsRoseExpression ()
   {
  // ROSE_ASSERT (roseRhsExpression != NULL);
  // return roseRhsExpression;
     ROSE_ASSERT (numberOfArguments() <= 2);

     return getArgumentExpression (1);  // The Lhs is at index position 0 and the Rhs is at index position 1
   }

// These functions get/set the Sage binary operator object within this class
// the purpose here is to provide a mechanism for the ROSE preprocessor to 
// reach into the SAGE tree and modify it.  Since some of the array binary operators
// are not really represented by SgBinaryOp objects it is not clear if this should be
// at this level (perhaps it should be at the BinaryOperatorEquals more directly 
// (pushed more toward the leaves)).
SgBinaryOp* CLASSNAME::getSageBinaryOperator()
   {
  // We need to verify that this has been set before we try to retrive it!
     ROSE_ASSERT (sageBinaryOperator != NULL);
     return sageBinaryOperator;
   }

void CLASSNAME::setSageBinaryOperator ( SgBinaryOp* newSageBinaryOperator )
   {
  // I think we want to avoid letting the input be a NULL pointer
  // ROSE_ASSERT (sageBinaryOperator != NULL);
     sageBinaryOperator = newSageBinaryOperator;
   }


ROSE_Node* CLASSNAME::transform( ROSE_Expression* roseLhsExpression, ROSE_Expression* roseRhsExpression )
   {
     printf ("Virtual function called within a base class CLASSNAME::transform(ROSE_Expression*,ROSE_Expression*)! \n");
     ROSE_ABORT();

     return ROSE_C_Expression::build_ROSE_C_Expression (this, roseLhsExpression, roseRhsExpression );
   }







CLASSNAME::~CLASSNAME ()
   {
   }

CLASSNAME::CLASSNAME ( SgStatement* stmt )
   : BASECLASSNAME(stmt)
   {
  // This function is a virtual member function
     recognizeSageSubTree (stmt);
   }

#if 0
// Define the abstractBaseClass function
void CLASSNAME::forceToBeAbstractBaseClass ()
   {
   }
#endif

ROSE_Node* CLASSNAME::transform()
   {
  // printf ("Sorry not implemented, CLASSNAME::Tranform() \n");
  // ROSE_ABORT();

     ROSE_ASSERT (!error());

     SgStatement* stmt = (SgStatement*) getSageSubTree();

     if ( (ROSE_DEBUG > 0) || (ROSE::verbose == TRUE) )
          printf ("In CLASSNAME::transform(): (file name = %s line number = %d) \n",
               ROSE::getFileName(stmt),ROSE::getLineNumber(stmt));

     ROSE_ASSERT (roseExpr != NULL);
     ROSE_Expression* roseExpression = (ROSE_Expression*) roseExpr->transform();

     SgExpression* sageExpression = (SgExpression*) roseExpression->getSageSubTree();
     ROSE_ASSERT (sageExpression != NULL);

#if 0
     printf ("\n\n");
     printf ("Now unparse the expression: \n");
     sageExpression->logical_unparse(NO_UNPARSE_INFO,cout);
     cout << endl << endl;
     printf ("\n\n");
#endif

  // showSgExpression (cout, sageExpression , "sageExpression inside of CLASSNAME::transform()");

  // This should be a function call to generate this Sg_File_Info object
     Sg_File_Info *fileInfo =  new Sg_File_Info("CUSTOM BUILT BY ROSE",1,0);
     ROSE_ASSERT (fileInfo != NULL);

  // Now we have built the inner loop we require only the wrapper to put it into (next)
     SgExprStatement* sageExprStatement = new SgExprStatement ( fileInfo, sageExpression);
     ROSE_ASSERT (sageExprStatement != NULL);

#if 0
     printf ("\n\n");
     showSgStatement (cout, sageExprStatement , "sageExprStatement inside of CLASSNAME::transform()");
     printf ("\n\n");
#endif

#if 0
     printf ("\n\n");
     printf ("Now unparse the statement: \n");
     sageExprStatement->logical_unparse(NO_UNPARSE_INFO,cout);
     cout << endl << endl;
#endif

  // But we are not done yet since we have to wrap this into a "for" loop 
  // and get the other supporting statements into place.  This might be 
  // better done with a template and a copy.  Maybe this should be done by the 
  // higher level grammar!!!

#if 0
     printf ("Exiting after showSgExpression (cout, ??? ); in CLASSNAME::transform() \n");
     ROSE_ABORT();
#endif

#if 1
  // Since we are holding the transformation of the array expression (which is a C
  // expression by definition) we can wrap it into a ROSE_C_Expression, alternatively
  // we could define a new grammar terminal to hold the transformed SAGE program tree.
     ROSE_C_Statement* roseStatement = new ROSE_C_Statement (sageExprStatement);
     ROSE_ASSERT (roseStatement != NULL);
     ROSE_ASSERT (!roseStatement->error());

     return roseStatement;
#endif
  // return this;
   }

void CLASSNAME::recognizeSageSubTree ( SgStatement* stmt )
   {
     ROSE_Node::setUp (CLASSNAME_TAG,stmt);
   }

void CLASSNAME::setRoseExpression ( ROSE_Expression* expr )
   {
     ROSE_ASSERT (!error());

     ROSE_ASSERT (expr != NULL);
     roseExpr = expr;
   }

ROSE_Expression* CLASSNAME::getRoseExpression ()
   {
     ROSE_ASSERT (!error());

     ROSE_ASSERT (roseExpr != NULL);
     return roseExpr;
   }

// CLASSNAME friend function
CLASSNAME* isRoseExpressionStatement (ROSE_Node* node)
   {
  // This function behaves just like the SAGE II mechanism which we copy
     ROSE_ASSERT (node != NULL);
     CLASSNAME* returnRoseStatement = NULL;
     switch (node->getVariant())
        {
       // Include all the object types which have CLASSNAME as a base class
          case CLASSNAME_TAG:
             {
               returnRoseStatement = (CLASSNAME *) node;
               break;
             }
          default:
             {
               returnRoseStatement = NULL;
               break;
             }
        }

     return returnRoseStatement;
   }



// Treat config.h separately from other include files
#ifdef HAVE_CONFIG_H
// This avoids requiring the user to use config.h and follows
// the automake manual request that we use <> instead of ""
#include <config.h>
#endif

#include "rose.h"

// Support for different types of queries (using the global tree traversal mechanism)
#include "nameQuery.h"
#include "indexOffsetQuery.h"

// #include "arrayStatementTransformation.h"
#include "scalarIndexingArrayStatementTransformation.h"
#include "scalarIndexingStatementTransformation.h"

// Implementation of pure virtual TransformationSpecificationType::transformation function (in the derived class)
// ProgramTransformationSynthesizedAttributeType
SynthesizedAttributeBaseClassType
ScalarIndexingArrayStatementTransformation::transformation ( SgProject & project, SgNode* astNode )
   {
  // The purpose of this transformation is to insert the array transformation in place of each array
  // statement.  This is a function defined in the class derived from the TransformationSpecificationType.
  // This function is a pure virtual function within the TransformationSpecificationType base class.

     ROSE_ASSERT (astNode != NULL);

     if (targetForTransformation(astNode) != true)
          return SynthesizedAttributeBaseClassType();

  // Many types of scalar array statement transformations could be implemented,
  // here we demonstrate a simple one scalar array assignment statement transformation
     SynthesizedAttributeBaseClassType gatheredData =
          ScalarIndexingStatementTransformation::transformation ( astNode );

#if 0
  // error checking
     ROSE_ASSERT (gatheredData.getGlobalDeclaration().isEmpty()      == false);
     ROSE_ASSERT (gatheredData.getVariableDeclaration().isEmpty()    == false);
     ROSE_ASSERT (gatheredData.getVariableInitialization().isEmpty() == false);
#endif

     ROSE_ASSERT (gatheredData.getTransformation().isEmpty() == false);

     ArrayTransformationSupport::replaceStatement ( project, astNode, gatheredData );

#if 1
     printf ("Exiting as part of testing ... (at base of ScalarIndexingArrayStatementTransformation::transformation) \n");
     ROSE_ABORT();
#endif

#if 0
  // Make sure this is an expression statement
     SgExprStatement *expressionStatement = isSgExprStatement(astNode);
     ROSE_ASSERT (expressionStatement != NULL);
     ROSE_ASSERT (isSgExprStatement(astNode) != NULL);

  // printf ("Found an expression statement to transform (line = %d) \n",ROSE::getLineNumber(expressionStatement));

  // Copy the operand data base from the ArrayAssignmentStatementTransformation object into the
  // ArrayStatementTransformation object (note: it is computed in the accumulator object within
  // the implementation of the ArrayAssignmentStatementTransformation transformation).
  // buy copying the database outside of the ArrayAssignmentStatementTransformation object
  // we make it available within the ArrayStatementTransformation object (interface).
  // operandDataBase = X.getOperandDataBase();

  // get out the source code string associated with the transformation
     string loopTransformationString = gatheredData.getTransformationString();

#if 1
  // These should be the same
  // printf ("Operand Database: operandDataBase.displayString() = %s \n",operandDataBase.displayString().c_str());
     printf ("Operand Database: gatheredData.displayString()       = %s \n",gatheredData.displayString().c_str());
#endif

#if 0
     printf ("Exiting as part of testing ... (in ScalarIndexingStatementTransformation::transformation) \n");
     ROSE_ABORT();
#endif

  // Get the column number of the statement we are transforming
     int statementColumnNumber = ROSE::getColumnNumber(expressionStatement);
  // printf ("Transformation starts at statementColumnNumber = %d \n",statementColumnNumber);

  // Now indent the whole string to match the column position of the original statement
  // (just to make it easy to look at)
     loopTransformationString = StringUtility::indentMultilineString (loopTransformationString.c_str(), statementColumnNumber);
     ROSE_ASSERT (loopTransformationString.c_str() != NULL);
#endif

     return gatheredData;
   }


// ********************************************************************************************
//                             Destructors and Constructors
// ********************************************************************************************

ScalarIndexingArrayStatementTransformation::~ScalarIndexingArrayStatementTransformation()
   {
  // Nothing to do here!
  // delete &accumulatorValue;
   }

ScalarIndexingArrayStatementTransformation::ScalarIndexingArrayStatementTransformation()
// : accumulatorValue( *(new ScalarIndexingStatementQueryAccumulatorType()) )
   {
  // Nothing to do here!
     printf ("Inside of body of constructor ScalarIndexingArrayStatementTransformation \n");
   }


// ********************************************************************************************
//                                  Functions
// ********************************************************************************************

#if 0
ScalarIndexingOperandDataBaseType &
ScalarIndexingArrayStatementTransformation::getOperandDataBase()
   {
     return operandDataBase;
   }
#endif

// ********************************************************************************************
//                                 Virtual Functions
// ********************************************************************************************

bool
ScalarIndexingArrayStatementTransformation::targetForTransformation( SgNode* astNode )
   {
  // This function returns true when the current node 
  // of the AST is a target for transformation.
     bool returnValue = FALSE;

     ROSE_ASSERT (astNode != NULL);

  // This code used to recognize the use of scalar indexing within an expression statement.
  // Currently the lhs operand must be an array operand which is indexed using the scalar indexing
  // operator. A more general test is required since only one of the operands (lhs or rhs) need be
  // indexed using the scalar indexing operator to qualify for the scalar indexing optimization.
  // However, the array statement must not be a normal array statment (mixed use of array operations
  // with scalar indexing would be a part of the array statement optimizations (transformation).

     SgExprStatement *expressionStatement = isSgExprStatement(astNode);

#if 1
     printf ("In ScalarIndexingArrayStatementTransformation::targetForTransformation() node = %s \n",
          astNode->sage_class_name());
     SgLocatedNode* locatedNode = isSgLocatedNode(astNode);
     if (locatedNode != NULL)
          printf ("      file = %s line #%d \n",ROSE::getFileName(locatedNode),ROSE::getLineNumber(locatedNode));
#endif

  // In this example we only perform transformations on declaration statements
     if (expressionStatement != NULL)
        {
          SgExpression* expression = expressionStatement->get_the_expr();
          ROSE_ASSERT (expression != NULL);

       // See if this is a scalar indexing lhs operand using an assignment operator (a better test
       // than this is required later).
          SgAssignOp* assignmentOperator = isSgAssignOp(expression);
       // ROSE_ASSERT (assignmentOperator != NULL);

          if (assignmentOperator != NULL)
             {
               SgExpression* lhsExpression = assignmentOperator->get_lhs_operand();
               ROSE_ASSERT (lhsExpression != NULL);

               SgFunctionCallExp* functionCallExp = isSgFunctionCallExp(lhsExpression);
            // ROSE_ASSERT (functionCallExp != NULL);

               if (functionCallExp != NULL)
                  {
                    string functionTypeName = TransformationSupport::getFunctionTypeName(functionCallExp);

                    if ( functionTypeName == "intArray"   ||
                         functionTypeName == "floatArray" ||
                         functionTypeName == "doubleArray")
                       {
#if 1
                         printf ("@@@@@@@@@@@ (RETURN TRUE) ScalarIndexingArrayStatementTransformation::targetForTransformation(): file = %s line #%d \n",
                              ROSE::getFileName(expressionStatement), ROSE::getLineNumber(expressionStatement));
#endif
                         returnValue = TRUE;
                       }
                      else
                       {
                         printf ("Not a expression statement containing a function call expression of type {double,float,int}Array ... \n");
                       }
                  }
                 else
                  {
                 // This case could be "A;" in which case there is no transformation
                    printf ("Not a assignment expression statement ... \n");
                  }
             }
            else
             {
            // This case could be "A;" in which case there is no transformation
               printf ("Not a expression statement containing a function call expression ... \n");
             }

       // Our test program should always be TRUE!
       // ROSE_ASSERT (returnValue == TRUE);
        }
       else
        {
          printf ("Not an expression statement (only expression statements qualify!) \n");
        }

#if 0
     printf ("Exiting in ScalarIndexingArrayStatementTransformation::targetForTransformation() \n");
     ROSE_ABORT();
#endif

     return returnValue;
   }

#if 0
char*
ScalarIndexingArrayStatementTransformation::internalSupportingGlobalDeclarations( SgNode* astNode )
   {
  // This function generates a string that is used in the function which assembles the strings into
  // code that is called internally with the front-end to generate an AST fragements (which is
  // patched into the AST to introduce the transformation).

  // NOTE: This extra code is required to allow the string representing the transformation to be
  // compiled.  Once it is compiled, the AST is searched and only the AST fragment representing the
  // transformation is extracted (not the AST framents representing any of the code specified in
  // this function).

  // The use of a include file simplifies and shortens the 
  // declaration section of the intermediate (generated) file
     char* staticStringSourceCodeTemplate = "\
#include \"simpleA++.h\" \n\
#define ROSE_MACROS_APPEAR_AS_FUNCTIONS \n\
#include \"transformationMacros.h\" \n\
\n\
$VARIABLE_DECLARATIONS\n\n\
";

  // Removed from staticStringSourceCodeTemplate
  // define USE_ROSE 1


  // We need to have a string built from dynamically allocated memory using 
  // the C++ new operator since it will be deleted in the copyEdit() function
  // This avoids a purify error (so we have to call stringDuplicate())
     char* sourceCodeTemplate = StringUtility::stringDuplicate(staticStringSourceCodeTemplate);

  // Variable declarations will have this form
     char* staticVariableDeclarationString = "$TYPE_NAME $VARIABLE_NAME; \n";

  // The start of the variable declaration section of code begins with the following comment (this
  // string is appended with the actual variable declarations).
     char* variableDeclarationString =
          "// Variables used in this transformation (automatically generated from simple dependence analysis of original code before transformation) \n";

  // Generate the list of types used within the target subtree of the AST
     list<string> typeNameStringList = NameQuery::getTypeNamesQuery ( astNode );

  // Loop over all the types and get list of variables of each type
  // (so they can be declared properly when the transformation is compiled)
     list<string>::iterator typeListStringElementIterator;
     for (typeListStringElementIterator = typeNameStringList.begin();
          typeListStringElementIterator != typeNameStringList.end();
          typeListStringElementIterator++)
        {
       // printf ("Type = %s \n",(*typeListStringElementIterator).c_str());

       // Find a list of names of variable of type (*listStringElementIterator)
          list<string> operandNameStringList =
               NameQuery::getVariableNamesWithTypeNameQuery (astNode, *typeListStringElementIterator );

       // Loop over all the types and get list of variable of each type
          list<string>::iterator variableListStringElementIterator;
          for (variableListStringElementIterator = operandNameStringList.begin();
               variableListStringElementIterator != operandNameStringList.end();
               variableListStringElementIterator++)
             {
#if 0
               printf ("Type = %s Variable = %s \n",
                    (*typeListStringElementIterator).c_str(),
                    (*variableListStringElementIterator).c_str());
#endif

               char* variableName = ROSE::stringDuplicate((*variableListStringElementIterator).c_str());
               char* typeName = ROSE::stringDuplicate((*typeListStringElementIterator).c_str());
               char* localOperandDataTemplate =
                    SgNode::copyEdit (ROSE::stringDuplicate(staticVariableDeclarationString),"$VARIABLE_NAME",variableName);
               localOperandDataTemplate =
                    SgNode::copyEdit (ROSE::stringDuplicate(localOperandDataTemplate),"$TYPE_NAME",typeName);

            // Append the new variable declaration to the variableDeclarationString
               variableDeclarationString = ROSE::stringConcatinate (variableDeclarationString,localOperandDataTemplate);
             }
#if 0
          printf ("Exiting in loop internalSupportingGlobalDeclarations (type = %s) ... \n",(*typeListStringElementIterator).c_str());
          ROSE_ABORT();
#endif
        }

#if 0
     printf ("Exiting at base of internalSupportingGlobalDeclarations ... \n");
     ROSE_ABORT();
#endif

  // Substitute the code fragment representing variable declaration into the generated source code
  // representing the specification of the transformation.
     char* finalSourceCodeString = SgNode::copyEdit ( sourceCodeTemplate, "$VARIABLE_DECLARATIONS" , variableDeclarationString );

     return finalSourceCodeString;
   }
#endif

#if 0
// ###############################################
// Global Declarations Supporting Transformation
// ###############################################
list<string>
ScalarIndexingArrayStatementTransformation::getGlobalDeclarationStrings()
   {
  // Build the list of variables to be declared at the top of any new scope
     list<string> declarationStrings;

  // retrive the saved declaration strings in the current object
     declarationStrings = globalDeclarationStrings;

     return declarationStrings;
   }

void
ScalarIndexingArrayStatementTransformation::setGlobalDeclarationStrings( list<string> & declarationStrings )
   {
  // merge function requires that all lists are sorted
     declarationStrings.sort();
     globalDeclarationStrings.merge ( declarationStrings );
   }

// ###############################################
// Variable Declarations Supporting Transformation
// ###############################################
list<string>
ScalarIndexingArrayStatementTransformation::getVariableDeclarationStrings()
   {
  // Build the list of variables to be declared at the top of any new scope
     list<string> declarationStrings;

  // retrive the saved declaration strings in the current object
     declarationStrings = variableDeclarationStrings;

     return declarationStrings;
   }

void
ScalarIndexingArrayStatementTransformation::setVariableDeclarationStrings( list<string> & declarationStrings )
   {
  // merge function requires that all lists are sorted
     declarationStrings.sort();
     variableDeclarationStrings.merge ( declarationStrings );
   }

// ##################################################
// Variable Initializations Supporting Transformation
// ##################################################
list<string>
ScalarIndexingArrayStatementTransformation::getVariableInitializationStrings()
   {
  // Build the list of variables to be declared at the top of any new scope
     list<string> initializationStrings;

  // retrive the saved declaration strings in the current object
     initializationStrings = variableInitializationStrings;

     return initializationStrings;
   }

void
ScalarIndexingArrayStatementTransformation::setVariableInitializationStrings( list<string> & initializationStrings )
   {
  // merge function requires that all lists are sorted
     initializationStrings.sort();
     variableInitializationStrings.merge ( initializationStrings );
   }
#endif














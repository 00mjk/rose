(require (lib "pretty.ss"))
(require (lib "match.ss"))
(require (lib "1.ss" "srfi"))

(define data (with-input-from-file "/home/willcock2/rose-svn-checkout/build/projects/assemblyToSourceAst/fnord.ss" read))

(define (simplify-begins t)
  (match t
    (`(begin . ,ls)
     (let* ((fixed-ls (map simplify-begins ls))
            (fixed-ls2 (append-map (match-lambda (`(begin . ,ls2) ls2) (x (list x))) fixed-ls)))
       (if (= (length fixed-ls2) 1)
           (car fixed-ls2)
           `(begin . ,fixed-ls2))))
    (`(expr . ,_) t)
    (`(parallel-assign . ,_) t)
    (`(goto . ,_) t)
    (`(label ,_) t)
    (`(label ,l ,body) `(label ,l ,(simplify-begins body)))
    (`(if ,p ,a ,b) `(if ,p ,(simplify-begins a) ,(simplify-begins b)))
    (`(if ,p ,a) `(if ,p ,(simplify-begins a)))
    (`(let ,vars . ,body*)
     (let ((fixed-body (simplify-begins `(begin . ,body*))))
       `(let ,vars ,fixed-body)))
    (`(case ,expr . ,body*) `(case ,expr . ,body*))
    (_ (error "Bad input" t))))

(set! data (simplify-begins data))

(define (add-bodies-to-labels e)
  (match e
    (`(begin . ,ls)
     `(begin . 
             ,(let loop ((ls ls))
                (if (null? ls)
                    '()
                    (match (car ls)
                      (`(label ,l)
                       (let-values (((this-label rest)
                                     (let loop2 ((ls (cdr ls)))
                                       (if (null? ls)
                                           (values '() '())
                                           (match (car ls)
                                             (`(label ,l2)
                                              (values `((goto ,l2)) ls))
                                             (x
                                              (let-values (((this-label2 rest2)
                                                            (loop2 (cdr ls))))
                                                (values (cons x this-label2) rest2))))))))
                         `((label ,l (begin . ,this-label)) . ,(loop rest))))
                      (x `(,x . ,(loop (cdr ls)))))))))
    (_ (error "Bad e" e))))

(set! data (simplify-begins (add-bodies-to-labels data)))

(define (forbid-labels e)
  (match e
    (`(label . ,_) (error "forbid-labels" e))
    (`(goto . ,_) (void))
    (`(expr . ,_) (void))
    (`(if ,p . ,rest) (for-each forbid-labels rest))
    (`(let ,vars ,body) (forbid-labels body))
    (`(begin . ,rest) (for-each forbid-labels rest))
    (`(case ,e . ,rest) (for-each (match-lambda (`(,keys ,body) (forbid-labels body))) rest))
    (_ (error "forbid-errors unrecognized" e))))

(match data (`(begin . ,rest)
             (for-each (match-lambda
                         (`(label ,l ,body) (forbid-labels body))
                         (e (forbid-labels e)))
                       rest)))

(define (conditionalize e cond negate)
  (match e
    (`(begin . ,ls) `(begin . ,(map (lambda (e2) (conditionalize e2 cond negate)) ls)))
    (`(expr (assign ,e1 ,e2))
     (if negate
         `(expr (assign ,e1 (if-e ,cond ,e1 ,e2)))
         `(expr (assign ,e1 (if-e ,cond ,e2 ,e1)))))
    (_ (error "Cannot conditionalize" e))))

(define (split-ifs e)
  (match e
    (`(if ,_ (goto ,_) (goto ,_)) e)
    (`(if ,_ (goto ,_)) e)
    (`(if (expr ,p) ,a ,b)
     (let ((var (gensym 'pred)))
       `(let ((,var ,p))
          (begin
            ,(conditionalize a var #f)
            ,(conditionalize b var #t)))))
    (`(if (expr ,p) ,a)
     (let ((var (gensym 'pred)))
       `(let ((,var ,p))
          ,(conditionalize a var #f))))
    (`(begin . ,rest) `(begin . ,(map split-ifs rest)))
    (`(expr . ,_) e)
    (`(let ,vars ,body) `(let ,vars ,(split-ifs body)))
    (`(label ,l ,body) `(label ,l ,(split-ifs body)))
    (`(goto ,l) e)
    (`(case ,k . ,body*) `(case ,k . ,(map (match-lambda (`(,keys ,body) `(,keys ,(split-ifs body)))) body*)))
    (_ (error "split-ifs" e))))

(set! data (simplify-begins (split-ifs data)))

(set! data (cdr data)) ; Remove starting begin

(define (change-to-pure-memory e)
  (letrec ((change-expr
            (lambda (e)
              (cond
                ((symbol? e) e)
                ((number? e) e)
                ((boolean? e) e)
                ((list? e)
                 (match e
                   (`(memoryReadDWord ,a) `(memoryReadDWord memory ,(change-expr a)))
                   (`(memoryReadWord ,a) `(memoryReadWord memory ,(change-expr a)))
                   (`(memoryReadByte ,a) `(memoryReadByte memory ,(change-expr a)))
                   (`(,f . ,args) `(,f . ,(map change-expr args)))))
                (else (error "change-expr" e))))))
  (match e
    (`(label ,l ,body)
     `(label ,l ,(change-to-pure-memory body)))
    (`(goto ,l) `(goto ,l))
    (`(if ,p . ,rest) `(if ,(change-expr p) . ,rest))
    (`(case ,key . ,rest) `(case ,(change-expr key) . ,rest))
    (`(begin . ,rest) `(begin . ,(map change-to-pure-memory rest)))
    (`(let ((,var ,val)) ,body) `(let ((,var ,(change-expr val))) ,(change-to-pure-memory body)))
    (`(expr (memoryWriteDWord ,a ,d)) `(expr (assign memory (memoryWriteDWord memory ,(change-expr a) ,(change-expr d)))))
    (`(expr (memoryWriteWord ,a ,d)) `(expr (assign memory (memoryWriteWord memory ,(change-expr a) ,(change-expr d)))))
    (`(expr (memoryWriteByte ,a ,d)) `(expr (assign memory (memoryWriteByte memory ,(change-expr a) ,(change-expr d)))))
    (`(expr ,e) `(expr ,(change-expr e)))
    (_ (error "change-to-pure-memory" e)))))

(set! data (map change-to-pure-memory data))

(define (fold-lets e)
  (letrec ((loop
            (lambda (e al as) ; as is list of assignment pairs
              (match e
                (`(begin) (writeout as))
                (`(begin (begin . ,rest1) . ,rest2) (loop `(begin ,@rest1 ,@rest2) al as))
                (`(begin (let ,vars ,body) . ,rest) (loop `(let ,vars (begin ,body . ,rest)) al as))
                (`(begin (if ,p ,a ,b) . ,rest) (loop `(if ,p (begin ,a . ,rest) (begin ,b . ,rest)) al as))
                (`(let ((,var ,val)) ,body)
                 (let ((new-var (gensym var)))
                   `(let ((,new-var ,(remap val al))) ,(loop body `((,var . ,new-var) . ,al) as))))
                (`(if ,p ,a ,b)
                 `(if ,(remap p al)
                      ,(loop a al as)
                      ,(loop b al as)))
                (`(begin (expr (assign ,a ,b)) . ,rest)
                 (let ((new-var (gensym a)))
                   `(let ((,new-var ,(remap b al))) ,(loop `(begin . ,rest)
                                                           `((,a . ,new-var) . ,al)
                                                           `((,a . ,new-var) . ,as)))))
                (`(begin (parallel-assign ,as2) . ,rest)
                 (let ((new-var* (map (match-lambda (`(,a . ,b) (gensym a))) as2)))
                   (let l ((asx as2) (nv new-var*))
                     (if (null? asx)
                         (loop `(begin . ,rest)
                               (append (map (match-lambda* (`((,a . ,b) ,n) (cons a n))) as2 new-var*) al)
                               (append (map (match-lambda* (`((,a . ,b) ,n) (cons a n))) as2 new-var*) as))
                         `(let ((,(car nv) ,(remap (cdar asx) al)))
                            ,(l (cdr asx) (cdr nv)))))))
                (`(expr . ,_) (loop `(begin ,e) al as))
                (`(case ,key . ,cases)
                 `(case ,(remap key al)
                    ,@(map (match-lambda (`(,k ,body) `(,k ,(loop body al as)))) cases)))
                (`(begin (expr (abort)) . ,_) `(expr (abort)))
                (`(begin (expr (interrupt ,i)) . ,rest)
                 `(begin (expr (interrupt ,i)) ,(loop `(begin . ,rest) al as)))
                (`(begin (case ,key . ,cases) . ,rest)
                 (loop `(case ,key . ,(map (match-lambda (`(,k ,body) `(,k (begin ,body . ,rest)))) cases))
                       al as))
                (`(goto ,l) `(begin ,(writeout as) (goto ,l)))
                (`(label ,l ,body) `(label ,l ,(loop body al as)))
                (`(begin (goto ,l) . ,_) (loop `(goto ,l) al as))
                (`(begin ,x) (loop x al as))
                (_ (error "fold-lets-3" e)))))
           (remap (lambda (e al)
                    (cond
                      ((symbol? e) (let ((p (assq e al))) (if p (cdr p) e)))
                      ((list? e) (cons (car e) (map (lambda (x) (remap x al)) (cdr e))))
                      (else e))))
           (writeout (lambda (as)
                       (if (null? as)
                           '(begin)
                           `(parallel-assign
                             ,(let l ((as as))
                                (if (null? as)
                                    '()
                                    (let ((a (caar as)) (b (cdar as)))
                                      `((,a . ,b)
                                        .
                                        ,(l (filter (match-lambda (`(,a2 . ,_) (not (eq? a a2))))
                                                    (cdr as))))))))))))
    (loop e '() '())))

(set! data (map fold-lets data))

(define (copy-and-constant-prop e al)
  (letrec ((subst-expr
            (lambda (e al)
              (if (list? e)
                  (cons (car e) (map (lambda (e2) (subst-expr e2 al)) (cdr e)))
                  (if (symbol? e)
                      (let ((p (assq e al))) (if p (cdr p) e))
                      e))))
           (simple? (lambda (x) #t #;(or (number? x) (symbol? x) (boolean? x)))))
  (match e
    (`(begin . ,rest) `(begin . ,(map (lambda (e) (copy-and-constant-prop e al)) rest)))
    (`(let ((,var ,val)) ,body)
     (let ((val (subst-expr val al)))
       (if (simple? val)
           (copy-and-constant-prop body `((,var . ,val) . ,al))
           `(let ((,var ,val)) ,(copy-and-constant-prop body al)))))
    (`(expr ,e) `(expr ,(subst-expr e al)))
    (`(parallel-assign ,al2) `(parallel-assign ,(map (match-lambda (`(,e1 . ,e2) `(,(subst-expr e1 al) . ,(subst-expr e2 al)))) al2)))
    (`(label ,l ,body) `(label ,l ,(copy-and-constant-prop body al)))
    (`(goto . ,_) e)
    (`(if ,p ,a ,b) `(if ,(subst-expr p al) ,(copy-and-constant-prop a al) ,(copy-and-constant-prop b al)))
    (`(case ,key . ,cases) `(case ,(subst-expr key al)
                              ,@(map (match-lambda (`(,k* ,body) `(,k* ,(copy-and-constant-prop body al))))
                                     cases)))
    (_ (error "copy-and-constant-prop" e)))))

(set! data (map (lambda (e) (copy-and-constant-prop e '())) data))

(define (change-to-let* e)
  (match e
    (`(begin . ,rest) `(begin . ,(map change-to-let* rest)))
    (`(let ,vars ,body)
     (match (change-to-let* body)
       (`(let* ,vars2 ,body2) `(let* ,(append vars vars2) ,body2))
       (b `(let* ,vars ,b))))
    (`(expr (assign ,a ,b)) e)
    (`(parallel-assign . ,al) e)
    (`(expr (abort)) e)
    (`(expr (interrupt ,_)) e)
    (`(goto . ,_) e)
    (`(if ,p ,a ,b) `(if ,p ,(change-to-let* a) ,(change-to-let* b)))
    (`(case ,key . ,cases) `(case ,key . ,(map (match-lambda (`(,k* ,body) `(,k* ,(change-to-let* body)))) cases)))
    (`(label ,l ,body) `(label ,l ,(change-to-let* body)))
    (_ (error "change-to-let*" e))))

; (set! data (map change-to-let* data))

(define (get-used-variables e)
  (letrec ((g (lambda (e)
                (cond
                  ((symbol? e) (list e))
                  ((list? e) (apply lset-union eq? (map g (cdr e))))
                  (else '())))))
    (match e
      (`(begin . ,rest) (apply lset-union eq? (map get-used-variables rest)))
      (`(let ((,var ,val)) ,body)
       (let ((x (get-used-variables body)))
         (if (memq var x)
             (lset-union eq? (g val) (lset-difference eq? x (list var)))
             x)))
      (`(goto ,_) '())
      (`(if ,p ,a ,b) (lset-union eq? (g p) (get-used-variables a) (get-used-variables b)))
      (`(case ,key . ,cases)
       (apply lset-union eq? (g key) (map (match-lambda (`(,k ,body) (get-used-variables body))) cases)))
      (`(parallel-assign ,al) (apply lset-union eq? (map g (map cdr al))))
      (`(expr ,e) (g e))
      (_ (error "get-used-variables" e)))))

(define (remove-unused-variables e)
  (match e
    (`(begin . ,rest) `(begin . ,(map remove-unused-variables rest)))
    (`(let ((,var ,val)) ,body)
     (let ((x (get-used-variables body)))
       (if (memq var x)
           `(let ((,var ,val)) ,(remove-unused-variables body))
           (remove-unused-variables body))))
    (`(goto ,_) e)
    (`(if ,p ,a ,b) `(if ,p ,(remove-unused-variables a) ,(remove-unused-variables b)))
    (`(case ,key . ,cases)
     `(case ,key . ,(map (match-lambda (`(,k ,body) `(,k ,(remove-unused-variables body)))) cases)))
    (`(parallel-assign ,al) e)
    (`(expr ,e) e)
    (_ (error "remove-unused-variables" e))))

(define (simplify-expr e)
  (letrec ((simp
            (lambda (e)
              (cond
                ((match e (`(subtract (add ,a ,b) ,c) (and (number? b) (number? c))) (else #f))
                 `(add ,(cadadr e) ,(- (caddr (cadr e)) (caddr e))))
                ((match e (`(add (add ,a ,b) ,c) (and (number? b) (number? c))) (else #f))
                 `(add ,(cadadr e) ,(+ (caddr (cadr e)) (caddr e))))
                ((match e (`(add ,a 0) #t) (_ #f)) (cadr e))
                ((match e (`(subtract ,a 0) #t) (_ #f)) (cadr e))
                ((match e (`(xor ,a ,b) (equal? a b)) (_ #f)) 0)
                ((match e (`(memoryWriteDWord ,m ,a (memoryReadDWord ,m ,b)) (equal? a b)) (_ #f))
                 (cadr e))
                ((match e (`(memoryReadDWord (memoryWriteDWord ,m ,a ,v) ,b) #t) (_ #f))
                 (match e (`(memoryReadDWord (memoryWriteDWord ,m ,a ,v) ,b)
                           `(if-e (equal ,a ,b)
                                  ,v
                                  (if-e (less-than (subtract (add ,a ,b) 3) 7)
                                        (error)
                                        (memoryReadDWord ,m ,b))))))
                ((list? e) (cons (car e) (map simp (cdr e))))
                (else e)))))
    (let loop ((e e))
      (let ((new-e (simp e)))
        (if (equal? e new-e) new-e (loop new-e))))))

(define (simplify e)
  (match e
    (`(begin . ,rest) `(begin . ,(map simplify rest)))
    (`(let ((,var ,val)) ,body)
     `(let ((,var ,(simplify-expr val))) ,(simplify body)))
    (`(goto ,_) e)
    (`(if ,p ,a ,b) `(if ,(simplify p) ,(simplify a) ,(simplify b)))
    (`(case ,key . ,cases)
     `(case ,(simplify key) . ,(map (match-lambda (`(,k ,body) `(,k ,(simplify body)))) cases)))
    (`(parallel-assign ,al)
     `(parallel-assign ,(map (match-lambda (`(,lhs . ,rhs) `(,lhs . ,(simplify-expr rhs)))) al)))
    (`(expr ,e) `(expr ,(simplify-expr e)))
    (_ (error "simplify" e))))

(define init-code `(begin . ,(filter (match-lambda (`(label . ,_) #f) (_ #t)) data)))
(define (get-label l) (or (ormap (match-lambda (`(label ,l2 ,body) (if (eq? l l2) body #f)) (_ #f)) data) (error "Label not found" l)))

(define (expand-one e)
  (match e
    (`(goto ,l) (get-label l))
    (`(if ,p ,a ,b) `(if ,p ,(expand-one a) ,(expand-one b)))
    (`(case ,k . ,cases) `(case ,k . ,(map (match-lambda (`(,keys ,e) `(,keys ,(expand-one e)))) cases)))
    (`(expr . ,_) e)
    (`(parallel-assign . ,_) e)
    (`(begin . ,rest) `(begin . ,(map expand-one rest)))
    (`(let ,vars ,body) `(let ,vars ,(expand-one body)))
    (_ (error "expand-one" e))))

(define (expand-one-simp e) (simplify (simplify-begins (remove-unused-variables (copy-and-constant-prop (fold-lets (expand-one e)) '())))))

(define (expand-many n e)
  (if (zero? n) e (expand-one-simp (expand-many (sub1 n) e))))

(pretty-print (change-to-let* (expand-many 3 init-code)))
; (pretty-print data)
;

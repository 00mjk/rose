(require (lib "pretty.ss"))
(require (lib "match.ss"))
(require (lib "1.ss" "srfi"))

(define data (with-input-from-file "/home/willcock2/rose-svn-checkout/build/projects/assemblyToSourceAst/fnord.ss" read))

(define (simplify-begins t)
  (match t
    (`(begin . ,ls)
     (let* ((fixed-ls (map simplify-begins ls))
            (fixed-ls2 (append-map (match-lambda (`(begin . ,ls2) ls2) (x (list x))) fixed-ls)))
       (if (= (length fixed-ls2) 1)
           (car fixed-ls2)
           `(begin . ,fixed-ls2))))
    (`(expr . ,_) t)
    (`(goto . ,_) t)
    (`(label ,_) t)
    (`(label ,l ,body) `(label ,l ,(simplify-begins body)))
    (`(if ,p ,a ,b) `(if ,p ,(simplify-begins a) ,(simplify-begins b)))
    (`(if ,p ,a) `(if ,p ,(simplify-begins a)))
    (`(let ,vars . ,body*)
     (let ((fixed-body (simplify-begins `(begin . ,body*))))
       `(let ,vars ,fixed-body)))
    (`(case ,expr . ,body*) `(case ,expr . ,body*))
    (_ (error "Bad input" t))))

(set! data (simplify-begins data))

(define (add-bodies-to-labels e)
  (match e
    (`(begin . ,ls)
     `(begin . 
             ,(let loop ((ls ls))
                (if (null? ls)
                    '()
                    (match (car ls)
                      (`(label ,l)
                       (let-values (((this-label rest)
                                     (let loop2 ((ls (cdr ls)))
                                       (if (null? ls)
                                           (values '() '())
                                           (match (car ls)
                                             (`(label ,l2)
                                              (values `((goto ,l2)) ls))
                                             (x
                                              (let-values (((this-label2 rest2)
                                                            (loop2 (cdr ls))))
                                                (values (cons x this-label2) rest2))))))))
                         `((label ,l (begin . ,this-label)) . ,(loop rest))))
                      (x `(,x . ,(loop (cdr ls)))))))))
    (_ (error "Bad e" e))))

(set! data (simplify-begins (add-bodies-to-labels data)))

(define (forbid-labels e)
  (match e
    (`(label . ,_) (error 'forbid-labels e))
    (`(goto . ,_) (void))
    (`(expr . ,_) (void))
    (`(if ,p . ,rest) (for-each forbid-labels rest))
    (`(let ,vars ,body) (forbid-labels body))
    (`(begin . ,rest) (for-each forbid-labels rest))
    (`(case ,e . ,rest) (for-each (match-lambda (`(,keys ,body) (forbid-labels body))) rest))
    (_ (error "forbid-errors unrecognized" e))))

(match data (`(begin . ,rest)
             (for-each (match-lambda
                         (`(label ,l ,body) (forbid-labels body))
                         (e (forbid-labels e)))
                       rest)))

;(define (propagate-assignments e)
;  (letrec ((prop 
;            (lambda (e)
;              (match e
;                (`(label ,l ,body)
;                 (let ((al-save al))
;                   (set! al '())
;                   `(begin ,@(dump-assignments al-save) (label ,l ,(prop body)) ,(prop* rest))))
;                (`(goto ,l)
;                 (let ((al-save al))
;                   (set! al '())
;                   `(begin ,@(dump-assignments al-save) (goto ,l) ,(prop* rest))))
;                (`(expr (assign ,var ,val))
;                 (let* ((new-var (gensym var))
;                        (new-val (prop-expr val)))
;                   (set! al (cons (cons var new-var) al))
;                   `(let ((,new-var ,(prop-expr val al))) ,(prop* rest (cons (cons var new-var) al)))))
;                (`(expr ,e) `(expr ,(prop-expr e)))
;                (`(if ,p ,a)
;                 (if (null? rest)
;                     `(if ,(prop p '() al) ,(prop a '() al))
;                     `(begin ,@(dump-assignments al) (if ,(prop p '() '()) ,(prop a '() '())))))
;                (`(if ,p ,a ,b)
;                 (if (null? rest)
;                     `(if ,(prop p '() al) ,(prop a '() al) ,(prop b '() al))
;                     `(begin
;                        ,@(dump-assignments al)
;                        (if ,(prop p '() '()) ,(prop a '() '()) ,(prop b '() '())))))
;                (`(begin . ,rest2)
;                 (prop* (append rest2 rest) al))
;                (`(let ,vars ,body)
;                 
;                
;           (prop*
;            (lambda (e* al)
;              (if (null? e*)
;                  `(begin ,@(dump-assignments al))
;                  (prop (car e*) (cdr e*) al))))
;           (prop-expr
;            (lambda (e al)
;              (cond
;                ((symbol? e) (let ((p (assq e al))) (if p (cdr p) e)))
;                ((list? e) (cons (car e) (map (lambda (e2) (prop-expr e2 al)) (cdr e))))
;                (else e)))))
;    (prop e '() '())))

(define (conditionalize e cond negate)
  (match e
    (`(begin . ,ls) `(begin . ,(map (lambda (e2) (conditionalize e2 cond negate)) ls)))
    (`(expr (assign ,e1 ,e2))
     (if negate
         `(expr (assign ,e1 (if-e ,cond ,e1 ,e2)))
         `(expr (assign ,e1 (if-e ,cond ,e2 ,e1)))))
    (_ (error "Cannot conditionalize" e))))

(define (split-ifs e)
  (match e
    (`(if ,_ (goto ,_) (goto ,_)) e)
    (`(if ,_ (goto ,_)) e)
    (`(if (expr ,p) ,a ,b)
     (let ((var (gensym 'pred)))
       `(let ((,var ,p))
          (begin
            ,(conditionalize a var #f)
            ,(conditionalize b var #t)))))
    (`(if (expr ,p) ,a)
     (let ((var (gensym 'pred)))
       `(let ((,var ,p))
          ,(conditionalize a var #f))))
    (`(begin . ,rest) `(begin . ,(map split-ifs rest)))
    (`(expr . ,_) e)
    (`(let ,vars ,body) `(let ,vars ,(split-ifs body)))
    (`(label ,l ,body) `(label ,l ,(split-ifs body)))
    (`(goto ,l) e)
    (`(case ,k . ,body*) `(case ,k . ,(map (match-lambda (`(,keys ,body) `(,keys ,(split-ifs body)))) body*)))
    (_ (error "split-ifs" e))))

(set! data (simplify-begins (split-ifs data)))

(define (split-begin-for-let-folding e*)
  (match e*
    (`() (values '() '()))
    (`((if . ,i) . ,rest)
     (let-values (((first-chunk others) (split-begin-for-let-folding rest)))
       (values '() `(((if . ,i)) ,first-chunk . ,others))))
    (`((label ,l ,body) . ,rest)
     (let-values (((first-chunk others) (split-begin-for-let-folding rest)))
       (values '() `(((label ,l ,body)) ,first-chunk . ,others))))
    (`((goto ,l) . ,rest)
     (let-values (((first-chunk others) (split-begin-for-let-folding rest)))
       (values '() `(((goto ,l)) ,first-chunk . ,others))))
    (`((begin . ,rest1) . ,rest) (split-begin-for-let-folding (append rest1 rest)))
    (`((expr ,e) . ,rest)
     (let-values (((first-chunk others) (split-begin-for-let-folding rest)))
       (values (cons `(expr ,e) first-chunk) others)))
    (`((let ,vars ,body) . ,rest)
     (let-values (((first-chunk others) (split-begin-for-let-folding rest)))
       (values (cons `(let ,vars ,body) first-chunk) others)))
    (_ (error "split-begin-for-let-folding" e*))))

(define (fold-lets-one-chunk e*)
  (if (null? e*)
      `(begin)
      (match (car e*)
        (`(begin . ,rest)
         (let-values (((first-chunk others) (split-begin-for-let-folding (append rest (cdr e*)))))
           (if (null? first-chunk)
               `(begin . ,(map fold-lets-one-chunk others))
               `(begin ,(fold-lets-one-chunk first-chunk) . ,(map fold-lets-one-chunk others)))))
        (`(let ,vars ,body)
         `(let ,vars ,(fold-lets-one-chunk (cons body e*))))
        (`(expr ,e) `(begin (expr ,e) ,(fold-lets-one-chunk (cdr e*))))
        (`(goto ,l) `(begin (goto ,l) ,(fold-lets-one-chunk (cdr e*))))
        (`(label ,l ,body) `(begin (label ,l ,(fold-lets body)) ,(fold-lets-one-chunk (cdr e*))))
        (`(if ,p ,a ,b) `(begin (if ,p ,a ,b) ,(fold-lets-one-chunk (cdr e*))))
        (`(case ,k . ,cases) `(begin (case ,k . ,cases) ,(fold-lets-one-chunk (cdr e*))))
        (e (error "fold-lets-one-chunk" e)))))

(define (fold-lets e)
  (fold-lets-one-chunk (list e)))

(set! data (simplify-begins (fold-lets data)))

(pretty-print data)
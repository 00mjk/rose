(require (lib "pretty.ss"))
(require (lib "match.ss"))
(require (lib "1.ss" "srfi"))

(define data (with-input-from-file "/home/willcock2/rose-svn-checkout/build/projects/assemblyToSourceAst/fnord.ss" read))

(define (simplify-begins t)
  (match t
    (`(begin . ,ls)
     (let* ((fixed-ls (map simplify-begins ls))
            (fixed-ls2 (append-map (match-lambda (`(begin . ,ls2) ls2) (x (list x))) fixed-ls)))
       (if (= (length fixed-ls2) 1)
           (car fixed-ls2)
           `(begin . ,fixed-ls2))))
    (`(expr . ,_) t)
    (`(parallel-assign . ,_) t)
    (`(goto . ,_) t)
    (`(label ,_) t)
    (`(label ,l ,body) `(label ,l ,(simplify-begins body)))
    (`(if ,p ,a ,b) `(if ,p ,(simplify-begins a) ,(simplify-begins b)))
    (`(if ,p ,a) `(if ,p ,(simplify-begins a)))
    (`(let ,vars . ,body*)
     (let ((fixed-body (simplify-begins `(begin . ,body*))))
       `(let ,vars ,fixed-body)))
    (`(case ,expr . ,body*) `(case ,expr . ,body*))
    (_ (error "Bad input" t))))

(set! data (simplify-begins data))

(define (add-bodies-to-labels e)
  (match e
    (`(begin . ,ls)
     `(begin . 
             ,(let loop ((ls ls))
                (if (null? ls)
                    '()
                    (match (car ls)
                      (`(label ,l)
                       (let-values (((this-label rest)
                                     (let loop2 ((ls (cdr ls)))
                                       (if (null? ls)
                                           (values '() '())
                                           (match (car ls)
                                             (`(label ,l2)
                                              (values `((goto ,l2)) ls))
                                             (x
                                              (let-values (((this-label2 rest2)
                                                            (loop2 (cdr ls))))
                                                (values (cons x this-label2) rest2))))))))
                         `((label ,l (begin . ,this-label)) . ,(loop rest))))
                      (x `(,x . ,(loop (cdr ls)))))))))
    (_ (error "Bad e" e))))

(set! data (simplify-begins (add-bodies-to-labels data)))

(define (forbid-labels e)
  (match e
    (`(label . ,_) (error "forbid-labels" e))
    (`(goto . ,_) (void))
    (`(expr . ,_) (void))
    (`(if ,p . ,rest) (for-each forbid-labels rest))
    (`(let ,vars ,body) (forbid-labels body))
    (`(begin . ,rest) (for-each forbid-labels rest))
    (`(case ,e . ,rest) (for-each (match-lambda (`(,keys ,body) (forbid-labels body))) rest))
    (_ (error "forbid-errors unrecognized" e))))

(match data (`(begin . ,rest)
             (for-each (match-lambda
                         (`(label ,l ,body) (forbid-labels body))
                         (e (forbid-labels e)))
                       rest)))

(define (conditionalize e cond negate)
  (match e
    (`(begin . ,ls) `(begin . ,(map (lambda (e2) (conditionalize e2 cond negate)) ls)))
    (`(expr (assign ,e1 ,e2))
     (if negate
         `(expr (assign ,e1 (if-e ,cond ,e1 ,e2)))
         `(expr (assign ,e1 (if-e ,cond ,e2 ,e1)))))
    (_ (error "Cannot conditionalize" e))))

(define (split-ifs e)
  (match e
    (`(if ,_ (goto ,_) (goto ,_)) e)
    (`(if ,_ (goto ,_)) e)
    (`(if (expr ,p) ,a ,b)
     (let ((var (gensym 'pred)))
       `(let ((,var ,p))
          (begin
            ,(conditionalize a var #f)
            ,(conditionalize b var #t)))))
    (`(if (expr ,p) ,a)
     (let ((var (gensym 'pred)))
       `(let ((,var ,p))
          ,(conditionalize a var #f))))
    (`(begin . ,rest) `(begin . ,(map split-ifs rest)))
    (`(expr . ,_) e)
    (`(let ,vars ,body) `(let ,vars ,(split-ifs body)))
    (`(label ,l ,body) `(label ,l ,(split-ifs body)))
    (`(goto ,l) e)
    (`(case ,k . ,body*) `(case ,k . ,(map (match-lambda (`(,keys ,body) `(,keys ,(split-ifs body)))) body*)))
    (_ (error "split-ifs" e))))

(set! data (simplify-begins (split-ifs data)))

(set! data (cdr data)) ; Remove starting begin

(define (change-to-pure-memory e)
  (letrec ((change-expr
            (lambda (e)
              (cond
                ((symbol? e) e)
                ((number? e) e)
                ((boolean? e) e)
                ((list? e)
                 (match e
                   (`(memoryReadDWord ,a) `(memoryReadDWord memory ,(change-expr a)))
                   (`(memoryReadWord ,a) `(memoryReadWord memory ,(change-expr a)))
                   (`(memoryReadByte ,a) `(memoryReadByte memory ,(change-expr a)))
                   (`(,f . ,args) `(,f . ,(map change-expr args)))))
                (else (error "change-expr" e))))))
  (match e
    (`(label ,l ,body)
     `(label ,l ,(change-to-pure-memory body)))
    (`(goto ,l) `(goto ,l))
    (`(if ,p . ,rest) `(if ,(change-expr p) . ,rest))
    (`(case ,key . ,rest) `(case ,(change-expr key) . ,rest))
    (`(begin . ,rest) `(begin . ,(map change-to-pure-memory rest)))
    (`(let ((,var ,val)) ,body) `(let ((,var ,(change-expr val))) ,(change-to-pure-memory body)))
    (`(expr (memoryWriteDWord ,a ,d)) `(expr (assign memory (memoryWriteDWord memory ,(change-expr a) ,(change-expr d)))))
    (`(expr (memoryWriteWord ,a ,d)) `(expr (assign memory (memoryWriteWord memory ,(change-expr a) ,(change-expr d)))))
    (`(expr (memoryWriteByte ,a ,d)) `(expr (assign memory (memoryWriteByte memory ,(change-expr a) ,(change-expr d)))))
    (`(expr ,e) `(expr ,(change-expr e)))
    (_ (error "change-to-pure-memory" e)))))

(set! data (map change-to-pure-memory data))

(define (fold-lets e)
  (letrec ((loop
            (lambda (e al as) ; as is list of assignment pairs
              (match e
                (`(begin) (writeout as))
                (`(begin (begin . ,rest1) . ,rest2) (loop `(begin ,@rest1 ,@rest2) al as))
                (`(begin (let ,vars ,body) . ,rest) (loop `(let ,vars (begin ,body . ,rest)) al as))
                (`(begin (if ,p ,a ,b) . ,rest) (loop `(if ,p (begin ,a . ,rest) (begin ,b . ,rest)) al as))
                (`(let ((,var ,val)) ,body)
                 (let ((new-var (gensym var)))
                   `(let ((,new-var ,(remap val al))) ,(loop body `((,var . ,new-var) . ,al) as))))
                (`(if ,p ,a ,b)
                 `(if ,(remap p al)
                      ,(loop a al as)
                      ,(loop b al as)))
                (`(begin (expr (assign ,a ,b)) . ,rest)
                 (let ((new-var (gensym a)))
                   `(let ((,new-var ,(remap b al))) ,(loop `(begin . ,rest)
                                                           `((,a . ,new-var) . ,al)
                                                           `((,a . ,new-var) . ,as)))))
                (`(begin (parallel-assign ,as2) . ,rest)
                 (let ((new-var* (map (match-lambda (`(,a . ,b) (gensym a))) as2)))
                   (let l ((asx as2) (nv new-var*))
                     (if (null? asx)
                         (loop `(begin . ,rest)
                               (append (map (match-lambda* (`((,a . ,b) ,n) (cons a n))) as2 new-var*) al)
                               (append (map (match-lambda* (`((,a . ,b) ,n) (cons a n))) as2 new-var*) as))
                         `(let ((,(car nv) ,(remap (cdar asx) al)))
                            ,(l (cdr asx) (cdr nv)))))))
                (`(expr . ,_) (loop `(begin ,e) al as))
                (`(parallel-assign ,_) (loop `(begin ,e) al as))
                (`(case ,key . ,cases)
                 `(case ,(remap key al)
                    ,@(map (match-lambda (`(,k ,body) `(,k ,(loop body al as)))) cases)))
                (`(begin (expr (abort)) . ,_) `(expr (abort)))
                (`(begin (expr (interrupt ,i)) . ,rest)
                 `(begin (expr (interrupt ,i)) ,(loop `(begin . ,rest) al as)))
                (`(begin (case ,key . ,cases) . ,rest)
                 (loop `(case ,key . ,(map (match-lambda (`(,k ,body) `(,k (begin ,body . ,rest)))) cases))
                       al as))
                (`(goto ,l) `(begin ,(writeout as) (goto ,l)))
                (`(label ,l ,body) `(label ,l ,(loop body al as)))
                (`(begin (goto ,l) . ,_) (loop `(goto ,l) al as))
                (`(begin ,x) (loop x al as))
                (_ (error "fold-lets-3" e)))))
           (remap (lambda (e al)
                    (cond
                      ((symbol? e) (let ((p (assq e al))) (if p (cdr p) e)))
                      ((list? e) (cons (car e) (map (lambda (x) (remap x al)) (cdr e))))
                      (else e))))
           (writeout (lambda (as)
                       (if (null? as)
                           '(begin)
                           `(parallel-assign
                             ,(let l ((as as))
                                (if (null? as)
                                    '()
                                    (let ((a (caar as)) (b (cdar as)))
                                      `((,a . ,b)
                                        .
                                        ,(l (filter (match-lambda (`(,a2 . ,_) (not (eq? a a2))))
                                                    (cdr as))))))))))))
    (loop e '() '())))

(set! data (map fold-lets data))

(define (copy-and-constant-prop e al simple?)
  ;(pretty-print `(copy-and-constant-prop ,e ,al ,simple?))
  (letrec ((subst-expr
            (lambda (e al)
              (if (list? e)
                  (cons (car e) (map (lambda (e2) (subst-expr e2 al)) (cdr e)))
                  (if (symbol? e)
                      (let ((p (assq e al))) (if p (cdr p) e))
                      e)))))
  (match e
    (`(begin . ,rest) `(begin . ,(map (lambda (e) (copy-and-constant-prop e al simple?)) rest)))
    (`(let ((,var ,val)) ,body)
     (let ((val (subst-expr val al)))
       (if (simple? val)
           (copy-and-constant-prop body `((,var . ,val) . ,al) simple?)
           `(let ((,var ,val)) ,(copy-and-constant-prop body al simple?)))))
    (`(expr ,e) `(expr ,(subst-expr e al)))
    (`(parallel-assign ,al2) `(parallel-assign ,(map (match-lambda (`(,e1 . ,e2) `(,(subst-expr e1 al) . ,(subst-expr e2 al)))) al2)))
    (`(label ,l ,body) `(label ,l ,(copy-and-constant-prop body al simple?)))
    (`(goto . ,_) e)
    (`(if ,p ,a ,b) `(if ,(subst-expr p al) ,(copy-and-constant-prop a al simple?) ,(copy-and-constant-prop b al simple?)))
    (`(case ,key . ,cases) `(case ,(subst-expr key al)
                              ,@(map (match-lambda (`(,k* ,body) `(,k* ,(copy-and-constant-prop body al simple?))))
                                     cases)))
    (_ (error "copy-and-constant-prop" e)))))

(define (basic-simple? x) (or (number? x) (boolean? x) (symbol? x)))
(define (always-simple? x) #t)

(set! data (map (lambda (e) (copy-and-constant-prop e '() basic-simple?)) data))

(define (change-to-let* e)
  (match e
    (`(begin . ,rest) `(begin . ,(map change-to-let* rest)))
    (`(let ,vars ,body)
     (match (change-to-let* body)
       (`(let* ,vars2 ,body2) `(let* ,(append vars vars2) ,body2))
       (b `(let* ,vars ,b))))
    (`(expr (assign ,a ,b)) e)
    (`(parallel-assign . ,al) e)
    (`(expr (abort)) e)
    (`(expr (interrupt ,_)) e)
    (`(goto . ,_) e)
    (`(if ,p ,a ,b) `(if ,p ,(change-to-let* a) ,(change-to-let* b)))
    (`(case ,key . ,cases) `(case ,key . ,(map (match-lambda (`(,k* ,body) `(,k* ,(change-to-let* body)))) cases)))
    (`(label ,l ,body) `(label ,l ,(change-to-let* body)))
    (_ (error "change-to-let*" e))))

; (set! data (map change-to-let* data))

(define (get-used-variables e)
  (letrec ((g (lambda (e)
                (cond
                  ((symbol? e) (list e))
                  ((list? e) (apply lset-union eq? (map g (cdr e))))
                  (else '())))))
    (match e
      (`(begin . ,rest) (apply lset-union eq? (map get-used-variables rest)))
      (`(let ((,var ,val)) ,body)
       (let ((x (get-used-variables body)))
         (if (memq var x)
             (lset-union eq? (g val) (lset-difference eq? x (list var)))
             x)))
      (`(goto ,_) '())
      (`(if ,p ,a ,b) (lset-union eq? (g p) (get-used-variables a) (get-used-variables b)))
      (`(case ,key . ,cases)
       (apply lset-union eq? (g key) (map (match-lambda (`(,k ,body) (get-used-variables body))) cases)))
      (`(parallel-assign ,al) (apply lset-union eq? (map g (map cdr al))))
      (`(expr ,e) (g e))
      (_ (error "get-used-variables" e)))))

(define (remove-unused-variables e)
  (match e
    (`(begin . ,rest) `(begin . ,(map remove-unused-variables rest)))
    (`(let ((,var ,val)) ,body)
     (let ((x (get-used-variables body)))
       (if (memq var x)
           `(let ((,var ,val)) ,(remove-unused-variables body))
           (remove-unused-variables body))))
    (`(goto ,_) e)
    (`(label ,l ,body) `(label ,l ,(remove-unused-variables body)))
    (`(if ,p ,a ,b) `(if ,p ,(remove-unused-variables a) ,(remove-unused-variables b)))
    (`(case ,key . ,cases)
     `(case ,key . ,(map (match-lambda (`(,k ,body) `(,k ,(remove-unused-variables body)))) cases)))
    (`(parallel-assign ,al) e)
    (`(expr ,_) e)
    (_ (error "remove-unused-variables" e))))

(define (split-and-value-number e)
  ;(pretty-print `(split-and-value-number ,e))
  (let ((exprs-known '()))
    (letrec ((split-expr
              (lambda (expr k)
                ;(pretty-print `(split-expr ,expr ,exprs-known))
                (cond
                  ((and (list? expr) (ormap list? (cdr expr)))
                   (let* ((first-list (find list? (cdr expr))))
                     (split-expr first-list
                                 (lambda (fl2)
                                   (let ((plugged-in (cons (car expr)
                                                           (map (lambda (e)
                                                                  (if (equal? e first-list) fl2 e))
                                                                (cdr expr)))))
                                     (split-expr plugged-in k))))))
                  ((assoc expr exprs-known) => (lambda (p) (k (cdr p))))
                  ((list? expr)
                   (let ((var (gensym 'temp)))
                     (set! exprs-known (cons (cons expr var) exprs-known))
                     `(let ((,var ,expr)) ,(k var))))
                  (else (k expr))))))
      (match e
        (`(label ,l ,body)
         `(label ,l ,(split-and-value-number body)))
        (`(let ((,v ,def)) ,body)
         (split-expr def (lambda (def2) `(let ((,v ,def2)) ,(split-and-value-number body)))))
        (`(expr (assign ,a ,b))
         (split-expr b (lambda (b2) `(expr (assign ,a ,b2)))))
        (`(expr (abort)) e)
        (`(expr (interrupt ,i)) e)
        (`(parallel-assign ,pairs)
         (let loop ((pairs pairs) (acc-rev '()))
           (match pairs
             (`() `(parallel-assign ,(reverse acc-rev)))
             (`((,var1 . ,def1) . ,rest)
              (split-expr def1 (lambda (def2) (loop rest `((,var1 . ,def2) . ,acc-rev))))))))
        (`(begin . ,ls) `(begin . ,(map split-and-value-number ls)))
        (`(if (expr ,p) ,a ,b)
         (split-expr p (lambda (p2) `(if (expr ,p2) ,(split-and-value-number a) ,(split-and-value-number b)))))
        (`(case (expr ,p) . ,cases)
         (split-expr p (lambda (p2)
                         `(case (expr ,p2)
                            . ,(map (match-lambda (`(,keys ,body) `(,keys ,(split-and-value-number body))))
                                    cases)))))
        (`(goto ,l) `(goto ,l))
        (else (error "split-and-value-number" e))))))

(define ((term-with-functor? f) t)
  (and (list? t) (eq? (car t) f)))

(define ((associative-list f id) t)
  (if ((term-with-functor? f) t) (cdr t) (if (equal? t id) '() (list t))))

(define ((flatten-assoc f id) t)
  (let ((result
         (if ((term-with-functor? f) t)
             (let ((ls (append-map (associative-list f id) (cdr t))))
               (cond
                 ((null? ls) id)
                 ((null? (cdr ls)) (car ls))
                 (else (cons f ls))))
             t)))
    (if (equal? result t) #f result)))

(define ((flatten-idem f) t)
  (and ((term-with-functor? f) t)
       (let ((tl (delete-duplicates (cdr t) equal?)))
         (if (equal? tl (cdr t))
             #f
             (cons (car t) tl)))))

(define ((flatten-zero f z) t)
  (and ((term-with-functor? f) t)
       (member z (cdr t))
       z))

(define (simplify-expr e)
  (letrec ((simp
            (lambda (e)
              (if (boolean? e)
                  (if e 1 0)
                  (or
                   (match e (`(subtract ,a ,b) `(add ,a (negate ,b))) (_ #f))
                   (match e (`(negate ,x) (and (number? x) (if (zero? x) 0 (- (expt 2 32) x)))) (_ #f))
                   (match e (`(negate (negate ,x)) x) (_ #f))
                   ((flatten-assoc 'add 0) e)
                   ((flatten-assoc 'and (- (expt 2 32) 1)) e)
                   ((flatten-zero 'and 0) e)
                   ((flatten-idem 'and) e)
                   ((flatten-assoc 'or 0) e)
                   ((flatten-idem 'or) e)
                   ((flatten-zero 'or (- (expt 2 32) 1)) e)
                   ((flatten-assoc 'xor 0) e)
                   ((flatten-assoc 'logical-and 1) e)
                   ((flatten-idem 'logical-and) e)
                   ((flatten-zero 'logical-and 0) e)
                   ((flatten-assoc 'logical-or 0) e)
                   ((flatten-idem 'logical-or) e)
                   ((flatten-zero 'logical-or 1) e)
                   (match e (`(logical-not ,x) (and (number? x) (if (zero? x) 1 0))) (_ #f))
                   (match e (`(xor ,a ,b) (and (equal? a b) 0)) (_ #f))
                   (match e (`(memoryWriteDWord ,m1 ,a (memoryReadDWord ,m2 ,b)) (and (equal? m1 m2) (equal? a b) m2)) (_ #f))
                   (match e
                     (`(memoryReadDWord (memoryWriteDWord ,m ,a ,v) ,b)
                      `(if-e (equal ,a ,b)
                             ,v
                             (memoryReadDWord ,m ,b))) ; FIXME
                     (_ #f))
                   (match e
                     (`(add . ,ls) (and (>= (length (filter number? ls)) 2)
                                        `(add ,@(filter (lambda (x) (not (number? x))) ls)
                                              ,(remainder (apply + (filter number? ls)) (expt 2 32)))))
                     (_ #f))
                   (match e
                     (`(and . ,ls) (and (>= (length (filter number? ls)) 2)
                                        `(and ,@(filter (lambda (x) (not (number? x))) ls)
                                              ,(apply bitwise-and (filter number? ls)))))
                     (_ #f))
                   (match e
                     (`(xor . ,ls) (and (>= (length (filter number? ls)) 2)
                                        `(xor ,@(filter (lambda (x) (not (number? x))) ls)
                                              ,(apply bitwise-xor (filter number? ls)))))
                     (_ #f))
                   (match e
                     (`(equal (add ,a1 . ,rest1) (add ,a2 . ,rest2)) (and (equal? a1 a2) `(equal (add . ,rest1) (add . ,rest2))))
                     (_ #f))
                   (match e 
                     (`(equal ,a ,b)
                      (cond
                        ((equal? a b) 1)
                        ((and (number? a) (number? b)) (if (= a b) 1 0))
                        (else #f)))
                     (_ #f))
                   (match e 
                     (`(less-than ,a ,b)
                      (cond
                        ((equal? a b) 0)
                        ((and (number? a) (number? b)) (if (< a b) 1 0))
                        ((and (number? b) (zero? b)) 0)
                        (else #f)))
                     (_ #f))
                   (match e (`(not-equal ,a ,b) `(logical-not (equal ,a ,b))) (_ #f))
                   (match e
                     (`(parity ,n) (and (number? n)
                                        (let parity ((n (bitwise-and n 255)))
                                          (cond
                                            ((zero? n) 1)
                                            ((odd? n) (- 1 (parity (/ (sub1 n) 2))))
                                            (else (parity (/ n 2)))))))
                     (_ #f))
                   (if (list? e) (cons (car e) (map simp (cdr e))) e))))))
    (let loop ((e e))
      (let ((new-e (simp e)))
        (if (equal? e new-e) new-e (loop new-e))))))

(define (simplify e)
  (match e
    (`(begin . ,rest) `(begin . ,(map simplify rest)))
    (`(let ((,var ,val)) ,body)
     `(let ((,var ,(simplify-expr val))) ,(simplify body)))
    (`(goto ,_) e)
    (`(label ,l ,body) `(label ,l ,(simplify body)))
    (`(if ,p ,a ,b) `(if ,(simplify p) ,(simplify a) ,(simplify b)))
    (`(case ,key . ,cases)
     `(case ,(simplify key) . ,(map (match-lambda (`(,k ,body) `(,k ,(simplify body)))) cases)))
    (`(parallel-assign ,al)
     `(parallel-assign ,(map (match-lambda (`(,lhs . ,rhs) `(,lhs . ,(simplify-expr rhs)))) al)))
    (`(expr ,e) `(expr ,(simplify-expr e)))
    (_ (error "simplify" e))))

(define (init-code) `(begin . ,(filter (match-lambda (`(label . ,_) #f) (_ #t)) data)))
(define (get-label l) (or (ormap (match-lambda (`(label ,l2 ,body) (if (eq? l l2) body #f)) (_ #f)) data) (error "Label not found" l)))

(define (expand-one e)
  (match e
    (`(goto ,l) (get-label l))
    (`(label ,l ,body) `(label ,l ,(expand-one body)))
    (`(if ,p ,a ,b) `(if ,p ,(expand-one a) ,(expand-one b)))
    (`(case ,k . ,cases) `(case ,k . ,(map (match-lambda (`(,keys ,e) `(,keys ,(expand-one e)))) cases)))
    (`(expr . ,_) e)
    (`(parallel-assign . ,_) e)
    (`(begin . ,rest) `(begin . ,(map expand-one rest)))
    (`(let ,vars ,body) `(let ,vars ,(expand-one body)))
    (_ (error "expand-one" e))))

(define (loop-simplify-and-ccp e)
  (let* ((e1 (simplify e))
         (e2 (copy-and-constant-prop e1 '() basic-simple?)))
    (if (equal? e2 e)
        e
        (loop-simplify-and-ccp e2))))

(define (memory-simple? x)
  (or (basic-simple? x)
      (and (list? x)
           (memq (car x) '(memoryWriteDWord memoryWriteWord memoryWriteByte)))))

(define (simplify-full e)
  (remove-unused-variables
   (copy-and-constant-prop
    (split-and-value-number
     (loop-simplify-and-ccp
      (simplify-begins
       (remove-unused-variables
        (copy-and-constant-prop
         (fold-lets e)
         '()
         memory-simple?)))))
    '()
    basic-simple?)))

(define (expand-one-simp e) (simplify-full (expand-one e)))

(define (expand-many n e)
  (if (zero? n) e (expand-one-simp (expand-many (sub1 n) e))))

; (pretty-print (change-to-let* (map expand-one-simp data)))
; (for-each (lambda (x) (pretty-print (change-to-let* (copy-and-constant-prop x '() always-simple?)))) data)
(for-each (lambda (x) (pretty-print (change-to-let* (simplify-full x)))) data)
; (for-each (lambda (x) (pretty-print (change-to-let* (split-and-value-number x)))) data)
; (pretty-print (map change-to-let* (map simplify-full data)))
;

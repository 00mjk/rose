(module bmc scheme
(require (only-in (lib "mzscheme") fluid-let))
(require scheme/pretty)
(require scheme/match)
(require srfi/1)
(require "bitblast.ss")

(define data (with-input-from-file "/home/willcock2/rose-svn-checkout/to-build/projects/assemblyToSourceAst/fnord.ss" read))

(define (simplify-begins t)
  (match t
    (`(begin . ,ls)
     (let* ((fixed-ls (map simplify-begins ls))
            (fixed-ls2 (append-map (match-lambda (`(begin . ,ls2) ls2) (x (list x))) fixed-ls)))
       (if (= (length fixed-ls2) 1)
           (car fixed-ls2)
           `(begin . ,fixed-ls2))))
    (`(expr . ,_) t)
    (`(parallel-assign . ,_) t)
    (`(goto . ,_) t)
    (`(label ,_) t)
    (`(label ,l ,body) `(label ,l ,(simplify-begins body)))
    (`(if ,p ,a ,b) `(if ,p ,(simplify-begins a) ,(simplify-begins b)))
    (`(if ,p ,a) `(if ,p ,(simplify-begins a) (begin)))
    (`(let ((,t ,var ,val)) . ,body*)
     (let ((fixed-body (simplify-begins `(begin . ,body*))))
       `(let ((,t ,var ,val)) ,fixed-body)))
    (`(case ,expr . ,body*) `(case ,expr . ,body*))
    (_ (error "Bad input" t))))

(set! data (simplify-begins data))

(define (add-bodies-to-labels e)
  (match e
    (`(begin . ,ls)
     `(begin . 
             ,(let loop ((ls ls))
                (if (null? ls)
                    '()
                    (match (car ls)
                      (`(label ,l)
                       (let-values (((this-label rest)
                                     (let loop2 ((ls (cdr ls)))
                                       (if (null? ls)
                                           (values '() '())
                                           (match (car ls)
                                             (`(label ,l2)
                                              (values `((goto ,l2)) ls))
                                             (x
                                              (let-values (((this-label2 rest2)
                                                            (loop2 (cdr ls))))
                                                (values (cons x this-label2) rest2))))))))
                         `((label ,l (begin . ,this-label)) . ,(loop rest))))
                      (x `(,x . ,(loop (cdr ls)))))))))
    (_ (error "Bad e" e))))

(set! data (simplify-begins (add-bodies-to-labels data)))

(define (forbid-labels e)
  (match e
    (`(label . ,_) (error "forbid-labels" e))
    (`(goto . ,_) (void))
    (`(expr . ,_) (void))
    (`(if ,p . ,rest) (for-each forbid-labels rest))
    (`(let ,vars ,body) (forbid-labels body))
    (`(begin . ,rest) (for-each forbid-labels rest))
    (`(case ,e . ,rest) (for-each (match-lambda (`(,keys ,body) (forbid-labels body))) rest))
    (_ (error "forbid-errors unrecognized" e))))

(match data (`(begin . ,rest)
             (for-each (match-lambda
                         (`(label ,l ,body) (forbid-labels body))
                         (e (forbid-labels e)))
                       rest)))

(define (conditionalize e cond negate)
  (match e
    (`(begin . ,ls) `(begin . ,(map (lambda (e2) (conditionalize e2 cond negate)) ls)))
    (`(expr (assign ,e1 ,e2))
     (if negate
         `(expr (assign ,e1 (if-e ,cond ,e1 ,e2)))
         `(expr (assign ,e1 (if-e ,cond ,e2 ,e1)))))
    (_ (error "Cannot conditionalize" e))))

(define (split-ifs e)
  (match e
    (`(if ,_ (goto ,_) (goto ,_)) e)
    (`(if ,_ (goto ,_)) e)
    (`(if (expr ,p) ,a ,b)
     (let ((var (gensym 'pred)))
       `(let ((bool ,var ,p))
          (begin
            ,(conditionalize a var #f)
            ,(conditionalize b var #t)))))
    (`(if (expr ,p) ,a)
     (let ((var (gensym 'pred)))
       `(let ((bool ,var ,p))
          ,(conditionalize a var #f))))
    (`(begin . ,rest) `(begin . ,(map split-ifs rest)))
    (`(expr . ,_) e)
    (`(let ,vars ,body) `(let ,vars ,(split-ifs body)))
    (`(label ,l ,body) `(label ,l ,(split-ifs body)))
    (`(goto ,l) e)
    (`(case ,k . ,body*) `(case ,k . ,(map (match-lambda (`(,keys ,body) `(,keys ,(split-ifs body)))) body*)))
    (_ (error "split-ifs" e))))

;(set! data (simplify-begins (split-ifs data)))

(set! data (cdr data)) ; Remove starting begin

(define (change-to-pure-memory e)
  (letrec ((change-expr
            (lambda (e)
              (cond
                ((symbol? e) e)
                ((number? e) e)
                ((boolean? e) e)
                ((list? e)
                 (match e
                   (`(memoryReadDWord ,a)
                    `(or (memoryReadByte memory ,(change-expr a))
                         (left-shift (memoryReadByte memory (add 1 ,(change-expr a))) 8)
                         (left-shift (memoryReadByte memory (add 2 ,(change-expr a))) 16)
                         (left-shift (memoryReadByte memory (add 3 ,(change-expr a))) 24)))
                   (`(memoryReadWord ,a)
                    `(or (memoryReadByte memory ,(change-expr a))
                         (left-shift (memoryReadByte memory (add 1 ,(change-expr a))) 8)))
                   (`(memoryReadByte ,a) `(memoryReadByte memory ,(change-expr a)))
                   (`(,f . ,args) `(,f . ,(map change-expr args)))))
                (else (error "change-expr" e))))))
  (match e
    (`(label ,l ,body)
     `(label ,l ,(change-to-pure-memory body)))
    (`(goto ,l) `(goto ,l))
    (`(if ,p . ,rest) `(if ,(change-expr p) . ,rest))
    (`(case ,key . ,rest) `(case ,(change-expr key) . ,rest))
    (`(begin . ,rest) `(begin . ,(map change-to-pure-memory rest)))
    (`(let ((,t ,var ,val)) ,body) `(let ((,t ,var ,(change-expr val))) ,(change-to-pure-memory body)))
    (`(expr (memoryWriteDWord ,a ,d))
     `(begin
        (expr (assign memory (memoryWriteByte memory ,(change-expr a) (and 255 ,(change-expr d)))))
        (expr (assign memory (memoryWriteByte memory (add 1 ,(change-expr a)) (and 255 (right-shift ,(change-expr d) 8)))))
        (expr (assign memory (memoryWriteByte memory (add 2 ,(change-expr a)) (and 255 (right-shift ,(change-expr d) 16)))))
        (expr (assign memory (memoryWriteByte memory (add 3 ,(change-expr a)) (and 255 (right-shift ,(change-expr d) 24)))))))
    (`(expr (memoryWriteWord ,a ,d))
     `(begin
        (expr (assign memory (memoryWriteByte memory ,(change-expr a) (and 255 ,(change-expr d)))))
        (expr (assign memory (memoryWriteByte memory (add 1 ,(change-expr a)) (and 255 (right-shift ,(change-expr d) 8)))))))
    (`(expr (memoryWriteByte ,a ,d))
     `(expr (assign memory (memoryWriteByte memory ,(change-expr a) ,(change-expr d)))))
    (`(expr ,e) `(expr ,(change-expr e)))
    (_ (error "change-to-pure-memory" e)))))

(set! data (map change-to-pure-memory data))

(define (infer-type expr tenv)
  (let ((arith-combine-2 (match-lambda*
                           (`(,x ,x) x)
                           (`(int32_t uint32_t) 'uint32_t)
                           (`(uint32_t int32_t) 'uint32_t)
                           (`(uint64_t uint32_t) 'uint64_t)
                           (`(uint32_t uint64_t) 'uint64_t)
                           (`(uint32_t uint8_t) 'uint32_t)
                           (`(uint32_t uint16_t) 'uint32_t)
                           (`(uint8_t uint32_t) 'uint32_t)
                           (`(uint16_t uint32_t) 'uint32_t)
                           (`(uint8_t uint16_t) 'uint16_t)
                           (`(uint16_t uint8_t) 'uint16_t)
                           (pr (error "arith-combine-2" pr))))
        (type-of-register (lambda (r)
                            (case r
                              ((rax rbx rcx rdx rsi rdi rbp rsp) 'uint32_t)
                              ((df sf of pf cf af zf sf_xor_of zf_or_cf) 'bool)
                              ((memory) '(memory 0))
                              (else (error "type-of-register" r))))))
    (letrec ((arith-combine (lambda t*
                              (cond
                                ((null? t*) (error "arith-combine empty list"))
                                ((null? (cdr t*)) (car t*))
                                (else (arith-combine-2 (car t*) (apply arith-combine (cdr t*))))))))
      (let loop ((expr expr))
        (match expr
          ((? symbol?)
           (let ((p (assq expr tenv)))
             (if p
                 (cdr p)
                 (type-of-register expr))))
          ((? number?) 'uint32_t)
          ((? boolean?) 'bool)
          (`(logical-not ,_) 'bool)
          (`(logical-and . ,_) 'bool)
          (`(logical-or . ,_) 'bool)
          (`(add . ,terms) (apply arith-combine (map loop terms)))
          (`(subtract ,a ,b) (arith-combine (loop a) (loop b)))
          (`(multiply ,a ,b) (arith-combine (loop a) (loop b)))
          (`(mulhi32 ,_ ,_) 'uint32_t)
          (`(imulhi32 ,_ ,_) 'uint32_t)
          (`(div32 ,_ ,_ ,_) 'uint32_t)
          (`(mod32 ,_ ,_ ,_) 'uint32_t)
          (`(idiv32 ,_ ,_ ,_) 'uint32_t)
          (`(imod32 ,_ ,_ ,_) 'uint32_t)
          (`(mulhi16 ,_ ,_) 'uint16_t)
          (`(imulhi16 ,_ ,_) 'uint16_t)
          (`(div16 ,_ ,_ ,_) 'uint16_t)
          (`(mod16 ,_ ,_ ,_) 'uint16_t)
          (`(idiv16 ,_ ,_ ,_) 'uint16_t)
          (`(imod16 ,_ ,_ ,_) 'uint16_t)
          (`(mulhi8 ,_ ,_) 'uint8_t)
          (`(imulhi8 ,_ ,_) 'uint8_t)
          (`(div8 ,_ ,_) 'uint8_t)
          (`(mod8 ,_ ,_) 'uint8_t)
          (`(idiv8 ,_ ,_) 'uint8_t)
          (`(imod8 ,_ ,_) 'uint8_t)
          (`(int32_t ,_) 'int32_t)
          (`(and . ,terms) (apply arith-combine (map loop terms)))
          (`(or . ,terms) (apply arith-combine (map loop terms)))
          (`(xor . ,terms) (apply arith-combine (map loop terms)))
          (`(bsr ,_) 'uint32_t)
          (`(bsf ,_) 'uint32_t)
          (`(not ,a) (loop a))
          (`(minus ,a) (loop a))
          (`(left-shift ,a ,_) (loop a))
          (`(right-shift ,a ,_) (loop a))
          (`(equal ,a ,b) 'bool)
          (`(not-equal ,a ,b) 'bool)
          (`(less-than ,a ,b) 'bool)
          (`(greater-than-or-equal ,a ,b) 'bool)
          (`(parity ,_) 'bool)
          (`(memoryReadByte ,_ ,_) 'uint32_t)
          (`(memoryWriteByte ,m ,_ ,_)
           (match (loop m)
             (`(memory ,i) `(memory ,(add1 i)))
             (mt (error "Bad memory type" mt))))
          (`(if-e ,p ,a ,b) (arith-combine (loop a) (loop b)))
          (_ (error "infer-type" expr)))))))

(define (fold-lets e)
  (letrec ((loop
            (lambda (e al as tenv) ; as is list of assignment pairs
              (match e
                (`(begin) (writeout as))
                (`(begin (begin . ,rest1) . ,rest2) (loop `(begin ,@rest1 ,@rest2) al as tenv))
                (`(begin (let ,vars ,body) . ,rest) (loop `(let ,vars (begin ,body . ,rest)) al as tenv))
                (`(begin (if ,p ,a ,b) . ,rest)
                 (loop `(if ,p (begin ,a . ,rest) (begin ,b . ,rest)) al as tenv))
                (`(let ((,t ,var ,val)) ,body)
                 (let ((new-var (gensym var))
                       (actual-val-type (infer-type val tenv)))
                   `(let ((,t ,new-var ,(remap val al)))
                      ,(loop body
                             `((,var . ,new-var) . ,al)
                             as
                             `((,new-var . ,t) (,var . ,t) . ,tenv)))))
                (`(if ,p ,a ,b)
                 `(if ,(remap p al)
                      ,(loop a al as tenv)
                      ,(loop b al as tenv)))
                (`(begin (expr (assign ,a ,b)) . ,rest)
                 (let* ((new-var (gensym a))
                        (new-b (remap b al))
                        (new-type (infer-type new-b tenv)))
                   `(let ((,new-type ,new-var ,new-b))
                      ,(loop `(begin . ,rest)
                             `((,a . ,new-var) . ,al)
                             `((,a . ,new-var) . ,as)
                             `((,new-var . ,new-type) . ,tenv)))))
                (`(begin (parallel-assign ,as2) . ,rest)
                 (let ((new-var* (map (match-lambda (`(,a . ,b) (gensym a))) as2)))
                   (let l ((asx as2) (nv new-var*)
                                     (t* (map (match-lambda (`(,a . ,b) (infer-type a tenv))) as2)))
                     (if (null? asx)
                         (loop `(begin . ,rest)
                               (append (map (match-lambda* (`((,a . ,b) ,n) (cons a n))) as2 new-var*) al)
                               (append (map (match-lambda* (`((,a . ,b) ,n) (cons a n))) as2 new-var*) as)
                               (append (map (match-lambda* (`((,a . ,b) ,t) (cons b t))) as2 t*) tenv))
                         `(let ((,(infer-type (car nv) tenv) ,(car nv) ,(remap (cdar asx) al)))
                            ,(l (cdr asx) (cdr nv)))))))
                (`(expr . ,_) (loop `(begin ,e) al as tenv))
                (`(parallel-assign ,_) (loop `(begin ,e) al as tenv))
                (`(case ,key . ,cases)
                 `(case ,(remap key al)
                    ,@(map (match-lambda (`(,k ,body) `(,k ,(loop body al as tenv)))) cases)))
                (`(begin (expr (abort)) . ,_) `(expr (abort)))
                (`(begin (expr (interrupt ,i)) . ,rest)
                 `(begin (expr (interrupt ,i)) ,(loop `(begin . ,rest) al as tenv)))
                (`(begin (case ,key . ,cases) . ,rest)
                 (loop `(case ,key . ,(map (match-lambda (`(,k ,body) `(,k (begin ,body . ,rest)))) cases))
                       al as tenv))
                (`(goto ,l) `(begin ,(writeout as) (goto ,l)))
                (`(label ,l ,body) `(label ,l ,(loop body al as tenv)))
                (`(begin (goto ,l) . ,_) (loop `(goto ,l) al as tenv))
                (`(begin ,x) (loop x al as tenv))
                (_ (error "fold-lets-3" e)))))
           (remap (lambda (e al)
                    (cond
                      ((symbol? e) (let ((p (assq e al))) (if p (cdr p) e)))
                      ((list? e) (cons (car e) (map (lambda (x) (remap x al)) (cdr e))))
                      (else e))))
           (writeout (lambda (as)
                       (if (null? as)
                           '(begin)
                           `(parallel-assign
                             ,(let l ((as as))
                                (if (null? as)
                                    '()
                                    (let ((a (caar as)) (b (cdar as)))
                                      `((,a . ,b)
                                        .
                                        ,(l (filter (match-lambda (`(,a2 . ,_) (not (eq? a a2))))
                                                    (cdr as))))))))))))
    (loop e '() '() '())))

(set! data (map fold-lets data))

(define (basic-simple? x) (or (number? x) (boolean? x) (symbol? x)))
(define (always-simple? x) #t)
(define (memory-simple? x)
  (or (basic-simple? x)
      (and (list? x)
           (memq (car x) '(memoryWriteDWord memoryWriteWord memoryWriteByte)))))

(define (annotate-types e tenv)
  `(,(infer-type e tenv) . ,(if (list? e) 
                                (cons (car e) (map (lambda (e2) (annotate-types e2 tenv)) (cdr e)))
                                e)))


(define (copy-and-constant-prop e al simple?)
  ;(pretty-print `(copy-and-constant-prop ,e ,al ,simple?))
  (letrec ((subst-expr
            (lambda (e al)
              (if (list? e)
                  (cons (car e) (map (lambda (e2) (subst-expr e2 al)) (cdr e)))
                  (if (symbol? e)
                      (let ((p (assq e al))) (if p (cddr p) e))
                      e)))))
  (match e
    (`(begin . ,rest) `(begin . ,(map (lambda (e) (copy-and-constant-prop e al simple?)) rest)))
    (`(let ((,t ,var ,val)) ,body)
     (let ((val (subst-expr val al)))
       (if (simple? val)
           (copy-and-constant-prop body `((,var ,t . ,val) . ,al) simple?)
           `(let ((,t ,var ,val)) ,(copy-and-constant-prop body al simple?)))))
    (`(expr ,e) `(expr ,(subst-expr e al)))
    (`(parallel-assign ,al2) `(parallel-assign ,(map (match-lambda (`(,e1 . ,e2) `(,(subst-expr e1 al) . ,(subst-expr e2 al)))) al2)))
    (`(label ,l ,body) `(label ,l ,(copy-and-constant-prop body al simple?)))
    (`(goto . ,_) e)
    (`(if ,p ,a ,b) `(if ,(subst-expr p al) ,(copy-and-constant-prop a al simple?) ,(copy-and-constant-prop b al simple?)))
    (`(case ,key . ,cases) `(case ,(subst-expr key al)
                              ,@(map (match-lambda (`(,k* ,body) `(,k* ,(copy-and-constant-prop body al simple?))))
                                     cases)))
    (_ (error "copy-and-constant-prop" e)))))

(set! data (map (lambda (e) (copy-and-constant-prop e '() basic-simple?)) data))

(define (change-to-let* e)
  (match e
    (`(begin . ,rest) `(begin . ,(map change-to-let* rest)))
    (`(let ,vars ,body)
     (match (change-to-let* body)
       (`(let* ,vars2 ,body2) `(let* ,(append vars vars2) ,body2))
       (b `(let* ,vars ,b))))
    (`(expr (assign ,a ,b)) e)
    (`(parallel-assign . ,al) e)
    (`(expr (abort)) e)
    (`(expr (interrupt ,_)) e)
    (`(goto . ,_) e)
    (`(if ,p ,a ,b) `(if ,p ,(change-to-let* a) ,(change-to-let* b)))
    (`(case ,key . ,cases) `(case ,key . ,(map (match-lambda (`(,k* ,body) `(,k* ,(change-to-let* body)))) cases)))
    (`(label ,l ,body) `(label ,l ,(change-to-let* body)))
    (_ (error "change-to-let*" e))))

; (set! data (map change-to-let* data))

(define (is-used-variable? var e)
  (letrec ((g (lambda (e)
                (cond
                  ((symbol? e) (eq? e var))
                  ((list? e) (ormap g (cdr e)))
                  (else #f)))))
    (let loop ((e e))
      (match e
        (`(begin . ,rest) (ormap loop rest))
        (`(let ((,t ,var2 ,val)) ,body)
         (or
          (g val)
          (and (not (eq? var var2))
               (loop body))))
        (`(goto ,_) #f)
        (`(if ,p ,a ,b) (or (g p) (loop a) (loop b)))
        (`(case ,key . ,cases)
         (or (g key) (ormap (match-lambda (`(,k ,body) (loop body))) cases)))
        (`(parallel-assign ,al) (ormap g (map cdr al)))
        (`(expr ,e) (g e))
        (_ (error "is-used-variable?" e))))))

(define (remove-unused-variables e)
  (match e
    (`(begin . ,rest) `(begin . ,(map remove-unused-variables rest)))
    (`(let ((,t ,var ,val)) ,body)
     (if (is-used-variable? var body)
         `(let ((,t ,var ,val)) ,(remove-unused-variables body))
         (remove-unused-variables body)))
    (`(goto ,_) e)
    (`(label ,l ,body) `(label ,l ,(remove-unused-variables body)))
    (`(if ,p ,a ,b) `(if ,p ,(remove-unused-variables a) ,(remove-unused-variables b)))
    (`(case ,key . ,cases)
     `(case ,key . ,(map (match-lambda (`(,k ,body) `(,k ,(remove-unused-variables body)))) cases)))
    (`(parallel-assign ,al) e)
    (`(expr ,_) e)
    (_ (error "remove-unused-variables" e))))

(define (count-points e)
  (if (pair? e)
      (+ 1 (count-points (car e)) (count-points (cdr e)))
      1))

(define (simplify-one-pass s)
  (let ((st (make-empty-bbstate))
        (depth 0))
    (letrec ((simplify-expr
              (lambda (e ccp-map tenv)
                (let loop ((e e))
                  (fluid-let ((st (copy-bbstate st)))
                  ;(pretty-print `(simplify-expr ,e))
                  (when (and #f (list? e))
                    (pretty-print `(simplify-expr ,(hash-count (bbstate-definitions st)) ,(count-points e), (equal-hash-code e) ,depth))
                    (set! depth (add1 depth)))
                  ;(pretty-print `(-> ,(annotate-types e tenv) ,tenv))
                  (let ((e2 (cond
                              ((list? e) (cons (car e) (map loop (cdr e))))
                              ((assq e ccp-map) => cdr)
                              (else e))))
                    (let inner-loop ((e2 e2))
                      (let* ((t (infer-type e2 tenv))
                             ;(_ (pretty-print `(,e ,t)))
                             (c
                               (match t
                                      (`(memory ,_) #f)
                                      (_ (is-constant-base? st t (annotate-types e2 tenv))))))
                        (begin0
                          (or (if c (if (eq? t 'bool) (if (zero? c) #f #t) c) #f)
                              (match e2
                                     ((? number?) e2)
                                     (`(if-e 0 ,a ,b) (pretty-print `(picking false branch)) b)
                                     (`(if-e ,(? number?) ,a ,b) (pretty-print `(picking true branch)) a)
                                     (`(if-e ,p ,a ,b)
                                       (let ((c2 (is-constant-base?
                                                   st
                                                   t
                                                   `(bool equal ,(annotate-types a tenv) ,(annotate-types b tenv)))))
                                         (if (eqv? c2 1)
                                           (begin (pretty-print `(branches are same)) a)
                                           `(if-e ,p
                                                  ,(fluid-let ((st (copy-bbstate st)))
                                                              (convert-constraints
                                                                st
                                                                (list `(check ,(annotate-types p tenv)))
                                                                (lambda _ (void)))
                                                              (simplify-expr a ccp-map tenv))
                                                  ,(fluid-let ((st (copy-bbstate st)))
                                                              (convert-constraints
                                                                st
                                                                (list `(check (bool logical-not ,(annotate-types p tenv))))
                                                                (lambda _ (void)))
                                                              (simplify-expr b ccp-map tenv))))))
                                     (`(memoryReadByte (memoryWriteByte ,m ,addr ,val) ,addr2)
                                       (inner-loop `(if-e ,(loop `(equal ,addr ,addr2)) ,val (memoryReadByte ,m ,addr2))))
                                     (e e)))
                          (when (and #f (list? e)) (pretty-print 'end) (set! depth (sub1 depth)))))))))))
             (simplify-stmt
              (lambda (s ccp-map tenv) ; -> s'
                ;(pretty-print `(simplify-stmt ,s))
                (fluid-let ((st (copy-bbstate st)))
                  (match s
                    (`(begin . ,s*) `(begin . ,(map (lambda (s) (simplify-stmt s ccp-map tenv)) s*)))
                    (`(goto ,l) s)
                    (`(let ((,t ,var ,val)) ,body)
                     (let ((val2 (simplify-expr val ccp-map tenv))
                           (tenv (cons (cons var t) tenv))
                           (_ (convert-constraints st
                                                   (list `(define ,var ,(annotate-types val tenv)))
                                                   (lambda _ (void)))))
                       (if (memory-simple? val2)
                           (simplify-stmt body (cons (cons var val2) ccp-map) tenv)
                           `(let ((,t ,var ,val2)) ,(simplify-stmt body ccp-map tenv)))))
                    (`(if (expr ,p) ,a ,b)
                     (let ((p (simplify-expr p ccp-map tenv)))
                       (cond
                         ((and (number? p) (zero? p))
                          (begin
                            (pretty-print `(picking false if branch))
                            (convert-constraints st
                                                 `((check (bool logical-not ,(annotate-types p tenv))))
                                                 (lambda _ (void)))
                            (simplify-stmt b ccp-map tenv)))
                         ((number? p)
                          (begin
                            (pretty-print `(picking true if branch))
                            (convert-constraints st
                                                 `((check ,(annotate-types p tenv)))
                                                 (lambda _ (void)))
                            (simplify-stmt a ccp-map tenv)))
                         (else `(if (expr ,p)
                                    ,(fluid-let ((st (copy-bbstate st)))
                                       (convert-constraints st
                                                            `((check ,(annotate-types p tenv)))
                                                            (lambda _ (void)))
                                       (simplify-stmt a
                                                      ccp-map
                                                      tenv))
                                    ,(fluid-let ((st (copy-bbstate st)))
                                       (convert-constraints st
                                                            `((check
                                                               (bool logical-not ,(annotate-types p tenv))))
                                                            (lambda _ (void)))
                                       (simplify-stmt b
                                                      ccp-map
                                                      tenv)))))))
                    (`(case (expr ,p) . ,cases)
                     (let ((p (simplify-expr p ccp-map tenv)))
                       (cond
                         ((number? p)
                          (let ((pr (assoc (list p) cases)))
                            (if pr
                              (simplify-stmt pr ccp-map tenv)
                              (begin
                                (pretty-print `(label for address ,p not found))
                                `(expr (abort))))))
                         (else
                          `(case (expr ,p) .
                             ,(map (match-lambda
                                     (`(,case ,body)
                                      `(,case ,(simplify-stmt body
                                                              ccp-map
                                                              tenv))))
                                   cases))))))
                    (`(parallel-assign ,bindings)
                     `(parallel-assign
                       ,(map (match-lambda (`(,var . ,val) `(,var . ,(simplify-expr val ccp-map tenv))))
                             bindings)))
                    (`(expr (abort)) s)
                    (`(expr (assign ,a ,b)) `(expr (assign ,a ,(simplify-expr b ccp-map tenv))))
                    (`(expr (interrupt ,i)) s)
                    (_ (error "simplify-stmt" s)))))))
      (match s
        (`(label ,l ,body)
         `(label ,l ,(fluid-let ((st (make-empty-bbstate))) (simplify-stmt body '() '()))))
        (e e)))))
  
  (define (check-types s)
    (letrec ((simplify-expr
              (lambda (e tenv)
                (let loop ((e e))
                  (let* ((_ (cond
                              ((list? e) (for-each loop (cdr e)))
                              (else e)))
                         (t (infer-type e tenv))
                         ;(_ (pretty-print `(,e ,t)))
                         (c
                          (match t
                            (`(memory ,_) #f)
                            (_ (annotate-types e tenv)))))
                    (void)))))
             (simplify-stmt
              (lambda (s tenv)
                (match s
                  (`(begin . ,s*) `(begin . ,(map (lambda (s) (simplify-stmt s tenv)) s*)))
                  (`(goto ,l) s)
                  (`(let ((,t ,var ,val)) ,body)
                   (simplify-expr val tenv)
                   (annotate-types val tenv)
                   (simplify-stmt body (cons (cons var t) tenv)))
                  (`(if (expr ,p) ,a ,b)
                   (simplify-expr p tenv)
                   (annotate-types p tenv)
                   (simplify-stmt a tenv)
                   (simplify-stmt b tenv))
                  (`(case (expr ,p) . ,cases)
                   (simplify-expr p tenv)
                   (for-each (match-lambda
                               (`(,case ,body)
                                (simplify-stmt body tenv)))
                             cases))
                  (`(parallel-assign ,bindings)
                   (for-each (match-lambda (`(,var . ,val) (simplify-expr val tenv)))
                             bindings))
                  (`(expr (abort)) (void))
                  (`(expr (assign ,a ,b)) (simplify-expr b tenv))
                  (`(expr (interrupt ,i)) (void))
                  (_ (error "simplify-stmt" s))))))
      (match s
        (`(label ,l ,body)
         (simplify-stmt body '()))
        (e e))))

(for-each check-types data)

(define (init-code) `(begin . ,(filter (match-lambda (`(label . ,_) #f) (_ #t)) data)))
(define (get-label l) (or (ormap (match-lambda (`(label ,l2 ,body) (if (eq? l l2) body #f)) (_ #f)) data) (error "Label not found" l)))

(define (expand-one e)
  (match e
    (`(goto ,l) (get-label l))
    (`(label ,l ,body) `(label ,l ,(expand-one body)))
    (`(if ,p ,a ,b) `(if ,p ,(expand-one a) ,(expand-one b)))
    (`(case ,k . ,cases)
     (if (>= (length cases) 4)
         `(case ,k . ,cases)
         `(case ,k . ,(map (match-lambda (`(,keys ,e) `(,keys ,(expand-one e)))) cases))))
    (`(expr . ,_) e)
    (`(parallel-assign . ,_) e)
    (`(begin . ,rest) `(begin . ,(map expand-one rest)))
    (`(let ,vars ,body) `(let ,vars ,(expand-one body)))
    (_ (error "expand-one" e))))

(define (sat-simplify-loop)
  (let ((c 0))
    (set! data
          (map (match-lambda
                 (`(label ,l ,body)
                  (set! c (add1 c))
                  (pretty-print `(entry ,c ,l of ,(length data)))
                  `(label ,l
                          ,(remove-unused-variables (simplify-one-pass `(label ,l ,body)))))
                 (e e))
               data))))

(define (expand-many n)
  (sat-simplify-loop)
  (let loop ((n n))
    (unless (zero? n)
      (set! data (expand-one data))
      (sat-simplify-loop)
      (loop (sub1 n)))))

(pretty-print `(starting-points = ,(count-points data)))
(expand-many 0)
(pretty-print `(after-simplify-points = ,(count-points data)))
(pretty-print data)
(exit 0)

(let loop ((n 5))
  (unless (zero? n)
    (pretty-print `(,n stages left))
    (set! data (map expand-one data))
    (pretty-print `(after-expand-points = ,(count-points data)))
    (sat-simplify-loop)
    (pretty-print `(after-loop-simplify-points = ,(count-points data)))
    (loop (sub1 n))))

(pretty-print (map change-to-let* data))
)

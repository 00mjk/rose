#include "statementProcessor.h"
#include <boost/tuple/tuple.hpp>
#include <boost/lexical_cast.hpp>
#include "utilities/CPPDefinesAndNamespaces.h"

using namespace SageInterface;
using namespace SageBuilder;

StatementObjectVec BasicStatementProcessor::process(
        SgStatement* stmt, const VariableVersionTable& var_table)
{
    if (SgExprStatement* exp_stmt = isSgExprStatement(stmt))
        return processExprStatement(exp_stmt, var_table);

	else if (SgVariableDeclaration* var_decl = isSgVariableDeclaration(stmt))
        return processVariableDeclaration(var_decl, var_table);

	else if (SgBasicBlock* block = isSgBasicBlock(stmt))
        return processBasicBlock(block, var_table);

	//The forward of a return statement is a return; the reverse is a no-op.
	else if (isSgReturnStmt(stmt))
	{
		StatementObjectVec results;
		results.push_back(StatementObject(SageInterface::copyStatement(stmt), NULL, var_table));
		return results;
	}
    //if (SgIfStmt* if_stmt = isSgIfStmt(stmt))
       // return processIfStmt(if_stmt, var_table);

    return StatementObjectVec();
}

#if 0
StmtPairs BasicStatementProcessor::processFunctionDeclaration(SgFunctionDeclaration* func_decl)
{
    SgBasicBlock* body = func_decl->get_definition()->get_body();
    StmtPairs bodies = processStatement(body);
    StmtPairs outputs;

    static int ctr = 0;

    foreach (StmtPair stmt_pair, bodies)
    {
        SgStatement *fwd_body, *rvs_body;
        tie(fwd_body, rvs_body) = stmt_pair;

        string ctr_str = lexical_cast<string>(ctr++);

        SgName fwd_func_name = func_decl->get_name() + "_forward" + ctr_str;
        SgFunctionDeclaration* fwd_func_decl = 
            buildDefiningFunctionDeclaration(fwd_func_name, func_decl->get_orig_return_type(), 
                    isSgFunctionParameterList(copyStatement(func_decl->get_parameterList())));
        SgFunctionDefinition* fwd_func_def = fwd_func_decl->get_definition();
        fwd_func_def->set_body(isSgBasicBlock(fwd_body));
        fwd_body->set_parent(fwd_func_def);

        SgName rvs_func_name = func_decl->get_name() + "_reverse" + ctr_str;
        SgFunctionDeclaration* rvs_func_decl = 
            buildDefiningFunctionDeclaration(rvs_func_name, func_decl->get_orig_return_type(), 
                    isSgFunctionParameterList(copyStatement(func_decl->get_parameterList()))); 
        SgFunctionDefinition* rvs_func_def = rvs_func_decl->get_definition();
        rvs_func_def->set_body(isSgBasicBlock(rvs_body));
        rvs_body->set_parent(rvs_func_def);

        outputs.push_back(StmtPair(fwd_func_decl, rvs_func_decl));
    }

    return outputs;
}
#endif

StatementObjectVec BasicStatementProcessor::processExprStatement(
        SgExprStatement* exp_stmt,
        const VariableVersionTable& var_table)
{
    ExpressionObjectVec exps = processExpression(exp_stmt->get_expression(), var_table);

    ROSE_ASSERT(!exps.empty());

    StatementObjectVec stmts;
    foreach (ExpressionObject& exp_obj, exps)
    {
        SgStatement *fwd_stmt = NULL, *rvs_stmt = NULL;

        if (exp_obj.fwd_exp)
            fwd_stmt = buildExprStatement(exp_obj.fwd_exp);
        if (exp_obj.rvs_exp)
            rvs_stmt = buildExprStatement(exp_obj.rvs_exp);

        // Use the variable version table output by expression processor.
        stmts.push_back(StatementObject(fwd_stmt, rvs_stmt, exp_obj.var_table));
    }
    return stmts;
}

StatementObjectVec BasicStatementProcessor::processVariableDeclaration(
        SgVariableDeclaration* var_decl,
        const VariableVersionTable& var_table)
{
    StatementObjectVec outputs;

    // Note the store and restore of local variables are processd in
    // basic block, not here. We just forward the declaration to forward
    // event function.

    // FIXME copyStatement also copies preprocessing info
    outputs.push_back(StatementObject(copyStatement(var_decl), NULL, var_table));

    //outputs.push_back(StatementObject(NULL, NULL, var_table));
    //outputs.push_back(pushAndPopLocalVar(var_decl));

    // FIXME  other cases
    
    return outputs;
}

StatementObjectVec BasicStatementProcessor::processBasicBlock(
        SgBasicBlock* body,
        const VariableVersionTable& var_table)
{
    // Use two vectors to store intermediate results.
    StatementObjectVec queue[2];
    vector<SgStatement*> to_delete;

    int i = 0;
    queue[i].push_back(StatementObject(buildBasicBlock(), buildBasicBlock(), var_table));

#if 1
    // Deal with variable declarations first, since they will affect the variable version table.
    // For each variable declared in this basic block, we choose storing or not storing it at the end.
    foreach (SgStatement* stmt, body->get_statements())
    {
        if (SgVariableDeclaration* var_decl = isSgVariableDeclaration(stmt))
        {
            foreach (StatementObject& obj, queue[i])
            {
                cout << "Begin:@@@";
                const SgInitializedNamePtrList& names = var_decl->get_variables();
                ROSE_ASSERT(names.size() == 1);
                SgInitializedName* init_name = names[0];


                /*******************************************************************************/
                // The first transformation is restore this local variable and restore it
                // at the beginning of the reverse basic block. Note that this variable already
                // has the final version unless we modify it.
#if 1
                StatementObject new_obj1 = obj.clone();
#else
                StatementObject new_obj1 = obj; // = obj.clone();
                new_obj1.fwd_stmt = copyStatement(obj.fwd_stmt);
                new_obj1.rvs_stmt = buildBasicBlock();

                foreach(SgStatement* s, isSgBasicBlock(obj.rvs_stmt)->get_statements())
                {
                    if (SgVariableDeclaration * decl = isSgVariableDeclaration(s))
                    {
                        SgInitializer* new_init = NULL;
                        SgInitializer* init = decl->get_variables()[0]->get_initializer();
                        if (init)
                            new_init = isSgInitializer(copyExpression(init));
                        isSgBasicBlock(new_obj1.rvs_stmt)->append_statement(
                                buildVariableDeclaration(
                                decl->get_variables()[0]->get_name(),
                                decl->get_variables()[0]->get_type(),
                                new_init));
                    } else
                        isSgBasicBlock(new_obj1.rvs_stmt)->append_statement(copyStatement(s));
                }
#endif

                ROSE_ASSERT(isSgBasicBlock(new_obj1.fwd_stmt));
                ROSE_ASSERT(isSgBasicBlock(new_obj1.rvs_stmt));

#if 1
                // Store the value of local variables at the end of the basic block.
                SgVarRefExp* var_stored = buildVarRefExp(init_name->get_name());
                SgStatement* store_var = buildExprStatement(
                        pushVal(var_stored, init_name->get_type()));

                // Retrieve the value which is used to initialize that local variable.
                SgVariableDeclaration* decl_restore_var = buildVariableDeclaration(
                        init_name->get_name(),
                        init_name->get_type(),
                        buildAssignInitializer(popVal(init_name->get_type())),
                        isSgBasicBlock(new_obj1.rvs_stmt));

                isSgBasicBlock(new_obj1.fwd_stmt)->append_statement(store_var);
                ROSE_ASSERT(store_var->get_parent() == new_obj1.fwd_stmt);

                isSgBasicBlock(new_obj1.rvs_stmt)->append_statement(decl_restore_var);
                ROSE_ASSERT(decl_restore_var->get_parent() == new_obj1.rvs_stmt);
#endif
                //fixVariableDeclaration(decl_restore_var, isSgBasicBlock(new_obj1.rvs_stmt));

                /*******************************************************************************/
                // The second transformation is not to store it. We have to set its version NULL.
#if 1
                StatementObject new_obj2 = obj.clone();
#else
                StatementObject new_obj2 = obj; // = obj.clone();
                new_obj2.fwd_stmt = copyStatement(obj.fwd_stmt);
                new_obj2.rvs_stmt = buildBasicBlock();

                foreach(SgStatement* s, isSgBasicBlock(obj.rvs_stmt)->get_statements())
                {
                    if (SgVariableDeclaration * decl = isSgVariableDeclaration(s))
                    {
                        SgInitializer* new_init = NULL;
                        SgInitializer* init = decl->get_variables()[0]->get_initializer();
                        if (init)
                            new_init = isSgInitializer(copyExpression(init));
                        isSgBasicBlock(new_obj2.rvs_stmt)->append_statement(
                                buildVariableDeclaration(
                                decl->get_variables()[0]->get_name(),
                                decl->get_variables()[0]->get_type(),
                                new_init));
                    } else
                        isSgBasicBlock(new_obj2.rvs_stmt)->append_statement(copyStatement(s));
                }
#endif

                ROSE_ASSERT(isSgBasicBlock(new_obj2.rvs_stmt));

                // The second transformation is not to store it.
                SgStatement* just_decl = buildVariableDeclaration(
                        init_name->get_name(),
                        init_name->get_type(),
                        NULL, isSgBasicBlock(new_obj2.rvs_stmt));

                isSgBasicBlock(new_obj2.rvs_stmt)->append_statement(just_decl);
                ROSE_ASSERT(just_decl->get_parent() == new_obj2.rvs_stmt);

                new_obj2.var_table.setNullVersion(init_name);

                queue[1-i].push_back(new_obj1);
                queue[1-i].push_back(new_obj2);

                cout << "@@@End\n";
            }

            foreach (StatementObject& obj, queue[i])
            {
                to_delete.push_back(obj.fwd_stmt);
                to_delete.push_back(obj.rvs_stmt);
                //delete obj.fwd_stmt;
                //delete obj.rvs_stmt;
            }
            queue[i].clear();
            // Switch the index between 0 and 1.
            i = 1 - i;
        }
    }
#endif

#if 1
    reverse_foreach (SgStatement* stmt, body->get_statements())
    {
        foreach (StatementObject& obj, queue[i])
        {
            StatementObjectVec result = processStatement(stmt, obj.var_table);
            
            ROSE_ASSERT(!result.empty());

            foreach (StatementObject& res, result)
            {
                // Currently, we cannot directly deep copy variable declarations. So we rebuild another one
                // with the same name, type and initializer.

#if 1
                StatementObject new_obj = obj;// = obj.clone();
                new_obj.fwd_stmt = copyStatement(obj.fwd_stmt);
                new_obj.rvs_stmt = buildBasicBlock();
                foreach (SgStatement* s, isSgBasicBlock(obj.rvs_stmt)->get_statements())
                {
                    if (SgVariableDeclaration* decl = isSgVariableDeclaration(s))
                    {
                        SgInitializer* new_init = NULL;
                        SgInitializer* init = decl->get_variables()[0]->get_initializer();
                        if (init)
                            new_init = isSgInitializer(copyExpression(init));
                        isSgBasicBlock(new_obj.rvs_stmt)->append_statement(
                                buildVariableDeclaration(
                                    decl->get_variables()[0]->get_name(),
                                    decl->get_variables()[0]->get_type(),
                                    new_init));
                    }
                    else
                        isSgBasicBlock(new_obj.rvs_stmt)->append_statement(copyStatement(s));
                }
#else
                StatementObject new_obj = obj.clone();
#endif


                ROSE_ASSERT(isSgBasicBlock(new_obj.fwd_stmt));
                ROSE_ASSERT(isSgBasicBlock(new_obj.rvs_stmt));

                if (res.fwd_stmt)
                {
                    isSgBasicBlock(new_obj.fwd_stmt)->prepend_statement(res.fwd_stmt);
                    //fixVariableReferences(isSgBasicBlock(new_obj.fwd_stmt));
                    //fixStatement(res.fwd_stmt, isSgBasicBlock(new_obj.fwd_stmt));
                }
                if (res.rvs_stmt)
                {
                    isSgBasicBlock(new_obj.rvs_stmt)->append_statement(res.rvs_stmt);
                    //fixVariableReferences(isSgBasicBlock(new_obj.rvs_stmt));
                    //fixStatement(res.rvs_stmt, isSgBasicBlock(new_obj.rvs_stmt));
                }
                new_obj.var_table = res.var_table;

                //fixVariableReferences(new_obj.fwd_stmt);
                //fixVariableReferences(new_obj.rvs_stmt);

                queue[1-i].push_back(new_obj);
            }
        }
        
        foreach (StatementObject& obj, queue[i])
        {
            to_delete.push_back(obj.fwd_stmt);
            to_delete.push_back(obj.rvs_stmt);
            //delete obj.fwd_stmt;
            //delete obj.rvs_stmt;
        }
        queue[i].clear();
        // Switch the index between 0 and 1.
        i = 1 - i;
    }
#endif


    // Since we build a varref before building its declaration, we may use the following function to fix them.
    foreach (StatementObject& obj, queue[i])
    {
        //cout << "Fixed: " << fixVariableReferences(obj.fwd_stmt) << endl;
        //fixVariableReferences(obj.rvs_stmt);
    }

    foreach (SgStatement* stmt, to_delete)
        deepDelete(stmt);
        //delete stmt;

    return queue[i];
}

#if 0
StmtPairs BasicStatementProcessor::processIfStmt(
        SgIfStmt* if_stmt,
        const VariableVersionTable& var_table)
{
    //SgStatement *fwd_true_body, *fwd_false_body;
    //SgStatement *rvs_true_body, *rvs_false_body;

    SgStatement* true_body = if_stmt->get_true_body();
    SgStatement* false_body = if_stmt->get_false_body();

    // Here we have do decide whether to store the flag. We don't have to store
    // the flag if the value of that flag will not change after the if statement.
    // Otherwise, we will push the flag at the end of if statement.

    // After normalization, we require that the condition part of if statement
    // does not need to be reversed. In other word, the expression of if condition
    // does not modify any value.

    StmtPairs transformed_true_bodies = processStatement(true_body);
    StmtPairs transformed_false_bodies = processStatement(false_body);

    //if (transformed_false_bodies.empty())
       // transformed_false_bodies.push_back(NULL_STMT_PAIR);

    StmtPairs output;

    foreach (StmtPair true_bodies, transformed_true_bodies)
    {
        foreach (StmtPair false_bodies, transformed_false_bodies)
        {
            SgIfStmt* fwd_if_stmt = buildIfStmt(
                    copyStatement(if_stmt->get_conditional()),
                    copyStatement(true_bodies.first),
                    copyStatement(false_bodies.first));

            // Note that after normalization, both true/false bodies are basic blocks.
            ROSE_ASSERT(isSgBasicBlock(fwd_if_stmt->get_true_body()));
            ROSE_ASSERT(isSgBasicBlock(fwd_if_stmt->get_false_body()));


            // At the end of true/false body, push the flag into stack.
            isSgBasicBlock(fwd_if_stmt->get_true_body())->append_statement(
                    buildExprStatement(pushVal(
                        buildBoolValExp(true),
                        buildBoolType())));
            isSgBasicBlock(fwd_if_stmt->get_false_body())->append_statement(
                    buildExprStatement(pushVal(
                        buildBoolValExp(false),
                        buildBoolType())));


            SgIfStmt* rvs_if_stmt = buildIfStmt(
                    popVal(buildBoolType()),
                    copyStatement(true_bodies.second),
                    copyStatement(false_bodies.second));
            output.push_back(StmtPair(fwd_if_stmt, rvs_if_stmt));
        }
    }

    return output;
}
#endif


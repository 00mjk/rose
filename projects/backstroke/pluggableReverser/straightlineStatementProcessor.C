#include "straightlineStatementProcessor.h"

#include "utilities/CPPDefinesAndNamespaces.h"

#include "rose.h"
#include "statementProcessor.h"
#include "pluggableReverser/eventProcessor.h"

struct StoredStatementReversal : public EvaluationResultAttribute
{
	StoredStatementReversal(const StatementReversal& reversal) : reversal(reversal)
	{

	}

	StatementReversal reversal;
};

vector<EvaluationResult> StraightlineStatementProcessor::evaluate(SgStatement* statement, const VariableVersionTable& var_table)
{
	if (SgBasicBlock * basicBlock = isSgBasicBlock(statement))
	{
		return evaluateBasicBlock(basicBlock, var_table);
	}
	else if (SgExprStatement * expressionStatement = isSgExprStatement(statement))
	{
		return evaluateExpressionStatement(expressionStatement, var_table);
	}

	return vector<EvaluationResult> ();
}


/** Process an expression statement by using the first expression handler returning a valid result. */
vector<EvaluationResult> StraightlineStatementProcessor::evaluateExpressionStatement(SgExprStatement* statement, const VariableVersionTable& var_table)
{
    ROSE_ASSERT(statement);
    
	vector<EvaluationResult> expressions = evaluateExpression(statement->get_expression(), var_table, false);

	//If none of the expression handlers could handle the code, we can't reverse it!
	ROSE_ASSERT(!expressions.empty());

	//This simple processor just takes the first valid reverse expression returned
	EvaluationResult& expressionReversalOption = expressions.front();
	ExpressionReversal expressionReversal = expressionReversalOption.generateReverseAST(statement->get_expression());
	SgStatement* forwardStatement = SageBuilder::buildExprStatement(expressionReversal.fwd_exp);
	SgStatement* reverseStatement = SageBuilder::buildExprStatement(expressionReversal.rvs_exp);

	//We just do all the work in the evaluation step and save it as an attribute
	EvaluationResult statementResult(this, expressionReversalOption.getVarTable(), expressionReversalOption.getCost());
	StatementReversal statementReversal(forwardStatement, reverseStatement);
	statementResult.setAttribute(EvaluationResultAttributePtr(new StoredStatementReversal(statementReversal)));

	vector<EvaluationResult> result;
	result.push_back(statementResult);

	return result;
}

StatementReversal StraightlineStatementProcessor::generateReverseAST(SgStatement* statement, const EvaluationResult& reversal)
{
	ROSE_ASSERT(reversal.getChildResults().size() == 0);
	ROSE_ASSERT(reversal.getStatementProcessor() == this);

	StoredStatementReversal* storedResult = dynamic_cast<StoredStatementReversal*>(reversal.getAttribute().get());
	ROSE_ASSERT(storedResult != NULL);

	return storedResult->reversal;
}


vector<EvaluationResult> StraightlineStatementProcessor::evaluateBasicBlock(SgBasicBlock* basicBlock, const VariableVersionTable& var_table)
{
    ROSE_ASSERT(basicBlock);
    
	SgBasicBlock* forwardBody = SageBuilder::buildBasicBlock();
	SgBasicBlock* reverseBody = SageBuilder::buildBasicBlock();

	vector<SgStatement*> scopeExitStores;
	vector<SgVariableDeclaration*> localVarDeclarations;

	VariableVersionTable currentVariableVersions = var_table;
	SimpleCostModel totalCost;

	reverse_foreach(SgStatement* s, basicBlock->get_statements())
	{
		// Put the declarations of local variables in the beginning of reverse
		// basic block and retrieve their values. Store values of all local
		// variables in the end of of forward basic block.
		// Also refer to the function "processVariableDeclaration"
		if (SgVariableDeclaration * variableDeclaration = isSgVariableDeclaration(s))
		{
			//Add a copy of the declaration to the forward body
			SgVariableDeclaration* forwardBodyDeclaration = isSgVariableDeclaration(SageInterface::copyStatement(variableDeclaration));
			forwardBody->prepend_statement(forwardBodyDeclaration);


			foreach(SgInitializedName* localVar, variableDeclaration->get_variables())
			{
				//First, check if we can restore the variable without savings its value
				VariableRenaming::VarName varName;
				varName.push_back(localVar);
				SgFunctionDefinition* enclosingFunction = SageInterface::getEnclosingFunctionDefinition(basicBlock);
				VariableRenaming::NumNodeRenameEntry definitions = getVariableRenaming()->getReachingDefsAtFunctionEndForName(enclosingFunction, varName);

				//vector<SgExpression*> restoredValue = restoreVariable(varName, currentVariableVersions, definitions);
				SgAssignInitializer* reverseVarInitializer;
				/*if (!restoredValue.empty())
				{
					reverseVarInitializer = SageBuilder::buildAssignInitializer(restoredValue.front());
				}
				else*/
				{
					//Push(save) the variable at the bottom of the forward statement
					SgExpression* storeVarValue = pushVal(SageBuilder::buildVarRefExp(localVar, forwardBody), localVar->get_type());
					SgExprStatement* varSaveStatement = SageBuilder::buildExprStatement(storeVarValue);
					scopeExitStores.push_back(varSaveStatement);

					//In the reverse body, declare & pop the variable at the very top
					reverseVarInitializer = SageBuilder::buildAssignInitializer(popVal(localVar->get_type()));
				}
		
				SgVariableDeclaration* reverseDeclaration = SageBuilder::buildVariableDeclaration(localVar->get_name(),
						localVar->get_type(), reverseVarInitializer);
				localVarDeclarations.push_back(reverseDeclaration);
			}

			//No need to do further processing for variable declarations
			continue;
		}

		//In this simple processor, we just take the first valid statement available
		vector<EvaluationResult> possibleStatements = evaluate(s, currentVariableVersions);
		if (possibleStatements.empty())
		{
			fprintf(stderr, "Failed to process statement of type '%s' on line %d: %s\n", s->class_name().c_str(),
					s->get_file_info()->get_line(), s->unparseToString().c_str());
			exit(1);
		}

		StatementReversal instrumentedStatement = possibleStatements.front().generateReverseAST(s);
		totalCost += possibleStatements.front().getCost();
		SgStatement* forwardStatement = instrumentedStatement.fwd_stmt;
		SgStatement* reverseStatement = instrumentedStatement.rvs_stmt;
		currentVariableVersions = possibleStatements.front().getVarTable();

		//The return statement should go at the very end of the forward statement
		//after the variables that exit scope have been stored
		if (isSgReturnStmt(forwardStatement))
		{
			scopeExitStores.push_back(forwardStatement);
		}
		else if (forwardStatement != NULL)
		{
			forwardBody->prepend_statement(forwardStatement);
		}

		//Insert the reverse statement
		if (isSgReturnStmt(reverseStatement))
		{
			//The reverse of a return statement is a null statement since the return statement
			//can only come at the end of a function. Hence, this case should never occur.
			ROSE_ASSERT(false);
		}
		else if (reverseStatement != NULL)
		{
			reverseBody->append_statement(reverseStatement);
		}
	}

	//Before exiting scope, store all local variables
	reverse_foreach(SgStatement* stmt, scopeExitStores)
	{
		forwardBody->append_statement(stmt);
	}

	//Restore all local variables upon returning into the scope
	reverse_foreach(SgStatement* stmt, localVarDeclarations)
	{
		reverseBody->prepend_statement(stmt);
	}

	//We actually did both cost evaluation and code generation. Store the result as an attribute
	StatementReversal result(forwardBody, reverseBody);
	EvaluationResult costAndStuff(this, currentVariableVersions, totalCost);
	costAndStuff.setAttribute(EvaluationResultAttributePtr(new StoredStatementReversal(result)));

	vector<EvaluationResult> out;
	out.push_back(costAndStuff);
	return out;
}

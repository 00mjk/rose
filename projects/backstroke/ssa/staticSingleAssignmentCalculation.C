//Author: George Vulov <georgevulov@hotmail.com>
//Based on work by Justin Frye <jafrye@tamu.edu>

#include "sage3basic.h"
#include "staticSingleAssignment.h"
#include "sageInterface.h"
#include <map>
#include <vector>
#include <string>
#include <sstream>
#include <algorithm>
#include <queue>
#include <fstream>
#include <stack>
#include <boost/foreach.hpp>
#include <boost/unordered_set.hpp>
#include <boost/tuple/tuple.hpp>
#include "uniqueNameTraversal.h"
#include "defsAndUsesTraversal.h"
#include "iteratedDominanceFrontier.h"

#define foreach BOOST_FOREACH
#define reverse_foreach BOOST_REVERSE_FOREACH

using namespace std;
using namespace ssa_private;
using namespace boost;

//Initializations of the static attribute tags
string StaticSingleAssignment::varKeyTag = "ssa_varname_KeyTag";
SgInitializedName* StaticSingleAssignment::thisDecl = NULL;
StaticSingleAssignment::VarName StaticSingleAssignment::emptyName;

bool StaticSingleAssignment::isFromLibrary(SgNode* node)
{
	Sg_File_Info* fi = node->get_file_info();
	if (fi->isCompilerGenerated())
		return true;
	string filename = fi->get_filenameString();

	if ((filename.find("include") != string::npos))
	{
		return true;
	}
	return false;
}

bool StaticSingleAssignment::isBuiltinVar(const VarName& var)
{
	string name = var[0]->get_name().getString();
	if (name == "__func__" ||
			name == "__FUNCTION__" ||
			name == "__PRETTY_FUNCTION__")
		return true;

	return false;
}

//Function to perform the StaticSingleAssignment and annotate the AST
void StaticSingleAssignment::run()
{
	originalDefTable.clear();
	expandedDefTable.clear();
	reachingDefsTable.clear();
	useTable.clear();
	nodeRenameTable.clear();
	numRenameTable.clear();
	globalVarList.clear();

	if (getDebug())
		cout << "Locating global variables." << endl;

	findGlobalVars();
	//Insert the global variables as being defined at every function call
	insertGlobalVarDefinitions();

	UniqueNameTraversal uniqueTrav;
	DefsAndUsesTraversal defUseTrav(this);

	vector<SgFunctionDefinition*> funcs = SageInterface::querySubTree<SgFunctionDefinition > (project, V_SgFunctionDefinition);
	foreach (SgFunctionDefinition* func, funcs)
	{
		ROSE_ASSERT(func);
		if (!isFromLibrary(func))
		{
			if (getDebug())
				cout << "Running UniqueNameTraversal on function:" << SageInterface::get_name(func) << func << endl;

			uniqueTrav.traverse(func->get_declaration());

			if (getDebug())
				cout << "Finished UniqueNameTraversal..." << endl;

			if (getDebug())
				cout << "Running DefsAndUsesTraversal on function: " << SageInterface::get_name(func) << func << endl;

			defUseTrav.traverse(func->get_declaration());

			if (getDebug())
				cout << "Finished DefsAndUsesTraversal..." << endl;

			insertDefsForExternalVariables(func->get_declaration());

			//Expand any member variable definition to also define its parents at the same node
			expandParentMemberDefinitions(func->get_declaration());

			//Expand any member variable uses to also use the parent variables (e.g. a.x also uses a)
			expandParentMemberUses(func->get_declaration());

			//Iterate the global table insert a def for each name at the function definition
			foreach(const VarName& globalVar, globalVarList)
			{
				//Add this function definition as a definition point of this variable
				originalDefTable[func].insert(globalVar);
			}

			insertDefsForChildMemberUses(func->get_declaration());

			insertPhiFunctions(func);
			insertLocalDefs(func);

			if (getDebug())
				cout << "Running DefUse Data Flow on function: " << SageInterface::get_name(func) << func << endl;
			runDefUseDataFlow(func);

			//We have all the propagated defs, now update the use table
			buildUseTable(func);
		}
	}


}

void StaticSingleAssignment::findGlobalVars()
{
	InitNameVec vars = SageInterface::querySubTree<SgInitializedName> (project, V_SgInitializedName);

	foreach(SgInitializedName* iter, vars)
	{
		//Ignore library/compiler generated variables.
		if (isFromLibrary(iter))
			continue;

		//Check if we are in global scope.
		SgNode* scope = iter->get_scope();
		if (isSgGlobal(scope))
		{
			//Since forward declaration parameters are inserted in global scope,
			//Check if we are in a forward declaration
			if (SageInterface::getEnclosingFunctionDeclaration(iter))
			{
				//We are in a declaration, so not a global var.
				continue;
			}
			//Add the variable to the global scope and name it.
			VarUniqueName *uName = new VarUniqueName(iter);
			iter->setAttribute(StaticSingleAssignment::varKeyTag, uName);
			//Add to the global var list
			globalVarList.push_back(uName->getKey());
			if (getDebug())
				cout << "Added global variable [" << iter->get_name().getString() << "] - " << iter << endl;
		}
	}
}

void StaticSingleAssignment::insertGlobalVarDefinitions()
{
	if (getDebug())
		cout << "Global Var List size: " << globalVarList.size() << endl;

	//Iterate the function calls and insert definitions for all global variables
	vector<SgFunctionCallExp*> calls = SageInterface::querySubTree<SgFunctionCallExp>(project, V_SgFunctionCallExp);

	foreach(SgFunctionCallExp* call, calls)
	{
		//Iterate the global table insert a def for each name at the function call
		foreach(VarName& entry, globalVarList)
		{
			//Add this function call as a definition point of this variable
			originalDefTable[call].insert(entry);
		}
	}
}

void StaticSingleAssignment::expandParentMemberDefinitions(SgFunctionDeclaration* function)
{
	class ExpandDefsTraversal : public AstSimpleProcessing
	{
	public:
		StaticSingleAssignment* ssa;

		void visit(SgNode* node)
		{
			if (ssa->originalDefTable.count(node) == 0)
				return;

			//We want to iterate the vars defined on this node, and expand them
			foreach(const VarName& definedVar, ssa->originalDefTable[node])
			{
				if (getDebugExtra())
				{
					cout << "Checking [" << varnameToString(definedVar) << "]" << endl;
				}

				//Check if the variableName has multiple parts
				if (definedVar.size() == 1)
				{
					continue;
				}

				//We are dealing with a multi-part variable, loop the entry and expand it
				//Start at one so we don't get the same defs in the original and expanded defs
				for (unsigned int i = 1; i < definedVar.size(); i++)
				{
					//Create a new varName vector that goes from beginning to end - i
					VarName newName;
					newName.assign(definedVar.begin(), definedVar.end() - i);

					if (getDebugExtra())
					{
						cout << "Testing for presence of [" << varnameToString(newName) << "]" << endl;
					}

					//Only insert the new definition if it does not already exist in the original def table
					if (ssa->originalDefTable[node].count(newName) == 0)
					{
						//Insert the new name as being defined here.
						ssa->expandedDefTable[node].insert(newName);

						if (getDebugExtra())
						{
							cout << "Inserted new name [" << varnameToString(newName) << "] into defs." << endl;
						}
					}
				}
			}
		}
	};

	ExpandDefsTraversal trav;
	trav.ssa = this;
	trav.traverse(function, preorder);
}

void StaticSingleAssignment::expandParentMemberUses(SgFunctionDeclaration* function)
{
	class ExpandUsesTraversal : public AstSimpleProcessing
	{
	public:
		StaticSingleAssignment* ssa;

		void visit(SgNode* node)
		{
			if (ssa->useTable.count(node) == 0)
				return;

			//We want to iterate the vars used on this node, and expand them
			foreach(TableEntry::value_type& entry, ssa->useTable[node])
			{
				const VarName& usedVar = entry.first;
				if (getDebugExtra())
				{
					cout << "Checking [" << varnameToString(usedVar) << "]" << endl;
				}

				//Check if the variableName has multiple parts
				if (usedVar.size() == 1)
				{
					continue;
				}

				//We are dealing with a multi-part variable, loop the entry and expand it
				//Start at one so we don't reinsert same use
				for (unsigned int i = 1; i < usedVar.size(); i++)
				{
					//Create a new varName vector that goes from beginning to end - i
					VarName newName;
					newName.assign(usedVar.begin(), usedVar.end() - i);

					if (getDebugExtra())
					{
						cout << "Testing for presence of [" << varnameToString(newName) << "]" << endl;
					}

					//Only insert the new definition if it does not already exist
					if (ssa->useTable[node].count(newName) == 0)
					{
						//Insert the new name as being used here.
						ssa->useTable[node][newName] = NodeVec(1, node);

						if (getDebugExtra())
						{
							cout << "Inserted new name [" << varnameToString(newName) << "] into uses." << endl;
						}
					}
				}
			}
		}
	};

	ExpandUsesTraversal trav;
	trav.ssa = this;
	trav.traverse(function, preorder);
}

void StaticSingleAssignment::runDefUseDataFlow(SgFunctionDefinition* func)
{
	if (getDebug())
		printOriginalDefTable();
	//Keep track of visited nodes
	boost::unordered_set<SgNode*> visited;

	vector<FilteredCfgNode> worklist;

	FilteredCfgNode current = FilteredCfgNode(func->cfgForBeginning());
	worklist.push_back(current);

	while (!worklist.empty())
	{
		if (getDebug())
			cout << "-------------------------------------------------------------------------" << endl;
		//Get the node to work on
		current = worklist.back();
		worklist.pop_back();

		//We don't want to do def_use on the ending CFGNode of the function definition
		//so if we see it, continue.
		//If we do this, then incorrect information will be propogated to the beginning of the function
		if (current == FilteredCfgNode(func->cfgForEnd()))
		{
			if (getDebug())
				cout << "Skipped defUse on End of function definition." << endl;
			continue;
		}

		//Propagate defs to the current node
		bool changed = mergeDefs(current);
		bool ssaChanged = ssaMergeDefs(current);

		//For every edge, add it to the worklist if it is not seen or something has changed
		reverse_foreach(const FilteredCfgEdge& edge, current.outEdges())
		{
			FilteredCfgNode nextNode = edge.target();

			//Insert the child in the worklist if the parent is changed or it hasn't been visited yet
			if (changed || visited.count(nextNode.getNode()) == 0)
			{
				//Add the node to the worklist
				if (find(worklist.begin(), worklist.end(), nextNode) == worklist.end())
				{
					worklist.push_back(nextNode);
					if (getDebug())
					{
						if (changed)
							cout << "Defs Changed: Added " << nextNode.getNode()->class_name() << nextNode.getNode() << " to the worklist." << endl;
						else
							cout << "Next unvisited: Added " << nextNode.getNode()->class_name() << nextNode.getNode() << " to the worklist." << endl;
					}
				}
			}
		}

		//Mark the current node as seen
		visited.insert(current.getNode());
	}
}

bool StaticSingleAssignment::ssaMergeDefs(FilteredCfgNode cfgNode)
{
	SgNode* node = cfgNode.getNode();

	//This updates the IN table with the reaching defs from previous nodes
	updateIncomingDefs(cfgNode);

	//Create a staging OUT table. At the end, we will check if this table
	//Was the same as the currently available one, to decide if any changes have occurred
	//We initialize the OUT tabel to the IN table
	NodeReachingDefTable outDefsTable = ssaReachingDefsTable[node].first;

	//Now overwrite any local definitions:
	if (ssaLocalDefTable.count(node) > 0)
	{
		foreach(const NodeReachingDefTable::value_type& varDefPair, ssaLocalDefTable[node])
		{
			const VarName& definedVar = varDefPair.first;
			ReachingDefPtr localDef = varDefPair.second;

			outDefsTable[definedVar] = localDef;
		}
	}

	//Compare old to new OUT tables
	bool changed = (ssaReachingDefsTable[node].second != outDefsTable);
	if (changed)
	{
		ssaReachingDefsTable[node].second = outDefsTable;
	}

	return changed;
}

bool StaticSingleAssignment::mergeDefs(FilteredCfgNode curNode)
{
	SgNode* node = curNode.getNode();

	if (getDebug())
	{
		cout << "merging defs..." << endl;
		printDefs(node);
	}

	TableEntry stagingPropagatedDefs;;
	//Retrieve the defs coming from previous cfgNodes
	aggregatePreviousDefs(curNode, stagingPropagatedDefs);

	//Replace every entry in staging table that has definition in original defs
	//Also assign renaming numbers to any new definitions
	foreach(const VarName& definedVar, originalDefTable[node])
	{
		//Replace the entry for this variable with the definitions at this node.
		stagingPropagatedDefs[definedVar].clear();
		stagingPropagatedDefs[definedVar].push_back(node);

		addRenameNumberForNode(definedVar, node);
	}

	//Replace every entry in staging table that has definition in expandedDefs
	//Also assign renaming numbers to any new definitions
	foreach(const VarName& definedVar, expandedDefTable[node])
	{
		stagingPropagatedDefs[definedVar].clear();
		stagingPropagatedDefs[definedVar].push_back(node);
		
		addRenameNumberForNode(definedVar, node);
	}

	if (getDebugExtra())
	{
		cout << "Local Defs replaced in propDefs ";
		printDefs(stagingPropagatedDefs);
	}

	//Now do a comparison to see if we should copy
	bool changed = false;
	if (stagingPropagatedDefs != reachingDefsTable[node])
	{
		reachingDefsTable[node] = stagingPropagatedDefs;
		changed = true;
	}

	if (getDebug())
	{
		cout << "Defs after Merge..." << endl;
		printDefs(node);
		printRenameTable();
	}

	return changed;
}

void StaticSingleAssignment::updateIncomingDefs(FilteredCfgNode cfgNode)
{
	//When we want to propogate the defs from the previous node(s) to this one,
	//We perform a few steps. This is dependent on the number of incoming edges.

	/*1 Edge: When we have linear control flow, we do the following:
	 *        1. Copy the definitions from the previous node wholesale to a staging table.
	 *        2. Copy in the original definitions from the current node, overwriting those
	 *           from the previous node.
	 *        3. Compare the staging and current tables, and only overwrite if needed.
	 */

	/*2+ Edges: When we have branched control flow, we do the following:
	 *       1. Copy the definitions from the previous node(s) wholesale to a staging table.
	 *          Be careful to not insert duplicates.
	 *       2. Copy in the original definitions from the current node, overwriting those
	 *          from the previous node(s).
	 *       3. Compare the staging and current tables, and only overwrite if needed.
	 */

	//Get the previous edges in the CFG for this node
	vector<FilteredCfgEdge> inEdges = cfgNode.inEdges();
	SgNode* node = cfgNode.getNode();

	NodeReachingDefTable& incomingDefTable = ssaReachingDefsTable[node].first;

	if (inEdges.size() == 1)
	{
		SgNode* prev = inEdges.front().source().getNode();
		incomingDefTable = ssaReachingDefsTable[prev].second;
	}
	else if (inEdges.size() > 1)
	{
		//Iterate all of the incoming edges
		for (unsigned int i = 0; i < inEdges.size(); i++)
		{
			SgNode* prev = inEdges[i].source().getNode();

			const NodeReachingDefTable& previousDefs = ssaReachingDefsTable[prev].second;
			foreach(const NodeReachingDefTable::value_type& varDefPair, previousDefs)
			{
				const VarName& var = varDefPair.first;
				const ReachingDefPtr previousDef = varDefPair.second;

				//If this is the first time this def has propagated to this node, just copy it over
				if (incomingDefTable.count(var) == 0)
				{
					incomingDefTable[var] = previousDef;
				}
				else
				{
					ReachingDefPtr existingDef = incomingDefTable[var];

					if (existingDef->isPhiFunction() && existingDef->getDefinitionNode() == node)
					{
						//There is a phi node here. We update the phi function to point to the previous reaching definition
						existingDef->addJoinedDef(previousDef);
					}
					else
					{
						//If there is no phi node, and we get a new definition, it better be the same as the one previously
						//propagated.
						ROSE_ASSERT(*previousDef == *existingDef);
					}
				}
			}
		}
	}
}

void StaticSingleAssignment::aggregatePreviousDefs(FilteredCfgNode curNode, TableEntry& results)
{
	//When we want to propogate the defs from the previous node(s) to this one,
	//We perform a few steps. This is dependent on the number of incoming edges.

	/*1 Edge: When we have linear control flow, we do the following:
	 *        1. Copy the definitions from the previous node wholesale to a staging table.
	 *        2. Copy in the original definitions from the current node, overwriting those
	 *           from the previous node.
	 *        3. Compare the staging and current tables, and only overwrite if needed.
	 */

	/*2+ Edges: When we have branched control flow, we do the following:
	 *       1. Copy the definitions from the previous node(s) wholesale to a staging table.
	 *          Be careful to not insert duplicates.
	 *       2. Copy in the original definitions from the current node, overwriting those
	 *          from the previous node(s).
	 *       3. Compare the staging and current tables, and only overwrite if needed.
	 */

	//Get the previous edges in the CFG for this node
	vector<FilteredCfgEdge> inEdges = curNode.inEdges();

	if (inEdges.size() == 1)
	{
		SgNode* prev = inEdges[0].source().getNode();

		//Copy the previous node defs to the staging table
		results = reachingDefsTable[prev];
	}
	else if (inEdges.size() > 1)
	{
		//Iterate all of the incoming edges
		for (unsigned int i = 0; i < inEdges.size(); i++)
		{
			SgNode* prev = inEdges[i].source().getNode();

			//Perform the union of all the infoming definitions.
			foreach(TableEntry::value_type& entry, reachingDefsTable[prev])
			{
				//Insert the definitions for this node at the end of the list
				results[entry.first].insert(results[entry.first].end(), entry.second.begin(), entry.second.end());
			}
		}
	}

	//Sort every vector in propDefs and remove duplicates
	foreach(TableEntry::value_type& entry, results)
	{
		sort(entry.second.begin(), entry.second.end());
		//Create new sequence of unique elements and remove duplicate ones
		entry.second.resize(unique(entry.second.begin(), entry.second.end()) - entry.second.begin());
	}
}

void StaticSingleAssignment::buildUseTable(SgFunctionDefinition* function)
{
	set<FilteredCfgNode> worklist;
	unordered_set<SgNode*> visited;
	worklist.insert(FilteredCfgNode(function->cfgForBeginning()));

	while (!worklist.empty())
	{
		FilteredCfgNode cfgNode = *worklist.begin();
		worklist.erase(worklist.begin());
		
		SgNode* node = cfgNode.getNode();
		visited.insert(node);

		//For every edge, add it to the worklist if it is not seen
		foreach(const FilteredCfgEdge& edge, cfgNode.outEdges())
		{
			FilteredCfgNode nextNode = edge.target();

			//Insert the child in the worklist if it hasn't been visited yet
			if (visited.count(nextNode.getNode()) == 0)
			{
				worklist.insert(nextNode);
			}
		}

		//We want to resolve the uses at the current node
		//We need to look to the defs at the current node, and match them
		//with the uses

		//Iterate every use at the current node
		foreach(const TableEntry::value_type& entry, useTable[node])
		{
			const VarName& usedVar = entry.first;

			//Check the defs that are active at the current node to find the reaching definition
			//We want to check if there is a definition entry for this use at the current node
			if (reachingDefsTable[node].find(usedVar) != reachingDefsTable[node].end())
			{
				useTable[node][usedVar] = reachingDefsTable[node][usedVar];
			}
			else
			{
				// There are no defs for this use at this node, this shouldn't happen
				printf("Error: Found use for the name '%s', but no reaching defs!\n", varnameToString(usedVar).c_str());
				ROSE_ASSERT(false);
			}
		}

		TableEntry results;
		//Get the previous defs
		aggregatePreviousDefs(cfgNode, results);

		//If there is a def at the current node, we want to use the previous
		//def as the use for this node.
		foreach(const TableEntry::value_type& entry, useTable[node])
		{
			if (originalDefTable[node].count(entry.first) != 0)
			{
				useTable[node][entry.first] = results[entry.first];

				if (getDebug())
					cout << "Fixed use of local def." << endl;
			}
		}
	}
}

int StaticSingleAssignment::addRenameNumberForNode(const VarName& var, SgNode* node)
{
	ROSE_ASSERT(node);

	//Check if the var/node combination is already in the table.
	if (nodeRenameTable[var].count(node) == 1)
	{
		return nodeRenameTable[var][node];
	}

	//Not in the table, so we now need to add it.
	int nextNum = nodeRenameTable[var].size() + 1;

	nodeRenameTable[var][node] = nextNum;
	numRenameTable[var][nextNum] = node;

	if (getDebug())
		cout << "Renaming Added:[" << varnameToString(var) << "]:" << nextNum << " - " << node << endl;

	return nextNum;
}

/** Returns a set of all the variables names that have uses in the subtree. */
set<StaticSingleAssignment::VarName> StaticSingleAssignment::getVarsUsedInSubtree(SgNode* root)
{
	class CollectUsesVarsTraversal : public AstSimpleProcessing
	{
	public:
		StaticSingleAssignment* ssa;

		//All the varNames that have uses in the function
		set<VarName> usedNames;

		void visit(SgNode* node)
		{
			DefUseTable::const_iterator useEntry = ssa->useTable.find(node);
			if (useEntry == ssa->useTable.end())
				return;

			foreach (const TableEntry::value_type& varNodesPair, useEntry->second)
			{
				const VarName& usedVar = varNodesPair.first;
				usedNames.insert(usedVar);
			}
		}
	};

	CollectUsesVarsTraversal usesTrav;
	usesTrav.ssa = this;
	usesTrav.traverse(root, preorder);
	return usesTrav.usedNames;
}

void StaticSingleAssignment::insertDefsForChildMemberUses(SgFunctionDeclaration* function)
{
	ROSE_ASSERT(function->get_definition() != NULL);

	set<VarName> usedNames = getVarsUsedInSubtree(function);

	//Map each varName to all used names for which it is a prefix
	map<VarName, set<VarName> > nameToChildNames;
	foreach(const VarName& rootName, usedNames)
	{
		foreach(const VarName& childName, usedNames)
		{
			if (childName.size() <= rootName.size())
				continue;

			if (isPrefixOfName(childName, rootName))
			{
				nameToChildNames[rootName].insert(childName);
			}
		}
	}

	//Now that we have all the used names, we iterate the definitions.
	//If there is a definition and a child of it is used, we have to insert a definition for the child also
	class InsertExpandedDefsTraversal : public AstSimpleProcessing
	{
	public:
		StaticSingleAssignment* ssa;
		map<VarName, set<VarName> >* nameToChildNames;

		void visit(SgNode* node)
		{
			LocalDefTable::const_iterator childDefs = ssa->originalDefTable.find(node);

			if (childDefs == ssa->originalDefTable.end())
				return;

			foreach(const VarName& definedVar, childDefs->second)
			{
				map<VarName, set<VarName> >::iterator childVars = nameToChildNames->find(definedVar);
				if (childVars == nameToChildNames->end())
					continue;

				//Go over all the child names and define them here also
				foreach (const VarName& childName, childVars->second)
				{
					ROSE_ASSERT(childName.size() > definedVar.size());
					for (size_t i = 0; i < (childName.size() - definedVar.size()); i++)
					{
						//Create a new varName vector that goes from beginning to end - i
						VarName newName;
						newName.assign(childName.begin(), childName.end() - i);

						if (ssa->expandedDefTable[node].count(newName) == 0 && ssa->originalDefTable[node].count(newName) == 0)
						{
							ssa->expandedDefTable[node].insert(newName);
						}
					}
				}
			}
		}
	};

	InsertExpandedDefsTraversal trav;
	trav.ssa = this;
	trav.nameToChildNames = &nameToChildNames;
	trav.traverse(function, preorder);
}


/** Insert defs for functions that are declared outside the function scope. */
void StaticSingleAssignment::insertDefsForExternalVariables(SgFunctionDeclaration* function)
{
	ROSE_ASSERT(function->get_definition() != NULL);

	set<VarName> usedNames = getVarsUsedInSubtree(function);

	set<VarName>& originalVarsAtFunctionEntry = originalDefTable[function->get_definition()];
	set<VarName>& expandedVarsAtFunctionEntry = expandedDefTable[function->get_definition()];

	//Iterate over each used variable and check it it is declared outside of the function scope
	foreach(const VarName& usedVar, usedNames)
	{
		VarName rootName;
		rootName.assign(1, usedVar[0]);

		SgScopeStatement* varScope = SageInterface::getScope(rootName[0]);
		SgScopeStatement* functionScope = function->get_definition();

		//If it is a local variable, there should be a def somewhere inside the functio
		if (varScope == functionScope || SageInterface::isAncestor(functionScope, varScope))
		{
			//We still need to insert defs for compiler-generated variables (e.g. __func__), since they don't have defs in the AST
			if (!isBuiltinVar(rootName))
				continue;
		}

		//Are there any other types of external vars?
		ROSE_ASSERT(isBuiltinVar(rootName) || isSgClassDefinition(varScope) || isSgNamespaceDefinitionStatement(varScope)
				|| isSgGlobal(varScope));

		//The variable is not in local scope; we need to insert a def for it at the function definition
		for (size_t i = 0; i < usedVar.size(); i++)
		{
			//Create a new varName vector that goes from beginning to end - i
			VarName newName;
			newName.assign(usedVar.begin(), usedVar.end() - i);
			originalVarsAtFunctionEntry.insert(newName);
			ROSE_ASSERT(expandedVarsAtFunctionEntry.count(newName) == 0);
		}
	}
}


void StaticSingleAssignment::insertPhiFunctions(SgFunctionDefinition* function)
{
	ROSE_ASSERT(function != NULL);

	//First, find all the places where each name is defined
	map<VarName, vector<FilteredCfgNode> > nameToDefNodesMap;

	set<FilteredCfgNode> worklist;
	unordered_set<SgNode*> visited;
	worklist.insert(FilteredCfgNode(function->cfgForBeginning()));

	while (!worklist.empty())
	{
		FilteredCfgNode cfgNode = *worklist.begin();
		worklist.erase(worklist.begin());

		SgNode* node = cfgNode.getNode();
		visited.insert(node);

		//For every edge, add it to the worklist if it is not seen
		foreach(const FilteredCfgEdge& edge, cfgNode.outEdges())
		{
			FilteredCfgNode nextNode = edge.target();

			//Insert the child in the worklist if it hasn't been visited yet
			if (visited.count(nextNode.getNode()) == 0)
			{
				worklist.insert(nextNode);
			}
		}

		//Check the definitions at this node and add them to the map
		LocalDefTable::const_iterator defEntry = originalDefTable.find(node);
		if (defEntry != originalDefTable.end())
		{
			foreach (const VarName& definedVar, defEntry->second)
			{
				nameToDefNodesMap[definedVar].push_back(cfgNode);
			}
		}

		defEntry = expandedDefTable.find(node);
		if (defEntry != expandedDefTable.end())
		{
			foreach (const VarName& definedVar, defEntry->second)
			{
				nameToDefNodesMap[definedVar].push_back(cfgNode);
			}
		}
	}

	//Build an iterated dominance frontier for this function
	map<FilteredCfgNode, set<FilteredCfgNode> > domFrontiers =
			calculateDominanceFrontiers<FilteredCfgNode, FilteredCfgEdge>(function);

	//Find the phi function locations for each variable
	VarName var;
	vector<FilteredCfgNode> definitionPoints;
	foreach (tie(var, definitionPoints), nameToDefNodesMap)
	{
		ROSE_ASSERT(!definitionPoints.empty() && "We have a variable that is not defined anywhere!");

		//Calculate the iterated dominance frontier
		set<FilteredCfgNode> phiNodes = calculateIteratedDominanceFrontier(domFrontiers, definitionPoints);

		if (getDebug())
			printf("Variable %s has phi nodes inserted at\n", varnameToString(var).c_str());

		foreach (FilteredCfgNode phiNode, phiNodes)
		{
			SgNode* node = phiNode.getNode();
			ROSE_ASSERT(ssaReachingDefsTable[node].first.count(var) == 0);
			
			ssaReachingDefsTable[node].first[var] = ReachingDefPtr(new ReachingDef(node, ReachingDef::PHI_FUNCTION));

			if (getDebug())
				printf("\t\t%s\n", phiNode.toStringForDebugging().c_str());
		}
	}
}

void StaticSingleAssignment::insertLocalDefs(SgFunctionDefinition* function)
{
	struct InsertDefs : public AstSimpleProcessing
	{
		StaticSingleAssignment* ssa;

		void visit(SgNode* node)
		{
			//Short circuit to prevent creating empty entries in the local def table when we don't need them
			if ((ssa->originalDefTable.count(node) == 0 || ssa->originalDefTable[node].empty()) &&
				(ssa->expandedDefTable.count(node) == 0 || ssa->expandedDefTable[node].empty()))
			{
				return;
			}

			//This is the table of local definitions at the current node
			NodeReachingDefTable& localDefs = ssa->ssaLocalDefTable[node];

			if (ssa->originalDefTable.count(node) > 0)
			{
				foreach(const VarName& definedVar, ssa->originalDefTable[node])
				{
					localDefs[definedVar] = ReachingDefPtr(new ReachingDef(node, ReachingDef::ORIGINAL_DEF));
				}
			}

			if (ssa->expandedDefTable.count(node) > 0)
			{
				foreach(const VarName& definedVar, ssa->expandedDefTable[node])
				{
					localDefs[definedVar] = ReachingDefPtr(new ReachingDef(node, ReachingDef::EXPANDED_DEF));
				}
			}
		}
	};

	InsertDefs trav;
	trav.ssa = this;
	trav.traverse(function, preorder);
}
#include "utilities.h"

#include <rose.h>
#include <boost/foreach.hpp>
#include <boost/algorithm/string.hpp>

using namespace std;
using namespace boost;
using namespace SageInterface;
using namespace SageBuilder;

#define foreach BOOST_FOREACH


/* For a scalar type, it can be modified by assignment and incrementation/decrementation.
 * For a class type, it can be modified by assignment or it's own member function calls.
 *
 *
 */


class StateSaver
{
    string event_name_;
    SgFunctionDefinition* func_def_;

public:
    StateSaver(SgFunctionDefinition* func)
        : func_def_(func)
    {}


    typedef bool (*IsStateFunc)(SgExpression*);



    vector<SgExpression*> getAllModifiedVars(IsStateFunc pred)
    {
        vector<SgExpression*> modified_vars;

        Rose_STL_Container<SgNode*> exp_list = NodeQuery::querySubTree(func_def_, V_SgExpression);
        foreach (SgNode* node, exp_list)
        {
            SgExpression* candidate = NULL;

            if (isSgPlusPlusOp(node) || isSgMinusMinusOp(node))
            {
                candidate = isSgUnaryOp(node)->get_operand();
            }

            else if(isSgAssignOp(node) ||
                    isSgPlusAssignOp(node) ||
                    isSgMinusAssignOp(node) ||
                    isSgMultAssignOp(node) ||
                    isSgDivAssignOp(node) ||
                    isSgModAssignOp(node) ||
                    isSgIorAssignOp(node) ||
                    isSgAndAssignOp(node) ||
                    isSgXorAssignOp(node) ||
                    isSgLshiftAssignOp(node) ||
                    isSgRshiftAssignOp(node))
            {
                candidate = isSgBinaryOp(node)->get_lhs_operand();
            }

            if (SgFunctionCallExp* func_call = isSgFunctionCallExp(node))
            {
                SgExpressionPtrList exp_list = func_call->get_args()->get_expressions();
                SgInitializedNamePtrList init_name_list = func_call->getAssociatedFunctionDeclaration()->get_args();
                for (size_t i = 0; i < exp_list.size(); ++i)
                {
                    SgExpression* par = exp_list[i];
                    if (pred(par))// && isPointerType(init_name_list[i]->get_type()))
                    {
                    }
                }
            }

            if (pred(candidate))
            {
                foreach (SgExpression* var, modified_vars)
                    if (areSameVariable(var, candidate))
                        continue;
                modified_vars.push_back(candidate);
                if (isSgVarRefExp(candidate))
                cout << get_name(candidate) << endl;
            }
        }

        return modified_vars;
    }

    SgClassDefinition* buildStorage(const vector<SgExpression*>& vars)
    {
        string event_name = func_def_->get_declaration()->get_name();
        SgClassDeclaration* storage_decl = buildStructDeclaration(event_name + "_Storage");
        SgClassDefinition* storage_def = buildClassDefinition(storage_decl);

        foreach (SgExpression* var, vars)
        {
            if (SgVarRefExp* var_ref = isSgVarRefExp(var))
            {
                cout << var_ref->get_symbol()->get_name().str() << endl;
                SgVariableDeclaration* var_decl = buildVariableDeclaration(
                        var_ref->get_symbol()->get_name(),
                        var_ref->get_symbol()->get_type());
                appendStatement(var_decl, storage_def);
            }
        }

        return storage_def;
    }



    void storeVariable(SgExpression* var)
    {
        SgType* var_type = var->get_type();
    }
};

bool isState(SgExpression*)
{
    return true;
}

class reverserTraversal : public AstSimpleProcessing
{
    public:
        reverserTraversal() 
            : AstSimpleProcessing(),
            events_num(0),  
            model_type(0)
    {}
        virtual void visit(SgNode* n);

        int events_num;
        SgClassType* model_type;
        vector<SgFunctionDeclaration*> funcs_gen;
        vector<SgFunctionDeclaration*> all_funcs;
        vector<SgStatement*> var_decls;
        vector<SgStatement*> var_inits;
        vector<string> event_names;
        vector<SgClassDefinition*> storages; 
};


void reverserTraversal::visit(SgNode* n)
{
    if (SgFunctionDeclaration* func_decl = isSgFunctionDeclaration(n))
    {
        all_funcs.push_back(func_decl);

        string func_name = func_decl->get_name();
        if (!istarts_with(func_name, "event") ||
                iends_with(func_name, "reverse") ||
                iends_with(func_name, "forward"))
            return;

        //cout << func_name << endl;
        event_names.push_back(func_name);

        StateSaver state_saver(func_decl->get_definition());
        SgClassDefinition* class_def = state_saver.buildStorage(state_saver.getAllModifiedVars(isState));
        storages.push_back(class_def);


#if 0
        vector<FuncDeclPair> func_pairs = reverser.outputFunctions();
        foreach (const FuncDeclPair& func_pair, func_pairs)
        {
            funcs_gen.push_back(func_pair.second);
            funcs_gen.push_back(func_pair.first);
        }

        // Collect all variables needed to be declared
        vector<SgStatement*> decls = reverser.getVarDeclarations();
        vector<SgStatement*> inits = reverser.getVarInitializers();

        var_decls.insert(var_decls.end(), decls.begin(), decls.end());
        var_inits.insert(var_inits.end(), inits.begin(), inits.end());

        // increase the number of events
        ++events_num;

        /* 
           pair<SgFunctionDeclaration*, SgFunctionDeclaration*> 
           func = reverseFunction(func_decl->get_definition());
           if (func.first != NULL)
           funcs.push_back(func.first);
           if (func.second != NULL)
           funcs.push_back(func.second);
           */
    }

    // Get the model structure type which will be used in other functions, like initialization.
    if (SgClassDeclaration* model_decl = isSgClassDeclaration(n))
    {
        //if (model_decl->get_qualified_name() == "model")
        model_type = model_decl->get_type();
    }
#endif
}
}


int main( int argc, char * argv[] )
{
    vector<string> args(argv, argv+argc);
    SgProject* project = frontend(args);

    

    reverserTraversal reverser;

    SgGlobal *globalScope = getFirstGlobalScope(project);
    reverser.traverseInputFiles(project,preorder);

    pushScopeStack(isSgScopeStatement(globalScope));

    cout << reverser.storages[0] << endl;
    appendStatement(reverser.storages[0]->get_declaration());
    
    popScopeStack();

    return backend(project);
#if 0
    ROSE_ASSERT(reverser.model_type);

    //SgStatement* init_func = buildInitializationFunction();


    for (size_t i = 0; i < reverser.var_decls.size(); ++i)
        prependStatement(reverser.var_decls[i]);
    for (size_t i = 0; i < reverser.funcs_gen.size(); ++i)
        insertFunctionInPlace(reverser.funcs_gen[i], reverser.all_funcs);
    //appendStatement(reverser.funcs[i]);

    //appendStatement(buildInitializationFunction(reverser.model_type));
    //appendStatement(buildCompareFunction(reverser.model_type));
    //appendStatement(buildMainFunction(reverser.var_inits, reverser.event_names, klee));


    popScopeStack();

    // Write or find a function to clear all nodes in memory pool who don't have parents.
#if 1
    cout << "Start to fix variables references\n";
    fixVariableReferences2(globalScope);
    cout << "Fix finished\n";

    //AstTests::runAllTests(project);
#endif
    return backend(project);

#endif
}


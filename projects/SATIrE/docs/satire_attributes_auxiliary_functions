$Id: satire_attributes_auxiliary_functions,v 1.6 2008-05-16 13:00:18 gergo Exp $

This file lists all CFG attributes and auxiliary functions accessible from
PAG analysis specifications when using the SATIrE system.


CFG Attributes
==============
A CFG attribute is accessible from the analysis specification by name,
essentially like a variable that may have different values in different
places. See Chapter 12 of the PAG manual for details on the general concept.
The attributes are presented in a way that is similar to the syntax used in
the .optla file.

GLOBAL Attributes
-----------------
globals: *VariableSymbolNT #
    A list of the global variables in the program. Types and initializers of
    global variables can be accessed via auxiliary functions, see below.

numtypes: unum #
    The number of different data types in the program. Types are associated
    with unique numbers that can be manipulated using auxiliary functions,
    see below.

numexprs: unum #
    The number of lexically different expressions in the program. Each
    expression is associated with a unique integer that can be manipulated
    using auxiliary functions, see below.

ROUTINE Attributes
------------------
procnum: snum #
    A unique numerical ID for the current procedure. Procedure numbers are
    never negative.

BLOCK Attributes
----------------
label: snum #
    A unique numerical label for the block; as each block in SATIrE consists
    of exactly one statement, this can also be considered a unique label for
    each statement. Labels are never negative.


Auxiliary Functions
===================
Auxiliary functions are functions provided by the SATIrE library to support
some common operations that would be impossible or very complicated to
implement in FULA. The definitions for these functions are automatically
linked against the generated analyzer. To use one of the functions, simply
copy the declaration listed below into the SUPPORT section of your analysis
specification. PAG will issue a warning that the function has an empty body;
you can disregard the warning as the definitions for the functions are
supplied elsewhere.

The functions are:

is_unary :: Expression -> bool;
    test whether an Expression is a unary expression

is_binary :: Expression -> bool;
    test whether an Expression is a binary expression

is_value :: Expression -> bool;
    test whether an Expression is a value expression (a constant appearing
    in the source code)

unary_get_child :: Expression -> Expression;
    get the operand expression of a unary expression

binary_get_left_child :: Expression -> Expression;
    get left child of a binary expression

binary_get_right_child :: Expression -> Expression;
    get right child of a binary expression

type_to_typenum :: Type -> unum;
    convert a type to its corresponding type number, a unique integer
    associated with each type

typenum_to_type :: unum -> Type;
    convert a type number to the corresponding type

typenum_to_str :: unum -> str;
    convert a type number to its corresponding string representation

is_subtype_of :: Type, Type -> bool;
    test whether type1 is a subtype of type2 (in the object oriented class
    hierarchy)

is_subtypenum_of :: unum, unum -> bool;
    test whether typenumber1 represents a subtype of the type corresponding
    to typenumber2 (in the object oriented class hierarchy)

expr_to_exprnum :: Expression -> unum;
    convert an expression to the corresponding expression number, a unique
    integer associated with each lexically distinct expression

exprnum_to_expr :: unum -> Expression;
    convert an expression number to the corresponding expression

exprnum_to_str :: unum -> str;
    convert an expression number to the corresponding string (of the
    expression)

expr_type :: Expression -> Type;
    get the type of an expression

exprnum_typenum :: unum -> unum;
    get the type number for a given expression number

global_get_type :: VariableSymbolNT -> Type;
    get the type of the global variable

global_has_initializer :: VariableSymbolNT -> bool;
    test whether the global variable has an initializer expression

global_get_initializer :: VariableSymbolNT -> Expression;
    get the initializer expression of the global variable

variable_varnum :: VariableSymbolNT -> unum;
    a unique integer identifier for this variable guaranteed to be the same
    as the exprnum for any use (VarRefExp) of this variable; if there are
    no VarRefExps for this variable, the identifier is >= numexprs

varnum_id :: unum -> VariableID;
    EXPERIMENTAL: maps the variable identifier to an opaque VariableID
    object that can be used almost like built-in PAG data types, i.e. it can
    appear in data flow information etc; VariableID needs a dummy
    declaration, we recommend a declaration like
        VariableID = set(VariableID)
    or
        VariableID = VariableID -> VariableID
    in the SET section of the .set file (any definition that applies a type
    constructor to something should be fine)

variable_id :: VariableSymbolNT -> VariableID;
    EXPERIMENTAL: maps a variable symbol to its VariableID

varref_id :: Expression -> VariableID;
    EXPERIMENTAL: maps a VarRefExp to its VariableID; it is an error to call
    this with any other subtype of Expression!

expr_id :: Expression -> ExpressionID;
    EXPERIMENTAL: maps the expression to an opaque ExpressionID object that
    can be used like built-in PAG data types, like VariableID

id_to_expr :: ExpressionID -> Expression;
    EXPERIMENTAL: maps the expression ID to the actual expression it
    represents

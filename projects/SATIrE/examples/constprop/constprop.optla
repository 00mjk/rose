// Author: Gergo Barany, 2006.

PROBLEM Constant_Propagation
    direction:  forward
    carrier:    State
    init:       bot
    init_start: [-> top]
    combine:    comb
    retfunc:    comb
    widening:   wide
    equal:      eq

TRANSFER
ExprStatement(ExpressionRoot(exp)), _:
    if @ != bot then
        eval(exp, @)!2!2
    else
        bot
    endif;

ArgumentAssignment(VarRefExp(var), exp), _:
    if @ != bot then
        @\[val-aststring(var) -> eval(exp, @)!1!2]
    else
        bot
    endif;

ParamAssignment(VariableSymbol(var), VariableSymbol(param)), _:
    if @ != bot then
        // assign var
        @\[val-aststring(var) -> @{!val-aststring(param)!}]
        // kill rhs
        \[val-aststring(param) -> top]
    else
        bot
    endif;

ReturnAssignment(VariableSymbol(var), VariableSymbol(retvar)), _:
    if @ != bot then
        // assign var
        @\[val-aststring(var) -> @{!val-aststring(retvar)!}]
        // kill rhs
        \[val-aststring(retvar) -> top]
    else
        bot
    endif;

ScopeStatement(IfStmt(ExprStatement(ExpressionRoot(cond)))), true_edge:
    branch(cond, @, true);

ScopeStatement(IfStmt(ExprStatement(ExpressionRoot(cond)))), false_edge:
    branch(cond, @, false);

ScopeStatement(WhileStmt(ExprStatement(ExpressionRoot(cond)))), true_edge:
    branch(cond, @, true);

ScopeStatement(WhileStmt(ExprStatement(ExpressionRoot(cond)))), false_edge:
    branch(cond, @, false);

ScopeStatement(ForStatement(_,ExpressionRoot(cond),_)), true_edge:
    branch(cond, @, true);

ScopeStatement(ForStatement(_,ExpressionRoot(cond),_)), false_edge:
    branch(cond, @, false);

LogicalIf(cond), true_edge:
    branch(cond, @, true);

LogicalIf(cond), false_edge:
    branch(cond, @, false);

UndeclareStmt(vars), _:
    kill_vars(@, vars);

FunctionExit(_, vars), _:
    kill_vars(@, vars);

FunctionCall(_,_), local_edge:
    bot;

_, _: @;

SUPPORT
eval :: Expression, State -> ConstStatePair;
eval(exp, state) =
    if is_unary(exp) then
        unary(unary_get_child(exp), exp, state)
    else if is_binary(exp) then
        binary(binary_get_left_child(exp), binary_get_right_child(exp),
                exp, state)
    else if is_value(exp) then
        case exp of
            BoolValExp(value) => (lift(val-astint(value)), state);
            IntVal(value)     => (lift(val-astint(value)), state);
            EnumVal(value)    => (lift(val-astint(value)), state);
            LongIntVal(value) => (lift(val-astlong(value)), state);
            _                 => print("unsupported value exp: ")
                                 print(exp) print("\n") (top, [-> top]);
        endcase
    else case exp of
        VarRefExp(name)             => (state{!val-aststring(name)!}, state);
        NewExp(_,_,_)               => (top, state);
        _                           => print("unknown exp: ")
                                       print(exp) print("\n") (top, [-> top]);
    endcase endif endif endif;

binary :: Expression, Expression, Expression, State -> ConstStatePair;
binary(left, right, exp, state) =
    // Evaluate the right child expression, yielding a (value, state)
    // pair assigned to r and rs, respectively.
    let rr = eval(right, state);
    in case exp of
        // If this is an assignment operation, update the state.
        // We do not evaluate the left-hand side as this might
        // yield bot, causing trouble.
        AssignOp(_, _) =>
            if rr!1!2 = top
            then
                (top, rr!2!2)
            else
                let r <= rr!1!2; rs = rr!2!2; in
                updatestate(rs, left, lift(r))
            endif;
        // If this is not an assignment, we may safely evaluate
        // the left-hand side as well (in the "new" state after
        // evaluation of the rhs) and perform the operation.
        _ =>
            let r <= rr!1!2; rs = rr!2!2;
            in let ll = eval(left, rs);
            in let l <= ll!1!2; ls = ll!2!2;
            in case exp of
                EqualityOp(_, _)        => (lift(bool_int(l = r)), ls);
                LessThanOp(_, _)        => (lift(bool_int(l < r)), ls);
                GreaterThanOp(_, _)     => (lift(bool_int(l > r)), ls);
                NotEqualOp(_, _)        => (lift(bool_int(l != r)), ls);
                LessOrEqualOp(_, _)     => (lift(bool_int(l <= r)), ls);
                GreaterOrEqualOp(_, _)  => (lift(bool_int(l >= r)), ls);
                AddOp(_, _)             => (lift(l + r), ls);
                SubtractOp(_, _)        => (lift(l - r), ls);
                MultiplyOp(_, _)        => (lift(l * r), ls);
                DivideOp(_, _)          => (lift(l / r), ls);
                IntegerDivideOp(_, _)   => (lift(l / r), ls);
                ModOp(_, _)             => (lift(l % r), ls);
                AndOp(_, _)         => (lift(bool_int(l != 0 && r != 0)), ls);
                OrOp(_, _)          => (lift(bool_int(l != 0 || r != 0)), ls);
                ScopeOp(_, _)       => (lift(r), ls);
                PlusAssignOp(_, _)  => updatestate(ls, left, lift(l + r));
                MinusAssignOp(_, _) => updatestate(ls, left, lift(l - r));
                MultAssignOp(_, _)  => updatestate(ls, left, lift(l * r));
                DivAssignOp(_, _)   => updatestate(ls, left, lift(l / r));
                ModAssignOp(_, _)   => updatestate(ls, left, lift(l % r));
                _ => print("unsupported binary: ") print(exp) (top, [-> top]);
            endcase;
    endcase;

unary :: Expression, Expression, State -> ConstStatePair;
unary(child, exp, state) =
    let ee = eval(child, state);
    in let e <= ee!1!2; es = ee!2!2;
    in case exp of
        MinusOp(_)      => (lift(-e), es);
        UnaryAddOp(_)   => (lift(e), es);
        NotOp(_)        => (lift(bool_int(e = 0)), es);
        CastExp(_, _)   => eval(child, state);
        // the following are only correct for prefix -- and ++
        MinusMinusOp(_) => updatestate(es, child, lift(e - 1));
        PlusPlusOp(_)   => updatestate(es, child, lift(e + 1));
        _ => print("unsupported unary: ") print(exp) (top, [-> top]);
    endcase;

bool_int :: bool -> snum;
bool_int(b) =
    if b then 1 else 0 endif;

int_bool :: snum -> bool;
int_bool(i) =
    if i != 0 then true else false endif;

updatestate :: State, Expression, Const -> ConstStatePair;
// Update state state by assigning the value value to the variable
// referenced by expression exp (if any). Yields a pair of the value
// and the new state.
updatestate(state, exp, value) =
    let newstate =
        case exp of
            VarRefExp(var) => state\[val-aststring(var) -> value];
            _ => state;
        endcase;
    in (value, newstate);

branch :: Expression, State, bool -> State;
branch(exp, state, edge) =
    let pair = eval(exp, state);
    in let c = pair!1!2; newstate = pair!2!2;
    in if c = top then
        state
    else let cond <= c;
    in if int_bool(cond) = edge then
        newstate
    else
        bot
    endif
    endif;

kill_vars :: State, *VariableSymbolNT -> State;
kill_vars(s, [!]) =
    s;
kill_vars(s, VariableSymbol(v)::vars) =
    kill_vars(s\[val-aststring(v) -> top], vars);

is_unary :: Expression -> bool;
is_binary :: Expression -> bool;
is_value :: Expression -> bool;
unary_get_child :: Expression -> Expression;
binary_get_left_child :: Expression -> Expression;
binary_get_right_child :: Expression -> Expression;

comb(a, b) = a lub b;
wide(a, b) = b;
eq(a, b)   = (a = b);

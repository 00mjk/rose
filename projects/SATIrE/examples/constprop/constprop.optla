// -*- prolog -*-
// Author: Gergo Barany, 2006.

PROBLEM Constant_Propagation
    direction:  forward
    carrier:    State
    init:       bot
    init_start: [-> top]
    combine:    comb
    retfunc:    comb
    widening:   wide
    equal:      eq

TRANSFER
FunctionEntry(_), _:
    if @ != bot then
        @
    else
        top
    endif;
 
ExprStatement(exp), _:
    if @ != bot then
        eval(exp, @)!2!2
    else
        bot
    endif;

ArgumentAssignment(VarRefExp(var), exp), _:
    if @ != bot then
        @\[val-aststring(var) -> eval(exp, @)!1!2]
    else
        bot
    endif;

ParamAssignment(VariableSymbol(var), VariableSymbol(param)), _:
    if @ != bot then
        // assign var
        @\[val-aststring(var) -> @{!val-aststring(param)!}]
        // kill rhs
        \[val-aststring(param) -> top]
    else
        bot
    endif;

ReturnAssignment(VariableSymbol(var), VariableSymbol(retvar)), _:
    if @ != bot then
        // assign var
        @\[val-aststring(var) -> @{!val-aststring(retvar)!}]
        // kill rhs
        \[val-aststring(retvar) -> top]
    else
        bot
    endif;

ScopeStatement(IfStmt(ExprStatement(cond))), true_edge:
    branch(cond, @, true);

ScopeStatement(IfStmt(ExprStatement(cond))), false_edge:
    branch(cond, @, false);

ScopeStatement(WhileStmt(ExprStatement(cond))), true_edge:
    branch(cond, @, true);

ScopeStatement(WhileStmt(ExprStatement(cond))), false_edge:
    branch(cond, @, false);

ScopeStatement(ForStatement(_,cond,_)), true_edge:
    branch(cond, @, true);

ScopeStatement(ForStatement(_,cond,_)), false_edge:
    branch(cond, @, false);

LogicalIf(cond), true_edge:
    branch(cond, @, true);

LogicalIf(cond), false_edge:
    branch(cond, @, false);

UndeclareStmt(vars), _:
    kill_vars(@, vars);

FunctionExit(_, vars), _:
    kill_vars(@, vars);

FunctionCall(_,_), local_edge:
    top;

_, _: @;

SUPPORT

eval :: Expression, State -> ConstStatePair;
eval(exp, state) =    
    if is_unary(exp) then
        unary(unary_get_child(exp), exp, state)
    else if is_binary(exp) then
        binary(binary_get_left_child(exp), binary_get_right_child(exp),
                exp, state)
    else if is_value(exp) then
        case exp of
            BoolValExp(value) => (lift(val-astint(value)), state);
            EnumVal(value)    => (lift(val-astint(value)), state);
            IntVal(value)     => (lift(val-astint(value)), state);
	    ShortVal(value)   => (lift(val-astshort(value)), state);
            LongIntVal(value) => (lift(val-astlong(value)), state);
            _                 => print("unsupported value exp: ")
                                 print(exp) print("\n") (top, [-> top]);
        endcase
    else case exp of
        VarRefExp(name)             => (state{!val-aststring(name)!}, state);
        NewExp(_,_,_)               => (bot, state);
        _                           => print("unknown exp: ")
                                       print(exp) print("\n") (top, [-> top]);
    endcase endif endif endif;

binary :: Expression, Expression, Expression, State -> ConstStatePair;
binary(left, right, exp, state) =
    // Evaluate the right child expression, yielding a (value, state)
    // pair assigned to r and rs, respectively.
    let rr = eval(right, state);
    in case exp of
        // If this is an assignment operation, update the state.
        // We do not evaluate the left-hand side as this might
        // yield top or bot, causing trouble.
        AssignOp(_, _) =>
            if rr!1!2 = top || rr!1!2 = bot
            then
                (top, rr!2!2)
            else
                let r <= rr!1!2; rs = rr!2!2; in
                updatestate(rs, left, lift(r))
            endif;
        // If this is not an assignment, we may safely evaluate
        // the left-hand side as well (in the "new" state after
        // evaluation of the rhs) and perform the operation.
        _ =>
            let rlifted = rr!1!2; rs = rr!2!2;
            in let ll = eval(left, rs);
            in let llifted = ll!1!2; ls = ll!2!2;
            in if rlifted = top || rlifted = bot then (rlifted, rs) else
               if llifted = top || llifted = bot then (llifted, ls) else
                let r <= rlifted;
                    l <= llifted;
                in case exp of
                    EqualityOp(_, _)        => (lift(bool_int(l = r)), ls);
                    LessThanOp(_, _)        => (lift(bool_int(l < r)), ls);
                    GreaterThanOp(_, _)     => (lift(bool_int(l > r)), ls);
                    NotEqualOp(_, _)        => (lift(bool_int(l != r)), ls);
                    LessOrEqualOp(_, _)     => (lift(bool_int(l <= r)), ls);
                    GreaterOrEqualOp(_, _)  => (lift(bool_int(l >= r)), ls);
                    AddOp(_, _)             => (lift(l + r), ls);
                    SubtractOp(_, _)        => (lift(l - r), ls);
                    MultiplyOp(_, _)        => (lift(l * r), ls);
                    DivideOp(_, _)          => (lift(l / r), ls);
                    IntegerDivideOp(_, _)   => (lift(l / r), ls);
                    ModOp(_, _)             => (lift(l % r), ls);
                    LshiftOp(_, _)          => (lift(shiftleft(l,r)), ls);
		    RshiftOp(_, _)          => (lift(shiftright(l,r)), ls);
		    BitAndOp(_, _)          => (lift((l & r)), ls);
		    BitOrOp(_, _)           => (lift((l | r)), ls);
		    AndOp(_, _)             => (lift(bool_int(l != 0 && r != 0)), ls);
                    OrOp(_, _)              => (lift(bool_int(l != 0 || r != 0)), ls);
                    ScopeOp(_, _)       => (lift(r), ls);
                    PlusAssignOp(_, _)  => updatestate(ls, left, lift(l + r));
                    MinusAssignOp(_, _) => updatestate(ls, left, lift(l - r));
                    MultAssignOp(_, _)  => updatestate(ls, left, lift(l * r));
                    DivAssignOp(_, _)   => updatestate(ls, left, lift(l / r));
                    ModAssignOp(_, _)   => updatestate(ls, left, lift(l % r));
                    _ => print("unsupported binary: ") print(exp) (top, [-> top]);
                endcase
            endif endif;
    endcase;

unary :: Expression, Expression, State -> ConstStatePair;
unary(child, exp, state) =
    let ee = eval(child, state);
    in let elifted = ee!1!2; es = ee!2!2;
    in if elifted = bot || elifted = top then (elifted, es) else
        let e <= elifted;
        in case exp of
            MinusOp(_)      => (lift(-e), es);
            UnaryAddOp(_)   => (lift(e), es);
            NotOp(_)        => (lift(bool_int(e = 0)), es);
            CastExp(_, _)   => eval(child, state);
         // the following are only correct for prefix -- and ++
            MinusMinusOp(_) => updatestate(es, child, lift(e - 1));
            PlusPlusOp(_)   => updatestate(es, child, lift(e + 1));
            _ => print("unsupported unary: ") print(exp) (top, [-> top]);
        endcase
    endif;

bool_int :: bool -> snum;
bool_int(b) =
    if b then 1 else 0 endif;

int_bool :: snum -> bool;
int_bool(i) =
    if i != 0 then true else false endif;
 
								      
updatestate :: State, Expression, Const -> ConstStatePair;
// Update state state by assigning the value value to the variable
// referenced by expression exp (if any). Yields a pair of the value
// and the new state.
updatestate(state, exp, value) =
    let newstate =
        case exp of
            VarRefExp(var) => state\[val-aststring(var) -> value];
            _ => state;
        endcase;
    in (value, newstate);

branch :: Expression, State, bool -> State;
branch(exp, state, edge) =
    let pair = eval(exp, state);
    in let c = pair!1!2; newstate = pair!2!2;
    in if c = top || c = bot then
        state
    else let cond <= c;
    in if int_bool(cond) = edge then
        newstate
    else
        bot
    endif
    endif;

kill_vars :: State, *VariableSymbolNT -> State;
kill_vars(s, [!]) =
    s;
kill_vars(s, VariableSymbol(v)::vars) =
    kill_vars(s\[val-aststring(v) -> top], vars);

is_unary :: Expression -> bool;
is_binary :: Expression -> bool;
is_value :: Expression -> bool;
unary_get_child :: Expression -> Expression;
binary_get_left_child :: Expression -> Expression;
binary_get_right_child :: Expression -> Expression;

shiftleft :: snum, snum -> snum;
shiftleft(a, 0) = a;
shiftleft(a, b) = a * 2 + shiftleft(a, b-1);

shiftright :: snum, snum -> snum;
shiftright(a, 0) = a;
shiftright(a, b) = a / 2 + shiftright(a, b-1);
								      

comb(a, b) =
 // print("comb a: ") print(a) print("\n")
 // print("comb b: ") print(b) print("\n")
 // print("result: ") print(
 // if a = bot then b else if b = bot then a else a glb b endif endif
 //                         ) print("\n\n")
    if a = bot then b else if b = bot then a else a glb b endif endif;
wide(a, b) = comb(a, b);
eq(a, b)   = (a = b);

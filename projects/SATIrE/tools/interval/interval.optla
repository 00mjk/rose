// -- -*- haskell -*- (Fake Emacs mode for syntax highlighting)
// -- vim: syntax=fula
// -- ------------------------------------------------------------------------
// -- Authors: Gergo Barany, 2006/2009 (original constprop/points-to info)
// --          Adrian Prantl, 2008-2009 (interval extensions)
// --          
// -- Contact: adrian@complang.tuwien.ac.at
// --
// -- TOP: Variable is not analyzABLE
// -- (min,max): Variable has the interval min =< v =< max
// -- BOT: Variable is not yet analyzED
// -- 
// -- remaining problems:
// -- * pointer aliasing is ignored -- not anymore!
// -- * type casts are ignored
// -- * interval arithmetic needs to be checked for correctness (esp. | and &)
// -- * wraparound is untestet
// -- * structures are not handled correctly yet
// -- 
// -- This program is free software; you can redistribute it and/or modify
// -- it under the terms of the GNU General Public License as published by
// -- the Free Software Foundation; version 3 of the License.
// -- 
// -- This program is distributed in the hope that it will be useful,
// -- but WITHOUT ANY WARRANTY; without even the implied warranty of
// -- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// -- GNU General Public License for more details.
// -- 
// -- ------------------------------------------------------------------------

SET
    VarIdList = list(VariableId)
DOMAIN
    BoolL = flat(bool) 
ENDDOMAIN

PROBLEM Interval_Analysis
  direction:  forward
  carrier:    itvl_State
  init:       bot
  init_start: lift([->(top, top)])
  combine:    comb
  retfunc:    ret
  widening:   wide
  equal:      eq
  prefix:     intvl_

TRANSFER

FunctionEntry(_), _: 
  if @ != bot then
    @
  else
    bot //top
  ;

ExprStatement(exp), _:
  if @ != bot then
    
    let state = eval(exp, @, context)!2!2 ; in
      // --print("\neval => ") print(state) print("\n") 
      state
  else
    bot
  ;

ArgumentAssignment(VarRefExp(_) as var, exp), _:
  if @ != bot then
   // -- In order to kill all tmpvars, we must here use the state returned
   // -- by eval.
      let e = eval(exp, @, context); in
      let value = e!1!2;
          state <= e!2!2; in
      lift(state\[varref_varid(var) -> value])
  else
    bot
  ;

ParamAssignment(VariableSymbol(_) as var, VariableSymbol(_) as param), _:
  if @ != bot then
    let f <= @; in
    // -- assign var
    lift(f\[varsym_varid(var) -> f{!varsym_varid(param)!}]
    // -- kill rhs
    \[varsym_varid(param) -> top])
  else
    bot
  ;

ReturnAssignment(VariableSymbol(_) as var, VariableSymbol(_) as retvar), _:
  if @ != bot then
    let f <= @; in
    // -- assign var
    lift(f\[varsym_varid(var) -> f{!varsym_varid(retvar)!}]
    // -- kill rhs
    \[varsym_varid(retvar) -> top])
  else
    bot
  ;

ScopeStatement(IfStmt(ExprStatement(cond))), true_edge:
  branch(cond, @, true, false, context);

ScopeStatement(IfStmt(ExprStatement(cond))), false_edge:
  branch(cond, @, false, false, context);

ScopeStatement(WhileStmt(ExprStatement(cond))), true_edge:
  branch(cond, @, true, true, context);

ScopeStatement(WhileStmt(ExprStatement(cond))), false_edge:
  branch(cond, @, false, false, context);

LogicalIf(cond), true_edge:
  branch(cond, @, true, false, context);

LogicalIf(cond), false_edge:
  branch(cond, @, false, false, context);

UndeclareStmt(vars), _:
  kill_vars(@, vars);

FunctionExit(_, vars), _:
  kill_vars(@, vars);

FunctionCall(_,_), local_edge:
  if @ != bot then
    let f <= @; in
      lift([(v,i)->top !! (v,i) <- f\top, if islocal(v)])
  else
    bot
  ;

FunctionCall(_,_), call_edge:
  if @ != bot then
    let f <= @; in
    // -- GB: values of (possibly) aliased locals must also be passed to the
    // -- function since they might be accessed there
      lift([(v,i)->top !! (v,i) <- f\top, if isglobal(v)
                                          || isaliasedlocal(v, context)])
  else
    bot
  ;

_, _: @;

SUPPORT

dup(a) = (a, a);
duplift(a) = dup(lift(a));
ltup(a,b) = (lift(a), lift(b));

eval :: Expression, itvl_State, ContextInfo -> itvl_IntervalStatePair;
eval(_, bot, _) = bot;
eval(_, top, _) = top;
eval(exp, state, context) =  
  // --print("eval(") print(exp) print(",") print(state) print(")\n")
  let s <= state; in

  case exp of 
    CommaOpExp(exp1, exp2) => let state1 = 
                                eval(exp1, state, context)!2!2; in
                                eval(exp2, state1, context);
    AssignOp(VarRefExp(_) as var, AggregateInitializer(_) as i)
                           => let st = initialize(s, varref_varid(var),
                                                     expr_type(var), i,
                                                     context);
                              in  (top, lift(st));

    _ =>
      if is_unary(exp) then
        unary(unary_get_child(exp), exp, state, context)
      else if is_binary(exp) then
        let r = binary(binary_get_left_child(exp), binary_get_right_child(exp),
          exp, state, context); in r // --print("BINARY <----") print(r) print("\n") r
      else if is_value(exp) then
        case exp of
          BoolValExp(value) => (duplift(val-astint(value)), state);
          EnumVal(value)    => (duplift(val-astint(value)), state);
          IntVal(value)     => (duplift(val-astint(value)), state);
          ShortVal(value)   => (duplift(val-astshort(value)), state);
          LongIntVal(value) => (duplift(val-astlong(value)), state);
          LongLongIntVal(value) => (duplift(val-astllong(value)), state);

          CharVal(value)  => (duplift(snum(val-astchar(value))), state);
          // -- FIXME: incorrect type conversions
          UnsignedCharVal(value) => (duplift(snum(val-astuchar(value))), state);
          UnsignedIntVal(value)  => (duplift(snum(val-astuint(value))), state);
          UnsignedShortVal(value)=>(duplift(snum(val-astushort(value))), state);
          UnsignedLongVal(value) => (duplift(snum(val-astulong(value))), state);
          UnsignedLongLongIntVal(value) => (duplift(snum(val-astullong(value))), state);
          // -- NOT IMPLEMENTED
          FloatVal(_) => ((top,top), state);
          DoubleVal(_) => ((top,top), state);
          _         => print("unsupported value exp: ")
                       print(exp) print("\n") 
                                  ((top,top), state);
        endcase
    else case exp of
      VarRefExp(name)       =>  // --print("###is_VARREF") 
                                // --print(val-aststring(name)) print("\n") 
                                let id = varref_varid(exp); in
                                if is_tmpvarid(id) then
                                    let s2 = s\[id -> top]; in
                              // -- println("killing tmp var ref ", exp,
                              // --         ":\n    old state = ", s,
                              // --         ",\n    new state = ", s2)
                                    (s{!id!}, lift(s2))
                                else
                                    (s{!id!}, state);
      AssignInitializer(e1) => eval(e1, state, context);
      NewExp(_,_,_)         => ((bot,bot), state);
      _                     => println("**WARNING: ignoring unknown exp: ",
                                       exp, ": ", expr_asttext(exp))
                               ((top,top), state); 
                                      // --((top,top), lift([-> top]));
    endcase   ;
  endcase;
          

binary :: Expression, Expression, Expression, itvl_State, ContextInfo -> itvl_IntervalStatePair;
binary(left, right, exp, state, context) =
  // -- Evaluate the right child expression, yielding a (value, state)
  // -- pair assigned to r and rs, respectively.
  // --print("BINARY(") print(exp) print(")\n")
  let rr = eval(right, state, context);
      dontknow = ((top,top), state);
  in case exp of
    // -- If this is an assignment operation, update the state.
    // -- We do not evaluate the left-hand side as this might
    // -- yield top or bot, causing trouble.
    AssignOp(_, _) => // --print("ASSIGNOP: ") print(left) print("=") print(rr!1!2) print(" ...\n")
      if bad(rr!1!2) then
        //(top, rr!2!2)
        updatestate(rr!2!2, left, top, context)
      else
        let r = rr!1!2; rs = rr!2!2; in
        updatestate(rs, left, r, context)
      ;
    // -- If this is not an assignment, we may safely evaluate
    // -- the left-hand side as well (in the "new" state after
    // -- evaluation of the rhs) and perform the operation.
    _ => 
      let rlifted = rr!1!2; rs = rr!2!2;
      in let ll = eval(left, rs, context);
      in let llifted = ll!1!2; ls = ll!2!2;
      in if bad(rlifted) then dontknow else
         if bad(llifted) then dontknow else
        let r1 <= rlifted!1!2; r2 <= rlifted!2!2;
            l1 <= llifted!1!2; l2 <= llifted!2!2; in
        let constp = (l1=l2) && (r1=r2); in
        // --print("evalbin(") print(exp) print(";;; ") print(llifted) print(", ") 
        // --                                           print(rlifted) print(")\n")
        case exp of
          EqualityOp(_, _) => if constp then (duplift(bool_int(l1=r1)), ls) else
                              if (l2 < r1) || (l1 > r2) then (duplift(0), ls) else
                              dontknow  ;

          LessThanOp(_, _)  => if (l2 < r1) then (duplift(1), ls) else 
                               if (l1 >=r2) then (duplift(0), ls) else 
                               dontknow  ;

          GreaterThanOp(_, _) => if (l1 > r2) then (duplift(1), ls) else 
                                 if (l2 <=r1) then (duplift(0), ls) else 
                                 dontknow  ;

          NotEqualOp(_, _) => if (l2 < r1) || (l1 > r2) then (duplift(1), ls) else
                              if (constp)  then (duplift(bool_int(l1!=r1)), ls) else
                              dontknow ;

          LessOrEqualOp(_, _) => if (l2 <= r1) then (duplift(1), ls) else 
                                 if (r2 <  l1) then (duplift(0), ls) else 
                                 dontknow  ;

          GreaterOrEqualOp(_, _) => if (l1 >= r2) then (duplift(1), ls) else 
                                    if (r1 >  l2) then (duplift(0), ls) else 
                                    dontknow  ;
                                             
          AddOp(_, _)     => (ltup(l1 + r1, l2 + r2), ls);
          SubtractOp(_, _)=> (ltup(l1 - r2, l2 - r1), ls);
          MultiplyOp(_, _)=> (ltup(mini(l1*r1, l1*r2), maxi(l2*r1, l2*r2)), ls);
          DivideOp(_, _)  => (ltup(mini(l1/r1, l1/r2), maxi(l2/r1, l2/r2)), ls);
          IntegerDivideOp(_, _) 
                          => (ltup(mini(l1/r1, l1/r2), maxi(l2/r1, l2/r2)), ls);
          ModOp(_, _)     => (ltup(0, r2), ls);
          LshiftOp(_, _)  => (ltup(l1<<unum(r1), l2<<unum(r2)), ls);
          RshiftOp(_, _)  => (ltup(l1>>unum(r1), l2>>unum(r2)), ls);
	  BitAndOp(_, _)  => (ltup(l1 & r1, l2 & r2), ls);
          BitOrOp(_, _)   => (ltup(l1 | r1, l2 | r2), ls);
          BitXorOp(_, _)  => if constp then 
                                 (duplift(bool_int(l1 != r1)), ls)
                             else dontknow ;

	  AndOp(_, _) => if constp then
                          (duplift(bool_int((l1 != 0) && (r1 != 0))), ls)
                         else dontknow ;

          OrOp(_, _)  => if constp then 
                          (duplift(bool_int((l1 != 0) || (r1 != 0))), ls)
                         else dontknow ;

          ScopeOp(_, _)       => (ltup(r1, r2), ls);
          PlusAssignOp(_, _)  => updatestate(ls, left, ltup(l1 + r1, l2 + r2), context);
          MinusAssignOp(_, _) => updatestate(ls, left, ltup(l1 - r2, l2 - r1), context);
          MultAssignOp(_, _)  => updatestate(ls, left, 
                                               ltup(mini(l1*r1, l1*r2), 
                                                    maxi(l2*r1, l2*r2)), context);
          DivAssignOp(_, _)   => updatestate(ls, left, 
                                               ltup(mini(l1/r1, l1/r2), 
                                                    maxi(l2/r1, l2/r2)), context);
          ModAssignOp(_, _)   => updatestate(ls, left, ltup(0, r2), context);
          LshiftAssignOp(_, _)=> updatestate(ls, left,
                                   ltup(l1<<unum(r1), l2<<unum(r2)), context);
          RshiftAssignOp(_, _)=> updatestate(ls, left, 
                                   ltup(l1>>unum(r2), l2>>unum(r1)), context);
          PntrArrRefExp(_, _) => let id = expr_exprid(exp); in
                                 let l = exprid_location_cs(id, context); in
                                 let syms = location_varsyms(l);
                                 in  (merged_var_values(ls, syms), ls);
          _ => print("**WARNING: unsupported binary: ") print(exp) print("\n") 
               (top, lift([-> top]));
        endcase
       ;
  endcase;

unary :: Expression, Expression, itvl_State, ContextInfo -> itvl_IntervalStatePair;
unary(child, exp, state, context) = 
  // --print("UNARY(") print(exp) print(")\n")
  let ee = eval(child, state, context); in
  let er = ee!1!2; es = ee!2!2; in
    // -- if child node is a dereference expression, consult pointer analysis
    case exp of
      PointerDerefExp(_)  => // -- println("PointerDerefExp in context ", context)
                             let id = expr_exprid(exp); in
                             let l = exprid_location_cs(id, context); in
                             let syms = location_varsyms(l);
                             in  (merged_var_values(es, syms), es);

    // -- otherwise, see if this is some arithmetic node
      _ =>
    // -- if child node is not analyzable, bail out
    if bad(er) then ((top,top), state) else // BUG!
       let e1 <= er!1!2; e2 <= er!2!2; in
      case exp of
        MinusOp(_)    => (ltup(-e2, -e1), es);
        UnaryAddOp(_) => (ltup( e1,  e2), es);
        NotOp(_)      => (ltup(bool_int(e2 = 0), bool_int(e1 = 0)), es);
        CastExp(_, _) => eval(child, state, context);
        // -- the following are only correct for prefix -- and ++
        MinusMinusOp(_) => updatestate(es, child, ltup(e1-1, e2-1), context);
        PlusPlusOp(_)   => updatestate(es, child, ltup(e1+1, e2+1), context);
        // -- an address-of operation does not yield a useful value; ignore it
        // -- here, the pointer analysis knows how to handle it; however, we
        // -- use state es to reflect possible side effects of evaluating
        // -- the operand
        AddressOfOp(_)  => ((top,top), es);
  
        _ => print("unsupported unary: ") print(exp) print("\n") 
             (top, lift([-> top]));
      endcase;
    endcase
  ;

bad((top, _)) = true;
bad((bot, _)) = true;
bad((_, top)) = true;
bad((_, bot)) = true;
bad((_,_)) = false;

bool_int :: bool -> snum;
bool_int(b) =
  if b then 1 else 0 ;

int_bool :: snum -> bool;
int_bool(0) = false;
int_bool(_) = true;
								    
updatestate :: itvl_State, Expression, itvl_Interval, ContextInfo -> itvl_IntervalStatePair;
updatestate(bot, _, _, _) = ((top,top),bot);
// -- Update state state by assigning the value value to the variable
// -- referenced by expression exp (if any). Yields a pair of the value
// -- and the new state.
updatestate(state, exp, value, context) = 
// --print("updatestate(") print(state) print(", ") print(exp) print(", ") print(value) print(")\n") 
  let s <= state; in 
  let newstate =
    case exp of
      VarRefExp(var) => lift(s\[varref_varid(exp) -> value]);
      _ => let exprid = expr_exprid(exp);
           in  if exprid_has_location(exprid) then
               let loc = exprid_location_cs(exprid, context); in
               let syms = location_varsyms(loc);
               in  // -- println("updating vars: ", syms)
                   case syms of
                // -- no var: could be an error; could also be harmless, if
                // -- this updatestate call resulted from an equality check
                   [!]    => println("warning: no varsyms for lhs in updatestate: ",
                                     exp, " :: ", expr_asttext(exp))
                             state;
                // -- singleton var, may be an array name: strong update of
                // -- scalar variables, weak update of arrays
                   v::[!] => if is_array_location(loc) then
                                 lift(weak_update_v(s, varsym_varid(v), value))
                             else
                                 lift(s\[varsym_varid(v) -> value]);
                // -- otherwise: more than one var, weak update
                   _      => // -- println("info: weak update ", syms, " := ", value)
                             lift(weak_update(s, syms, value));
               endcase
           else
               println("info: cannot updatestate for lhs expression: ",
                       exp, " :: ", expr_asttext(exp))
               state;
    endcase;
  in // --print("\n=> ") print(state) print("\n") 
     (value, newstate);

weak_update :: itvl_fState, *VariableSymbolNT, itvl_Interval -> itvl_fState;
weak_update(s, [!], _) = // -- println("weak update result: ", s)
    s;
weak_update(s, vsym::vs, value) =
    let v = varsym_varid(vsym); in
    let newstate = weak_update_v(s, v, value);
    in  weak_update(newstate, vs, value);

weak_update_v(s, v, value) =
    let v_old_val = s{!v!}; in
    let v_new_val = combi(v_old_val, value);
    in  s\[v -> v_new_val];

// merged_var_values(s, vsyms): Look up an interval that covers the values
// of all variables in vsyms in state s.
merged_var_values :: itvl_State, *VariableSymbolNT -> itvl_Interval;
merged_var_values(top, _) = (top, top);
merged_var_values(_, [!]) =
    println("in merged_var_values: merging empty variable list!")
    (top, top);
merged_var_values(lift(s), v::[!]) = s{!varsym_varid(v)!};
merged_var_values(lift(s) as ls, v::vs) =
    let merged = merged_var_values(ls, vs);
    in  combi(s{!varsym_varid(v)!}, merged);

initialize :: itvl_fState, VariableId, Type, Expression, ContextInfo -> itvl_fState;
initialize(s, v, ArrayType(BasicType(_)),
                 AggregateInitializer(ExprListExp(exprs)), context) =
 // default value: 0 (missing initializers default to 0)
    initialize_array(s\[v -> duplift(0)], v, exprs, context);
// ignore unknown initializer
initialize(s, _, _, _, _) = s;

initialize_array :: itvl_fState, VariableId, *Expression, ContextInfo -> itvl_fState;
initialize_array(s, _, [!], _) = s;
initialize_array(s, var, expr::exprs, ctx) =
    let value = eval(expr, lift(s), ctx)!1!2; // -- FIXME: assumes pure exprs
    in  initialize_array(weak_update_v(s, var, value), var, exprs, ctx);

branch :: Expression, itvl_State, bool, bool, ContextInfo -> itvl_State;
branch(exp, state, edge, isLoopBody, context) =
  // --print("\nbranching...\nexp: ") print(exp) 
  // --print("\nstate: ") print(state) 
  // --print("\nedge: ") print(edge)  
  // --print("\n")

  let pair = eval(exp, state, context); in
  let c = interval_to_bool(pair!1!2); 
          newstate = pair!2!2; in
  if (c = top || isLoopBody) then 
    // -- We don't know for sure which edge will be taken
    // --print("c=top\n") 
    // --print("Maybe\n") 
    eval_branch_condition(exp, state, newstate, edge, isLoopBody, context)
  else if c = bot then 
    print("FIXME c=bot\n") 
    state
  else if drop(c) = edge then  
    // -- This edge will ALWAYS be taken
    // --print(newstate) print("\n") 
    // --print("Always\n") 
    newstate
  else 
    // -- This edge will NEVER be taken
    // --print("bot\n") 
    // --print("Never\n") 
    bot
    ;


eval_branch_condition :: Expression, itvl_State, itvl_State, bool, bool, ContextInfo -> itvl_State;
eval_branch_condition(exp, state, newstate, edge, isLoopBody, context) =
  if is_binary(exp) then
    let lhs = eval(binary_get_left_child(exp), state, context)!1!2;
        rhs = eval(binary_get_right_child(exp), state, context)!1!2; in

    case exp of 
      AndOp(exp1, exp2) =>
        let state1 = 
          eval_branch_condition(exp1, state, newstate, edge, isLoopBody, context); in
          eval_branch_condition(exp2, state1, newstate, edge, isLoopBody, context);
  
      LessThanOp(var, _) =>
        if edge = true then 
            updatestate(state, var, adjust_max_plus(lhs, rhs,-1), context)!2!2
        else 
            updatestate(state, var, adjust_min(lhs, rhs), context)!2!2
        ;
      LessOrEqualOp(var, _) =>
        if edge = true then 
            updatestate(state, var, adjust_max(lhs, rhs), context)!2!2
        else 
            updatestate(state, var, adjust_min_plus(lhs, rhs, 1), context)!2!2
        ;
      GreaterThanOp(var, _) =>
        if edge = true then 
            updatestate(state, var, adjust_min_plus(lhs, rhs, 1), context)!2!2
        else 
            updatestate(state, var, adjust_max(lhs, rhs), context)!2!2
        ;
      GreaterOrEqualOp(var, _) =>
        if edge = true then 
            updatestate(state, var, adjust_min(lhs, rhs), context)!2!2
        else 
            updatestate(state, var, adjust_max_plus(lhs, rhs,-1), context)!2!2
        ;

      EqualityOp(var, _) =>
        if edge = true then 
            updatestate(state, var, rhs, context)!2!2
        else 
            newstate
        ;
      NotEqualOp(var, _) =>
        if edge = true then 
            newstate
        else 
            updatestate(state, var, rhs, context)!2!2
        ;

      _ => newstate;
    endcase
  else 
    lift([-> (top,top)])
    //newstate
  ;


// -- update the min portion of an interval
adjust_min :: itvl_Interval, itvl_Interval -> itvl_Interval;
adjust_min((_, a2), (m, _)) = (m, max(m, a2));

// -- update the max portion of an interval
adjust_max :: itvl_Interval, itvl_Interval -> itvl_Interval;
adjust_max((a1, _), (_, m)) = (min(a1, m), m);

// -- update the min portion of an interval and add c
adjust_min_plus :: itvl_Interval, itvl_Interval, snum -> itvl_Interval;
adjust_min_plus((_, a2), (m, _), c) = 
    let m1 <= m; in
    let m2 = lift(m1+c); in
      (m2, max(m2, a2));

// -- update the max portion of an interval and add c
adjust_max_plus :: itvl_Interval, itvl_Interval, snum -> itvl_Interval;
adjust_max_plus((a1, _), (_, m), c) =
    let m1 <= m; in
    let m2 = lift(m1+c); in
      (min(a1, m2), m2);


kill_vars :: itvl_State, *VariableSymbolNT -> itvl_State;
kill_vars(s, [!]) =
  s;
kill_vars(s, v::vars) =
  let ss <= s; in
  kill_vars(lift(ss\[varsym_varid(v) -> top]), vars);

interval_to_bool :: itvl_Interval -> BoolL;
interval_to_bool((lift(0), lift(0))) = lift(false);
interval_to_bool((lift(1), lift(1))) = lift(true);
interval_to_bool(_) = top;

// --shiftleft :: snum, snum -> snum;
// --shiftleft(a, 0) = a;
// --shiftleft(a, b) = shiftleft(a*2, b-1);

// --shiftright :: snum, snum -> snum;
// --shiftright(a, 0) = a;
// --shiftright(a, b) = shiftright(a/2, b-1);

comb(a, bot) = a;
comb(bot, b) = b;
comb(_, top) = top;
comb(top, _) = top;
comb(a, b) =
  let res = lift(crunch(drop(a), drop(b), combi)); // -- a glb b
  in
  // --print("comb a: ") print(a) print("\n")
  // --print("comb b: ") print(b) print("\n")
  // --print("result: ") print(res) print("\n\n")
  res;

combi((a1, a2), (b1, b2)) = 
  (min(a1, b1), max(a2, b2));

ret(a, bot) = a;
ret(bot, b) = b;
ret(_, top) = top;
ret(top, _) = top;
ret(local, exit) = 
  let returnvar = [(v,i)->top !! (v,i) <- drop(exit)\top, if is_tmpvarid(v)];
   // -- Here, we compute the set of locals that come back from the function.
   // -- Their new values override any ones before the call!
      modified_vars = [(v,i)->top !! (v,i) <- drop(exit)\top, if islocal(v)];
  in (let localstate <= local;
      in  // -- println("return locals: ", modified_vars)
          lift(override(localstate, modified_vars))
      ) glb lift(returnvar);

// -- override(locals, modified): "locals" and "modified" are two maps,
// -- typically with some shared domain objects; yield a map in which
// -- definitions from "modified" override ones from "locals", i.e.
// -- (Haskell syntax):
// --   \x -> if modified(x) != top then modified(x) else locals(x)
override(locals, modified) = crunch(locals, modified, second_if_present);

second_if_present(a, b) =
 // -- should this also check for b != bot?
    if b != top then b else a;

min(_, top) = top;
min(top, _) = top;
min(a, bot) = a;
min(bot, b) = b;
min(a, b) = if drop(a) < drop(b) then a else b ;

// -- all glory to polymorphism
mini(a, b) = if a < b then a else b ;

max(_, top) = top;
max(top, _) = top;
max(a, bot) = a;
max(bot, b) = b;
max(a, b) = if drop(a) > drop(b) then a else b ;

maxi(a, b) = if a > b then a else b ;

// -- default widening operator:
//wide(_, b) = b;

wide(bot, b) = b;
wide(a, bot) = a;
wide(_, top) = top;
wide(top, _) = top;
wide(a, b) = lift(crunch(drop(a), drop(b), widen));

widen((top, bot), b) = b;
widen((a1, a2), (b1, b2)) = ( if a1=b1 then a1 else top /*min(a1, b1)*/ ,
                              if a2=b2 then a2 else top /*max(a1, b1)*/  );

//widen((a1, a2), (b1, b2)) = let v1 <= b1 ;
//                                v2 <= b2 ; in 
//                            ( if v2-v1 > 10 then top else b1 ,
//                              if v2-v1 > 10 then top else b2 ) ;


eq(a, b)   = //print("eq a: ") print(a) print("\n")
             //print("eq b: ") print(b) print("\n\n")
             (a = b);

isglobal(var) = is_tmpvarid(var) || varmember(var, globals);
islocal(var) = !isglobal(var);
isaliasedlocal(var, ctx) =
    let result = islocal(var) && varid_has_location(var)
                              && may_be_aliased(varid_location_cs(var, ctx));
    in  // -- println("checking aliasing of var ", var, " in context ", ctx,
        // --         " -> ", result)
        result;

varmember(_, [!]) = false;
varmember(v, g::gs) = 
    if varsym_varid(g) = v 
    then true 
    else varmember(v, gs);
    

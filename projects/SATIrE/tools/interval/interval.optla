// -- -*- haskell -*- (Fake Emacs mode for syntax highlighting)
// -- vim: syntax=fula
// -- ------------------------------------------------------------------------
// -- Authors: Gergo Barany, 2006/2009 (original constprop/points-to info)
// --          Adrian Prantl, 2008-2009 (interval extensions)
// --          
// -- Contact: adrian@complang.tuwien.ac.at
// --
// -- TOP: Variable is not analyzABLE
// -- (min,max): Variable has the interval min =< v =< max
// -- BOT: Variable is not yet analyzED
// -- Please note that, however, the values min and max are again _lifted_
// -- integers, where bot = -inf and top = +inf.// -- 
// -- 
// -- remaining problems:
// -- * type casts are ignored
// -- * interval arithmetic needs to be checked for correctness (esp. | and &)
// -- * wraparound is untestet
// -- * structures are not handled correctly yet
// -- 
// -- This program is free software; you can redistribute it and/or modify
// -- it under the terms of the GNU General Public License as published by
// -- the Free Software Foundation; version 3 of the License.
// -- 
// -- This program is distributed in the hope that it will be useful,
// -- but WITHOUT ANY WARRANTY; without even the implied warranty of
// -- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// -- GNU General Public License for more details.
// -- 
// -- ------------------------------------------------------------------------

SET
    VarIdList = list(VariableId)
DOMAIN
    BoolL = flat(bool) 
ENDDOMAIN

PROBLEM Interval_Analysis
  direction:  forward
  carrier:    itvl_State
  init:       bot
  init_start: lift([->top])
  combine:    comb
  retfunc:    ret
  widening:   wide
  equal:      eq
  prefix:     intvl_

TRANSFER

FunctionEntry(_), _: 
  if @ != bot then
    @
  else
    bot //top
  ;

ExprStatement(exp), _:
  if @ != bot then
    
    let state = eval(exp, @, context)!2!2 ; in
      // --print("\neval => ") print(state) print("\n") 
      state
  else
    bot
  ;

ArgumentAssignment(VarRefExp(_) as var, exp), _:
  if @ != bot then
   // -- In order to kill all tmpvars, we must here use the state returned
   // -- by eval.
      let e = eval(exp, @, context); in
      let value = e!1!2;
          state <= e!2!2; in
      lift(state\[varref_varid(var) -> value])
  else
    bot
  ;

ParamAssignment(VariableSymbol(_) as var, VariableSymbol(_) as param), _:
  if @ != bot then
    let f <= @; in
    // -- assign var
    lift(f\[varsym_varid(var) -> f{!varsym_varid(param)!}]
    // -- kill rhs
    \[varsym_varid(param) -> top])
  else
    bot
  ;

ReturnAssignment(VariableSymbol(_) as var, VariableSymbol(_) as retvar), _:
  if @ != bot then
    let f <= @; in
    // -- assign var
    lift(f\[varsym_varid(var) -> f{!varsym_varid(retvar)!}]
    // -- kill rhs
    \[varsym_varid(retvar) -> top])
  else
    bot
  ;

ScopeStatement(IfStmt(ExprStatement(cond))), true_edge:
  branch(cond, @, true, false, context);

ScopeStatement(IfStmt(ExprStatement(cond))), false_edge:
  branch(cond, @, false, false, context);

ScopeStatement(WhileStmt(ExprStatement(cond))), true_edge:
  branch(cond, @, true, true, context);

ScopeStatement(WhileStmt(ExprStatement(cond))), false_edge:
  branch(cond, @, false, true, context);

LogicalIf(cond), true_edge:
  branch(cond, @, true, false, context);

LogicalIf(cond), false_edge:
  branch(cond, @, false, false, context);

UndeclareStmt(vars), _:
  kill_vars(@, vars);

FunctionExit(_, vars), _:
  kill_vars(@, vars);

FunctionCall(_,_), local_edge:
  if @ != bot then
    let f <= @; in
      lift([(v,i)->top !! (v,i) <- f\top, if islocal(v)])
  else
    bot
  ;

FunctionCall(_,_), call_edge:
  if @ != bot then
    let f <= @; in
    // -- GB: values of (possibly) aliased locals must also be passed to the
    // -- function since they might be accessed there
      lift([(v,i)->top !! (v,i) <- f\top, if isglobal(v)
                                          || isaliasedlocal(v, context)])
  else
    bot
  ;

_, _: @;

SUPPORT

dup(a) = (a, a);
duplift(a) = dup(lift(a));
ltup(a,b) = (lift(a), lift(b));

eval :: Expression, itvl_State, ContextInfo -> itvl_IntervalStatePair;
eval(_, bot, _) = bot;
eval(_, top, _) = top;
eval(exp, state, context) =  
  // --print("eval(") print(exp) print(",") print(state) print(")\n")
  let s <= state; in

  case exp of 
    CommaOpExp(exp1, exp2) => let state1 = 
                                eval(exp1, state, context)!2!2; in
                                eval(exp2, state1, context);
    AssignOp(VarRefExp(_) as var, AggregateInitializer(_) as i)
                           => let st = initialize(s, varref_varid(var),
                                                     expr_type(var), i,
                                                     context);
                              in  (top, lift(st));
    AssignOp(VarRefExp(_) as var, ExprListExp(_) as i)
                           => let st = initialize(s, varref_varid(var),
                                                     expr_type(var), i,
                                                     context);
                              in  (top, lift(st));
    ConditionalExp(cond, t, f) =>
        // -- Evaluate the condition twice, once for truth and once for
        // -- falsity; if only one of these holds, use that state, otherwise
        // -- use a merged state.
        let tb = branch(cond, state, true, false, context); in
        let fb = branch(cond, state, false, false, context); in
        let cs = (if   tb = bot then fb else
                  if   fb = bot then tb
                  else comb(tb, fb)); in
        // -- Now we have the state after the evaluation of the condition.
        // -- Evaluate one or both of the "true" and "false" expressions.
        let tt = eval(t, cs, context);
            ff = eval(f, cs, context);
        in  if   tb = bot then ff else
            if   fb = bot then tt
            else (combi(tt!1!2, ff!1!2), comb(tt!2!2, ff!2!2));

    _ =>
      if is_unary(exp) then
        unary(unary_get_child(exp), exp, state, context)
      else if is_binary(exp) then
        let r = binary(binary_get_left_child(exp), binary_get_right_child(exp),
          exp, state, context); in r // --print("BINARY <----") print(r) print("\n") r
      else if is_value(exp) then
        case exp of
          BoolValExp(value) => (duplift(val-astint(value)), state);
          EnumVal(value)    => (duplift(val-astint(value)), state);
          IntVal(value)     => (duplift(val-astint(value)), state);
          ShortVal(value)   => (duplift(val-astshort(value)), state);
          LongIntVal(value) => (duplift(val-astlong(value)), state);
          LongLongIntVal(value) => (duplift(val-astllong(value)), state);

          CharVal(value)  => (duplift(snum(val-astchar(value))), state);
          // -- FIXME: incorrect type conversions
          UnsignedCharVal(value) => (duplift(snum(val-astuchar(value))), state);
          UnsignedIntVal(value)  => (duplift(snum(val-astuint(value))), state);
          UnsignedShortVal(value)=>(duplift(snum(val-astushort(value))), state);
          UnsignedLongVal(value) => (duplift(snum(val-astulong(value))), state);
          UnsignedLongLongIntVal(value) => (duplift(snum(val-astullong(value))), state);
          // -- NOT IMPLEMENTED
          FloatVal(_) => (top, state);
          DoubleVal(_) => (top, state);
          StringVal(_) => (top, state);
          _         => print("unsupported value exp: ")
                       print(exp) print("\n") 
                                  (top, state);
        endcase
    else case exp of
      VarRefExp(name)       =>  // --print("###is_VARREF") 
                                // --print(val-aststring(name)) print("\n") 
                                let id = varref_varid(exp); in
                                if is_tmpvarid(id) then
                                    let s2 = s\[id -> top]; in
                              // -- println("killing tmp var ref ", exp,
                              // --         ":\n    old state = ", s,
                              // --         ",\n    new state = ", s2)
                                    (s{!id!}, lift(s2))
                              // -- The interval analysis is easily extended
                              // -- to pointers ranging over arrays by
                              // -- simply treating an array's name as (an
                              // -- offset value of) 0; pointer arithmetic
                              // -- then automagically maps to offset
                              // -- interval arithmetic.
                                else if is_array_type(expr_type(exp)) then
                                    (duplift(0), state)
                                else
                                    (s{!id!}, state);
      AssignInitializer(e1) => eval(e1, state, context);
      NewExp(_,_,_)         => (top, state);
      FunctionRefExp()      => (top, state);
      NullExpression()      => (top, state);
      _                     => println("**WARNING: ignoring unknown exp: ",
                                       exp, ": ", expr_asttext(exp))
                               (top, state); 
                                      // --(top, lift([-> top]));
    endcase   ;
  endcase;


binary :: Expression, Expression, Expression, itvl_State, ContextInfo -> itvl_IntervalStatePair;
binary(left, right, exp, state, context) =
  // -- Evaluate the right child expression, yielding a (value, state)
  // -- pair assigned to rlifted and rs, respectively. Evaluate the left
  // -- child in state rs and assign to llifted and ls. Note that we may not
  // -- in all cases drop llifted or rlifted! Even if the lhs has an unknown
  // -- value, we can evaluate plain assignments. Conversely, if the rhs has
  // -- an unknown value, we must be careful with op-assign operators.
  // --println("BINARY(", exp, " :: ", expr_asttext(exp), ") in state ", state)
  let rr = eval(right, state, context); in
  let rlifted = rr!1!2; rs = rr!2!2; in
  let ll = eval(left, rs, context); in
  let llifted = ll!1!2; ls = ll!2!2; in
  let dontknow = (top, state); in
  // -- Factored out handling of op-assign operators.
  if is_op_assign(exp) then
    op_assign_effects(ls, exp, llifted, rlifted, context)
  else case exp of
    // -- If this is a plain assignment operation, update the state without
    // -- regard for the old value of the lhs.
    AssignOp(_, _) => // --println("ASSIGNOP: ", left, "=", rr!1!2, " in state ", rr!2!2, " ...")
      updatestate(ls, left, if bad(rlifted) then top else rlifted, context);

    // -- PntrArrRefExp is special in that we can also derive some
    // -- information if not all operands have known interval values.
    PntrArrRefExp(_, _) =>
      // -- println("ARRAY: ", exp, " :: ", expr_asttext(exp), ")")
      let id = expr_exprid(exp); in
      let l = exprid_location_cs(id, context); in
      let syms = location_varsyms(l); in
      let s2 = constrain_array_index(ls, expr_type(left), right);
      in  let result = (merged_var_values(s2, syms), s2);
      in  // println("arr ", exp, " result: ", result)
          result;

    // -- plain arithmetic, logical, comparison operators
    _ => 
      if bad(rlifted) then dontknow else
      if bad(llifted) then dontknow else
      let r1 <= rlifted!1!2; r2 <= rlifted!2!2;
          l1 <= llifted!1!2; l2 <= llifted!2!2; in
      let constp = (l1=l2) && (r1=r2);
          pointerp = is_pointer_type(expr_type(left))
                  || is_pointer_type(expr_type(right)); in
      // --print("evalbin(") print(exp) print(";;; ") print(llifted) print(", ")
      // --                                           print(rlifted) print(")\n")
      case exp of
        EqualityOp(_, _) =>
          if !pointerp && constp then (duplift(bool_int(l1=r1)), ls) else
          if !pointerp && (l2 < r1 || l1 > r2) then (duplift(0), ls) else
          dontknow  ;

        LessThanOp(_, _)  =>
          if !pointerp && l2 < r1 then (duplift(1), ls) else
          if !pointerp && l1 >=r2 then (duplift(0), ls) else
          dontknow  ;

        GreaterThanOp(_, _) =>
          if !pointerp && l1 > r2 then (duplift(1), ls) else
          if !pointerp && l2 <=r1 then (duplift(0), ls) else
          dontknow  ;

        NotEqualOp(_, _) =>
          if !pointerp && l2 < r1 || (l1 > r2) then (duplift(1), ls) else
          if !pointerp && constp  then (duplift(bool_int(l1!=r1)), ls) else
          dontknow ;

        LessOrEqualOp(_, _) =>
          if !pointerp && l2 <= r1 then (duplift(1), ls) else
          if !pointerp && r2 <  l1 then (duplift(0), ls) else
          dontknow  ;

        GreaterOrEqualOp(_, _) =>
          if !pointerp && l1 >= r2 then (duplift(1), ls) else
          if !pointerp && r1 >  l2 then (duplift(0), ls) else
          dontknow  ;

        AddOp(_, _)     => (ltup(l1 + r1, l2 + r2), ls);
        SubtractOp(_, _)=> (ltup(l1 - r2, l2 - r1), ls);
        MultiplyOp(_, _)=> (ltup(mini(l1*r1, l1*r2), maxi(l2*r1, l2*r2)), ls);
        DivideOp(_, _)  => if r1 != 0 && r2 != 0 then
                              (ltup(mini(l1/r1, l1/r2),
                                    maxi(l2/r1, l2/r2)), ls)
                           else
                              dontknow;
        IntegerDivideOp(_, _)
                        => if r1 != 0 && r2 != 0 then
                              (ltup(mini(l1/r1, l1/r2),
                                    maxi(l2/r1, l2/r2)), ls)
                           else
                              dontknow;
        ModOp(_, _)     => (ltup(0, r2), ls);
        LshiftOp(_, _)  => (ltup(l1<<unum(r1), l2<<unum(r2)), ls);
        RshiftOp(_, _)  => (ltup(l1>>unum(r1), l2>>unum(r2)), ls);
        BitAndOp(_, _)  => (and(l1, l2, r1, r2), ls);
        BitOrOp(_, _)   => (ltup(l1 | r1, l2 | r2), ls);
        BitXorOp(_, _)  => (xor(l1, l2, r1, r2), ls);

        AndOp(_, _) => if constp then
                        (duplift(bool_int((l1 != 0) && (r1 != 0))), ls)
                       else dontknow ;

        OrOp(_, _)  => if constp then
                        (duplift(bool_int((l1 != 0) || (r1 != 0))), ls)
                       else dontknow ;

        ScopeOp(_, _)       => (ltup(r1, r2), ls);
        _ => print("**WARNING: unsupported binary: ") print(exp) print("\n")
             (top, lift([-> top]));
      endcase
     ;
  endcase;

unary :: Expression, Expression, itvl_State, ContextInfo -> itvl_IntervalStatePair;
unary(child, exp, state, context) = 
  // --print("UNARY(") print(exp) print(")\n")
  let ee = eval(child, state, context); in
  let er = ee!1!2; es = ee!2!2; in
    // -- if child node is a dereference expression, consult pointer analysis
    case exp of
      PointerDerefExp(_)  => // -- println("PointerDerefExp in context ", context)
                             let id = expr_exprid(exp); in
                             let l = exprid_location_cs(id, context); in
                             let syms = location_varsyms(l);
                             in  (merged_var_values(es, syms), es);

    // -- otherwise, see if this is some arithmetic node
      _ =>
    // -- if child node is not analyzable, bail out
    if bad(er) then (top, es) else // BUG!
       let e1 <= er!1!2; e2 <= er!2!2; in
      case exp of
        MinusOp(_)    => (ltup(-e2, -e1), es);
        UnaryAddOp(_) => (ltup( e1,  e2), es);
        NotOp(_)      => (ltup(bool_int(e2 = 0), bool_int(e1 = 0)), es);
        CastExp(_, _) => eval(child, es, context);
        // -- the following are only correct for prefix -- and ++
        MinusMinusOp(_) => if unary_is_prefix(exp) then
                              updatestate(es, child, ltup(e1-1, e2-1), context)
                           else
                              let st = updatestate(es, child,
                                                   ltup(e1-1, e2-1), context);
                              in  (er, st!2!2);  // -- old value, new state
        PlusPlusOp(_)   => if unary_is_prefix(exp) then
                              updatestate(es, child, ltup(e1+1, e2+1), context)
                           else
                              let st = updatestate(es, child,
                                                   ltup(e1+1, e2+1), context);
                              in  (er, st!2!2);  // -- old value, new state
        // -- an address-of operation does not yield a useful value; ignore it
        // -- here, the pointer analysis knows how to handle it; however, we
        // -- use state es to reflect possible side effects of evaluating
        // -- the operand
        AddressOfOp(_)  => (top, es);

        BitComplementOp(_) => (complement(e1, e2), es);
  
        _ => print("unsupported unary: ") print(exp) print("\n") 
             (top, lift([-> top]));
      endcase;
    endcase
  ;

bad((top, _)) = true;
bad((bot, _)) = true;
bad((_, top)) = true;
bad((_, bot)) = true;
bad((_,_)) = false;

bool_int :: bool -> snum;
bool_int(b) =
  if b then 1 else 0 ;

int_bool :: snum -> bool;
int_bool(0) = false;
int_bool(_) = true;

updatestate :: itvl_State, Expression, itvl_Interval, ContextInfo -> itvl_IntervalStatePair;
updatestate(bot, _, _, _) = (top,bot);
// -- Update state state by assigning the value value to the variable
// -- referenced by expression exp (if any). Yields a pair of the value
// -- and the new state.
updatestate(state, exp, value, context) = 
// --print("updatestate(") print(state) print(", ") print(exp) print(", ") print(value) print(")\n") 
  let s <= state; in 
  let newstate =
    case exp of
      VarRefExp(var) => lift(s\[varref_varid(exp) -> value]);
   // -- ignore comparisons against null pointer constants, which due to
   // -- complex issues have location assigned by the points-to analysis
      CastExp(IntVal(_), _) => state;
      _ => let exprid = expr_exprid(exp);
           in  if exprid_has_location(exprid) then
               let loc = exprid_location_cs(exprid, context); in
               let syms = location_varsyms(loc);
               in  // -- println("updating vars: ", syms)
                   case syms of
                // -- no var: could be an error; could also be harmless, if
                // -- this updatestate call resulted from an equality check
                   [!]    => println("warning: no varsyms for exp in updatestate: ",
                                     exp, " :: ", expr_asttext(exp))
                             state;
                // -- singleton var, may be an array name: strong update of
                // -- scalar variables, weak update of arrays
                   v::[!] => if is_array_location(loc) then
                                 lift(weak_update_v(s, varsym_varid(v), value))
                             else
                                 lift(s\[varsym_varid(v) -> value]);
                // -- otherwise: more than one var, weak update
                   _      => // -- println("info: weak update ", syms, " := ", value)
                             lift(weak_update(s, syms, value));
               endcase
           else
               println("info: cannot updatestate for lhs expression: ",
                       exp, " :: ", expr_asttext(exp))
               state;
    endcase;
  in // --print("\n=> ") print(state) print("\n") 
     (value, newstate);

weak_update :: itvl_fState, *VariableSymbolNT, itvl_Interval -> itvl_fState;
weak_update(s, [!], _) = // -- println("weak update result: ", s)
    s;
weak_update(s, vsym::vs, value) =
    let v = varsym_varid(vsym); in
    let newstate = weak_update_v(s, v, value);
    in  weak_update(newstate, vs, value);

weak_update_v(s, v, value) =
    let v_old_val = s{!v!}; in
    let v_new_val = combi(v_old_val, value);
    in  s\[v -> v_new_val];

// merged_var_values(s, vsyms): Look up an interval that covers the values
// of all variables in vsyms in state s.
merged_var_values :: itvl_State, *VariableSymbolNT -> itvl_Interval;
merged_var_values(top, _) = top;
merged_var_values(_, [!]) =
    println("in merged_var_values: merging empty variable list!")
    top;
merged_var_values(lift(s), v::[!]) = s{!varsym_varid(v)!};
merged_var_values(lift(s) as ls, v::vs) =
    let merged = merged_var_values(ls, vs);
    in  combi(s{!varsym_varid(v)!}, merged);

initialize :: itvl_fState, VariableId, Type, Expression, ContextInfo -> itvl_fState;
initialize(s, v, ArrayType(BasicType(_), _) as t, // -- TODO: use array size
                 AggregateInitializer(initexpr), context) =
    initialize(s, v, t, initexpr, context);
initialize(s, v, ArrayType(BasicType(_), _), // -- TODO: use array size
                 ExprListExp(exprs), context) =
 // default value: 0 (missing initializers default to 0)
    initialize_array(s\[v -> duplift(0)], v, exprs, context);
// ignore unknown initializer
initialize(s, _, _, _, _) = s;

initialize_array :: itvl_fState, VariableId, *Expression, ContextInfo -> itvl_fState;
initialize_array(s, _, [!], _) = s;
initialize_array(s, var, expr::exprs, ctx) =
    let value = eval(expr, lift(s), ctx)!1!2; // -- FIXME: assumes pure exprs
    in  initialize_array(weak_update_v(s, var, value), var, exprs, ctx);

is_op_assign :: Expression -> bool;
is_op_assign(PlusAssignOp(_,_)) = true;
is_op_assign(MinusAssignOp(_,_)) = true;
is_op_assign(MultAssignOp(_,_)) = true;
is_op_assign(DivAssignOp(_,_)) = true;
is_op_assign(ModAssignOp(_,_)) = true;
is_op_assign(LshiftAssignOp(_,_)) = true;
is_op_assign(RshiftAssignOp(_,_)) = true;
is_op_assign(IorAssignOp(_,_)) = true;
is_op_assign(AndAssignOp(_,_)) = true;
is_op_assign(XorAssignOp(_,_)) = true;
is_op_assign(_) = false;

// -- Assign-op operators: If either operand is unknown, kill the lhs.
op_assign_effects :: itvl_State, Expression, itvl_Interval, itvl_Interval,
                     ContextInfo -> itvl_IntervalStatePair;
op_assign_effects(state, exp, llifted, rlifted, context) =
  let left = binary_get_left_child(exp); in
  if bad(llifted) || bad(rlifted) then
    updatestate(state, left, top, context)
  else
    let r1 <= rlifted!1!2; r2 <= rlifted!2!2;
        l1 <= llifted!1!2; l2 <= llifted!2!2;
    in case exp of
      PlusAssignOp(_, _)  =>
          updatestate(state, left, ltup(l1 + r1, l2 + r2), context);
      MinusAssignOp(_, _) =>
          updatestate(state, left, ltup(l1 - r2, l2 - r1), context);
      MultAssignOp(_, _)  =>
          updatestate(state, left, ltup(mini(l1*r1, l1*r2),
                                        maxi(l2*r1, l2*r2)), context);
      DivAssignOp(_, _)   =>
          updatestate(state, left, ltup(mini(l1/r1, l1/r2),
                                        maxi(l2/r1, l2/r2)), context);
      ModAssignOp(_, _)   =>
          updatestate(state, left, ltup(0, r2), context);
      LshiftAssignOp(_, _)=>
          updatestate(state, left, ltup(l1<<unum(r1), l2<<unum(r2)), context);
      RshiftAssignOp(_, _)=>
          updatestate(state, left, ltup(l1>>unum(r2), l2>>unum(r1)), context);
      IorAssignOp(_, _)   =>
          updatestate(state, left, ltup(l1 | r1, l2 | r2), context);
      AndAssignOp(_, _)   =>
          updatestate(state, left, and(l1, l2, r1, r2), context);
      XorAssignOp(_, _)   =>
          updatestate(state, left, xor(l1, l2, r1, r2), context);
      _ => error("unexpected assign-op expression");
    endcase;

// -- constrain_array_index: If an array with a known size is indexed with a
// -- varref expression, force the variable's interval to be at most the
// -- array's valid index range (0..size-1).
constrain_array_index :: itvl_State, Type, Expression -> itvl_State;
constrain_array_index(s, ArrayType(_, size), VarRefExp(_) as varref) =
    let state <= s; in
    if val-astint(size) > 0 then  // size is -1 if unknown
        let var = varref_varid(varref); in
        let index_range = ltup(0, val-astint(size) - 1);
            known_range = state{!var!}; in
        let constrained_range = intersect_itvls(known_range, index_range);
        in  // -- println("constrained ", var, " from ", known_range,
            // --         ", with ", index_range, ", to ", constrained_range)
            lift(state\[var -> constrained_range])
    else
        s;
constrain_array_index(s, _, _) = s;

branch :: Expression, itvl_State, bool, bool, ContextInfo -> itvl_State;
branch(exp, state, edge, isLoopBody, context) =
  // -- print("\nbranching...\nexp: ") print(exp) 
  // -- print("\nstate: ") print(state) 
  // -- print("\nedge: ") print(edge)  
  // -- print("\n")

  let pair = eval(exp, state, context); in
  let c = interval_to_bool(pair!1!2); 
          newstate = pair!2!2; in
  if (c = top /* || isLoopBody */) then  // GB: don't think loops are special
    // -- We don't know for sure which edge will be taken
    // --print("c=top\n") 
    // --print("Maybe\n") 
    branch_condition_effects(exp, state, newstate, edge, isLoopBody, context)
  else if c = bot then 
    print("FIXME c=bot\n") 
    state
  else if drop(c) = edge then  
    // -- This edge will ALWAYS be taken
    // --print(newstate) print("\n") 
    // --print("Always\n") 
    newstate
  else 
    // -- This edge will NEVER be taken
    // --print("bot\n") 
    // --print("Never\n") 
    bot
    ;


branch_condition_effects :: Expression, itvl_State, itvl_State, bool, bool, ContextInfo -> itvl_State;
branch_condition_effects(exp, state, newstate, edge, isLoopBody, context) =
  // -- println("branch_condition_effects ", exp)
  if is_binary(exp) then
    if is_comparison(exp) then
      comparison_effects(exp, state, newstate, edge, context)
    else
      case exp of
        AndOp(exp1, exp2) => println("AND: ", state)
          let state1 =
            branch_condition_effects(
                exp1, state, newstate, edge, isLoopBody, context);
          in println(state1)
            branch_condition_effects(
                exp2, state1, newstate, edge, isLoopBody, context);
        _ => newstate;
      endcase
  else
    lift([-> top])
    //newstate
  ;

is_comparison :: Expression -> bool;
is_comparison(LessThanOp(_,_)) = true;
is_comparison(LessOrEqualOp(_,_)) = true;
is_comparison(GreaterThanOp(_,_)) = true;
is_comparison(GreaterOrEqualOp(_,_)) = true;
is_comparison(EqualityOp(_,_)) = true;
is_comparison(NotEqualOp(_,_)) = true;
is_comparison(_) = false;

comparison_effects :: Expression, itvl_State, itvl_State, bool, ContextInfo
                      -> itvl_State;
comparison_effects(exp, oldstate, state, edge, context) =
 if !is_binary(exp) || !is_comparison(exp) then
   println("*** comparison_effects called with non-comparison ", exp,
           " :: ", expr_asttext(exp))
   error("*** fatal error")
 else
 let lhsexp = binary_get_left_child(exp);
     rhsexp = binary_get_right_child(exp); in
 let lhs = eval(lhsexp, oldstate, context)!1!2;
     rhs = eval(rhsexp, oldstate, context)!2!2; in
 case exp of
   LessThanOp(_, _) =>
     if edge = true then
       less_effects(state, lhsexp, rhsexp, context)
     else
       less_or_equal_effects(state, rhsexp, lhsexp, context)
     ;
   LessOrEqualOp(_, _) =>
     if edge = true then
       less_or_equal_effects(state, lhsexp, rhsexp, context)
     else
       less_effects(state, rhsexp, lhsexp, context)
     ;
   GreaterThanOp(_, _) =>
     if edge = true then
       less_effects(state, rhsexp, lhsexp, context)
     else
       less_or_equal_effects(state, lhsexp, rhsexp, context)
     ;
   GreaterOrEqualOp(_, _) =>
     if edge = true then
       less_or_equal_effects(state, rhsexp, lhsexp, context)
     else
       less_effects(state, lhsexp, rhsexp, context)
     ;
   EqualityOp(_, _) =>
     if edge = true then
       equal_effects(state, lhsexp, rhsexp, context)
     else
       state
     ;
   NotEqualOp(_, _) =>
     if edge = true then
       state
     else
       equal_effects(state, lhsexp, rhsexp, context)
     ;
 endcase;

less_effects :: itvl_State, Expression, Expression, ContextInfo -> itvl_State;
less_effects(state, lhsexp, rhsexp, context) =
  let lhs = eval(lhsexp, state, context)!1!2;
      rhs = eval(rhsexp, state, context)!1!2;
  in  cond_update(
        cond_update(state, lhsexp, adjust_max_plus(lhs, rhs, -1), context),
                           rhsexp, adjust_min_plus(rhs, lhs,  1), context);

less_or_equal_effects :: itvl_State, Expression, Expression, ContextInfo
                         -> itvl_State;
less_or_equal_effects(state, lhsexp, rhsexp, context) =
  let lhs = eval(lhsexp, state, context)!1!2;
      rhs = eval(rhsexp, state, context)!1!2;
  in  cond_update(
        cond_update(state, lhsexp, adjust_max(lhs, rhs), context),
                           rhsexp, adjust_min(rhs, lhs), context);

equal_effects :: itvl_State, Expression, Expression, ContextInfo -> itvl_State;
equal_effects(state, lhsexp, rhsexp, context) =
  let lhs = eval(lhsexp, state, context)!1!2;
      rhs = eval(rhsexp, state, context)!1!2; in
  let intersection = intersect_itvls(lhs, rhs);
  in  cond_update(
        cond_update(state, lhsexp, intersection, context),
                           rhsexp, intersection, context);

// -- cond_update: Update a state with new value for the object(s)
// -- represented by the expression, if any; if the expression does not
// -- refer to any object(s), nothing is changed.
cond_update :: itvl_State, Expression, itvl_Interval, ContextInfo -> itvl_State;
cond_update(state, exp, value, context) =
  if exprid_has_location(expr_exprid(exp)) then
     updatestate(state, exp, value, context)!2!2
  else
     state;

// -- update the min portion of an interval
adjust_min :: itvl_Interval, itvl_Interval -> itvl_Interval;
adjust_min((a1, a2), (m, _)) = (intersect_max(a1, m), max(m, a2));

// -- update the max portion of an interval
adjust_max :: itvl_Interval, itvl_Interval -> itvl_Interval;
adjust_max((a1, a2), (_, m)) = (min(a1, m), intersect_min(a2, m));

// -- update the min portion of an interval and add c
adjust_min_plus :: itvl_Interval, itvl_Interval, snum -> itvl_Interval;
adjust_min_plus((a1, a2), (m, _), c) =
    let m1 <= m; in
    let m2 = lift(m1+c); in
      (intersect_max(a1, m2), max(m2, a2));

// -- update the max portion of an interval and add c
adjust_max_plus :: itvl_Interval, itvl_Interval, snum -> itvl_Interval;
adjust_max_plus((a1, a2), (_, m), c) =
    let m1 <= m; in
    let m2 = lift(m1+c); in
      (min(a1, m2), intersect_min(a2, m2));


kill_vars :: itvl_State, *VariableSymbolNT -> itvl_State;
kill_vars(s, [!]) =
  s;
kill_vars(s, v::vars) =
  let ss <= s; in
  kill_vars(lift(ss\[varsym_varid(v) -> top]), vars);

interval_to_bool :: itvl_Interval -> BoolL;
interval_to_bool((lift(0), lift(0))) = lift(false);
interval_to_bool((lift(1), lift(1))) = lift(true);
interval_to_bool(_) = top;

// --shiftleft :: snum, snum -> snum;
// --shiftleft(a, 0) = a;
// --shiftleft(a, b) = shiftleft(a*2, b-1);

// --shiftright :: snum, snum -> snum;
// --shiftright(a, 0) = a;
// --shiftright(a, b) = shiftright(a/2, b-1);

comb(a, bot) = a;
comb(bot, b) = b;
comb(_, top) = top;
comb(top, _) = top;
comb(a, b) =
  let res = lift(crunch(drop(a), drop(b), combi)); // -- a glb b
  in
  // --print("comb a: ") print(a) print("\n")
  // --print("comb b: ") print(b) print("\n")
  // --print("result: ") print(res) print("\n\n")
  res;

combi((a1, a2), (b1, b2)) = 
  (min(a1, b1), max(a2, b2));

// -- intersect_itvls: compute *intersection* of two intervals, e.g. if we
// -- know that both are valid
intersect_itvls((a1, a2), (b1, b2)) =
    (intersect_max(a1, b1), intersect_min(a2, b2));

// -- intersect_max, intersect_min: like max and min, but a number always
// -- wins against top or bot
intersect_max(a, top) = a;
intersect_max(a, bot) = a;
intersect_max(top, b) = b;
intersect_max(bot, b) = b;
intersect_max(a, b) = if drop(a) > drop(b) then a else b;

intersect_min(a, top) = a;
intersect_min(a, bot) = a;
intersect_min(top, b) = b;
intersect_min(bot, b) = b;
intersect_min(a, b) = if drop(a) < drop(b) then a else b;

ret(a, bot) = a;
ret(bot, b) = b;
ret(_, top) = top;
ret(top, _) = top;
ret(local, exit) = 
  let returnvar = [(v,i)->top !! (v,i) <- drop(exit)\top, if is_tmpvarid(v)];
   // -- Here, we compute the set of locals that come back from the function.
   // -- Their new values override any ones before the call!
      modified_vars = [(v,i)->top !! (v,i) <- drop(exit)\top, if islocal(v)];
  in (let localstate <= local;
      in  // -- println("return locals: ", modified_vars)
          lift(override(localstate, modified_vars))
      ) glb lift(returnvar);

// -- override(locals, modified): "locals" and "modified" are two maps,
// -- typically with some shared domain objects; yield a map in which
// -- definitions from "modified" override ones from "locals", i.e.
// -- (Haskell syntax):
// --   \x -> if modified(x) != top then modified(x) else locals(x)
override(locals, modified) = crunch(locals, modified, second_if_present);

second_if_present(a, b) =
 // -- should this also check for b != bot?
    if b != top then b else a;

// -- for lifted integers, we use top as +infty and bot as -infty
// -- GB: this is not true anymore! -infty is top as well.
min(a, top) = top;
min(top, a) = top;
min(a, bot) = bot;
min(bot, b) = bot;
min(a, b) = if drop(a) < drop(b) then a else b ;

// -- all glory to polymorphism (... and the hypnotoad!)
mini(a, b) = if a < b then a else b ;

max(_, top) = top;
max(top, _) = top;
max(a, bot) = a;
max(bot, b) = b;
max(a, b) = if drop(a) > drop(b) then a else b ;

maxi(a, b) = if a > b then a else b ;


// -- Lots of auxiliary bitwise functions.
xor(a1, a2, b1, b2) =
 // -- If the sign bit is set on both intervals, the xor's result will be
 // -- non-negative. Otherwise, the lower limit is -inf.
    if (a2 & b2) < 0 then
        ltup(lowest_power_of_2(a1 | b1), next_higher_power_of_2(a2 | b2) - 1)
    else
        ltup(1 << unum(31), next_higher_power_of_2(a2 | b2) - 1);

and(a1, a2, b1, b2) =
 // -- If the sign bit is not set on *both* intervals, the and's result will
 // -- be non-negative. We make wild guesses regarding the limits.
 // -- Otherwise, the result is negative, and we don't even try to be clever.
    if a2 >= 0 || b2 >= 0 then
        ltup(0, (1 << unum(31)) - 1)
    else
        ltup(1 << unum(31), -1);

complement(a1, a2) =
 // -- If the sign bit is set on the interval, the complement's sign bit is
 // -- not set. Otherwise, we don't know anything.
    if a2 < 0 then
        ltup(0, (1 << unum(31)) - 1)
    else
        ltup(1 << unum(31), (1 << unum(31)) - 1);

lowest_bit :: snum -> unum;
lowest_bit(0) = unum(0);
lowest_bit(n) =
    if n = (1 << unum(31)) then unum(32) else  // -- the critical negative case
    if (n & 1) = 1         then unum(1)
                           else unum(1) + lowest_bit(n >> unum(1));

highest_bit :: snum -> unum;
highest_bit(0) = unum(0);
highest_bit(n) =
    if n < 0 then unum(32)  // -- sign bit is set
             else unum(1) + highest_bit(n >> unum(1));

lowest_power_of_2 :: snum -> snum;
lowest_power_of_2(0) = 0;
lowest_power_of_2(n) = (1 << (lowest_bit(n) - unum(1)));

highest_power_of_2 :: snum -> snum;
highest_power_of_2(0) = 0;
highest_power_of_2(n) = (1 << (highest_bit(n) - unum(1)));

next_higher_power_of_2 :: snum -> snum;
next_higher_power_of_2(0) = 0;
next_higher_power_of_2(n) = (1 << highest_bit(n));

// -- default widening operator:
//wide(_, b) = b;

wide(bot, b) = b;
wide(a, bot) = a;
wide(_, top) = top;
wide(top, _) = top;
wide(a, b) = lift(crunch(drop(a), drop(b), widen));

widen((top, top), b) = b;
widen((a1, a2), (b1, b2)) = ( if a1=b1 then a1 else top /*min(a1, b1)*/ ,
                              if a2=b2 then a2 else top /*max(a1, b1)*/  );

//widen((a1, a2), (b1, b2)) = let v1 <= b1 ;
//                                v2 <= b2 ; in 
//                            ( if v2-v1 > 10 then top else b1 ,
//                              if v2-v1 > 10 then top else b2 ) ;


eq(a, b)   = //print("eq a: ") print(a) print("\n")
             //print("eq b: ") print(b) print("\n\n")
             (a = b);

isglobal(var) = is_tmpvarid(var) || varmember(var, globals);
islocal(var) = !isglobal(var);
isaliasedlocal(var, ctx) =
    let result = islocal(var) && varid_has_location(var)
                              && may_be_aliased(varid_location_cs(var, ctx));
    in  // -- println("checking aliasing of var ", var, " in context ", ctx,
        // --         " -> ", result)
        result;

varmember(_, [!]) = false;
varmember(v, g::gs) = 
    if varsym_varid(g) = v 
    then true 
    else varmember(v, gs);
    
is_array_type :: Type -> bool;
is_array_type(type) =
    case type of
        ArrayType(_, _) => true;
        ModifierType(t) => is_array_type(t);
        _               => false;
    endcase;

is_pointer_type :: Type -> bool;
is_pointer_type(type) =
  case type of
    PointerType(_)  => true;
    ModifierType(t) => is_pointer_type(t);
    _               => false;
  endcase;

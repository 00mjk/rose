// Support for the following functions:
// varid_has_location :: VariableId -> bool;
// varid_location :: VariableId -> Location;
// exprid_has_location :: ExpressionId -> bool;
// exprid_location :: ExpressionId -> Location;
// location_varsyms :: Location -> *VariableSymbolNT;
// may_be_aliased :: Location -> bool;

// void **Ir::createNodeList(std::vector<T> &) should come in handy

// TODO: Add points-to analysis to ICFG.
//       *** Avoid confusion between PointsToAnalysis::Location and the
//       wrapper class for PAG.
//       Design and implement a nice interface to query the points-to
//       analyzer.
//       Ideally, the abstract locations seen by PAG analyses are only the
//       equivalence class representatives; not every location is
//       meaningful. This is relevant if some user tries to construct the
//       set of all locations, for instance.

// GB (2008-11-07): This is the initial implementation of PAG analyzer
// access to points-to information.

#include "gc_mem.h"
#include "unum.h"
#include "str.h"

#include "cfg_support.h"
#include "IrCreation.h"
#include "o_VariableId.h"
#include "o_ExpressionId.h"

#include "pointsto.h"
#include "o_Location.h"

using SATIrE::Analyses::PointsToAnalysis;

// initial value, changed by o_Location_init
int LocationWrapper::type_id = -1;

// initial value, changed by o_Location_init
static unsigned long numberOfLocations = 0;

// initial value, can be changed by ExpressionId::setPrintFormat
// ExpressionId::PrintFormat ExpressionId::printFormat = ExpressionId::F_Expression;

// PAG functions follow
extern "C" void o_Location_mark(void *)
{
 // dummy: an abstract location does not contain any PAG heap pointers, so
 // there is nothing to mark recursively
}

extern "C" void o_Location_mcopy(void *src, void *dst)
{
    LocationWrapper *s = (LocationWrapper *) src;
    LocationWrapper *d = (LocationWrapper *) dst;

    d->id = s->id;
    d->loc = s->loc;
}

// number of locations; to be initialized after points-to analysis
ull o_Location_power;

int o_Location_is_power_unendl = 0;

LocationWrapper *createLocationWrapper(PointsToAnalysis::Location *loc)
{
    void *n = GC_alloc(LocationWrapper::type_id);
    LocationWrapper *l = (LocationWrapper *) n;
    l->id = get_global_cfg()->pointsToAnalysis->location_id(loc);
    l->loc = loc;
    return l;
}

extern "C" FLO_BOOL o_Location_eq(void *p, void *q)
{
    LocationWrapper *a = (LocationWrapper *) p;
    LocationWrapper *b = (LocationWrapper *) q;

    return (a->id == b->id ? FLO_TRUE : FLO_FALSE);
}

extern "C" FLO_BOOL o_Location_neq(void *p, void *q)
{
    LocationWrapper *a = (LocationWrapper *) p;
    LocationWrapper *b = (LocationWrapper *) q;

    return (a->id != b->id ? FLO_TRUE : FLO_FALSE);
}

extern "C" unsigned int o_Location_hash(void *p)
{
    LocationWrapper *v = (LocationWrapper *) p;
 // conversion to unsigned int from unsigned long might wrap around to a
 // smaller number, but that's fine for a hash
    return v->id;
}

extern "C" void o_Location_init(void)
{
    if (LocationWrapper::type_id == -1)
    {
     // Register the type with the PAG garbage collector.
        LocationWrapper::type_id = GC_registertype(sizeof (LocationWrapper),
                                                   o_Location_mark,
                                                   o_Location_mcopy,
                                                   o_Location_eq,
                                                   o_Location_hash,
                                                   /* noshare = */ 0);

     // This must be called after the ICFG has been built, and points-to
     // analysis has been performed.
        const std::vector<PointsToAnalysis::Location *> &locations
            = get_global_cfg()->pointsToAnalysis->get_locations();
        o_Location_power = locations.size();
     // numberOfLocations is needed to test for termination of the
     // abstract cursor functions below.
        numberOfLocations = locations.size();
    }
}

extern "C" void *o_Location_duplicate(void *src)
{
    LocationWrapper *s = (LocationWrapper *) src;
    LocationWrapper *dst = (LocationWrapper *) GC_alloc(
                                                    LocationWrapper::type_id);
    dst->id = s->id;
    dst->loc = s->loc;
    return dst;
}

extern "C" void o_Location_find_obj(void)
{
 // dummy: We have no global instances of locations.
}

extern "C" void o_Location_copy_obj(void)
{
 // dummy iff o_Location_find_obj is a dummy
}

extern "C" void o_Location_clear_flag(void)
{
 // dummy iff o_Location_find_obj is a dummy
}

EXTERN_C FLO_BOOL o_Location_le(void *a, void *b)
{
    LocationWrapper *v = (LocationWrapper *) a;
    LocationWrapper *w = (LocationWrapper *) b;
    return (v->id < w->id ? FLO_TRUE : FLO_FALSE);
}

EXTERN_C FLO_BOOL o_Location_leq(void *a, void *b)
{
    LocationWrapper *v = (LocationWrapper *) a;
    LocationWrapper *w = (LocationWrapper *) b;
    return (v->id <= w->id ? FLO_TRUE : FLO_FALSE);
}

EXTERN_C FLO_BOOL o_Location_ge(void *a, void *b)
{
    LocationWrapper *v = (LocationWrapper *) a;
    LocationWrapper *w = (LocationWrapper *) b;
    return (v->id > w->id ? FLO_TRUE : FLO_FALSE);
}

EXTERN_C FLO_BOOL o_Location_geq(void *a, void *b)
{
    LocationWrapper *v = (LocationWrapper *) a;
    LocationWrapper *w = (LocationWrapper *) b;
    return (v->id >= w->id ? FLO_TRUE : FLO_FALSE);
}


// *** Analyzer support functions
extern "C" FLO_BOOL o_varid_has_location(void *vp)
{
    if (o_is_tmpvarid(vp) == FLO_TRUE)
        return FLO_FALSE;

    VariableId *v = (VariableId *) vp;
    SgVariableSymbol *sym = get_global_cfg()->ids_varsyms[v->id];
    PointsToAnalysis::Location *loc
        = get_global_cfg()->pointsToAnalysis->symbol_location(sym);
    return (loc != NULL ? FLO_TRUE : FLO_FALSE);
}

extern "C" void *o_varid_location(void *vp)
{
    VariableId *v = (VariableId *) vp;
    SgVariableSymbol *sym = get_global_cfg()->ids_varsyms[v->id];
    PointsToAnalysis::Location *loc
        = get_global_cfg()->pointsToAnalysis->symbol_location(sym);
    return createLocationWrapper(loc);
}

extern "C" FLO_BOOL o_exprid_has_location(void *ep)
{
    std::cerr
        << "o_exprid_has_location not implemented yet"
        << std::endl;
    std::abort();
}

extern "C" void *o_exprid_location(void *ep)
{
    SgExpression *exp = (SgExpression *) o_exprid_expr(ep);
    PointsToAnalysis::Location *loc
        = get_global_cfg()->pointsToAnalysis->expressionLocation(exp);
    return createLocationWrapper(loc);
}

extern "C" void *o_location_varsyms(void *lp)
{
    LocationWrapper *wrapper = (LocationWrapper *) lp;
    PointsToAnalysis::Location *loc = wrapper->loc;
    const std::list<SgSymbol *> &syms
        = get_global_cfg()->pointsToAnalysis->location_symbols(loc);
    std::list<SgSymbol *>::const_iterator s;
    std::vector<SgVariableSymbol *> varsyms;
    for (s = syms.begin(); s != syms.end(); ++s)
    {
        if (SgVariableSymbol *varsym = isSgVariableSymbol(*s))
            varsyms.push_back(varsym);
    }
    return Ir::createNodeList(varsyms);
}

extern "C" FLO_BOOL o_may_be_aliased(void *lp)
{
    LocationWrapper *wrapper = (LocationWrapper *) lp;
    PointsToAnalysis::Location *loc = wrapper->loc;
    bool mayBeAliased = get_global_cfg()->pointsToAnalysis->mayBeAliased(loc);
    return (mayBeAliased ? FLO_TRUE : FLO_FALSE);
}

#if 0
// map expression to ExpressionId object, i.e. construct a new instance
// on the PAG heap
extern "C" void *o_expr_exprid(void *p)
{
    SgExpression *expr = (SgExpression *) p;
    void *n = GC_alloc(ExpressionId::type_id);
    ExpressionId *e = (ExpressionId *) n;
    e->id = get_global_cfg()->exprs_numbers[expr];
    return n;
}
#endif

// *** Other PAG support functions
// 10.2 Common Functions
extern "C" char *o_Location_print(void *p)
{
    LocationWrapper *wrapper = (LocationWrapper *) p;
    std::string label = wrapper->print();
    const char *s = label.c_str();
    char *result = (char *) gc_tmp(std::strlen(s) + 1);
    std::strcpy(result, s);
    return result;
#if 0
 // print a label for the variable into a buffer allocated using gc_tmp
    ExpressionId *v = (ExpressionId *) p;
    std::string label = v->print();
    const char *s = label.c_str();
    char *result = (char *) gc_tmp(std::strlen(s) + 1);
    std::strcpy(result, s);
    return result;
#endif
}

extern "C" void o_Location_print_fp(FILE *f, void *p)
{
    LocationWrapper *v = (LocationWrapper *) p;
    std::string label = v->print();
    const char *s = label.c_str();
    std::fputs(s, f);
}

extern "C" char *o_Location_to_charp(void *p)
{
 // the PAG manual is quite vague about what this is supposed to be; use
 // print for now
    return o_Location_print(p);
}

extern "C" char *o_Location_gdlprint(void *p)
{
    return o_Location_print(p);
}

// 10.2.1.2 Abstract Cursors
// The abstract cursor is an index into the points-to analysis' vector of
// locations; initialization and advancing of the cursor is therefore quite
// simple. For the "get" operation, we fetch the corresponding location and
// build a wrapper instance on the PAG heap.
extern "C" void o_Location_acur_reset(unsigned long *p)
{
    *p = 0;
}

extern "C" void o_Location_acur_next(unsigned long *p)
{
    ++*p;
}

extern "C" void *o_Location_acur_get(unsigned long *p)
{
    PointsToAnalysis::Location *loc
        = get_global_cfg()->pointsToAnalysis->get_locations().at(*p);
    return createLocationWrapper(loc);
#if 0
    void *n = GC_alloc(ExpressionId::type_id);
    ExpressionId *v = (ExpressionId *) n;
    v->id = *p;
    return n;
#endif
}

extern "C" FLO_BOOL o_Location_acur_is_empty(unsigned long *p)
{
    return (*p >= numberOfLocations ? FLO_TRUE : FLO_FALSE);
}


// implementation of LocationWrapper member functions
std::string LocationWrapper::print() const
{
    std::stringstream result;

    result << id;

    return result.str();
}

#if 0
// implementation of ExpressionId member functions
std::string ExpressionId::print() const
{
    std::stringstream result;

    switch (printFormat)
    {
    case F_Id:
        result << id;
        break;

    case F_Expression:
        result << Ir::fragmentToString(get_global_cfg()->numbers_exprs[id]);
        break;

    case F_IdAndExpression:
        result
            << "("
            << id
	    << ","
            << Ir::fragmentToString(get_global_cfg()->numbers_exprs[id])
            << ")";
        break;
    default: std::cerr << "Wrong format mode or print mode for nodes (Expression:print) in gdl file"; std::abort();
    }

    return result.str();
}

void ExpressionId::setPrintFormat(PrintFormat format)
{
    printFormat = format;
}
#endif

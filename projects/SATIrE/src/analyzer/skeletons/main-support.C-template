/* -*- c -*-
 * Specify the carrier type of the analysis. This should be the same
 * as the one given with "carrier:" in the optla file.
 * For example: #define CARRIER_TYPE State */

#ifndef CARRIER_TYPE
    #define CARRIER_TYPE PLEASE_SPECIFY_CARRIER_TYPE
#endif

#include "main-support.h"
#include "cfg_support.h"
#include "analysis_info.h"

extern "C" DFI_STORE doit(ANALYSIS)(void *);
extern "C" void gdl_create(char *, int);

std::string get_statement_pre_info_string(DFI_STORE store, SgStatement* stmt) {
  return (carrier_printfunc(CARRIER_TYPE)(
					  (carrier_type_o(CARRIER_TYPE))
					  get_statement_pre_info(store, stmt)
					  ));
}

std::string get_statement_post_info_string(DFI_STORE store, SgStatement* stmt) {
  return (carrier_printfunc(CARRIER_TYPE)(
					  (carrier_type_o(CARRIER_TYPE))
					  get_statement_post_info(store, stmt)
					  ));
}

carrier_type_o(CARRIER_TYPE) 
select_info(DFI_STORE store, SgStatement *stmt, std::string attrName) {
  StatementAttribute* stmtAttr = dynamic_cast<StatementAttribute *>(stmt->getAttribute(attrName));
  BasicBlock* block=stmtAttr->get_bb();
  int pos=stmtAttr->get_pos();
  switch (pos) {
  case POS_PRE:
    return dfi_get_pre_info(store, block->id);
  case POS_POST:
    return dfi_get_post_info_all(store, block->id);
  }
  return NULL;
}

carrier_type_o(CARRIER_TYPE) 
get_statement_pre_info(DFI_STORE store, SgStatement *stmt)
{
  return select_info(store, stmt, "PAG statement start");
}

carrier_type_o(CARRIER_TYPE) 
get_statement_post_info(DFI_STORE store, SgStatement *stmt)
{
  return select_info(store, stmt, "PAG statement end");
}

DFI_STORE perform_pag_analysis(ANALYSIS)(SgProject *root,AnalyzerOptions* opt)
{
  bool verbose=opt->verbose();
  
    if (verbose) std::cout << "collecting functions ... ";
    ProcTraversal s;
    s.setPrintCollectedFunctionNames(opt->printCollectedFunctionNames());
    s.traverse(root, preorder);
    if (verbose) std::cout << "done" << std::endl;

    if (verbose) std::cout << "generating cfg ... ";
    CFGTraversal t(s.get_procedures());
    t.traverse(root, preorder);
    if (verbose) std::cout << "done" << std::endl;

    if (verbose) std::cout << "testing cfg ... ";

    int test_result = kfg_testit(t.getCFG(), 1 /* quiet */);
    if (test_result == 0)
    {
      std::cout << "failed." << std::endl;
      std::cerr << std::endl
		<< "Warning: PAG reports: there are problems in the ICFG."
		<< std::endl;
    } else {
      if (verbose) std::cout << "done" << std::endl;
    }
    
    if(opt->outputIcfg()) {
      if(verbose) std::cout << "generating icfg visualization " << opt->getOutputIcfgFileName() << " ... ";
      outputIcfg(t.getCFG(),const_cast<char*>(opt->getOutputIcfgFileName().c_str()));
      if (verbose) std::cout << "done" << std::endl;
    }

    if (verbose) std::cout << "performing analysis " stringize(ANALYSIS) " ... ";
    std::cout.flush();
    DFI_STORE results = doit(ANALYSIS)(t.getCFG());
    if (verbose) std::cout << "done" << std::endl;
    
    /* we must run gdl_create for both single file and animation */
    std::string outputgdlfile;
    if(opt->outputGdl())
      outputgdlfile=opt->getOutputGdlFileName();
    else
      if(opt->outputGdlAnim())
	outputgdlfile=opt->getOutputGdlAnimDirName() + "/result.gdl"; // we cannot create an animation, but not create a gdl file

    if(opt->outputGdl() || opt->outputGdlAnim()) {
      if(verbose) std::cout << "generating ";
      if(verbose && opt->outputGdl()) std::cout << "visualization " << outputgdlfile << " ";
      if(verbose && opt->outputGdl() && opt->outputGdlAnim()) std::cout << "and ";
      if(verbose && opt->outputGdlAnim()) std::cout << "animation in directory " << opt->getOutputGdlAnimDirName() << " ";
      if(verbose) std::cout << "... ";
      gdl_create(const_cast<char*>(outputgdlfile.c_str()), 0);
      if (verbose) std::cout << "done" << std::endl;
    }

    return results;
}

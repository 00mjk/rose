// -*- C++ -*-
// vim: syntax=cpp

#include <satire.h>

// Include stuff generated by PAG.
#include "iterate.h"

/*
 * Macros used in this file:
 * - ANALYSIS: The identifier of the analysis.
 * - PREFIX_SET: A true value iff a prefix is set for this analysis.
 * - PREFIX: The prefix itself (identifier syntax) iff PREFIX_SET is true.
 * - CARRIER: The name of the carrier type of the analysis.
 * The definition of ANALYSIS is generated by the newanalysis script, the
 * others are expected to be passed via the command line.
 *                  
 * Macros defined in this file (with their intended arguments):
 * - stringize(ANALYSIS): A string constant containing the analysis name.
 * - doit(ANALYSIS): The name of the analysis_doit function generated by PAG.
 * - carrier_type_o(CARRIER): The C type name of the carrier type.
 * - carrier_printfunc(CARRIER): The name of the carrier's print function.
 *                  
 * Macros possibly defined in this file: These are defined iff PREFIX_SET
 * expands to a true value, which should be the case iff PREFIX expands to
 * some identifier. In this case, the following function and object names
 * defined by PAG are hidden behind macros of the same name that expand to
 * prefixed versions of the identifiers:
 * - DFI_STORE
 * - persistent
 * - gdl_create
 * - debug_stat
 * - global_retfunc
 * - dfi_get_pre_info
 * - dfi_get_post_info_all
 */

#define stringize(analysis) xstringize(analysis)
#define xstringize(analysis) #analysis

#define doit(analysis) xdoit(analysis)
#define xdoit(analysis) analysis##_doit

#define carrier_type_o(type) xcarrier_type(type)
#define xcarrier_type(type) o_##type

#define carrier_printfunc(type) xcarrier_printfunc(type)
#define xcarrier_printfunc(type) o_##type##_print

#if PREFIX_SET
    #define prefixed_DFI_STORE(P) p2_DFI_STORE(P)
    #define prefixed_persistent(P) p2_persistent(P)
    #define prefixed_gdl_create(P) p2_gdl_create(P)
    #define prefixed_debug_stat(P) p2_debug_stat(P)
    #define prefixed_global_retfunc(P) p2_global_retfunc(P)
    #define prefixed_dfi_get_pre_info(P) p2_dfi_get_pre_info(P)
    #define prefixed_dfi_get_post_info_all(P) p2_dfi_get_post_info_all(P)

    #define p2_DFI_STORE(P) o_##P##DFI_STORE
    #define p2_persistent(P) P##_persistent
    #define p2_gdl_create(P) o_##P##gdl_create
    #define p2_debug_stat(P) o_##P##debug_stat
    #define p2_global_retfunc(P) o_##P##global_retfunc
    #define p2_dfi_get_pre_info(P) o_##P##dfi_get_pre_info
    #define p2_dfi_get_post_info_all(P) o_##P##dfi_get_post_info_all

    #define DFI_STORE prefixed_DFI_STORE(PREFIX)
    #define persistent prefixed_persistent(PREFIX)
    #define gdl_create prefixed_gdl_create(PREFIX)
    #define debug_stat prefixed_debug_stat(PREFIX)
    #define global_retfunc prefixed_global_retfunc(PREFIX)
    #define dfi_get_pre_info prefixed_dfi_get_pre_info(PREFIX)
    #define dfi_get_post_info_all prefixed_dfi_get_post_info_all(PREFIX)
#else
 // "persistent" is apparently prefixed with the analysis name if the
 // analysis does not have a prefix.
    #define prefixed_persistent(A) p2_persistent(A)
    #define p2_persistent(A) A##_persistent
    #define persistent prefixed_persistent(ANALYSIS)
#endif

using namespace std;

// Variables defined by PAG.
extern int debug_stat;
extern int global_retfunc;
// Functions generated by PAG.
extern "C" DFI_STORE doit(ANALYSIS)(void *);
extern "C" void persistent(void);


// A more readable name for the carrier type.
typedef carrier_type_o(CARRIER_TYPE) CarrierType;
// And for the print function.
char *carrierPrintFunction(CarrierType c)
{
    return carrier_printfunc(CARRIER_TYPE)(c);
}



// Definitions of a few functions for retrieving and stringizing analysis
// results.
CarrierType
select_info(DFI_STORE store, SgStatement *stmt, std::string attrName)
{
    if (stmt->attributeExists(attrName))
    {
        StatementAttribute* stmtAttr
            = dynamic_cast<StatementAttribute *>(stmt->getAttribute(attrName));
        BasicBlock* block=stmtAttr->get_bb();
        int pos=stmtAttr->get_pos();
        switch (pos)
        {
        case POS_PRE:
            return dfi_get_pre_info(store, block->id);
        case POS_POST:
            return dfi_get_post_info_all(store, block->id);
        }
    }
    return NULL;
}

CarrierType
get_statement_pre_info(DFI_STORE store, SgStatement *stmt)
{
    return select_info(store, stmt, "PAG statement start");
}

CarrierType
get_statement_post_info(DFI_STORE store, SgStatement *stmt)
{
    return select_info(store, stmt, "PAG statement end");
}

#if 0
std::string
get_statement_pre_info_string(DFI_STORE store, SgStatement* stmt)
{
    CarrierType info = get_statement_pre_info(store, stmt);
    if (info != NULL)
        return carrierPrintFunction(info);
    else
        return "<undefined dfi>";
}

std::string
get_statement_post_info_string(DFI_STORE store, SgStatement* stmt)
{
    CarrierType info = get_statement_post_info(store, stmt);
    if (info != NULL)
        return carrierPrintFunction(info);
    else
        return "<undefined dfi>";
}
#else
std::string
statement_info_string(DFI_STORE store, SgStatement *stmt, std::string attrName)
{
    if (!stmt->attributeExists(attrName))
        return "<undefined dfi>";

    std::stringstream str;

    CarrierType info;
    StatementAttribute *stmtAttr
        = dynamic_cast<StatementAttribute *>(stmt->getAttribute(attrName));
    BasicBlock *block = stmtAttr->get_bb();
    int procnum = block->procnum;
    int arity = kfg_arity_id(block->id);  // number of contexts
    int prePost = stmtAttr->get_pos();
    if (prePost == POS_PRE)
    {
        for (int ctx = 0; ctx < arity; ctx++)
        {
            info = dfi_get_pre(store, block->id, ctx);
            str << "Context(" << procnum << "," << ctx << "):"
                << carrierPrintFunction(info) << " ";
        }
        str << "Merged:"
            << carrierPrintFunction(dfi_get_pre_info(store, block->id));
    }
    else
    {
     // outedges is a bitmask with a 1 bit for each type of edge leaving
     // this block
        unsigned int outedges = kfg_which_out_edges(block);
        unsigned int edge;
        for(edge = 0; outedges != 0; edge++, outedges >>= 1)
        {
            if (outedges & 1 != 0)
            {
                for (int ctx = 0; ctx < arity; ctx++)
                {
                    info = dfi_get_post(store, block->id, ctx,
                                        (KFG_EDGE_TYPE) edge);
                    str << "Edge(" << edgetypenames[edge] << "):"
                        << "Context(" << procnum << "," << ctx << "):"
                        << carrierPrintFunction(info) << " ";
                }
                str << "Merged:"
                    << carrierPrintFunction(
                            dfi_get_post_info_all(store, block->id));
            }
        }
    }

    return str.str();
}

std::string
get_statement_pre_info_string(DFI_STORE store, SgStatement* stmt)
{
    return statement_info_string(store, stmt, "PAG statement start");
}

std::string
get_statement_post_info_string(DFI_STORE store, SgStatement* stmt)
{
    return statement_info_string(store, stmt, "PAG statement end");
}
#endif


// Now PAG's identifiers are as they should be; we can now include template
// definitions that use these. These are the PagDfiTextPrinter,
// PagDfiCommentAnnotator, and TermPrinter classes.
#include <PagDfiTextPrinter.h>
#include <PagDfiCommentAnnotator.h>
#include <TermPrinter.h>


namespace SATIrE
{

namespace ANALYSIS
{

// ---- Definition of Implementation class
std::string
Implementation::identifier() const
{
    return stringize(ANALYSIS);
}

std::string
Implementation::description() const
{
    return "A data-flow analysis called " + identifier()
         + " for use with SATIrE.";
}

void
Implementation::analysisDoit(CFG *cfg)
{
    analysisInfo = doit(ANALYSIS)(cfg);
}

void
Implementation::makePersistent() const
{
    persistent();
}

void
Implementation::createGDL(const char *filename) const
{
    gdl_create((char *) filename, 0);
}

void
Implementation::setDebugStat(int debugStat) const
{
    debug_stat = debugStat;
}

void
Implementation::setGlobalRetfunc(int globalRetfunc) const
{
    global_retfunc = globalRetfunc;
}

void
Implementation::annotateProgram(Program *program)
{
    /* Handle command line option --analysis-annotation. */
    if (program->options->analysisAnnotation())
    {
        TimingPerformance timer("Annotate source code with comments:");
        PagDfiCommentAnnotator<DFI_STORE> ca((DFI_STORE) analysisInfo);

        if (program->options->analysisWholeProgram())
            ca.traverse(program->astRoot, preorder);
        else
            ca.traverseInputFiles(program->astRoot, preorder);
    }
}

void
Implementation::outputAnnotatedProgram(Program *program)
{
    /* Handle command line option --output-text. */
    if (program->options->outputText())
    {
        TimingPerformance timer("Generate text output:");
        PagDfiTextPrinter<DFI_STORE> p((DFI_STORE) analysisInfo);

        if (program->options->analysisWholeProgram())
            p.traverse(program->astRoot, preorder);
        else
            p.traverseInputFiles(program->astRoot, preorder);
    }

    /* Handle command line option --output-term. */
    if (program->options->outputTerm())
    {
        if (program->prologTerm == NULL)
        {
            TimingPerformance timer("Output Termite term:");
            TermPrinter<DFI_STORE> tp((DFI_STORE) analysisInfo, program->icfg);

            if (program->options->analysisWholeProgram())
                tp.traverse(program->astRoot);
            else
                tp.traverseInputFiles(program->astRoot);

            ofstream termfile;
            string filename = program->options->getOutputTermFileName();
            termfile.open(filename.c_str());
            termfile << "% Termite term representation" << endl;
            termfile << tp.getTerm()->getRepresentation() << "." << endl;
            termfile.close();
            program->prologTerm = tp.getTerm();
        }
    }
}

void
Implementation::outputAnalysisVisualization(Program *program)
{
    AnalyzerOptions *options = program->options;
    bool verbose = options->verbose();

    /* Handle command line options --output-gdl and --output-gdlanim. */
    std::string outputGdlFile;
    if (options->outputGdl())
        outputGdlFile = options->getOutputGdlFileName();
    else if (options->outputGdlAnim())
        outputGdlFile = options->getOutputGdlAnimDirName() + "/result.gdl";

    if (options->outputGdl() || options->outputGdlAnim())
    {
        TimingPerformance timer(
                "Generate GDL visualization of analysis results:");
        if (verbose)
            std::cout << "generating ";
        if (verbose && options->outputGdl())
            std::cout << "visualization " << outputGdlFile << " ";
        if (verbose && options->outputGdl() && options->outputGdlAnim())
            std::cout << "and ";
        if (verbose && options->outputGdlAnim())
        {
            std::cout
                << "animation in directory "
                << options->getOutputGdlAnimDirName() << " ";
        }
        if (verbose)
            std::cout << "... " << std::flush;
        createGDL(outputGdlFile.c_str());
        if (verbose)
            std::cout << "done" << std::endl;
    }
}


} // namespace ANALYSIS

} // namespace SATIrE

// GB (2009-03-10): This used to be in pag_support.C. However, when we moved
// to libtool and dynamic linking, it started segfaulting mysteriously. It
// seems to work here.
extern "C"
const char *Expression_print(void *e)
{
    std::cout << expr_to_string(isSgExpression((SgNode *) e));
    return "";
}

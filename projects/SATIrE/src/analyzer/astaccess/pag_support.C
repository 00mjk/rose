// -*- mode: c++; c-basic-offset: 4; -*-
// Copyright 2005,2006,2007 Markus Schordan, Gergo Barany
// $Id: pag_support.C,v 1.14 2008-05-19 12:36:34 gergo Exp $

#include <iostream>

#include <satire_rose.h>

#include "syntree.h"
#include "pignodelist.h"
#include "pag_support.h"
#include "IrCreation.h"

// GB (2008-05-08): The manual doesn't tell you this, but apparently these
// need to be initialized to negative values in the beginning; then the
// analyzer generated by PAG will call the syntax_init function, which is
// important.
int syntaxtype = -1;
int e_syntaxtype = -1;

#if OLD_GET_VALUE
#define get_value_macro(T) char *T##_get_value(void *s) \
    { if (s == NULL) return "<null>"; return (char *) s; }
#else
#define get_value_macro(T) char *T##_get_value(T x) \
{ std::stringstream s; s << x; return Ir::getCharPtr(s.str()); }
#endif

PIG_EXTERN_C get_value_macro(astint)
PIG_EXTERN_C get_value_macro(aststring)
PIG_EXTERN_C get_value_macro(astshort)
PIG_EXTERN_C get_value_macro(astchar)
PIG_EXTERN_C get_value_macro(astuchar)
PIG_EXTERN_C get_value_macro(astushort)
PIG_EXTERN_C get_value_macro(astuint)
PIG_EXTERN_C get_value_macro(astlong)
PIG_EXTERN_C get_value_macro(astllong)
PIG_EXTERN_C get_value_macro(astullong)
PIG_EXTERN_C get_value_macro(astulong)
PIG_EXTERN_C get_value_macro(astfloat)
PIG_EXTERN_C get_value_macro(astdouble)
PIG_EXTERN_C get_value_macro(astldouble)

PIG_EXTERN_C
const char *Expression_print(void *e)
{
    std::cout << expr_to_string(isSgExpression((SgNode *) e));
    return "";
}

PIG_EXTERN_C
const char *c_str_print(const void *s)
{
    std::cout << (const char *) s;
    return (const char *) s;
}

// GB (2007-10-31): This has been commented out for a while. The reason is
// that these functions are now generated by pig.
#if 0
PIG_EXTERN_C
int LIST_VariableSymbolNT_empty(void *l)
{
    return ((PigNodeList *) l)->empty();
}

PIG_EXTERN_C
void *LIST_VariableSymbolNT_hd(void *l)
{
    return ((PigNodeList *) l)->head();
}

PIG_EXTERN_C
void *LIST_VariableSymbolNT_tl(void *l)
{
    return ((PigNodeList *) l)->tail();
}
#endif

PIG_EXTERN_C
char *basic_type_name(const void *p)
{
    const SgNode *node = (SgNode *) p;

    switch (node->variantT())
    {
    case V_SgTypeBool: return "bool"; break;
    case V_SgTypeChar: return "char"; break;
    case V_SgTypeDouble: return "double"; break;
    case V_SgTypeFloat: return "float"; break;
    case V_SgTypeInt: return "int"; break;
    case V_SgTypeLong: return "long"; break;
    case V_SgTypeLongDouble: return "long double"; break;
    case V_SgTypeLongLong: return "long long"; break;
    case V_SgTypeShort: return "short"; break;
    case V_SgTypeSignedChar: return "signed char"; break;
    case V_SgTypeSignedInt: return "signed int"; break;
    case V_SgTypeSignedLong: return "signed long"; break;
    case V_SgTypeSignedShort: return "signed short"; break;
    case V_SgTypeString: return "string"; break;
    case V_SgTypeUnsignedChar: return "unsigned char"; break;
    case V_SgTypeUnsignedInt: return "unsinged int"; break;
    case V_SgTypeUnsignedLong: return "unsigned long"; break;
    case V_SgTypeUnsignedLongLong: return "unsigned long long"; break;
    case V_SgTypeUnsignedShort: return "unsigned short"; break;
    case V_SgTypeVoid: return "void"; break;
    case V_SgTypeWchar: return "wchar"; break;
    default: return NULL;
    }
}

#include "genkfg.h"

KFG_ATTR_DEF empty = { 0 };
KFG_ATTR_DEF *addr = &empty;
int zero = 0;

char const *kfg_get_attribute_symbol(char *)
{
    return NULL;
}

int kfg_get_global_attribute_information(KFG, KFG_ATTR_DEF **arr, int *len)
{
    arr = &addr;
    len = &zero;
    return 1;
}

int kfg_get_routine_attribute_information(KFG, KFG_ATTR_DEF **arr, int *len)
{
    arr = &addr;
    len = &zero;
    return 1;
}

int kfg_get_bblock_attribute_information(KFG, KFG_ATTR_DEF **arr, int *len)
{
    arr = &addr;
    len = &zero;
    return 1;
}

int kfg_get_instruction_attribute_information(KFG, KFG_ATTR_DEF **arr, int *len)
{
    arr = &addr;
    len = &zero;
    return 1;
}

int kfg_remap_global_attributes(KFG, KFG_ATTR_DEF **, int)
{
    return 1;
}

int kfg_remap_routine_attributes(KFG, KFG_ATTR_DEF **, int)
{
    return 1;
}

int kfg_remap_bblock_attributes(KFG, KFG_ATTR_DEF **, int)
{
    return 1;
}

int kfg_remap_instruction_attributes(KFG, KFG_ATTR_DEF **, int)
{
    return 1;
}

char const *kfg_get_global_attribute(KFG, int)
{
    return "";
}

char const *kfg_get_routine_attribute(KFG, int, int)
{
    return "";
}

char const *kfg_get_bblock_attribute(KFG, KFG_NODE, int)
{
    return "";
}

char const *kfg_get_instruction_attribute(KFG, KFG_NODE, int, int)
{
    return "";
}

char const *kfg_get_global_attribute_by_name(KFG, char *)
{
    return "";
}

char const *kfg_get_routine_attribute_by_name(KFG, int, char*)
{
    return "";
}

char const *kfg_get_bblock_attribute_by_name(KFG, KFG_NODE, char *)
{
    return "";
}

char const *kfg_get_instruction_attribute_by_name(KFG, KFG_NODE, int, char *)
{
    return "";
}

/* static attributes */
//#define HAVE_MEMMOVE
#include "pagheader.h"
#include "snum.h"
#include "unum.h"
/* list of global variables */
extern "C" void *kfg_get_global_attribute__globals(KFG cfg)
{
    return Ir::createNodeList(((CFG *) cfg)->globals);
 // return new PigNodeList(((CFG *) cfg)->globals);
}
/* numbers of types and expressions */
extern "C" unum kfg_get_global_attribute__numtypes(KFG cfg)
{
    return int_to_unum(((CFG *) cfg)->types_numbers.size());
}
extern "C" unum kfg_get_global_attribute__numexprs(KFG cfg)
{
    return int_to_unum(((CFG *) cfg)->numbers_exprs.size());
}
/* number of the current procedure */
extern "C" snum kfg_get_routine_attribute__procnum(KFG, int procnum)
{
    return int_to_snum(procnum);
}
/* statement labels */
extern "C" snum kfg_get_bblock_attribute__label(KFG cfg, KFG_NODE bb)
{
    return int_to_snum(kfg_get_id(cfg, bb));
}

/* external support functions */
#include "bool.h"
extern "C" bool o_is_unary(void *expr)
{
    return isSgUnaryOp((SgNode *) expr);
}

extern "C" bool o_is_binary(void *expr)
{
    return isSgBinaryOp((SgNode *) expr);
}

extern "C" bool o_is_value(void *expr)
{
    return isSgValueExp((SgNode *) expr);
}

#include "assert.h"

extern "C" void *o_unary_get_child(void *expr)
{
    assert(is_unary(expr));
    return isSgUnaryOp((SgNode *) expr)->get_operand();
}

extern "C" void *o_binary_get_left_child(void *expr)
{
    assert(is_binary(expr));
    return isSgBinaryOp((SgNode *) expr)->get_lhs_operand();
}

extern "C" void *o_binary_get_right_child(void *expr)
{
    assert(is_binary(expr));
    return isSgBinaryOp((SgNode *) expr)->get_rhs_operand();
}

CFG *global_cfg = NULL;

CFG *get_global_cfg()
{
    return global_cfg;
}

extern "C" void *o_typenum_to_type(unum n)
{
    return get_global_cfg()->numbers_types[unum_to_unsigned(n)];
}

extern "C" unum o_type_to_typenum(void *type)
{
    return int_to_unum(get_global_cfg()->types_numbers[isSgType((SgNode *) type)]);
}

#include "str.h"

extern "C" str o_typenum_to_str(unum n)
{
    return Ir::getCharPtr(Ir::fragmentToString(isSgType((SgNode *)o_typenum_to_type(n))));
}

extern "C" void *o_exprnum_to_expr(unum n)
{
    return get_global_cfg()->numbers_exprs[unum_to_unsigned(n)];
}

extern "C" unum o_expr_to_exprnum(void *expr)
{
    return int_to_unum(get_global_cfg()->exprs_numbers[isSgExpression((SgNode *) expr)]);
}

extern "C" str o_exprnum_to_str(unum n)
{
    return expr_to_string((SgExpression *) o_exprnum_to_expr(n));
}

extern "C" void *o_expr_type(void *expr)
{
    return isSgExpression((SgNode *) expr)->get_type();
}

extern "C" unum o_exprnum_typenum(unum n)
{
    return o_type_to_typenum(o_expr_type(o_exprnum_to_expr(n)));
}

extern "C" bool o_is_subtype_of(void *a, void *b)
{
    SgClassType *at = isSgClassType((SgType *) a),
                *bt = isSgClassType((SgType *) b);
    /* a is subtype of b if a inherits from b: look at a's
     * inheritances (base classes) */
    if (at == NULL) return false;
    if (bt == NULL) return false;
    const SgBaseClassPtrList &base_classes = 
        isSgClassDeclaration(at->get_declaration())->get_definition()
            ->get_inheritances();
    SgBaseClassPtrList::const_iterator i;
    for (i = base_classes.begin(); i != base_classes.end(); ++i)
    {
        SgClassDeclaration *base = (*i)->get_base_class();
        SgClassDeclaration *bdecl
            = isSgClassDeclaration(bt->get_declaration());
        if (base == bdecl || (base->get_type() != NULL && bdecl != NULL
                    && o_is_subtype_of(base->get_type(), bdecl->get_type())))
            return true;
    }
    return false;
}

extern "C" bool o_is_subtypenum_of(unum a, unum b)
{
    return o_is_subtype_of(o_typenum_to_type(a), o_typenum_to_type(b));
}

extern "C" void *o_global_get_type(void *symbol)
{
    SgVariableSymbol *varsym = (SgVariableSymbol *) symbol;
    return varsym->get_type();
}

extern "C" bool o_global_has_initializer(void *symbol)
{
    SgVariableSymbol *varsym = (SgVariableSymbol *) symbol;
    if (get_global_cfg()->globals_initializers.find(varsym)
            != get_global_cfg()->globals_initializers.end())
    {
        return true;
    }
    else
        return false;
}

extern "C" void *o_global_get_initializer(void *symbol)
{
    SgVariableSymbol *varsym = (SgVariableSymbol *) symbol;
    return get_global_cfg()->globals_initializers[varsym];
}

// GB (2008-05-09): This function returns a variable symbol's "ID", which is
// just the expression number that we also assign to uses of the same
// variable. These IDs are computed by the ICFG builder after having
// numbered all expressions.
// GB (2008-05-13): (Temporarily?) renamed "ID" to varnum because the
// VariableID class was introduced.
extern "C" unum o_variable_varnum(void *symbol)
{
    SgVariableSymbol *varsym = (SgVariableSymbol *) symbol;
    unsigned long id = get_global_cfg()->varsyms_ids[varsym];
    return int_to_unum(id);
}

extern "C" str o_exp_root_str(void *exp)
{
    /* WARNING: This is not clean at all, but the Value Flow Graph
     * analysis relies on the fact that the strings representing
     * operators returned by this function begin with "op " (yes,
     * including the space character; that ensures it is not a
     * variable name beginning with "op").
     * Please do not change that without due cause, thanks. */
    SgExpression *expr = isSgExpression((SgNode *) exp);
    if (expr == NULL)
        return "'not an expression'";
    else switch (expr->variantT())
    {
    case V_SgAddOp:             return "op +";
    case V_SgSubtractOp:        return "op -";
    case V_SgMultiplyOp:        return "op *";
    case V_SgDivideOp:          return "op / (floating)";
    case V_SgIntegerDivideOp:   return "op / (integer)";
    case V_SgModOp:             return "op %";
    case V_SgAndOp:             return "op &&";
    case V_SgOrOp:              return "op ||";
    case V_SgBitXorOp:          return "op ^";
    case V_SgBitAndOp:          return "op &";
    case V_SgBitOrOp:           return "op |";
    case V_SgLshiftOp:          return "op <<";
    case V_SgRshiftOp:          return "op >>";
    case V_SgMinusOp:           return "op - (unary)";
    case V_SgPointerDerefExp:   return "op * (dereference)";
    case V_SgAddressOfOp :      return "op & (address of)";
    case V_SgVarRefExp:
        {
            SgVarRefExp *v = isSgVarRefExp(expr);
            std::string name = v->get_symbol()->get_name().str();
            return Ir::getCharPtr(name);
        }
    case V_SgIntVal:
        {
            std::stringstream value;
            value << isSgIntVal((SgNode *) expr)->get_value();
            return Ir::getCharPtr(value.str());
        }
    default:
        {
            SgValueExp *ve = isSgValueExp(expr);
            if (ve != NULL)
                return expr_to_string(ve);
            std::string class_name = expr->class_name();
            return Ir::getCharPtr(class_name);
        }
    }
}

extern "C" bool o_is_operatorname(str s)
{
    return strncmp(s, "op ", 3) == 0;
}

#include <string.h>
#include "gc_mem.h"

unsigned long synttype_hash(void *x)
{
    return (unsigned long) x;
}

int syntax_eq(void *x, void *y)
{
    return (strcmp((const char *) x, (const char *) y) != 0);
}

void syntax_mcopy(void *x, void *y)
{
    strcpy((char *) y, (const char *) x);
}

void syntaxdummy(void *)
{
}

#ifdef __cplusplus
extern "C"
#endif
void syntax_init(void)
{
    bool calledBefore = false;
    if (!calledBefore)
    {
     // GB (2008-05-08): This code is required by PAG; in the manual I have,
     // it is in Section 9.4 "Additional Requirements" of Chapter 9
     // "Frontend Interface Reference".
        syntaxtype = GC_registertype(48, syntaxdummy, syntax_mcopy,
            syntax_eq, synttype_hash, 0);
        e_syntaxtype = GC_registertype(1024, syntaxdummy, syntax_mcopy,
            syntax_eq, synttype_hash, 0);
     // Don't execute this code again, even if this function should be
     // called again.
        calledBefore = true;
    }
}

#include "ast_support_funcs.h"

// GB (2007-10-31): These are not marked extern "C" because they are not
// called directly from the PAG code; PAG calls the functions with the o_
// prefixes.
SgType *typenum_to_type(unsigned long n)
{
    return get_global_cfg()->numbers_types[n];
}

unsigned long type_to_typenum(SgType *type)
{
    return get_global_cfg()->types_numbers[type];
}

std::string typenum_to_str(unsigned long n)
{
    return Ir::fragmentToString(typenum_to_type(n));
}

SgExpression *exprnum_to_expr(unsigned long n)
{
    return get_global_cfg()->numbers_exprs[n];
}

unsigned long expr_to_exprnum(SgExpression *expr)
{
    return get_global_cfg()->exprs_numbers[expr];
}

std::string exprnum_to_str(unsigned long n)
{
    return expr_to_string(exprnum_to_expr(n));
}

SgType *expr_type(SgExpression *expr)
{
    return expr->get_type();
}

unsigned long exprnum_typenum(unsigned long n)
{
    return type_to_typenum(expr_type(exprnum_to_expr(n)));
}

bool is_subtype_of(SgClassType *a, SgClassType *b)
{
    return o_is_subtype_of(a, b);
}

bool is_subtypenum_of(unsigned long a, unsigned long b)
{
    SgClassType *ta = isSgClassType(typenum_to_type(a));
    SgClassType *tb = isSgClassType(typenum_to_type(b));
    return (ta != NULL && tb != NULL && is_subtype_of(ta, tb));
}


// Two support functions that PAG suddenly started to require at some point.
int kfg_routine_is_loop (KFG cfg, KFG_ROUTINE routine)
{
    return 0;
}

int kfg_routine_is_infeasible (KFG cfg, KFG_ROUTINE routine)
{
    return 0;
}

/* Author: Markus Schordan
   E-mail: markus@complang.tuwien.ac.at
   Year  : 2006
*/

// ------------------------------------------------------------------------
// High-level functions that only pass through (for consistency in calling)
// ------------------------------------------------------------------------

tassign_x_null::str,ShapeGraph -> ShapeGraph;
tassign_x_null(x,sg) = assign_x_null(x,sg);

tassign_xsel_null::str,str,ShapeGraph -> ShapeGraph;
tassign_xsel_null(x,sel,sg) = assign_xsel_null(x,sel,sg);

// ---------------------------------------------------------------------
// High-level functions, creating temporaries for handling special cases
// ---------------------------------------------------------------------

// x = y;
tassign_x_y::str,str,ShapeGraph->ShapeGraph;
tassign_x_y(x,y,G) =
  if x = y then
    G 
  else
    let G1=assign_x_y("_$",y,G); in
    let G2=assign_x_null(x,G1); in
    //let G3=assign_x_y(x,y,G2); in  //FIXME falsch?? sollte es nicht so sein wie in folgender zeile?
    let G3=assign_x_y(x,"_$",G2); in
      assign_x_null("_$",G3)
  endif 
;  

// x.sel = y;
tassign_xsel_y::str,str,str,ShapeGraph->ShapeGraph;
tassign_xsel_y(x,selp,y,G) =
  let G1=assign_x_y("_$",y,G); in
  let G2=assign_xsel_null(x,selp,G1); in
  let G3=assign_xsel_y(x,selp,"_$",G2); in
    assign_x_null("_$",G3);

// x = y.sel;
tassign_x_ysel::str,str,str,ShapeGraph -> ShapeGraph;
tassign_x_ysel(x,y,selp,G) =
  let G1=assign_x_ysel("_$",y,selp,G); in
  let G2=assign_x_null(x,G1); in
  let G3=assign_x_y(x,"_$",G2); in
    assign_x_null("_$",G3);

// x = new;
tassign_x_new::str,ShapeGraph->ShapeGraph;
tassign_x_new(x,G) =
    let G1=assign_x_null(x,G); in
      assign_x_new(x,G1);

// x.sel = new;
tassign_xsel_new::str,str,ShapeGraph->ShapeGraph;
tassign_xsel_new(x,selp,G) =
    let G1=assign_xsel_null(x,selp,G); in
    let G2=assign_x_new("_$",G1); in
    let G3=assign_xsel_y(x,selp,"_$",G2); in
      assign_x_null("_$",G3);

// ----------------------------------------------------------------------
// Low-level functions, without temporaries (do not handle special cases)
// ----------------------------------------------------------------------

// x = null;
assign_x_null::str,ShapeGraph -> ShapeGraph;
assign_x_null(x,((Ev0,Es0),is0)) =
  let Ev1={(y,rem(x,W))!!(y,W) <-- Ev0, if !(y=x)};
    Es1={(rem(x,V),sel0,rem(x,W))!!(V,sel0,W) <-- Es0};
    is1={rem(x,n) !! n <-- is0}; in
  ((Ev1,Es1),is1);

// x.sel = null;
assign_xsel_null::str,str,ShapeGraph -> ShapeGraph;
assign_xsel_null(x,selp,((Ev0,Es0),is0)) =
         let Es1 = edgesetminus(Es0,{(X0,sel0,ANY0) !! (X0,sel0,ANY0) <-- Es0, if x ? X0 && sel0=selp});
         in
           let is1 = nodesetminus(is0,{n !! n <-- is0, if (!iis(Es1,n)) && no_outedge_exists(Es1,n)});
           in ((Ev0,Es1),is1);

// an outedge is an edge starting at the summary node '{}' and ending in 'n'
// we check this for a given set of edges 'Es'
no_outedge_exists::HeapEdgeSet,VarSet -> bool;
no_outedge_exists(Es,n)=
  {"1" !! (X0,sel0,Y0) <-- Es, if X0={} && Y0=n} = {}; // the set of found outedges must be empty

// x = new
assign_x_new::str,ShapeGraph->ShapeGraph;
assign_x_new(x,((Ev0,Es0),is0)) =
  ((union(Ev0,{(x,{x})}),Es0),is0);

// x = y;
assign_x_y::str,str,ShapeGraph -> ShapeGraph;
assign_x_y(x,y,((Ev0,Es0),is0)) =
  let Ev1=union({(za,msgc(x,y,Z))!!(za,Z) <-- Ev0},
              {(x,msgc(x,y,Z))!!(y1,Z) <-- Ev0, if y1=y});
    Es1={(msgc(x,y,Z1),sel0,msgc(x,y,Z2))!!(Z1,sel0,Z2) <-- Es0};
    is1={msgc(x,y,Z)!!Z <-- is0}; in
    ((Ev1,Es1),is1);

// x.sel = y;
assign_xsel_y::str,str,str,ShapeGraph -> ShapeGraph;
assign_xsel_y(x,selp,y,((Ev0,Es0),is0)) =
  let Es1 = union(Es0,{(X0,selp,Y0) !! (xa,X0) <-- Ev0, (ya,Y0) <-- Ev0,
                                       if xa=x && ya=y && compatible2(X0,Y0)}
                 ); in
  let is1 = union(is0,{n !! (ya,n) <-- Ev0, if ya=y && iis(Es1,n)}); in 
    ((Ev0,Es1),is1);
  
// x = y.sel;
assign_x_ysel::str,str,str,ShapeGraph -> ShapeGraph;
assign_x_ysel(x,y,selp,((Ev0,Es0),is0)) = 
  let G=((Ev0,Es0),is0); in
    let Ev1 = union(Ev0,union(
        {(x,h(x,Z))!!(ya,Y0) <-- Ev0, (Y1,sel0,Z) <-- Es0,
                 if ya=y && Y0=Y1 && selp=sel0},
        {(za,h(x,Z))!!(ya,Y0) <-- Ev0, (Y1,sel0,Z1) <-- Es0, (za,Z) <-- Ev0,
                 if y=ya && Y0=Y1 && selp=sel0 && Z1=Z}));

       temp = {aux_as(x,y,Y0,selp,Z,G) !! (ya,Y0) <-- Ev0, (Y2,sel0,Z) <-- Es0, 
                                    if y=ya && Y0=Y2 && selp=sel0};
       in      
       let Es1 = union(
                   (edgesetminus(Es0,{(Y0,sel0,Z)!!(Y0,sel0,Z) <-- Es0, if (y ? Y0) && sel0=selp})),
	           ssunion(temp));
       in //let is1 = {s !! s <-- NEs(Es1), if rem(x,s) ? is0}; // TODO?
       
       let is1 = new_is(is0,x);

       in ((Ev1,Es1),is1);

// ----------------------------------------------
// Auxiliary functions for extracting information
// ----------------------------------------------

N::StackEdgeSet,HeapEdgeSet -> NodeSet;
N(Ev,Es) = union({n!!(x,n)<--Ev},NEs(Es));

NEs::HeapEdgeSet -> NodeSet;
NEs(Es) = union({s!!(s,a,e)<--Es},{e!!(s,a,e)<--Es});

edgesetminus::HeapEdgeSet,HeapEdgeSet -> HeapEdgeSet;
edgesetminus(S1,S2) = {x!!x<--S1, if !(x ? S2)};

stackedgesetminus::StackEdgeSet,StackEdgeSet -> StackEdgeSet;
stackedgesetminus(S1,S2) = {x!!x<--S1, if !(x ? S2)};

nodesetminus::NodeSet,NodeSet -> NodeSet;
nodesetminus(S1,S2) = {x!!x<--S1, if !(x ? S2)};

ssunion::HeapEdgeSetSet -> HeapEdgeSet;
ssunion(ss) = { e !! s <-- ss, e <-- s };

// ----------------------------------------------------
// Auxiliary functions for low-level transfer functions
// ----------------------------------------------------

semeq::VarSet,VarSet -> bool;
semeq(X,Y) =
  X=Y;  

semneq::VarSet,VarSet -> bool;
semneq(X,Y) = 
  (!(X = Y)) || (X={} && Y={});

compatible3::VarSet,VarSet,VarSet -> bool;
compatible3(X,Y,Z) =
     (X=Y || intersect(X,Y)={}) 
  && (X=Z || intersect(X,Z)={})
  && (Y=Z || intersect(Y,Z)={});

compatible2::VarSet,VarSet -> bool;
compatible2(X,Y) = 
  X=Y || intersect(X,Y)={};

rem::str,VarSet -> VarSet;
rem(x,Z) = 
  { v !! v <-- Z, if !(x=v) }; // Z-{x};

//del::VarSet,str -> VarSet;
//del(t,x) = t # x;

h::str,VarSet -> VarSet;
h(x,Z) = union(Z,{x});

msgc::str,str,VarSet -> VarSet;
msgc(x,y,Z) =
 if y ? Z then union(Z,{x})
 else Z
 endif;

iis::HeapEdgeSet,VarSet -> bool;
iis(Es,Z) =
  let exist = { "1" !! (Z1,sel1,Z31) <-- Es, (Z2,sel2,Z32) <-- Es,
                if Z31=Z && Z32=Z && compatible3(Z1,Z2,Z) 
                   &&( semneq(Z1,Z2) || !(sel1=sel2))}; in
      !(exist = {});
           

compat_in::StackEdge,HeapEdge,HeapEdge,ShapeGraph -> bool;
compat_in((_,Y),(Y2,sel0,Z),(W,sel1,Z3),((Ev0,Es0),is0)) =
    Y=Y2 && Z=Z3
    && compatible3(Y,Z,W)
    && semneq(Z,W)
    && ((semeq(Y,W) && sel0=sel1) || (Z ? is0));

compat_out::StackEdge,HeapEdge,HeapEdge,ShapeGraph -> bool;
compat_out((_,Y),(Y2,sel0,Z),(W,sel1,Z3),((Ev0,Es0),is0)) =
    Y=Y2 && Z=Z3
    && compatible3(Y,Z,W) 
    && semneq(Z,W)
    && (semneq(Y,Z) || !(sel0=sel1));

compat_self::StackEdge,HeapEdge,HeapEdge,ShapeGraph -> bool;
compat_self((_,Y),(Y2,sel0,Z),(Z31,sel1,Z32),((Ev0,Es0),is0)) =
    Y=Y2 && Z=Z31 && Z=Z32 && Z31=Z32
      && compatible2(Y,Z)
      && ((semeq(Y,Z) && sel0=sel1) || (Z ? is0));

aux_as::str,str,VarSet,str,VarSet,ShapeGraph -> HeapEdgeSet;
aux_as(x,yp,Y,selp,Z,((Ev0,Es0),is0)) =
 let newin = {(W,sel1,h(x,Z)) !! (W,sel1,Z3) <-- Es0,
         if Z=Z3
         && compat_in((yp,Y),(Y,selp,Z),(W,sel1,Z),((Ev0,Es0),is0))};
    newself = {(h(x,Z),sel1,h(x,Z)) !! (Z31,sel1,Z32) <-- Es0,
        if Z=Z31 && Z=Z32
         && compat_self((yp,Y),(Y,selp,Z),(Z,sel1,Z),((Ev0,Es0),is0))};
    newout = {(h(x,Z),sel1,W) !! (Z3,sel1,W) <-- Es0,
        if Z=Z3
         && compat_out((yp,Y),(Y,selp,Z),(Z,sel1,W),((Ev0,Es0),is0))};
    in
    union(union(newin,newself),newout);

new_is(rest,x) = { ha # x !! ha <-- rest }; // should become obsolete (TODO?)

mybot::->dfi; 
mybot() = bot;



/* Author: Viktor Pavlu
   E-mail: e0425543@student.tuwien.ac.at
   Year  : 2006
*/

/* decomposes arbitrarily nested expressions into primitive
 * forms by introducing temporary variables.
 * a list of opcodes is returned that specifies which transfer
 * functions need to be called. by doing so, the normalisation
 * functions do not need to modify the shape graph, hence 
 * they do not need to be adapted to different carrier types.
 *
 * an opcode looks like this: ("x_ysel", ["arg1", "arg2", ...])
 * interpretation of the opcodes is done by the function
 * execute :: OpCodeList,<carrier> -> <carrier>;
 */
 
// -------------------------------------
// functions for temp normalisation vars
// -------------------------------------

is_normalisation_temp :: str -> bool;
is_normalisation_temp(s) = substr(s, 0, 5) = "#norm_";

gen_normalisation_temp :: str -> str;
gen_normalisation_temp(label) = "#norm_".label."_";

kill_normalisation_temps :: OpCodeList,dfi -> dfi;
kill_normalisation_temps(list,sg) = kill_normalisation_temps1([x !! x <-- extract_tempvars(list,{})], sg);

kill_normalisation_temps1 :: StrList,dfi -> dfi;
kill_normalisation_temps1(     [], s) = s;
kill_normalisation_temps1(car:cdr, s) = delete_var(kill_normalisation_temps1(cdr,s),car);

extract_tempvars :: OpCodeList,VarSet -> VarSet;
extract_tempvars(     [], temps) = temps;
extract_tempvars((_,v:_):cdr, temps) = 
    let new_temps = if is_normalisation_temp(v) then {v} else {} endif; in
    extract_tempvars(cdr, union(temps,new_temps));

// -----------------------------
// expression accessor functions
// -----------------------------

min :: snum,snum -> snum;
min(a,b) = if a < b then a else b endif;

max :: snum,snum -> snum;
max(a,b) = if a > b then a else b endif;

expr_depth :: Expression -> snum;
expr_depth(e) = case e of
    ArrowExp(VarRefExp(_),VarRefExp(_)) => 0;
    ArrowExp(child,_)                   => 1 + expr_depth(child);
    DotExp(PointerDerefExp(child),_)    => 1 + expr_depth(child);
    _                                   => 0;
endcase;

expr_is_complex :: Expression -> bool;
expr_is_complex(e) = case e of
    DotExp(PointerDerefExp(child),_) => true;
    ArrowExp(child,_)                => true;
    _                                => false;
endcase;

// returns the expression at the given depth, where
// 0 is the topmost expression that contains the others, and
// expr_depth is the innermost expression
expr_at :: Expression,snum -> Expression;
expr_at(e,nesting_level) =
    let
        descending_steps = min(nesting_level, expr_depth(e));
    in
        rec_expr_at(e, descending_steps);

rec_expr_at :: Expression,snum -> Expression;
rec_expr_at(e,0) = e;
rec_expr_at(DotExp(PointerDerefExp(child),_),descending_steps) = rec_expr_at(child, descending_steps - 1);
rec_expr_at(ArrowExp(child,_),descending_steps) = rec_expr_at(child, descending_steps - 1);

expr_innermost :: Expression -> Expression;
expr_innermost(e) = expr_at(e, expr_depth(e));

// -----------------------------------------------------------
// normalisation function, generates the normalisation opcodes
// -----------------------------------------------------------

normalisation_ops :: Expression,str -> OpCodeList;
normalisation_ops(e,label) =
    case e of AssignOp(lhs,rhs) =>
        let     tmp = gen_normalisation_temp(label); in
        let lhs_tmp = tmp."l";
            rhs_tmp = tmp."r";
        in
            rec_normalise(lhs,expr_depth(lhs),lhs_tmp,[]) ++
            rec_normalise(rhs,expr_depth(rhs),rhs_tmp,[]) ++
            perform_assign(e,lhs_tmp,rhs_tmp,[]);
        _ => [];
    endcase;

rec_normalise :: Expression,snum,str,OpCodeList -> OpCodeList;
rec_normalise(  _,          0,             _, list) = list;
rec_normalise(lhs, lhs_cursor, tmpvar_prefix, list) =
    let new_var  = tmpvar_prefix . str(lhs_cursor - 1); in
    let new_list = case expr_at(lhs,lhs_cursor) of
    
        // <new_var> = <parent_var>.sel
        DotExp(PointerDerefExp(_),VarRefExp(na_sel)) =>
            [("x_ysel", [new_var, tmpvar_prefix.str(lhs_cursor), val-aststring(na_sel)])];
              
        // <new_var> = x.sel
        ArrowExp(VarRefExp(na_x),VarRefExp(na_sel)) =>
            [("x_ysel", [new_var,val-aststring(na_x),val-aststring(na_sel)])];

        // <new_var> = x
        VarRefExp(na_x) =>
            [("x_y", [new_var,val-aststring(na_x)])];
            
        _ => [];
        
    endcase; in
    rec_normalise(lhs, lhs_cursor - 1, tmpvar_prefix, list ++ new_list);


perform_assign :: Expression,str,str,OpCodeList -> OpCodeList;
perform_assign(e,lhs_tmp,rhs_tmp,list) =
    case e of
        // x = new;
        AssignOp(VarRefExp(na_x),NewExp(_,_,_)) =>
            [("x_new", [val-aststring(na_x)])];

        // x = null;
        AssignOp(VarRefExp(na_x),CastExp(IntVal(n),_)) =>  
            [("x_null", [val-aststring(na_x)])];
            
        // x = y;
        AssignOp(VarRefExp(na_x),VarRefExp(na_y)) => 
            [("x_y", [val-aststring(na_x),val-aststring(na_y)])];

        // x.sel = null;
        AssignOp(ArrowExp(VarRefExp(na_x),VarRefExp(na_sel)),CastExp(IntVal(n),_)) => 
            [("xsel_null", [val-aststring(na_x),val-aststring(na_sel)])];

        // ...sel = null;  NEW
        AssignOp(DotExp(PointerDerefExp(_),VarRefExp(na_sel)),CastExp(IntVal(n),_)) => 
            [("xsel_null", [lhs_tmp."0", val-aststring(na_sel)])];

        // x.sel = y;
        AssignOp(ArrowExp(VarRefExp(na_x),VarRefExp(na_sel)),VarRefExp(na_y)) =>
            [("xsel_null", [val-aststring(na_x), val-aststring(na_sel), "DEBUG"]),
             ("xsel_y",    [val-aststring(na_x), val-aststring(na_sel), val-aststring(na_y)])];

        // ...sel = y; NEW
        AssignOp(DotExp(PointerDerefExp(_),VarRefExp(na_sel)),VarRefExp(na_y)) =>
            [("xsel_null", [lhs_tmp."0", val-aststring(na_sel)]),
             ("xsel_y",    [lhs_tmp."0", val-aststring(na_sel), val-aststring(na_y)])];

        // x = y.sel;
        AssignOp(VarRefExp(na_x),ArrowExp(VarRefExp(na_y),VarRefExp(na_sel))) => 
            [("x_ysel", [val-aststring(na_x), val-aststring(na_y), val-aststring(na_sel)])];

        // x = ...sel; NEW
        AssignOp(VarRefExp(na_x),DotExp(PointerDerefExp(_),VarRefExp(na_sel))) => 
            [("x_ysel", [val-aststring(na_x), rhs_tmp."0", val-aststring(na_sel)])];

        // x.sel = y.sel; NEW
        AssignOp(ArrowExp(VarRefExp(na_x),VarRefExp(na_xsel)),ArrowExp(VarRefExp(na_y),VarRefExp(na_ysel))) =>
            [("x_ysel", [rhs_tmp."a", val-aststring(na_y), val-aststring(na_ysel)]),
             ("xsel_y", [val-aststring(na_x), val-aststring(na_xsel), rhs_tmp."a"])];
            
        // ...sel = y.sel; NEW
        AssignOp(DotExp(PointerDerefExp(_),VarRefExp(na_xsel)),ArrowExp(VarRefExp(na_y),VarRefExp(na_ysel))) =>
            [("x_ysel", [rhs_tmp."a", val-aststring(na_y), val-aststring(na_ysel)]),
             ("xsel_y", [lhs_tmp."0", val-aststring(na_xsel), rhs_tmp."a"])];

        // x.sel = ...sel; NEW
        AssignOp(ArrowExp(VarRefExp(na_x),VarRefExp(na_xsel)),DotExp(PointerDerefExp(_),VarRefExp(na_ysel))) =>
            [("x_ysel", [rhs_tmp."a", rhs_tmp."0", val-aststring(na_ysel)]),
             ("xsel_y", [val-aststring(na_x), val-aststring(na_xsel), rhs_tmp."a"])];
            
        // ...sel = ...sel; NEW
        AssignOp(DotExp(PointerDerefExp(_),VarRefExp(na_xsel)),DotExp(PointerDerefExp(_),VarRefExp(na_ysel))) =>
            [("x_ysel", [rhs_tmp."a", rhs_tmp."0", val-aststring(na_ysel)]),
             ("xsel_y", [lhs_tmp."0", val-aststring(na_xsel), rhs_tmp."a"])];

        _ => list;
    endcase;


// Author: Viktor Pavlu
// E-mail: e0425543@student.tuwien.ac.at
// Year  : 2006, 2007, 2008

UNIVERSAL
option_kill_normalisation_temps : bool#
option_kill_empty_graph         : bool#
option_kill_unreachable_nodes   : bool#

GLOBAL
globals     : *VariableSymbolNT#

BLOCK
label       : snum#

PROBLEM nnh99
  direction : forward
  carrier   : dfi
  init      : bot
  init_start: lift({(({},{}),{})})
  combine   : comb
  retfunc   : comb
  widening  : wide
  equal     : eq

TRANSFER
#include "../common_transfer.optla"

SUPPORT
comb::dfi,dfi->dfi;
comb(a,bot) = a;
comb(a,top) = top;
comb(bot,b) = b;
comb(top,b) = top;
comb(  a,b) = lift(union(drop(a),drop(b)));

wide::dfi,dfi->dfi;
wide(a,b) = b;

eq(a,b) = a=b;

tassign_x_null::VariableId,ShapeGraphSet->ShapeGraphSet;
tassign_xsel_null::VariableId,VariableId,ShapeGraphSet->ShapeGraphSet;
tassign_x_new::VariableId,ShapeGraphSet->ShapeGraphSet;
tassign_xsel_new::VariableId,VariableId,ShapeGraphSet->ShapeGraphSet;
tassign_x_y::VariableId,VariableId,ShapeGraphSet->ShapeGraphSet;
tassign_x_ysel::VariableId,VariableId,VariableId,ShapeGraphSet->ShapeGraphSet;
tassign_xsel_y::VariableId,VariableId,VariableId,ShapeGraphSet->ShapeGraphSet;
#include "../common_highlevel.optla"
#include "../common_support.optla"
#include "../common_normalisation.optla"

//remove_empty_graph::ShapeGraphSet->ShapeGraphSet;
//remove_empty_graph(g) = if g = {(({},{}),{})} then {(({},{}),{})} else if option_kill_empty_graph then g # (({},{}),{}) else g endif endif;

// print_graphs::str,ShapeGraphSet->bool;
// print_graphs(label,{}) = print(label) print("{}\n") false;
// print_graphs(label,gs) = {print_graph(label,g) !! g <-- gs} != {};
// print_graph::str,ShapeGraph->bool;
// print_graph(label,g) = print(label) print(g) print("\n") true;

shape_carrier_to_shapegraphset::dfi->ShapeGraphSet;
shape_carrier_to_shapegraphset(lifted_sg) = drop(lifted_sg);

// ----------------------------------------
// Analysis Entry Point: Transfer Functions
// ----------------------------------------

assign_x_null::VariableId,ShapeGraphSet->ShapeGraphSet;
assign_x_null(x,g0) = sgs_flatten([fassign_x_null(x,g) !! g <-- g0]);

assign_x_new::VariableId,ShapeGraphSet->ShapeGraphSet;
assign_x_new(x,g0) = sgs_flatten([fassign_x_new(x,g) !! g <-- g0]);

assign_xsel_null::VariableId,VariableId,ShapeGraphSet->ShapeGraphSet;
assign_xsel_null(x,sel,g0) = sgs_flatten([fassign_xsel_null(x,sel,g) !! g <-- g0]);

assign_x_y::VariableId,VariableId,ShapeGraphSet->ShapeGraphSet;
assign_x_y(x,y,g0) = sgs_flatten([fassign_x_y(x,y,g) !! g <-- g0]);
  
assign_x_ysel::VariableId,VariableId,VariableId,ShapeGraphSet->ShapeGraphSet;
assign_x_ysel(x,y,selp,g0) = sgs_flatten([fassign_x_ysel(x,y,selp,g) !! g <-- g0]);

assign_xsel_y::VariableId,VariableId,VariableId,ShapeGraphSet->ShapeGraphSet;
assign_xsel_y(x,selp,y,g0) = sgs_flatten([fassign_xsel_y(x,selp,y,g) !! g <-- g0]);




sgs_flatten::ShapeGraphSetList->ShapeGraphSet;
sgs_flatten([]) = {};
sgs_flatten(car:cdr) = union(car,sgs_flatten(cdr));

fassign_x_null::VariableId,ShapeGraph->ShapeGraphSet;
fassign_x_null(x,g) =
  {kill_x(x,g)};

fassign_xsel_null::VariableId,VariableId,ShapeGraph->ShapeGraphSet;
fassign_xsel_null(x,s,((S0,H0),is0) as g) =
  if !var_exists(x,g) || !var_sel_exists(x,s,g) then
    {g}
  else
    // edge (nx,sel,nu) is guaranteed to be in H0 and must be removed
    let edge = heapedge_by_var_sel(x,s,H0); in
    case edge of
      (nx,sel,nu) =>
        let S1 = S0;
            H1 = {e !! (nv,sel1,nw) as e <-- H0, if !(nx=nv && sel=sel1)}; in
        /* if
         *  - nu was shared and
         *  - there is no ({},_,nu) edge and
         *  - there is no more than one (_,_,nu) edge then
         * nu is no longer shared.
         * otherweise is0 remains unchanged
         */
        let is1 = if (nu ? is0)
            && !many_into(nu,H1)
            && {} = {e     !! (nk,_,nl) as e <-- H1, if (nk={}) && (nl=nu)} then
          is0 # nu
        else
          is0
        endif; in
        {((S1,H1),is1)};
    endcase
  endif;

fassign_x_new::VariableId,ShapeGraph->ShapeGraphSet;
fassign_x_new(x,((S0,H0),is0) as g) =
  {((union(S0,{(x,{x})}),H0),is0)};

fassign_x_y::VariableId,VariableId,ShapeGraph->ShapeGraphSet;
fassign_x_y(x,y,((S0,H0),is0) as g) = 
  let S1  = union(
            {(z,gxy(x,y,nz)) !! (z,nz) <-- S0},                      // add x to all edges where y is already
            {(x,gxy(x,y,ny)) !! (y1,ny) <-- S0, if (y1 = y)});       // add a new edge (x,{x,y,...}) to where y pointed to
      H1  = {(gxy(x,y,nv),sel,gxy(x,y,nw)) !! (nv,sel,nw) <-- H0}; // add x to all edges where y is already
      is1 = {gxy(x,y,nz) !! nz <-- is0}; in
  {((S1,H1),is1)};

fassign_xsel_y::VariableId,VariableId,VariableId,ShapeGraph->ShapeGraphSet;
fassign_xsel_y(x,sel,y,((S0,H0),is0) as g) = 
  if !var_exists(x,g) || !var_exists(y,g) then
    {g}
  else
    let nx = node_by_var(x,g);
        ny = node_by_var(y,g); in
    let H1  = union(H0, {(nx,sel,ny)}); in
    let is1 = if many_into(ny,H1) then union(is0,{ny}) else is0 endif; in
    {((S0,H1),is1)}
  endif;

fassign_x_ysel::VariableId,VariableId,VariableId,ShapeGraph->ShapeGraphSet;
fassign_x_ysel(x,y,sel,((S0,H0),is0) as g) = // it is guaranteed that x!=y
  /* three possibilities:
   * - there is no (_,{y,...}) <- S or no ({y,...},sel,_) <- H
   * - there is (_,{y,...}) <- S and ({y,...},sel,dest) <- H where dest != {}
   * - there is (_,{y,...}) <- S and ({y,...},sel,{}) <- H
   */
  if !var_exists(y,g) then
    // case 1: null dereferencing
    error("tried dereferencing of non-existent variable")
  else if !var_sel_exists(y,sel,g) then
    // case 1: non-existing selector
    error("tried dereferencing of null pointer (non-existent selector)")
  else
    case heapedge_by_var_sel(y,sel,H0) of
      (ny,_,{}) =>  // case 3
         materialise(x,y,sel,g);

      (ny,_,nu) => // case 2
        // rename the location nu to include {x} and add the binding (x,union(nu,{x}))
        let S1  = union({(z,hxu(x,nu,nz)) !! (z,nz) <-- S0}, {(x,hxu(x,nu,nu))});
            H1  = {(hxu(x,nu,nv),sel1,hxu(x,nu,nw)) !! (nv,sel1,nw) <-- H0};
            is1 = {hxu(x,nu,nz) !! nz <-- is0}; in
            {((S1,H1),is1)};
    endcase
  endif
  endif;

materialise::VariableId,VariableId,VariableId,ShapeGraph->ShapeGraphSet;
materialise(x,y,sel,((S0,H0),is0) as g) = 
  let S1         = union(S0,{(x,{x})});
      Hextern    = {e !! (v1,sel1,w1) as e <-- H0, if v1 != {} && w1 != {}}; in
  let Hintern    = [e !! e <-- heapedge_subtract(H0,Hextern)]; in
  let candidates = if {} ? is0 then
    // if {} is shared, generate candidates for 3 cases
    // after the materialisation:
    //   - {} remains shared, new {x} is unshared
    //   - {} remains shared, new {x} is shared
    //   - {} loses sharing,  new {x} is shared
    // note that the sharing can not go away, as there
    // is no case where both {} and {x} are unshared
    // after materialisation if {} was shared before
    sgs_flatten([gen_cand({x},S1,Hextern,Hintern,union(is0 # {},is_shared)) !! is_shared <-- { {{}}, {{x}}, {{x},{}} } ])
  else
    // if {} is unshared, both {} and {x} must also
    // be unshared after the materialisation
    gen_cand({x},S1,Hextern,Hintern,is0)
  endif; in 
  {sg !! ((S2,H2),is2) as sg <-- candidates,
    if is_compatible(sg)
    && kill_x(x,sg) = ((S0,H0),is0)
    && (x,{x}) ? S2
    && var_exists(y,sg)
    && var_exists(x,sg)
    && (node_by_var(y,sg),sel,node_by_var(x,sg)) ? H2};

gen_cand::Node,StackEdgeSet,HeapEdgeSet,HeapEdgeList,NodeSet->ShapeGraphSet;
gen_cand(x,S,H,(_,sel,_) as edge:cdr,is0) =
  let Hn = case edge of
    ({},_,{}) => 
      if x ? is0 then {
        {({},sel,{})},
        {({},sel, x)},
        {( x,sel,{})},
        {( x,sel, x)},

        {({},sel,{}),({},sel, x)},
        {({},sel,{}),( x,sel,{})},
        {({},sel,{}),( x,sel, x)},
        {({},sel, x),( x,sel,{})},
        {({},sel, x),( x,sel, x)},
        {( x,sel,{}),( x,sel, x)},
        
        {({},sel,{}),({},sel, x),(x,sel,{})},
        {({},sel,{}),({},sel, x),(x,sel, x)},
        {({},sel,{}),( x,sel,{}),(x,sel, x)},
        
        {({},sel,{}),({},sel,x),(x,sel,{}),(x,sel,x)}
      } else {
        {({},sel,{})},
        {( x,sel,{})},

        {({},sel,{}),(x,sel,{})}
      } endif;
      
    ({},_,y) =>
      if y ? is0 then {
        {({},sel,y)},
        {( x,sel,y)},
        {({},sel,y),(x,sel,y)}
      } else {
        {({},sel,y)},
        {( x,sel,y)}
      } endif;

    (y,_,{}) => {
        {(y,sel,{})},
        {(y,sel,x)}
      };
  endcase; in
  sgs_flatten([gen_cand(x,S,union(H,new_edge),cdr,is0) !! new_edge <-- Hn]);
gen_cand(_,S,H,[],is0) = {((S,H),is0)};

// -------------------
// auxiliary functions
// -------------------

is_compatible::ShapeGraph->bool;
is_compatible(((S0,H0),is0) as g) =
  let alocs = union(union(aloc_S([x !! x <-- S0],{}), aloc_H([x !! x <-- H0],{})), is0); in
  check_inv1([(a,b) !! a <-- alocs, b <-- alocs])
  // Inv2: if x points to a node, the nodes name must contain x (naming convention)
  && {(x,nx) !! (x,nx) <-- S0, if x ? nx} = S0
  && check_inv3([((nv,sel,nw),(nv1,sel1,nw1)) !! (nv,sel,nw) <-- H0, (nv1,sel1,nw1) <-- H0, if nv = nv1 && sel = sel1 && nv != {}])
  && check_inv4([x !! x <-- is0],H0)
  && check_inv5([nx1 !! (nv1,sel1,nx1) <-- H0, (nv2,sel2,nx2) <-- H0, if nx1 = nx2 && (sel1 != sel2 || nv1 != nv2) && nx1 != {}],is0);
    
aloc_S::StackEdgeList,NodeSet->NodeSet;
aloc_S((_,v):cdr,nodes) = aloc_S(cdr, union(nodes,{v}));
aloc_S(       [],nodes) = nodes;

aloc_H::HeapEdgeList,NodeSet->NodeSet;
aloc_H((v,_,v1):cdr,nodes) = aloc_H(cdr, union(nodes, {v,v1}));
aloc_H(          [],nodes) = nodes;

// Inv1: two nodes a,b are either the same or have no common variables */
check_inv1::NodeTupleList->bool;
check_inv1((a,b):cdr) = if (a = b) || (intersect(a,b) = {}) then check_inv1(cdr) else false endif;
check_inv1(       []) = true;

// Inv3: nv,sel,nw  and  nv,sel,nw1: either nw and nw1 are the same node or nv 
// is the summary node. no node,sel pair may point to more than one node
// except the source is the summary node
check_inv3::HeapEdgeTupleList->bool;
check_inv3(((nv,sel,nw),(nv1,sel1,nw1)):cdr) = if (nw = nw1) then check_inv3(cdr) else false endif;
check_inv3(         []) = true;

// Inv4: if nx is shared, there exists either {},sel,nx or 2+ edges pointing to nx */
check_inv4::NodeList, HeapEdgeSet->bool;
check_inv4(nx:cdr, H) = 
  if ({e !! (n1,_,m1) as e <-- H, if n1 = {} && m1 = nx} != {})
  || ({e !! (n2,sel2,m2) as e <-- H, (n3,sel3,m3) <-- H, if (m2 = m3) && ((sel2 != sel3) || (n2 != n3))} != {}) then
    check_inv4(cdr,H)
  else
    false
  endif;
check_inv4(     [],_) = true;

// Inv5: if nv,sel,nx and nv1,sel1,nx are in the shapegraph, then nx is shared */
check_inv5::NodeList,NodeSet->bool;
check_inv5(nx:cdr, shared) = if nx ? shared then check_inv5(cdr,shared) else false endif;
check_inv5(    [],      _) = true;

kill_x::VariableId,ShapeGraph->ShapeGraph;
kill_x(x,((S0,H0),is0)) =
  let S1  = {(z,rem(x,nz)) !! (z,nz) <-- S0, if !(z=x)}; 
      H1  = {(rem(x,nv),sel,rem(x,nw)) !! (nv,sel,nw) <-- H0};
      is1 = {rem(x,nx) !! nx <-- is0}; in
  ((S1,H1),is1);

// remove x from Z  (called kx in Nnh)
rem::VariableId,Node->Node;
rem(x,Z) = Z # x;
//rem(x,Z) = {v !! v <-- Z, if !(x=v) };

// add x to Z if y is already there
gxy::VariableId,VariableId,Node->Node;
gxy(x,y,Z) = if (y ? Z) then union(Z,{x}) else Z endif;

// add x to U if U = Z
hxu::VariableId,Node,Node->Node;
hxu(x,U,Z) = if (Z = U) then union(U,{x}) else Z endif;

many_into::Node,HeapEdgeSet->bool;
many_into(nu,edges) =
  !({} = {true !! (p1,s1,q1) <-- edges, (p2,s2,q2) <-- edges,
                  if ((q1 = nu)
                  && (q2 = nu)
                  && !(p1=p2 && s1=s2))});
                              
// vim: ts=2 sts=2 sw=2 expandtab:

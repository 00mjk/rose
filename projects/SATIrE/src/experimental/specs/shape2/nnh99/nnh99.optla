// Author: Viktor Pavlu
// E-mail: e0425543@student.tuwien.ac.at
// Year  : 2006, 2007, 2008

UNIVERSAL
option_kill_normalisation_temps : bool#
option_kill_empty_graph         : bool#
option_kill_unreachable_nodes   : bool#

GLOBAL
globals   : *VariableSymbolNT#

BLOCK
label: snum#

PROBLEM nnh
  direction : forward
  carrier   : dfi
  init      : bot
  init_start: lift({(({},{}),{})})
  combine   : comb
  retfunc   : comb
  widening  : wide
  equal     : eq

TRANSFER

// assignments
ExprStatement(AssignOp(lhs,rhs) as e),_:
  assign(lhs,rhs,@);

// scope
DeclareStmt(VariableSymbol(var) as varsym,type),_: @;
UndeclareStmt(local_vars),_:
  delete_vars(@, local_vars);

// before call, $arg = expr
ArgumentAssignment(lhs,rhs),_:
  assign(lhs,rhs,@);

FunctionCall(fn,vars),local_edge: bot;
FunctionCall(fn,vars),call_edge: @;
FunctionReturn(funcname,local_vars), _: delete_vars(@, local_vars);

FunctionEntry(funcname),_: @;
FunctionExit(funcname,local_vars), return_edge: delete_vars(@, local_vars);

// in function, localvar = $arg
ParamAssignment(VariableSymbol(_) as sym_var,VariableSymbol(_) as sym_tmp),_:
  let var = varsym_varid(sym_var);
      tmp = varsym_varid(sym_tmp); in
  delete_var(lift(tassign_x_y(var,tmp,drop(@))),tmp);

// after return, $retvar_i = $retvar
ReturnAssignment(VariableSymbol(_) as sym_ret,VariableSymbol(_) as sym_tmp),_:
  let ret = varsym_varid(sym_ret);
      tmp = varsym_varid(sym_tmp); in
  delete_var(lift(tassign_x_y(ret,tmp,drop(@))),tmp);

_,_: @;

SUPPORT

eq(a,b) = a=b;

wide::dfi,dfi->dfi;
wide(a,b) = b;

comb::dfi,dfi->dfi;
comb(a,bot) = a;
comb(a,top) = top;
comb(bot,b) = b;
comb(top,b) = top;
comb(  a,b) = case drop(a),drop(b) of aa,bb => lift(remove_empty_graph(union(aa,bb))); endcase;

remove_empty_graph::ShapeGraphSet->ShapeGraphSet;
remove_empty_graph(g) = if g = {(({},{}),{})} then {(({},{}),{})} else if option_kill_empty_graph then g # (({},{}),{}) else g endif endif;

delete_vars::dfi,*VariableSymbolNT->dfi;
delete_vars(g,[!]) = g;
delete_vars(g,VariableSymbol(_) as v::vs) = delete_vars(delete_var(g,varsym_varid(v)), vs);

delete_var::dfi,VariableId->dfi;
delete_var(top,_) = top;
delete_var(bot,_) = bot;
delete_var(  g,v) = lift(tassign_x_null(v,drop(g)));

print_graphs::str,ShapeGraphSet->bool;
print_graphs(label,{}) = print(label) print("{}\n") false;
print_graphs(label,gs) = {print_graph(label,g) !! g <-- gs} != {};

print_graph::str,ShapeGraph->bool;
print_graph(label,g) = print(label) print(g) print("\n") true;

// Predefined SATIrE Support Functions
expr_type::Expression->Type;
expr_exprid::Expression->ExpressionId;
exprid_expr::ExpressionId->Expression;
exprid_str::ExpressionId->str;

varsym_varid::VariableSymbolNT->VariableId;
varref_varid::Expression->VariableId;
varid_exprid::VariableId->ExpressionId;
varid_str::VariableId->str;

exprid_typeid::ExpressionId->TypeId;
type_typeid::Type->TypeId;
typeid_type::TypeId->Type;
typeid_str::TypeId->str;

is_tmpvarid::VariableId->bool;
add_tmpvarid::TypeId->VariableId;

// [ Normalisation
// Author: Viktor Pavlu
// E-mail: e0425543@student.tuwien.ac.at
// Year  : 2008

// ----------------------------------------------------------
// assign normalises to handle arbitrarily nested expressions
// ----------------------------------------------------------

assign::Expression,Expression,dfi-> dfi;
assign(_,_,top) = top;
assign(_,_,bot) = bot;
assign(lhs,rhs,lifted_g) =
  // see how many normalisation steps will be required, then allocate
  // one tempvar for each normalisation step
  let lhs_vars = allocate_tmpvars(lhs,expr_depth(lhs));
      rhs_vars = allocate_tmpvars(rhs,expr_depth(rhs)); in
  // parse the expression, collecting the necessary transfer function
  // calls in the opcode list

  // all ops but the last one refer to transfer functions (ie OP_X_Y,OP_X_YSEL, ...)
  // the last element in both lists are only fragments:
  //   the lhs part comes from lhs_ops (eg LHS_XSEL) and
  //   the rhs part comes from rhs_ops (eg RHS_Y)
  // join the fragments (eg OP_XSEL_Y) to perform the final assignment
  // then execute all ops, modifying the shape graph
  let lhs_ops  = reverse(normalisation_ops(Side_LHS,lhs,expr_depth(lhs),lhs_vars));
      rhs_ops  = reverse(normalisation_ops(Side_RHS,rhs,expr_depth(rhs),rhs_vars)); in
  let L = hd(lhs_ops);
      R = hd(rhs_ops); in
  let last_op = case (R)!1!2 of

    RHS_NULL => if (L)!1!2 = LHS_X then
        [(OP_X_NULL,    [pick_arg(L,1)])] else
        [(OP_XSEL_NULL, [pick_arg(L,1),pick_arg(L,2)])] endif;
 
    RHS_NEW => if (L)!1!2 = LHS_X then
        [(OP_X_NEW,     [pick_arg(L,1)])] else
        [(OP_XSEL_NEW,  [pick_arg(L,1),pick_arg(L,2)])] endif;

    RHS_Y => if (L)!1!2 = LHS_X then
        [(OP_X_Y,       [pick_arg(L,1),pick_arg(R,1)])] else
        [(OP_XSEL_Y,    [pick_arg(L,1),pick_arg(L,2),pick_arg(R,1)])] endif;
      
    RHS_YSEL => if (L)!1!2 = LHS_X then
        [(OP_X_YSEL,    [pick_arg(L,1),pick_arg(R,1),pick_arg(R,2)])]
      else
        // additional normalisation step when x.sel and y.sel meet 
        let tmp = add_tmpvarid_like_expr(expr_at(lhs,0)); in
        [(OP_X_YSEL, [tmp,pick_arg(R,1),pick_arg(R,2)])] ++
        [(OP_XSEL_Y, [pick_arg(L,1),pick_arg(L,2),tmp])]
      endif;
     
    _ => print((R)!1!2) print(": ") error("unknown opcode\n");
  endcase; in
  let remove_tmps_op = case (R)!1!2 of
    // tmpvars are used only once and can be eliminated
    RHS_Y => let v = pick_arg(R,1); in if is_tmpvarid(v) then [(OP_X_NULL, [v])] else [] endif;
    _     => [];  // don't remove any vars
  endcase; in
  let ops = reverse(tl(lhs_ops)) ++ reverse(tl(rhs_ops)) ++ last_op ++ remove_tmps_op; in
  execute_ops(ops,lifted_g);

// call transfer functions according to given instruction in instructionlist
execute_ops::InstructionList,dfi->dfi;
execute_ops(           [], g) = g;
execute_ops((op,args):cdr, g) =
  let new_g = case op of
    OP_X_NULL    => tassign_x_null(pick(args,1),drop(g));
    OP_X_NEW     => tassign_x_new(pick(args,1),drop(g));
    OP_X_Y       => tassign_x_y(pick(args,1),pick(args,2),drop(g));
    OP_X_YSEL    => tassign_x_ysel(pick(args,1),pick(args,2),pick(args,3),drop(g));
    OP_XSEL_NULL => tassign_xsel_null(pick(args,1),pick(args,2),drop(g));
    OP_XSEL_NEW  => tassign_xsel_new(pick(args,1),pick(args,2),drop(g));
    OP_XSEL_Y    => tassign_xsel_y(pick(args,1),pick(args,2),pick(args,3),drop(g));
    OP_XSEL_YSEL => error("OP_XSEL_YSEL should have been normalised already.");
    _            => print(op) print(": ") error("unknown opcode");
  endcase; in
  execute_ops(cdr,lift(new_g));

// -----------------------------------------------------------
// normalisation function, generates the normalisation opcodes
// -----------------------------------------------------------

normalisation_ops::EnumSide,Expression,snum,VarList->InstructionList;
normalisation_ops(Side_LHS, e, 0, tmpvars) =
  case expr_at(e,0) of
    VarRefExp(_) as ref_x                                   => [(LHS_X, [varref_varid(ref_x)])];
    ArrowExp(VarRefExp(_) as ref_x,VarRefExp(_) as ref_sel) => [(LHS_XSEL, [varref_varid(ref_x),varref_varid(ref_sel)])];
    DotExp(PointerDerefExp(_),VarRefExp(_) as ref_sel)      => [(LHS_XSEL, [pick(tmpvars,1),varref_varid(ref_sel)])];
    _                                                       => error("unknown toplevel expression on lhs in normalisation_ops");
  endcase;

normalisation_ops(Side_RHS, e, 0, tmpvars) =
  case expr_at(e,0) of
    VarRefExp(_) as ref_x                                   => [(RHS_Y,    [varref_varid(ref_x)])];
    ArrowExp(VarRefExp(_) as ref_x,VarRefExp(_) as ref_sel) => [(RHS_YSEL, [varref_varid(ref_x),varref_varid(ref_sel)])];
    DotExp(PointerDerefExp(_),VarRefExp(_) as ref_sel)      => [(RHS_YSEL, [pick(tmpvars,1),varref_varid(ref_sel)])];
    NewExp(_,_,_)                                           => [(RHS_NEW,  [])];
    CastExp(IntVal(n),_)                                    => [(RHS_NULL, [])];
    _                                                       => [(RHS_NULL, [])];
      // FIXME: wait for default-case that lets output syntactical constructors [from GB]
      // then add all cases that are encountered in tests (so that they return valid results, in most cases [(RHS_NULL,[])]
      // the other cases should then create an error
      //error("unknown toplevel expression on rhs in normalisation_ops");
  endcase;
normalisation_ops(side,_,0,_) = print(side) print(": ") error("unknown EnumSide value.");
normalisation_ops(side, e, e_cursor, tmpvars) =
  let tmp = pick(tmpvars,e_cursor); in
  case expr_at(e,e_cursor) of
    ArrowExp(VarRefExp(_) as ref_x,VarRefExp(_) as ref_sel) => [(OP_X_YSEL, [tmp,varref_varid(ref_x),varref_varid(ref_sel)])];       // $tmp = x.sel
    DotExp(PointerDerefExp(_),VarRefExp(_) as ref_sel)      => [(OP_X_YSEL, [tmp,pick(tmpvars,e_cursor+1),varref_varid(ref_sel)])];  // $tmp = $prev_tmp.sel
    _                                                       => print(expr_at(e,e_cursor)) print(": ") error("unhandled expression");
  endcase ++ normalisation_ops(side, e, e_cursor - 1, tmpvars);

// ------------------------------
// normalisation helper functions
// ------------------------------

// allocates typed temporary variables for nested expressions
allocate_tmpvars::Expression,snum->VarList;
allocate_tmpvars(_,0) = [];
allocate_tmpvars(e,e_cursor) = allocate_tmpvars(e,e_cursor - 1) ++ [ add_tmpvarid_like_expr(expr_at(e,e_cursor)) ];

// creates tmpvar with same type as given variable (x)
add_tmpvarid_like_varid::VariableId->VariableId;
add_tmpvarid_like_varid(var) = add_tmpvarid(exprid_typeid(varid_exprid(var)));

// creates tmpvar with same type as given expression (x.sel)
add_tmpvarid_like_expr::Expression->VariableId;
add_tmpvarid_like_expr(expr) = add_tmpvarid(type_typeid(expr_type(expr)));

pick::VarList,snum->VariableId;
pick(     [],_) = error("pick below lower bound.");
pick(     _, 0) = error("pick above upper bound.");
pick(car:cdr,1) = car;
pick(car:cdr,n) = pick(cdr, n - 1);

pick_arg::Instruction,snum->VariableId;
pick_arg((_,args),i) = pick(args,i);

min::snum,snum->snum;
min(a,b) = if a < b then a else b endif;

// 0 for (x) and (x.sel)
// higher numbers for more nested expressions
expr_depth::Expression->snum;
expr_depth(e) = case e of
    ArrowExp(VarRefExp(_),VarRefExp(_)) => 0;
    ArrowExp(child,_) => 1 + expr_depth(child);
    DotExp(PointerDerefExp(child),_) => 1 + expr_depth(child);
    _ => 0;
endcase;

// returns the expression at the given depth. 0 is outermost expression
expr_at::Expression,snum->Expression;
expr_at(e,nesting_level) =
  let descending_steps = min(nesting_level, expr_depth(e)); in
  rec_expr_at(e, descending_steps);

rec_expr_at::Expression,snum->Expression;
rec_expr_at(e,0) = e;
rec_expr_at(DotExp(PointerDerefExp(child),_),descending_steps) = rec_expr_at(child, descending_steps - 1);
rec_expr_at(ArrowExp(child,_),descending_steps) = rec_expr_at(child, descending_steps - 1);

// returns innermost expression
expr_innermost::Expression->Expression;
expr_innermost(e) = expr_at(e, expr_depth(e));

// ] -- end of normalisation code

// ---------------------------------------------------------------------
// High-level functions, creating temporaries for handling special cases
// ---------------------------------------------------------------------

tassign_x_null::VariableId,ShapeGraphSet->ShapeGraphSet;
tassign_x_null(x,sg) =
  assign_x_null(x,sg);

tassign_xsel_null::VariableId,VariableId,ShapeGraphSet->ShapeGraphSet;
tassign_xsel_null(x,sel,sg) =
  assign_xsel_null(x,sel,sg);

tassign_x_new::VariableId,ShapeGraphSet->ShapeGraphSet;
tassign_x_new(x,G) =
  let G1=assign_x_null(x,G); in
  assign_x_new(x,G1);

tassign_xsel_new::VariableId,VariableId,ShapeGraphSet->ShapeGraphSet;
tassign_xsel_new(x,selp,G) =
  let tmp=add_tmpvarid_like_varid(selp); in
  let G1=assign_xsel_null(x,selp,G); in
  let G2=assign_x_new(tmp,G1); in
  let G3=assign_xsel_y(x,selp,tmp,G2); in
  assign_x_null(tmp,G3);

tassign_x_y::VariableId,VariableId,ShapeGraphSet->ShapeGraphSet;
tassign_x_y(x,y,G) =
  if x = y then
    G
  else
    let tmp=add_tmpvarid_like_varid(y); in
    let G1=assign_x_y(tmp,y,G); in
    let G2=assign_x_null(x,G1); in
    let G3=assign_x_y(x,tmp,G2); in
    assign_x_null(tmp,G3)
  endif;

tassign_x_ysel::VariableId,VariableId,VariableId,ShapeGraphSet->ShapeGraphSet;
tassign_x_ysel(x,y,selp,G) =
  let tmp=add_tmpvarid_like_varid(y); in
  let G1=assign_x_ysel(tmp,y,selp,G); in
  let G2=assign_x_null(x,G1); in
  let G3=assign_x_y(x,tmp,G2); in
  assign_x_null(tmp,G3);

tassign_xsel_y::VariableId,VariableId,VariableId,ShapeGraphSet->ShapeGraphSet;
tassign_xsel_y(x,selp,y,G) =
  let tmp=add_tmpvarid_like_varid(y); in
  let G1=assign_x_y(tmp,y,G); in
  let G2=assign_xsel_null(x,selp,G1); in
  let G3=assign_xsel_y(x,selp,tmp,G2); in
  assign_x_null(tmp,G3);

// ---------------------------------------------------------------------------------
// Set wrapping functions, modify sets of shapegraphs calling the transfer functions
// ---------------------------------------------------------------------------------

assign_x_null::VariableId,ShapeGraphSet->ShapeGraphSet;
assign_x_null(x,g0) = sgs_flatten([fassign_x_null(x,g) !! g <-- g0]);

assign_xsel_null::VariableId,VariableId,ShapeGraphSet->ShapeGraphSet;
assign_xsel_null(x,sel,g0) = sgs_flatten([fassign_xsel_null(x,sel,g) !! g <-- g0]);

assign_x_new::VariableId,ShapeGraphSet->ShapeGraphSet;
assign_x_new(x,g0) = sgs_flatten([fassign_x_new(x,g) !! g <-- g0]);

assign_x_y::VariableId,VariableId,ShapeGraphSet->ShapeGraphSet;
assign_x_y(x,y,g0) = sgs_flatten([fassign_x_y(x,y,g) !! g <-- g0]);

assign_xsel_y::VariableId,VariableId,VariableId,ShapeGraphSet->ShapeGraphSet;
assign_xsel_y(x,selp,y,g0) = sgs_flatten([fassign_xsel_y(x,selp,y,g) !! g <-- g0]);
  
assign_x_ysel::VariableId,VariableId,VariableId,ShapeGraphSet->ShapeGraphSet;
assign_x_ysel(x,y,selp,g0) = sgs_flatten([fassign_x_ysel(x,y,selp,g) !! g <-- g0]);

sgs_flatten::ShapeGraphSetList->ShapeGraphSet;
sgs_flatten([]) = {};
sgs_flatten(car:cdr) = union(car,sgs_flatten(cdr));

// ----------------------------------------------------------------------
// Low-level functions, without temporaries (do not handle special cases)
// ----------------------------------------------------------------------

fassign_x_null::VariableId,ShapeGraph->ShapeGraphSet;
fassign_x_null(x,g) =
  {kill_x(x,g)};

fassign_xsel_null::VariableId,VariableId,ShapeGraph->ShapeGraphSet;
fassign_xsel_null(x,s,((S0,H0),is0) as g) =
  if !var_exists(x,g) || !var_sel_exists(x,s,g) then
    {g}
  else
    // edge (nx,sel,nu) is guaranteed to be in H0 and must be removed
    let edge = heapedge_by_var_sel(x,s,H0); in
    case edge of
      (nx,sel,nu) =>
        let S1 = S0;
            H1 = {e !! (nv,sel1,nw) as e <-- H0, if !(nx=nv && sel=sel1)}; in
        /* if
         *  - nu was shared and
         *  - there is no ({},_,nu) edge and
         *  - there is no more than one (_,_,nu) edge then
         * nu is no longer shared.
         * otherweise is0 remains unchanged
         */
        let is1 = if (nu ? is0)
            && !many_into(nu,H1)
            && {} = {e     !! (nk,_,nl) as e <-- H1, if (nk={}) && (nl=nu)} then
          is0 # nu
        else
          is0
        endif; in
        {((S1,H1),is1)};
    endcase
  endif;

fassign_x_new::VariableId,ShapeGraph->ShapeGraphSet;
fassign_x_new(x,((S0,H0),is0) as g) =
  {((union(S0,{(x,{x})}),H0),is0)};

fassign_x_y::VariableId,VariableId,ShapeGraph->ShapeGraphSet;
fassign_x_y(x,y,((S0,H0),is0) as g) = 
  let S1  = union(
            {(z,gxy(x,y,nz)) !! (z,nz) <-- S0},                      // add x to all edges where y is already
            {(x,gxy(x,y,ny)) !! (y1,ny) <-- S0, if (y1 = y)});       // add a new edge (x,{x,y,...}) to where y pointed to
      H1  = {(gxy(x,y,nv),sel,gxy(x,y,nw)) !! (nv,sel,nw) <-- H0}; // add x to all edges where y is already
      is1 = {gxy(x,y,nz) !! nz <-- is0}; in
  {((S1,H1),is1)};

fassign_xsel_y::VariableId,VariableId,VariableId,ShapeGraph->ShapeGraphSet;
fassign_xsel_y(x,sel,y,((S0,H0),is0) as g) = 
  if !var_exists(x,g) || !var_exists(y,g) then
    {g}
  else
    let nx = node_by_var(x,g);
        ny = node_by_var(y,g); in
    let H1  = union(H0, {(nx,sel,ny)}); in
    let is1 = if many_into(ny,H1) then union(is0,{ny}) else is0 endif; in
    {((S0,H1),is1)}
  endif;

fassign_x_ysel::VariableId,VariableId,VariableId,ShapeGraph->ShapeGraphSet;
fassign_x_ysel(x,y,sel,((S0,H0),is0) as g) = // it is guaranteed that x!=y
  /* three possibilities:
   * - there is no (_,{y,...}) <- S or no ({y,...},sel,_) <- H
   * - there is (_,{y,...}) <- S and ({y,...},sel,dest) <- H where dest != {}
   * - there is (_,{y,...}) <- S and ({y,...},sel,{}) <- H
   */
  if !var_exists(y,g) then
    // case 1: null dereferencing
    {g}
  else if !var_sel_exists(y,sel,g) then
    // case 1: non-existing selector
    {g}
  else
    case heapedge_by_var_sel(y,sel,H0) of
      (ny,_,{}) =>  // case 3
         materialise(x,y,sel,g);

      (ny,_,nu) => // case 2
        // rename the location nu to include {x} and add the binding (x,union(nu,{x}))
        let S1  = union({(z,hxu(x,nu,nz)) !! (z,nz) <-- S0}, {(x,hxu(x,nu,nu))});
            H1  = {(hxu(x,nu,nv),sel1,hxu(x,nu,nw)) !! (nv,sel1,nw) <-- H0};
            is1 = {hxu(x,nu,nz) !! nz <-- is0}; in
            {((S1,H1),is1)};
    endcase
  endif
  endif;

materialise::VariableId,VariableId,VariableId,ShapeGraph->ShapeGraphSet;
materialise(x,y,sel,((S0,H0),is0) as g) = 
  let S1         = union(S0,{(x,{x})});
      Hextern    = {e !! (v1,sel1,w1) as e <-- H0, if v1 != {} && w1 != {}}; in
  let Hintern    = [e !! e <-- heapedge_subtract(H0,Hextern)]; in
  let candidates = if {} ? is0 then
    // if {} is shared, generate candidates for 3 cases
    // after the materialisation:
    //   - {} remains shared, new {x} is unshared
    //   - {} remains shared, new {x} is shared
    //   - {} loses sharing,  new {x} is shared
    // note that the sharing can not go away, as there
    // is no case where both {} and {x} are unshared
    // after materialisation if {} was shared before
    sgs_flatten([gen_cand({x},S1,Hextern,Hintern,union(is0 # {},is_shared)) !! is_shared <-- { {{}}, {{x}}, {{x},{}} } ])
  else
    // if {} is unshared, both {} and {x} must also
    // be unshared after the materialisation
    gen_cand({x},S1,Hextern,Hintern,is0)
  endif; in 
  {sg !! ((S2,H2),is2) as sg <-- candidates,
    if is_compatible(sg)
    && kill_x(x,sg) = ((S0,H0),is0)
    && (x,{x}) ? S2
    && var_exists(y,sg)
    && var_exists(x,sg)
    && (node_by_var(y,sg),sel,node_by_var(x,sg)) ? H2};

gen_cand::Node,StackEdgeSet,HeapEdgeSet,HeapEdgeList,NodeSet->ShapeGraphSet;
gen_cand(x,S,H,(_,sel,_) as edge:cdr,is0) =
  let Hn = case edge of
    ({},_,{}) => 
      if x ? is0 then {
        {({},sel,{})},
        {({},sel, x)},
        {( x,sel,{})},
        {( x,sel, x)},

        {({},sel,{}),({},sel, x)},
        {({},sel,{}),( x,sel,{})},
        {({},sel,{}),( x,sel, x)},
        {({},sel, x),( x,sel,{})},
        {({},sel, x),( x,sel, x)},
        {( x,sel,{}),( x,sel, x)},
        
        {({},sel,{}),({},sel, x),(x,sel,{})},
        {({},sel,{}),({},sel, x),(x,sel, x)},
        {({},sel,{}),( x,sel,{}),(x,sel, x)},
        
        {({},sel,{}),({},sel,x),(x,sel,{}),(x,sel,x)}
      } else {
        {({},sel,{})},
        {( x,sel,{})},

        {({},sel,{}),(x,sel,{})}
      } endif;
      
    ({},_,y) =>
      if y ? is0 then {
        {({},sel,y)},
        {( x,sel,y)},
        {({},sel,y),(x,sel,y)}
      } else {
        {({},sel,y)},
        {( x,sel,y)}
      } endif;

    (y,_,{}) => {
        {(y,sel,{})},
        {(y,sel,x)}
      };
  endcase; in
  sgs_flatten([gen_cand(x,S,union(H,new_edge),cdr,is0) !! new_edge <-- Hn]);
gen_cand(_,S,H,[],is0) = {((S,H),is0)};

// ----------------------------------------------------
// Auxiliary functions for low-level transfer functions
// ----------------------------------------------------

is_compatible::ShapeGraph->bool;
is_compatible(((S0,H0),is0) as g) =
  let alocs = union(union(aloc_S([x !! x <-- S0],{}), aloc_H([x !! x <-- H0],{})), is0); in
  check_inv1([(a,b) !! a <-- alocs, b <-- alocs])
  // Inv2: if x points to a node, the nodes name must contain x (naming convention)
  && {(x,nx) !! (x,nx) <-- S0, if x ? nx} = S0
  && check_inv3([((nv,sel,nw),(nv1,sel1,nw1)) !! (nv,sel,nw) <-- H0, (nv1,sel1,nw1) <-- H0, if nv = nv1 && sel = sel1 && nv != {}])
  && check_inv4([x !! x <-- is0],H0)
  && check_inv5([nx1 !! (nv1,sel1,nx1) <-- H0, (nv2,sel2,nx2) <-- H0, if nx1 = nx2 && (sel1 != sel2 || nv1 != nv2) && nx1 != {}],is0);
    
aloc_S::StackEdgeList,NodeSet->NodeSet;
aloc_S((_,v):cdr,nodes) = aloc_S(cdr, union(nodes,{v}));
aloc_S(       [],nodes) = nodes;

aloc_H::HeapEdgeList,NodeSet->NodeSet;
aloc_H((v,_,v1):cdr,nodes) = aloc_H(cdr, union(nodes, {v,v1}));
aloc_H(          [],nodes) = nodes;

// Inv1: two nodes a,b are either the same or have no common variables */
check_inv1::NodeTupleList->bool;
check_inv1((a,b):cdr) = if (a = b) || (intersect(a,b) = {}) then check_inv1(cdr) else false endif;
check_inv1(       []) = true;

// Inv3: nv,sel,nw  and  nv,sel,nw1: either nw and nw1 are the same node or nv 
// is the summary node. no node,sel pair may point to more than one node
// except the source is the summary node
check_inv3::HeapEdgeTupleList->bool;
check_inv3(((nv,sel,nw),(nv1,sel1,nw1)):cdr) = if (nw = nw1) then check_inv3(cdr) else false endif;
check_inv3(         []) = true;

// Inv4: if nx is shared, there exists either {},sel,nx or 2+ edges pointing to nx */
check_inv4::NodeList, HeapEdgeSet->bool;
check_inv4(nx:cdr, H) = 
  if ({e !! (n1,_,m1) as e <-- H, if n1 = {} && m1 = nx} != {})
  || ({e !! (n2,sel2,m2) as e <-- H, (n3,sel3,m3) <-- H, if (m2 = m3) && ((sel2 != sel3) || (n2 != n3))} != {}) then
    check_inv4(cdr,H)
  else
    false
  endif;
check_inv4(     [],_) = true;

// Inv5: if nv,sel,nx and nv1,sel1,nx are in the shapegraph, then nx is shared */
check_inv5::NodeList,NodeSet->bool;
check_inv5(nx:cdr, shared) = if nx ? shared then check_inv5(cdr,shared) else false endif;
check_inv5(    [],      _) = true;

kill_x::VariableId,ShapeGraph->ShapeGraph;
kill_x(x,((S0,H0),is0)) =
  let S1  = {(z,rem(x,nz)) !! (z,nz) <-- S0, if !(z=x)}; 
      H1  = {(rem(x,nv),sel,rem(x,nw)) !! (nv,sel,nw) <-- H0};
      is1 = {rem(x,nx) !! nx <-- is0}; in
  ((S1,H1),is1);

// remove x from Z  (called kx in Nnh)
rem::VariableId,Node->Node;
rem(x,Z) = Z # x;
//rem(x,Z) = {v !! v <-- Z, if !(x=v) };

// add x to Z if y is already there
gxy::VariableId,VariableId,Node->Node;
gxy(x,y,Z) = if (y ? Z) then union(Z,{x}) else Z endif;

// add x to U if U = Z
hxu::VariableId,Node,Node->Node;
hxu(x,U,Z) = if (Z = U) then union(U,{x}) else Z endif;

many_into::Node,HeapEdgeSet->bool;
many_into(nu,edges) =
  !({} = {true !! (p1,s1,q1) <-- edges, (p2,s2,q2) <-- edges,
                  if ((q1 = nu)
                  && (q2 = nu)
                  && !(p1=p2 && s1=s2))});
                              
var_sel_exists::VariableId,VariableId,ShapeGraph->bool;
var_sel_exists(x,sel,((_,H0),_)) = {e !! (nv,sv,_) as e <-- H0, if (x ? nv) && (sv = sel)} != {};


heapedge_by_var_sel::VariableId,VariableId,HeapEdgeSet->HeapEdge;
heapedge_by_var_sel(x,sel,edges) = hd([e !! (nv,sv,_) as e <-- edges, if (x ? nv) && (sv = sel)]);

// Author: Viktor Pavlu
// E-mail: vpavlu@gmail.com
// Year  : 2006, 2007, 2008
// ---------------------------------------
// SUPPORT FUNCTIONS CALLED BY APPLICATION
// ---------------------------------------

extract_stackedge_set::ShapeGraph->StackEdgeSet;
extract_stackedge_set(((se,_),_)) = se;

extract_stackedges::ShapeGraph->StackEdgeList;
extract_stackedges(((se,_),_)) = [x !! x <-- se];

extract_heapnodes::ShapeGraph->NodeList;
extract_heapnodes(((EV,ES),_))  =
  [ x !! x <-- union(union({ a !! (a,_,_) <-- ES},{ c !! (_,_,c) <-- ES}),{b !! (_,b) <-- EV}) ];

extract_heapedges::ShapeGraph->HeapEdgeList;
extract_heapedges(((_,ES),_)) = [x !! x <-- ES];

extract_is_shared::ShapeGraph->NodeList;
extract_is_shared((_,iss)) = [x !! x <-- iss];

src_sel_exists::Node,VariableId,ShapeGraph->bool;
src_sel_exists(src,sel,((_,H0),_)) = {e !! (nv,sv,_) as e <-- H0, if (src = nv) && (sel = sv)} != {};

no_duplicates::VarList->VarList;
no_duplicates(list) = [x !! x <-- {y !! y <- list}];

// Author: Viktor Pavlu
// E-mail: e0425543@student.tuwien.ac.at
// Year  : 2006
// --------------------------------------------
// GRAPH TRANSFORMATION FUNCTIONS (SRW <-> NNH)
// --------------------------------------------
srw_extract_graphs::ShapeGraph->SrwNnhPair;
srw_extract_graphs(sg) = (sg,sgSet_to_sgList(srwSG_to_nnhSG(sg)));

nnh_extract_graphs::ShapeGraphSet->SrwNnhPair;
nnh_extract_graphs(sg) = (nnhSG_to_srwSG(sg), sgSet_to_sgList(sg));

sgSet_to_sgList::ShapeGraphSet->ShapeGraphList;
sgSet_to_sgList(sgs) = [sg !! sg <-- sgs];

//srw_extract_summaryGraph::ShapeGraph->ShapeGraphList;
//srw_extract_summaryGraph(sg) = [sg];
//srw_extract_shapeGraphs::ShapeGraph->ShapeGraphList;
//srw_extract_shapeGraphs(sg) = [x !! x <-- srwSG_to_nnhSG(sg)];

//nnh_extract_summaryGraph::ShapeGraphSet->ShapeGraphList;
//nnh_extract_summaryGraph(sg) = [nnhSG_to_srwSG(sg)];
//nnh_extract_shapeGraphs::ShapeGraphSet->ShapeGraphList;
//nnh_extract_shapeGraphs(sg) = [x !! x <-- sg];

// convert nnh to srw graph
// nnh: set of graphs, each selector points to one node
// srw: single graph, each selector can point to many nodes

nnhSG_to_srwSG::ShapeGraphSet->ShapeGraph;
nnhSG_to_srwSG(graphs) = rec_join_shapegraphs( (({},{}),{}), [x !! x <-- graphs]);

rec_join_shapegraphs::ShapeGraph,ShapeGraphList->ShapeGraph;
rec_join_shapegraphs(sg, []) = sg;
rec_join_shapegraphs(((S0,H0),is0), ((S1,H1),is1):cdr) =
  let new_S = union(S0,S1);
      new_H = union(H0,H1); in
  let new_sharing = nnh_compute_is(((new_S,new_H),union(is0,is1))); in
  rec_join_shapegraphs(((new_S,new_H),new_sharing), cdr);

// computes shared nodes 
//  - Inv4: is = intersect(is, union({n !! ({},_,n)}, nodes_that_are_more_than_once_target_of_an_heapedge()))
//  - Inv5: i s+= (nodes_that_are_mone_than_once_target_of_an_heapedge() / {})
nnh_compute_is::ShapeGraph->NodeSet;
nnh_compute_is(((S,H),iss)) =
  union(
    // Inv4: if nx is shared, then
    //  - Inv4a: ({},_,nx) must be one of the heapedges OR
    //  - Inv4b: nx must be the target of more than one heapedge
    intersect(
      iss,
      union(
        {x !! x <-  dests_of_heapedges(heapedges_by_src({},H))},   // Inv 4a
        {y !! y <-- more_than_once(dests_of_heapedges(H))}         //Inv 4b
      )
    ),
    // Inv5: nx is shared if two or more heapedges have nx as their
    // target (if nx != {})
    nodes_target2plus(((S,H),iss))
  );

// nodes that are target of 2 (or more) heapedges, but not {}
nodes_target2plus::ShapeGraph->NodeSet;
nodes_target2plus(((_,H),_)) = more_than_once(dests_of_heapedges(H)) # {};

dests_of_heapedges::HeapEdgeSet->NodeList;
dests_of_heapedges(H) = [d !! (_,_,d) <-- H];

more_than_once::NodeList->NodeSet;
more_than_once(nodes) = rec_more_than_once(nodes,{},{});

rec_more_than_once::NodeList,NodeSet,NodeSet->NodeSet;
rec_more_than_once([],         _, result) = result;
rec_more_than_once(car:cdr, seen, result) =
  if car ? seen then
    rec_more_than_once(cdr, seen, union(result, {car}))
  else
    rec_more_than_once(cdr, union(seen, {car}), result)
  endif;

// convert srw to nnh graph
// nnh: set of graphs, each selector points to one node
// srw: single graph, each selector can point to many nodes

srwSG_to_nnhSG::ShapeGraph->ShapeGraphSet;
srwSG_to_nnhSG(((ES,EH),IS)) =
  {((ESn,EHn),IS) !!
    ESn <- transform_stackedges(ES),
    EHn <- transform_heapedges(
      reachable_heapedges({n !! (_,n) <-- ESn}, EH), // only pass reachable edges
                          {n !! (_,n) <-- ESn})      // startnodes (reachable via ES)
  };

// -- transform the stackedges
transform_stackedges::StackEdgeSet->StackEdgeSetList;
transform_stackedges(ES) = rec_transform_stackedges(ES, {});

rec_transform_stackedges::StackEdgeSet,StackEdgeSet->StackEdgeSetList;
rec_transform_stackedges(      {}, res_Graph) = [res_Graph];
rec_transform_stackedges(in_Graph, res_Graph) =
  let var   = hd(vars_by_stackedges(in_Graph)); in // pick a variable var
  let edges = stackedges_by_var(var,in_Graph); in  // select all out-edges of var
  [rg !! (_,node) as edge <-- edges,
    rg <- rec_transform_stackedges(
  //  stackedge_subtract(in_Graph, {edge}), //stackedges_by_vars(node,in_Graph)), //FIXME mit [b]
    stackedge_subtract(in_Graph, stackedges_by_vars(node,in_Graph)), //FIXME ohne [b]
    union(res_Graph, stackedges_by_dest(node, in_Graph))
  )];

// -- transform the heapedges
transform_heapedges::HeapEdgeSet,NodeSet->HeapEdgeSetList;
transform_heapedges(EH,startnodes) = rec_transform_heapedges(EH,startnodes,{});

rec_transform_heapedges::HeapEdgeSet,NodeSet,HeapEdgeSet->HeapEdgeSetList;
rec_transform_heapedges(      {},          _, res_Graph) = [res_Graph];
rec_transform_heapedges(in_Graph, startnodes, res_Graph) =
  let out_edges = [e !! e <-- reachable_heapedges(startnodes, in_Graph)]; in
  if out_edges = [] then
    [res_Graph]
  else
    let src_sel_pattern = hd(out_edges); in
    let src             = src_of_heapedge(src_sel_pattern);
        sel             = sel_of_heapedge(src_sel_pattern); in
    let edges           = heapedges_by_src_sel(src,sel,in_Graph); in
    [rg !! (_,_,dest) as edge <-- edges,
      rg <- rec_transform_heapedges(
        heapedge_subtract(in_Graph, edges),
          union(startnodes, {dest}),
          union(res_Graph, {edge})
      )
    ]
  endif;

// ----------------------------------------
// Auxiliary functions for graph conversion
// ----------------------------------------

shapeGraph_list_member::ShapeGraph,ShapeGraphList->bool;
shapeGraph_list_member(a,b:c) = if a=b then true else shapeGraph_list_member(a,c) endif;
shapeGraph_list_member(a,[])  = false;

mk_unique_shapeGraph_list::ShapeGraphList->ShapeGraphList;
mk_unique_shapeGraph_list(a:b) = if shapeGraph_list_member(a,b) then mk_unique_shapeGraph_list(b) else a: mk_unique_shapeGraph_list(b) endif;
mk_unique_shapeGraph_list([])  = [];

// all stackedges that originiate from <var>
stackedges_by_var::VariableId,StackEdgeSet->StackEdgeSet;
stackedges_by_var(var,edges) = {e !! (v,_) as e <-- edges, if v = var};

// all stackedges that originate from any of <vars>
stackedges_by_vars::Node,StackEdgeSet->StackEdgeSet;
stackedges_by_vars(vars,edges) = {e !! (_,n) as e <-- edges, if !(intersect(vars,n) = {})};

// all stackedges that point to <node>
stackedges_by_dest::Node,StackEdgeSet->StackEdgeSet;
stackedges_by_dest(dest,edges) = {e !! (_,d) as e <-- edges, if d = dest};

// all vars of stackedges
vars_by_stackedges::StackEdgeSet->VarList;
vars_by_stackedges(ES) = no_duplicates([v !! (v,n) <-- ES]);

stackedge_subtract::StackEdgeSet,StackEdgeSet->StackEdgeSet;
stackedge_subtract(S1,S2) = {x!!x<--S1, if !(x ? S2)};

heapedge_subtract::HeapEdgeSet,HeapEdgeSet->HeapEdgeSet;
heapedge_subtract(S1,S2) = {x!!x<--S1, if !(x ? S2)};

heapedges_by_src::Node,HeapEdgeSet->HeapEdgeSet;
heapedges_by_src(src,edges) = {e !! (s,_,_) as e <-- edges, if s = src};

heapedges_by_dest::Node,HeapEdgeSet->HeapEdgeSet;
heapedges_by_dest(dest,edges) = {e !! (_,_,d) as e <-- edges, if d = dest};

heapedges_by_src_sel::Node,VariableId,HeapEdgeSet->HeapEdgeSet;
heapedges_by_src_sel(src,sel,edges) = {e !! (srcx,selx,_) as e <-- edges, if srcx = src && selx = sel};

src_of_heapedge::HeapEdge->Node;
src_of_heapedge((src,_,_)) = src;

sel_of_heapedge::HeapEdge->VariableId;
sel_of_heapedge((_,sel,_)) = sel;

dest_of_heapedge::HeapEdge->Node;
dest_of_heapedge((_,_,dest)) = dest;

reachable_heapedges::NodeSet,HeapEdgeSet->HeapEdgeSet;
reachable_heapedges(nodes, es) =
  flatten_heapedge_set({heapedges_by_src(src, es) !! src <-- reachable_heapnodes(nodes,es)});

reachable_heapnodes::NodeSet,HeapEdgeSet->NodeSet;
reachable_heapnodes(nodes,es) =
  let new_nodes = union({dest !! (src,_,dest) <-- es, if src ? nodes}, nodes); in
  if nodes != new_nodes then reachable_heapnodes(new_nodes,es) else new_nodes endif;

flatten_heapedge_set::HeapEdgeSetSet->HeapEdgeSet;
flatten_heapedge_set(sets) = rec_flatten_heapedge_set([s !! s <-- sets],{});

rec_flatten_heapedge_set::HeapEdgeSetList,HeapEdgeSet->HeapEdgeSet;
rec_flatten_heapedge_set(    [],set) = set;
rec_flatten_heapedge_set(s:sets,set) = rec_flatten_heapedge_set(sets, union(set,s));

// ----------------------------
// is_may_alias / is_must_alias
// ----------------------------

// convert carrier to set of shapegraphs on which the aliases will be computed
shape_carrier_to_shapegraphset::dfi->ShapeGraphSet;
shape_carrier_to_shapegraphset(lifted_sg) = drop(lifted_sg);

is_no_alias::Expression,Expression,ShapeGraphSet->bool;
is_no_alias(a,b,sgs) = !is_may_alias(a,b,sgs);

// a,b are may aliases
// if there EXISTS one graph in which a and b refer to the same node
is_may_alias::Expression,Expression,ShapeGraphSet->bool;
is_may_alias(a,b,sgs) = {g !! g <-- sgs, if is_same_node(Alias_May,a,b,g)} != {};

// a,b are must aliases
// if there exists no graph in which a and b refer NOT to the same node (ie they do refer in all nodes)
is_must_alias::Expression,Expression,ShapeGraphSet->bool;
is_must_alias(a,b,sgs) = {g !! g <-- sgs, if !is_same_node(Alias_Must,a,b,g)} = {};

// returns true if both expressions refer to the same node
is_same_node::EnumAlias,Expression,Expression,ShapeGraph->bool;
is_same_node(alias_type,expr_a,expr_b,(_,is0) as sg) =
  let invalid_node = {add_tmpvarid_like_expr(expr_a)}; in  // will be used to indicate "node not found" case
  let a_nodes      = nodes_visited_by_expr(expr_a,sg,invalid_node);
      b_nodes      = nodes_visited_by_expr(expr_b,sg,invalid_node);
      a_sels       = selectors_visited_by_expr(expr_a);
      b_sels       = selectors_visited_by_expr(expr_b); in
  rec_is_same_node(alias_type, {} ? is0, a_sels, a_nodes, b_sels, b_nodes, invalid_node);

rec_is_same_node::EnumAlias,bool, VarList,NodeList, VarList,NodeList, Node->bool;
rec_is_same_node(_, _, _, [], _,  _, _) = false;
rec_is_same_node(_, _, _,  _, _, [], _) = false;
rec_is_same_node(alias_type, summary_is_shared, a_sels, a:a_rest, b_sels, b:b_rest, invalid_node) =
  if a != b || a = invalid_node || b = invalid_node then
    // different nodes or not in graph at all
    false 
  else
    // nodes are equal
    if a != {} then
      // same node and not the summary node, hooray!
      true
    else
      // both paths lead to the summary node
      if Alias_May = alias_type && summary_is_shared then
        // when the summary node is shared, any two paths leading
        // to the summary node POSSIBLY end at the same summary node
        true
      else
        // a and b can still be aliases if the paths minus the
        // last selector ended at the same node if the same
        // selector was used on both paths
        // (nb: while the selectors are identical on both paths, the elements in the selector- and nodelists can be dropped -- investigate: faster??)
        if a_sels = [] || b_sels = [] || a_sels != b_sels then
          false
        else
          rec_is_same_node(alias_type, summary_is_shared, tl(a_sels), a_rest, tl(b_sels), b_rest, invalid_node)
        endif
      endif
    endif
  endif;

// returns list of names where expressions like
// (*(a->b)).c->d yield
// [d,c,b,a]
selectors_visited_by_expr::Expression->VarList;
selectors_visited_by_expr(e) = reverse(rec_selectors_visited_by_expr(e, expr_depth(e)));

rec_selectors_visited_by_expr::Expression,snum->VarList;
rec_selectors_visited_by_expr(_, -1) = []; // intentionally -1, topmost case in iteration
rec_selectors_visited_by_expr(e, e_cursor) =
  let inner_e  = expr_at(e,e_cursor); in
  let new_list = case inner_e of
    VarRefExp(_) as ref_x                                   => [varref_varid(ref_x)];
    ArrowExp(VarRefExp(_) as ref_x,VarRefExp(_) as ref_sel) => [varref_varid(ref_x),varref_varid(ref_sel)];
    DotExp(PointerDerefExp(_),VarRefExp(_) as ref_sel)      => [varref_varid(ref_sel)];
    _ => print(inner_e) print(": ") error("unhandled expression.");
  endcase; in
  new_list ++ rec_selectors_visited_by_expr(e, e_cursor - 1);

// returns list of all heapnodes on a path given by the expression
// [node(n), node(n-1), node(n-2), ..., node(0)]
nodes_visited_by_expr::Expression,ShapeGraph,Node->NodeList;
nodes_visited_by_expr(e,g,invalid_node) = rec_nodes_visited_by_expr(e, expr_depth(e),g,[],invalid_node);

rec_nodes_visited_by_expr::Expression,snum,ShapeGraph,NodeList,Node->NodeList;
rec_nodes_visited_by_expr(_,       -1, _, trail,            _) = trail; // intentionally -1, topmost case in iteration
rec_nodes_visited_by_expr(e, e_cursor, g, trail, invalid_node) =
  let inner_e  = expr_at(e,e_cursor); in
  let new_list = case inner_e of

    VarRefExp(_) as ref_x =>
      let x   = varref_varid(ref_x); in
      if var_exists(x,g) then [node_by_var(x,g)] else [invalid_node] endif;

    ArrowExp(VarRefExp(_) as ref_x,VarRefExp(_) as ref_sel) =>
      let x   = varref_varid(ref_x);
          sel = varref_varid(ref_sel); in
      let nl0 = if var_exists(x,g) then [node_by_var(x,g)] else [invalid_node] endif; in
      let nl1 = if src_sel_exists({x},sel,g) then [node_by_src_sel({x},sel,g)] else [invalid_node] endif; in
      nl1 ++ nl0;

    DotExp(PointerDerefExp(_),VarRefExp(_) as ref_sel) =>
      let x   = hd(trail);
          sel = varref_varid(ref_sel); in
      if src_sel_exists(x,sel,g) then [node_by_src_sel(x,sel,g)] else [invalid_node] endif;

    _ => print(inner_e) print(": ") error("unhandled expression.");
  endcase; in
  rec_nodes_visited_by_expr(e, e_cursor - 1, g, new_list ++ trail, invalid_node);

var_exists::VariableId,ShapeGraph->bool;
var_exists(x,((S0,_),_)) =  {e !! (y,ny) as e <-- S0, if (x=y)} != {};

node_by_var::VariableId,ShapeGraph->Node;
node_by_var(x,((S0,_),_) as g) = hd([nk !! (k,nk) <-- S0, if (k=x)]);

node_by_src_sel::Node,VariableId,ShapeGraph->Node;
node_by_src_sel(x,sel,((_,H0),_)) = hd([nk !! (x1,sel1,nk) <-- H0, if x1 = x && sel1 = sel]);

// ------------------
// garbage collection
// ------------------
/*
gc::dfi->dfi;
gc(lifted_sg) = if option_kill_unreachable_nodes then
  case drop(lifted_sg) of sgs => lift(remove_empty_graph({gc_sg(sg) !! sg <-- sgs})); endcase
else
  lift(remove_empty_graph(drop(lifted_sg)))
endif;


gc_sg::ShapeGraph->ShapeGraph;
gc_sg(((v,e),s) as sg) =
let
  var_nodes = {n !! (_,n) <-- v};
in let 
  v_new = v;
  e_new = reachable_heapedges(var_nodes,e);
  s_new = intersect(s,reachable_heapnodes(var_nodes,e));
in
  ((v_new,e_new),s_new);
*/

// vim: ts=2 sts=2 sw=2 expandtab:

/* Author: Viktor Pavlu
   E-mail: vpavlu@gmail.com
   Year  : 2006
*/

// ----------------------------------------------------------------------
// SUPPORT FUNCTIONS
// CALLED BY APPLICATION

extract_stackedge_set :: ShapeGraph -> StackEdgeSet;
extract_stackedge_set(((EV,_),_)) = EV;

extract_stackedges::ShapeGraph -> StackEdgeList;
extract_stackedges(((EV,_),_)) = [x !! x <-- EV];

extract_heapnodes::ShapeGraph -> NodeList;
extract_heapnodes(((EV,ES),_))  =
   [ x !! x <-- union(union({ a !! (a,_,_) <-- ES},{ c !! (_,_,c) <-- ES}),{b !! (_,b) <-- EV}) ];

extract_heapedges::ShapeGraph -> HeapEdgeList;
extract_heapedges(((_,ES),_)) = [x !! x <-- ES];

extract_is_shared::ShapeGraph -> NodeList;
extract_is_shared((_,iss)) = [x !! x <-- iss];


// AUXILIARY FUNCTIONS FOR SUPPORT FUNCTIONS

str_list_member::str,StrList->bool;
str_list_member(a,b:c) = if a=b then true else str_list_member(a,c) endif;
str_list_member(a,[])  = false;

mk_unique_str_list::StrList->StrList;
mk_unique_str_list(a:b) = if str_list_member(a,b) then mk_unique_str_list(b) else a: mk_unique_str_list(b) endif;
mk_unique_str_list([])  = [];


// ----------------------------------------------------------------------
// TRANSFORMATION FUNCTIONS:
//   transforms list of shapegraphs where each selector may appear only
//   once per node (nielson) into a single shapegraph where selectors may
//   point to more than one node at the same time (srw), and vice versa.
//

//
//  test wrappers
//

srw_extract_shapeGraphs_t :: ShapeGraph -> ShapeGraphList;
//extract_shapeGraphs_t(((EV,ES),IS)) = srwSG_to_nielsonSG((({("x",{"x"}),("x",{"x","y"}),("y",{"y"}),("y",{"x","y"}),("z",{"z"})},{({"x"},"next",{"z"}),({"x"},"next",{}),({},"next",{}),({"y"},"next",{})}),{}));
//extract_shapeGraphs_t(((EV,ES),IS)) = srwSG_to_nielsonSG((({("x",{"x"}),("z",{"z"}),("y",{"x","y"}),("x",{"x","y"})},{({"x"},"next",{"z"}),({"x"},"next",{}),({},"next",{}),({"y"},"next",{})}),{}));
//!!! ~/test/test1.C
srw_extract_shapeGraphs_t(x) = srw_extract_shapeGraphs(x); 

srw_extract_summaryGraph_t :: ShapeGraph -> ShapeGraphList;
//extract_summaryGraph_t(sg) = [(({("x",{"x","y"}),("y",{"y"}),("x",{"x"}),("y",{"x","y"}),("z",{"z"})},{({"x"},"next",{"z"}),({"x"},"next",{}),({},"next",{}),({"y"},"next",{})}),{})];
//extract_summaryGraph_t(sg) = [(({("x",{"x","y"}),("x",{"x"}),("y",{"x","y"}),("z",{"z"})},{({"x"},"next",{"z"}),({"x"},"next",{}),({},"next",{}),({"y"},"next",{})}),{})];
srw_extract_summaryGraph_t(sg) = srw_extract_summaryGraph(sg);


//
// functions for Sagiv/Reps/Wilhelm analysis
//

srw_extract_summaryGraph :: ShapeGraph -> ShapeGraphList;
srw_extract_summaryGraph(sg) = [sg];

srw_extract_shapeGraphs :: ShapeGraph -> ShapeGraphList;
srw_extract_shapeGraphs(sg) = srwSG_to_nielsonSG(sg);

//
// functions for Nielson analysis
//

nielson_extract_summaryGraph :: ShapeGraphList -> ShapeGraphList;
nielson_extract_summaryGraph(sg) = [nielsonSG_to_srwSG(sg)];

nielson_extract_shapeGraphs :: ShapeGraphList -> ShapeGraphList;
nielson_extract_shapeGraphs(sg) = sg;


//
// conversion functions
//

// converts a "Nielson shapegraph" (a list of graphs where
// each selector may appear at most once at a certain node) into a
// "Sagiv/Reps/Wilhelm shapegraph" (a single graph where selectors
// may point to more than one node simultaneously)

nielsonSG_to_srwSG :: ShapeGraphList -> ShapeGraph;
nielsonSG_to_srwSG(graphs) = rec_combine_graphs(hd(graphs),tl(graphs));

rec_combine_graphs :: ShapeGraph,ShapeGraphList -> ShapeGraph;
rec_combine_graphs(g, []     ) = g;
rec_combine_graphs(((EV0,ES0),IS0), ((EV1,ES1),IS1):rest) =
  rec_combine_graphs(((union(EV0,EV1),union(ES0,ES1)),union(IS0,IS1)), rest);

// converts a "Sagiv/Reps/Wilhelm shapegraph" (a single graph where selectors
// may point to more than one node simultaneously)
// into a "Hanne Riis Nielson shapegraph" (a list of graphs where
// each selector may appear at most once at a certain node)

srwSG_to_nielsonSG :: ShapeGraph -> ShapeGraphList;
srwSG_to_nielsonSG(((EV,ES),IS)) =
    mk_unique_shapeGraph_list([((EVn,ESn),IS) !!
        EVn <- transform_stackedges(EV),
        ESn <- transform_heapedges(
            reachable_heapedges({n !! (_,n) <-- EVn}, ES), // only pass reachable edges
                                {n !! (_,n) <-- EVn})      // startnodes (reachable via EV)
    ]);

// -- transform the var-edges (EV)
transform_stackedges::StackEdgeSet->StackEdgeSetList;
transform_stackedges(EV) = rec_transform_stackedges(EV, {});

rec_transform_stackedges :: StackEdgeSet,StackEdgeSet -> StackEdgeSetList;
rec_transform_stackedges(      {}, res_Graph) = [res_Graph];
rec_transform_stackedges(in_Graph, res_Graph) =
  let
    var   = hd(vars_by_stackedges(in_Graph));  // pick a variable var
  in let
    edges = stackedges_by_var(var,in_Graph);  // select all out-edges of var
  in
    [rg !! (_,node) as edge <-- edges, //FIXME as edge weg
           rg <- rec_transform_stackedges(
//             stackedge_subtract(in_Graph, {edge}), //stackedges_by_vars(node,in_Graph)), //FIXME mit [b]
             stackedge_subtract(in_Graph, stackedges_by_vars(node,in_Graph)), //FIXME ohne [b]
             union(res_Graph, stackedges_by_heapnode(node, in_Graph))
           )];

// -- transform the selector-edges (ES)
transform_heapedges::HeapEdgeSet,NodeSet->HeapEdgeSetList;
transform_heapedges(ES,startnodes) = rec_transform_heapedges(ES,startnodes,{});

rec_transform_heapedges :: HeapEdgeSet,NodeSet,HeapEdgeSet -> HeapEdgeSetList;
rec_transform_heapedges(      {},          _, res_Graph) = [res_Graph];
rec_transform_heapedges(in_Graph, startnodes, res_Graph) =
    let
        out_edges = [e !! e <-- reachable_heapedges(startnodes, in_Graph)];
    in
        if out_edges = [] then
            [res_Graph]
        else
            let src_sel_pattern = hd(out_edges); in
            let
                src = srcnode_of_heapedge(src_sel_pattern);
                sel = selector_of_heapedge(src_sel_pattern);
            in let
                edges = heapedges_by_srcnode_sel(src,sel,in_Graph);
            in
                [rg !! (_,_,dest) as edge <-- edges,
                 rg <- rec_transform_heapedges(
                       heapedge_subtract(in_Graph, edges),
                       union(startnodes, {dest}),
                       union(res_Graph, {edge})
                     )]
        endif;


// AUXILIARY FUNCTIONS FOR TRANSFORMATION INTO SET OF GRAPHS

shapeGraph_list_member::ShapeGraph,ShapeGraphList->bool;
shapeGraph_list_member(a,b:c) = if a=b then true else shapeGraph_list_member(a,c) endif;
shapeGraph_list_member(a,[])  = false;


mk_unique_shapeGraph_list::ShapeGraphList->ShapeGraphList;
mk_unique_shapeGraph_list([])  = [];
mk_unique_shapeGraph_list(a:b) =
    if shapeGraph_list_member(a,b) then
        mk_unique_shapeGraph_list(b)
    else 
        a: mk_unique_shapeGraph_list(b)
    endif;

// all ev that originiate from <var>
stackedges_by_var::str,StackEdgeSet->StackEdgeSet;
stackedges_by_var(var,edges) = {e !! (v,_) as e <-- edges, if v = var};

// all ev that originate from any of <vars>
stackedges_by_vars::VarSet,StackEdgeSet->StackEdgeSet;
stackedges_by_vars(vars,edges) = {e !! (_,n) as e <-- edges, if !(intersect(vars,n) = {})};

// all ev that point to <node>
stackedges_by_heapnode::VarSet,StackEdgeSet->StackEdgeSet;
stackedges_by_heapnode(node,edges) = {e !! (_,n) as e <-- edges, if n = node};

vars_by_stackedges::StackEdgeSet->StrList;
vars_by_stackedges(EV) = mk_unique_str_list([v !! (v,n) <-- EV]);

stackedge_subtract::StackEdgeSet,StackEdgeSet -> StackEdgeSet;
stackedge_subtract(S1,S2) = {x!!x<--S1, if !(x ? S2)};

heapedge_subtract::HeapEdgeSet,HeapEdgeSet -> HeapEdgeSet;
heapedge_subtract(S1,S2) = {x!!x<--S1, if !(x ? S2)};



heapedges_by_srcnode::VarSet,HeapEdgeSet -> HeapEdgeSet;
heapedges_by_srcnode(src,edges) = {e !! (s,_,_) as e <-- edges, if s = src};

heapedges_by_srcnode_sel::VarSet,str,HeapEdgeSet -> HeapEdgeSet;
heapedges_by_srcnode_sel(src,sel,edges) = {e !! (srcx,selx,_) as e <-- edges, if srcx = src && selx = sel};

srcnode_of_heapedge::HeapEdge->VarSet;
srcnode_of_heapedge((src,_,_)) = src;

selector_of_heapedge::HeapEdge->str;
selector_of_heapedge((_,sel,_)) = sel;

//es_extract_dest::HeapEdge->VarSet;
//es_extract_dest((_,_,dest)) = dest;

reachable_heapedges::NodeSet,HeapEdgeSet -> HeapEdgeSet;
reachable_heapedges(nodes, es) =
  flatten_heapedge_set({heapedges_by_srcnode(src, es) !! src <-- reachable_heapnodes(nodes,es)});

reachable_heapnodes::NodeSet,HeapEdgeSet -> NodeSet;
reachable_heapnodes(nodes,es) =
    let
        new_nodes = union({dest !! (src,_,dest) <-- es, if src ? nodes}, nodes);
    in
        if nodes != new_nodes then reachable_heapnodes(new_nodes,es) else new_nodes endif;

flatten_heapedge_set::HeapEdgeSetSet -> HeapEdgeSet;
flatten_heapedge_set(sets) = rec_flatten_heapedge_set([s !! s <-- sets],{});

rec_flatten_heapedge_set::HeapEdgeSetList,HeapEdgeSet -> HeapEdgeSet;
rec_flatten_heapedge_set(    [],set) = set;
rec_flatten_heapedge_set(s:sets,set) = rec_flatten_heapedge_set(sets, union(set,s));



// -- rest --

//extract_ES :: ShapeGraph->HeapEdgeSet;
//extract_ES(((_,es),_)) = es;

//extract_IS :: ShapeGraph -> NodeSet;
//extract_IS((_,IS)) = IS;

emptylist :: -> ShapeGraphList;
emptylist() = [];

// ----------------------------
// is_may_alias / is_must_alias
// -----------------------------

test_alias :: dfi -> str;
test_alias(lifted_g) = let g = drop(lifted_g); in "<need two expressions to compare>";

is_no_alias :: Expression,Expression,dfi -> bool;
is_no_alias(a,b,lifted_sgs) = !is_may_alias(a,b,lifted_sgs);

is_may_alias :: Expression,Expression,dfi -> bool;
is_may_alias(a,b,lifted_sgs) = let g = drop(lifted_sgs); in is_same_node("may",a,b,g);

is_must_alias :: Expression,Expression,dfi -> bool;
is_must_alias(a,b,lifted_sgs) = let g = drop(lifted_sgs); in is_same_node("must",a,b,g);

is_same_node :: str,Expression,Expression,ShapeGraph -> bool;
is_same_node(may_or_must,a,b,(_,is0) as sg) =
    let 
        atail = get_tail_node(a,sg);
        btail = get_tail_node(b,sg);
    in
        if may_or_must = "may" then cmp_may(atail,btail,is0) else cmp_must(atail,btail) endif;

cmp_must :: NodeTuple,NodeTuple -> bool;
cmp_must((ay,az),(by,bz)) =
    if az = {} && bz = {} then
        ay != {"0$dummyvar"} && ay = by
    else
        if az = {"0$dummyvar"} || bz = {"0$dummyvar"} then false else az = bz endif
    endif;

cmp_may :: NodeTuple,NodeTuple,NodeSet -> bool;
cmp_may((ay,az),(by,bz),is0) =
    if az = {} && bz = {} then
        if {} ? is0 then true else ay != {"0$dummyvar"} && ay = by endif
    else
        if az = {"0$dummyvar"} || bz = {"0$dummyvar"} then false else az = bz endif
    endif;

node_by_var :: str,ShapeGraph -> VarSet;
node_by_var(x,((S0,_),_) as g) = hd([nk !! (k,nk) <-- S0, if (k=x)]);

get_tail_node :: Expression, ShapeGraph -> NodeTuple;
get_tail_node(e, sg) = rec_get_tail_node(e, expr_depth(e), sg, {"0$dummyvar"}, {"0$dummyvar"});

rec_get_tail_node :: Expression, snum, ShapeGraph, VarSet, VarSet -> NodeTuple;
rec_get_tail_node(_, 0, _, prev, act) = (prev,act);
rec_get_tail_node(e, e_cursor, g, prev, act) =
    let next = case expr_at(e,e_cursor) of
        // <act>.sel
        DotExp(PointerDerefExp(_),VarRefExp(na_sel)) =>
            node_by_src_sel(act,val-aststring(na_sel),g);

        // x.sel
        ArrowExp(VarRefExp(na_x),VarRefExp(na_sel)) =>
            node_by_src_sel(node_by_var(val-aststring(na_x),g), val-aststring(na_sel),g);

        // x
        VarRefExp(na_x) =>
            node_by_var(val-aststring(na_x),g);
          
        _ =>
            print("can not parse Expr: ")
            print(expr_at(e,e_cursor))
            print("\n")
            {"0$dummyvar"};
    endcase; in
    rec_get_tail_node(e, e_cursor - 1, g, act, next);

node_by_src_sel :: VarSet,str,ShapeGraph -> VarSet;
node_by_src_sel(x,sel,((_,H0),_)) = hd([nk !! (x1,sel1,nk) <-- H0, if x1 = x && sel1 = sel]);


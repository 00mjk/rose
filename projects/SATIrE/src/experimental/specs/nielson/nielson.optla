/* Author: Viktor Pavlu
   E-mail: e0425543@student.tuwien.ac.at
   Year  : 2006
*/

UNIVERSAL
kill_norm_temps : bool#

BLOCK
label: snum#

PROBLEM nielson
    direction : forward
    carrier   : dfi
    init      : bot
    init_start: lift({(({},{}),{})})
    equal     : eq
    combine   : comb
    retfunc   : comb
    widening  : w

TRANSFER

ExprStatement(ExpressionRoot(e)),_: expression(e,str(label),@);

ArgumentAssignment(VarRefExp(na_l),NewExp(_,_,_)),_:
let
    rx = val-aststring(na_l);
in
    lift(tassign_x_new(rx,drop(@)));

ArgumentAssignment(VarRefExp(na_l),VarRefExp(na_r)),_:
let
    rx = val-aststring(na_l);
    ry = val-aststring(na_r);
in
    lift(tassign_x_y(rx,ry,drop(@)));

ParamAssignment(VariableSymbol(na_l),VariableSymbol(param)),_:
let
    rx = val-aststring(na_l);
    ry = val-aststring(param);
in
    delete_var(lift(tassign_x_y(rx,ry,drop(@))),ry);

ReturnAssignment(VariableSymbol(na_l),VariableSymbol(na_r)),_:
let
    rx = val-aststring(na_l);
    ry = val-aststring(na_r);
in
    let
    newinfo=lift(tassign_x_y(rx,ry,drop(@)));
in
    delete_var(newinfo,ry);

FunctionExit(functionName,params), _:
    kill_vars(@, params);

UndeclareStmt(vars), _:
    kill_vars(@, vars);

_,_: @;


SUPPORT

eq(a,b) = a=b;

w::dfi,dfi->dfi;
w(a,b) = b;

comb::dfi,dfi->dfi;
comb(a,b) = a lub b;

//
// remove variables from shapegraph
//

kill_vars :: dfi, *VariableSymbolNT -> dfi;
kill_vars(s, [!]) = s;
kill_vars(s, VariableSymbol(p)::ps) =
     delete_var(kill_vars(s, ps),val-aststring(p));

delete_var::dfi,str->dfi;
delete_var(g,var) = 
    case g of
        top  => top;
        bot  => bot;
        info => lift(tassign_x_null(var,drop(info)));
    endcase;

/* Author: Viktor Pavlu
   E-mail: e0425543@student.tuwien.ac.at
   Year  : 2006
*/

should_trace::str->bool;
should_trace("stmt")  = false;    //source code statements
should_trace("graph") = false;    //shape graph
should_trace("norm")  = false;    //intermediate assignments for normalisation
should_trace("lowl") =  false;    //lowest transfer functions
should_trace(_) = false;

trace_stmt :: str,Expression,Expression -> bool;
trace_stmt(label, lhs, rhs) = if should_trace("stmt") then print("    ") print(lhs) print(" = ") print(rhs) print("\n") true else false endif;

trace_assign :: str,str,ShapeGraphSet -> bool;
trace_assign(lhs, rhs, sgs) = if should_trace("norm") then print ("        ") print(lhs) print(" = ") print(rhs) print (": ") print_graphs("        ",sgs) else false endif;

trace_transfer :: str,ShapeGraphSet -> bool;
trace_transfer(label, gs) = if should_trace("lowl") then print_graphs("            ".label.": ", gs) else false endif;

print_graphs :: str,ShapeGraphSet -> bool;
print_graphs(label,gs) = {print_graph(label,g) !! g <-- gs} != {};

print_graph :: str,ShapeGraph -> bool;
print_graph(label,g) = print(label) print(g) print("\n") true;

is_temp :: str -> bool;
is_temp(s) = substr(s, 0, 0) = "$";

// --------------------------------------------------------------------------
// highlevel functions handle normalisation and special cases using tassign()
// --------------------------------------------------------------------------

expression :: Expression,str,dfi -> dfi;
expression(_,_,bot) = bot;
expression(_,_,top) = top;
expression(e,label,lifted_gs) = 
    let result_gsv = normalise(e, label, (lifted_gs,{})); in
    case result_gsv of (result_gs, tmpvars) =>
        let g = if kill_norm_temps then 
            kill_normalisation_temps(result_gs,tmpvars)
        else
            result_gs
        endif; in
            let dummy0 = if should_trace("graph") then print_graphs("    ",drop(g)) else false endif; in
            g;
    endcase;

/* Author: Viktor Pavlu
   E-mail: e0425543@student.tuwien.ac.at
   Year  : 2006
*/

/* decomposition of arbitrary long expressions into
 * the primitive forms covered by the transfer functions
 * is performed by normalise :: expr->label->(dfi,varset) -> (dfi,varset)
 *
 * all functions in this file are source-level
 * polymorphic but not code-level polymorphic, ie the
 * source code herein does not have to be changed if the
 * carrier changes, but it has to be recompiled.
 */

// -------------------------------------
// functions for temp normalisation vars
// -------------------------------------

is_normalisation_temp :: str -> bool;
is_normalisation_temp(s) = substr(s, 0, 5) = "$norm_";

gen_normalisation_temp :: str -> str;
gen_normalisation_temp(label) = "$norm_".label."_";

kill_normalisation_temps :: dfi, VarSet -> dfi;
kill_normalisation_temps(s, varset) = let
    varlist = [ x !! x <-- varset ]; in
    kill_normalisation_temps1(s, varlist);

kill_normalisation_temps1 :: dfi, StrList -> dfi;
kill_normalisation_temps1(s, []) = s;
kill_normalisation_temps1(s, car:cdr) =
    delete_var(kill_normalisation_temps1(s,cdr),car);

// -----------------------------
// expression accessor functions
// -----------------------------

min :: snum,snum -> snum;
min(a,b) = if a < b then a else b endif;

max :: snum,snum -> snum;
max(a,b) = if a > b then a else b endif;

expr_depth :: Expression -> snum;
expr_depth(e) = case e of
    ArrowExp(VarRefExp(_),VarRefExp(_)) => 0;
    ArrowExp(child,_)                   => 1 + expr_depth(child);
    DotExp(PointerDerefExp(child),_)    => 1 + expr_depth(child);
    _                                   => 0;
endcase;


expr_is_complex :: Expression -> bool;
expr_is_complex(e) = case e of
    DotExp(PointerDerefExp(child),_) => true;
    ArrowExp(child,_)                => true;
    _                                => false;
endcase;

/*
  returns the expression at the given nesting_level 0..<expr_depth>, where
  0 ... topmost expression that contains all other expressions
  expr_depth ... innermost expression
*/
expr_at :: Expression,snum -> Expression;
expr_at(e,nesting_level) =
    let
        descending_steps = min(nesting_level, expr_depth(e));
    in
        rec_expr_at(e, descending_steps);

rec_expr_at :: Expression,snum -> Expression;
rec_expr_at(e,0) = e;
rec_expr_at(DotExp(PointerDerefExp(child),_),descending_steps) = rec_expr_at(child, descending_steps - 1);
rec_expr_at(ArrowExp(child,_),descending_steps) = rec_expr_at(child, descending_steps - 1);

expr_innermost :: Expression -> Expression;
expr_innermost(e) = expr_at(e, expr_depth(e));

// --------------------------------------
// normalisation function, calls tassign*
// --------------------------------------

normalise :: Expression,str,CarrierVarSetTuple -> CarrierVarSetTuple;
normalise(e,label,g0) =
    case e  of AssignOp(lhs,rhs) =>
        let debug0 = trace_stmt(label, lhs, rhs); in
        let     tmp = gen_normalisation_temp(label); in
        let lhs_tmp = tmp."l";
            rhs_tmp = tmp."r"; in
        let g1 = rec_normalise(lhs,expr_depth(lhs),lhs_tmp,g0); in
        let g2 = rec_normalise(rhs,expr_depth(rhs),rhs_tmp,g1); in
        perform_assign(e,lhs_tmp,rhs_tmp,g2);
    _ =>
        g0;
    endcase;

rec_normalise :: Expression,snum,str,CarrierVarSetTuple -> CarrierVarSetTuple;
rec_normalise(  _,          0,             _, gv) = gv;
rec_normalise(lhs, lhs_cursor, tmpvar_prefix, gv) =
    case gv of (lifted_g, tmpvars) =>
    case drop(lifted_g) of g0 =>
    let new_var = tmpvar_prefix . str(lhs_cursor - 1); in
    let result_gv = case expr_at(lhs,lhs_cursor) of
    
        // <new_var> = <parent_var>.sel
        DotExp(PointerDerefExp(_),VarRefExp(na_sel)) =>
        let
            parent_var = tmpvar_prefix . str(lhs_cursor);
            sel        = val-aststring(na_sel);
        in
            let g1 = tassign_x_ysel(new_var,parent_var,sel,g0); in
            let debug0 = trace_assign(new_var, parent_var.".".sel,g1); in
            (lift(g1),union(tmpvars,{new_var}));
              
        // <new_var> = x.sel
        ArrowExp(VarRefExp(na_x),VarRefExp(na_sel)) =>
        let
            x       = val-aststring(na_x);
            sel     = val-aststring(na_sel);
        in
            let g1 = tassign_x_ysel(new_var,x,sel,g0); in
            let debug0 = trace_assign(new_var, x.".".sel,g1); in
            (lift(g1),union(tmpvars,{new_var}));

        // <new_var> = x
        VarRefExp(na_x) =>
        let
            x = val-aststring(na_x);
        in
            let g1 = tassign_x_y(new_var,x,g0); in
            let debug0 = trace_assign(new_var, x,g1); in
            (lift(g1),union(tmpvars,{new_var}));
            
        _ =>
            (lifted_g,tmpvars);
    endcase; in
    rec_normalise(lhs, lhs_cursor - 1, tmpvar_prefix, result_gv);
    endcase;
    endcase;


perform_assign :: Expression,str,str,CarrierVarSetTuple -> CarrierVarSetTuple;
perform_assign(e,lhs_tmp,rhs_tmp,gv) =
    case gv of (lifted_g,tmpvars) =>
    case drop(lifted_g) of g0 =>
    case e of
   
        // x = new;
        AssignOp(VarRefExp(na_x),NewExp(_,_,_)) =>
        let 
            x = val-aststring(na_x);
        in
            let g1 = tassign_x_new(x,g0); in
            let debug0 = trace_assign(x, "<new>",g1); in
            (lift(g1),tmpvars);

        // x = null;
        AssignOp(VarRefExp(na_x),CastExp(IntVal(n),_)) =>  
        let
            x = val-aststring(na_x);
        in
            let g1 = tassign_x_null(x,g0); in
            let debug0 = trace_assign(x, "null",g1); in
            (lift(g1),tmpvars);

        // x = y;
        AssignOp(VarRefExp(na_x),VarRefExp(na_y)) => 
        let 
            x = val-aststring(na_x);
            y = val-aststring(na_y);
        in let
            g1 = tassign_x_y(x,y,g0);
        in let
            g2 = if (!is_temp(y)) then 
                g1
            else 
                drop(delete_var(lift(g1),y)) // temporary is assigned exactly once and can be eliminated
            endif;
        in let
            debug0 = trace_assign(x, y, g2); in
            (lift(g2),tmpvars);
            

        // x.sel = null;
        AssignOp(ArrowExp(VarRefExp(na_x),VarRefExp(na_sel)),CastExp(IntVal(n),_)) => 
        let
            x   = val-aststring(na_x);
            sel = val-aststring(na_sel); 
        in 

            if (val-astint(n) = 0) then 
                let g1 = tassign_xsel_null(x,sel,g0); in
                let debug0 = trace_assign(x.".".sel, "null", g1); in
                (lift(g1),tmpvars)
            else 
                let debug0 = trace_assign(x.".".sel, "null", {}); in
                (mybot(),tmpvars)
            endif;

        // ...sel = null;  NEW
        AssignOp(DotExp(PointerDerefExp(_),VarRefExp(na_sel)),CastExp(IntVal(n),_)) => 
        let
            x   = lhs_tmp."0";        //changed
            sel = val-aststring(na_sel);
        in 

            if (val-astint(n) = 0) then 
                let g1 = tassign_xsel_null(x,sel,g0); in
                let debug0 = trace_assign(x.".".sel, "null", g1); in
                (lift(g1),tmpvars)
            else 
                let debug0 = trace_assign(x.".".sel, "null", {}); in
                (mybot(),tmpvars)
            endif;

        // x.sel = y;
        AssignOp(ArrowExp(VarRefExp(na_x),VarRefExp(na_sel)),VarRefExp(na_y)) =>
        let
            x   = val-aststring(na_x);
            sel = val-aststring(na_sel);
            y   = val-aststring(na_y);
        in
            let g1 = tassign_xsel_null(x,sel,g0); in
            let g2 = tassign_xsel_y(x,sel,y,g1); in
            let debug0 = trace_assign(x.".".sel, "null", g1); in
            let debug1 = trace_assign(x.".".sel,      y, g2); in
            (lift(g2),tmpvars);

        // ...sel = y; NEW
        AssignOp(DotExp(PointerDerefExp(_),VarRefExp(na_sel)),VarRefExp(na_y)) =>
        let
            x   = lhs_tmp."0";
            sel = val-aststring(na_sel);
            y   = val-aststring(na_y);
        in
            let g1 = tassign_xsel_null(x,sel,g0); in
            let g2 = tassign_xsel_y(x,sel,y,g1); in
            let debug0 = trace_assign(x.".".sel, "null", g1); in
            let debug1 = trace_assign(x.".".sel,      y, g2); in
            (lift(g2),tmpvars);

        // x = y.sel;
        AssignOp(VarRefExp(na_x),ArrowExp(VarRefExp(na_y),VarRefExp(na_sel))) => 
        let
            x   = val-aststring(na_x);
            y   = val-aststring(na_y); 
            sel = val-aststring(na_sel);
        in
            let g1 = tassign_x_ysel(x,y,sel,g0); in
            let debug0 = trace_assign(x, y.".".sel,g1); in
            (lift(g1),tmpvars);

        // x = ...sel; NEW
        AssignOp(VarRefExp(na_x),DotExp(PointerDerefExp(_),VarRefExp(na_sel))) => 
        let
            x   = val-aststring(na_x);
            y   = rhs_tmp."0";       //changed
            sel = val-aststring(na_sel);
        in
            let g1 = tassign_x_ysel(x,y,sel,g0); in
            let debug0 = trace_assign(x, y.".".sel,g1); in
            (lift(g1),tmpvars);

        // x.sel = y.sel; NEW
        AssignOp(ArrowExp(VarRefExp(na_x),VarRefExp(na_xsel)),ArrowExp(VarRefExp(na_y),VarRefExp(na_ysel))) =>
        let
            x    = val-aststring(na_x);
            xsel = val-aststring(na_xsel);
            y    = val-aststring(na_y);
            ysel = val-aststring(na_ysel);
        in
            let g1 = tassign_x_ysel(rhs_tmp."a",y,ysel,g0); in
            let g2 = tassign_xsel_y(x,xsel,rhs_tmp."a",g1); in
            let debug0 = trace_assign(rhs_tmp."a", y.".".ysel,g1); in
            let debug1 = trace_assign(x.".".xsel, rhs_tmp."a",g2); in
            (lift(g2),union(tmpvars,{rhs_tmp."a"}));
            
        // ...sel = y.sel; NEW
        AssignOp(DotExp(PointerDerefExp(_),VarRefExp(na_xsel)),ArrowExp(VarRefExp(na_y),VarRefExp(na_ysel))) =>
        let
            x    = lhs_tmp."0";        //changed
            xsel = val-aststring(na_xsel);
            y    = val-aststring(na_y);
            ysel = val-aststring(na_ysel);
        in
            let g1 = tassign_x_ysel(rhs_tmp."a",y,ysel,g0); in
            let g2 = tassign_xsel_y(x,xsel,rhs_tmp."a",g1); in
            let debug0 = trace_assign(rhs_tmp."a", y.".".ysel,g1); in
            let debug1 = trace_assign(x.".".xsel, rhs_tmp."a",g2); in
            (lift(g2),union(tmpvars,{rhs_tmp."a"}));

        // x.sel = ...sel; NEW
        AssignOp(ArrowExp(VarRefExp(na_x),VarRefExp(na_xsel)),DotExp(PointerDerefExp(_),VarRefExp(na_ysel))) =>
        let
            x    = val-aststring(na_x);
            xsel = val-aststring(na_xsel);
            y    = rhs_tmp."0";        //changed
            ysel = val-aststring(na_ysel);
        in
            let g1 = tassign_x_ysel(rhs_tmp."a",y,ysel,g0); in
            let g2 = tassign_xsel_y(x,xsel,rhs_tmp."a",g1); in
            let debug0 = trace_assign(rhs_tmp."a", y.".".ysel,g1); in
            let debug1 = trace_assign(x.".".xsel, rhs_tmp."a",g2); in
            (lift(g2),union(tmpvars,{rhs_tmp."a"}));
            
        // ...sel = ...sel; NEW
        AssignOp(DotExp(PointerDerefExp(_),VarRefExp(na_xsel)),DotExp(PointerDerefExp(_),VarRefExp(na_ysel))) =>
        let
            x    = lhs_tmp."0";         //changed
            xsel = val-aststring(na_xsel);
            y    = rhs_tmp."0";         //changed
            ysel = val-aststring(na_ysel);
        in
            let g1 = tassign_x_ysel(rhs_tmp."a",y,ysel,g0); in
            let g2 = tassign_xsel_y(x,xsel,rhs_tmp."a",g1); in
            let debug0 = trace_assign(rhs_tmp."a", y.".".ysel,g1); in
            let debug1 = trace_assign(x.".".xsel, rhs_tmp."a",g2); in
            (lift(g2),union(tmpvars,{rhs_tmp."a"}));

        _ => (lift(g0),tmpvars);

    endcase;
    endcase;
    endcase;

/* Author: Markus Schordan
   E-mail: markus@complang.tuwien.ac.at
   Year  : 2006
*/

// ------------------------------------------------------------------------
// High-level functions that only pass through (for consistency in calling)
// ------------------------------------------------------------------------

tassign_x_null::str,ShapeGraphSet -> ShapeGraphSet;
tassign_x_null(x,sg) = assign_x_null(x,sg);

tassign_xsel_null::str,str,ShapeGraphSet -> ShapeGraphSet;
tassign_xsel_null(x,sel,sg) = assign_xsel_null(x,sel,sg);

// ---------------------------------------------------------------------
// High-level functions, creating temporaries for handling special cases
// ---------------------------------------------------------------------

// x = y;
tassign_x_y::str,str,ShapeGraphSet -> ShapeGraphSet;
tassign_x_y(x,y,G) =
  if x = y then
    G
  else
    let dummy0 = trace_transfer("tassign_x_y(".x.",".y.")", G); in
    let G1=assign_x_y("_$",y,G); in
    let dummy1 = trace_transfer("_$ = ".y, G1); in
    let G2=assign_x_null(x,G1); in
    let dummy2 = trace_transfer(x." = null", G2); in
    let G3=assign_x_y(x,"_$",G2); in
    let dummy3 = trace_transfer(x." = _$", G3); in
    let G4=assign_x_null("_$",G3); in
    let dummy4 = trace_transfer(x." = null", G4); in
    G4
  endif; 

// x.sel = y;
tassign_xsel_y::str,str,str,ShapeGraphSet -> ShapeGraphSet;
tassign_xsel_y(x,selp,y,G) =
  let dummy0 = trace_transfer("tassign_xsel_y(".x.",".selp.",".y.")", G); in
  let G1=assign_x_y("_$",y,G); in
  let dummy1 = trace_transfer("_$ = ".y, G1); in
  let G2=assign_xsel_null(x,selp,G1); in
  let dummy2 = trace_transfer(x.".".selp." = null", G2); in
  let G3=assign_xsel_y(x,selp,"_$",G2); in
  let dummy3 = trace_transfer(x.".".selp." = _$", G3); in
  let G4=assign_x_null("_$",G3); in
  let dummy4 = trace_transfer("_$ = null", G4); in
  G4;

// x = y.sel;
tassign_x_ysel::str,str,str,ShapeGraphSet -> ShapeGraphSet;
tassign_x_ysel(x,y,selp,G) =
  let dummy0 = trace_transfer("tassign_x_ysel(".x.",".y.",".selp.")", G); in
  let G1=assign_x_ysel("_$",y,selp,G); in
  let dummy1 = trace_transfer("_$ = ".y.".".selp, G1); in
  let G2=assign_x_null(x,G1); in
  let dummy2 = trace_transfer(x." = null", G2); in
  let G3=assign_x_y(x,"_$",G2); in
  let dummy3 = trace_transfer(x." = ".y, G3); in
  let G4=assign_x_null("_$",G3); in
  let dummy4 = trace_transfer("_$ = null", G4); in
  G4;

// x = new;
tassign_x_new::str,ShapeGraphSet -> ShapeGraphSet;
tassign_x_new(x,G) =
  let dummy0 = trace_transfer("tassign_x_new(".x.")", G); in
  let G1=assign_x_null(x,G); in
  let dummy1 = trace_transfer(x." = null", G1); in
  let G2=assign_x_new(x,G1); in
  let dummy2 = trace_transfer(x." = new", G2); in
  G2;

// x.sel = new;
tassign_xsel_new::str,str,ShapeGraphSet -> ShapeGraphSet;
tassign_xsel_new(x,selp,G) =
  let dummy0 = trace_transfer("tassign_xse_new(".x.",".selp.")", G); in
  let G1=assign_xsel_null(x,selp,G); in
  let dummy1 = trace_transfer(x.".".selp." = null", G1); in
  let G2=assign_x_new("_$",G1); in
  let dummy2 = trace_transfer(x." = new", G2); in
  let G3=assign_xsel_y(x,selp,"_$",G2); in
  let dummy3 = trace_transfer(x.".".selp." = _$", G3); in
  let G4=assign_x_null("_$",G3); in
  let dummy4 = trace_transfer("_$ = null", G4); in
  G4;

// --------------------------------------------------------------
// transfer function F(SGS)[...] = union( f(SG)[...] | SG <- SGS)
// F operates on a set of shapegraphs, calls f() for each graph
// of the argument. each call to f() returns a set of graphs that
// are then combined to form the result of F
// --------------------------------------------------------------

// x = null;
assign_x_null::str,ShapeGraphSet -> ShapeGraphSet;
assign_x_null(x,g0) = sgs_flatten([fassign_x_null(x,g) !! g <-- g0]);

// x.sel = null;
assign_xsel_null::str,str,ShapeGraphSet -> ShapeGraphSet;
assign_xsel_null(x,sel,g0) = sgs_flatten([fassign_xsel_null(x,sel,g) !! g <-- g0]);

// x = new
assign_x_new::str,ShapeGraphSet -> ShapeGraphSet;
assign_x_new(x,g0) = sgs_flatten([fassign_x_new(x,g) !! g <-- g0]);

// x = y;
assign_x_y::str,str,ShapeGraphSet -> ShapeGraphSet;
assign_x_y(x,y,g0) = sgs_flatten([fassign_x_y(x,y,g) !! g <-- g0]);

// x.sel = y;
assign_xsel_y::str,str,str,ShapeGraphSet -> ShapeGraphSet;
assign_xsel_y(x,selp,y,g0) = sgs_flatten([fassign_xsel_y(x,selp,y,g) !! g <-- g0]);
  
// x = y.sel;
assign_x_ysel::str,str,str,ShapeGraphSet -> ShapeGraphSet;
assign_x_ysel(x,y,selp,g0) = sgs_flatten([fassign_x_ysel(x,y,selp,g) !! g <-- g0]);

sgs_flatten :: ShapeGraphSetList -> ShapeGraphSet;
sgs_flatten(l) = rec_sgs_flatten(l,{});

rec_sgs_flatten :: ShapeGraphSetList,ShapeGraphSet -> ShapeGraphSet;
rec_sgs_flatten(     [], sgs) = sgs;
rec_sgs_flatten(car:cdr, sgs) = rec_sgs_flatten(cdr, union(car,sgs));

// ----------------------------------------------------------------------
// Low-level functions, without temporaries (do not handle special cases)
// ----------------------------------------------------------------------

fassign_x_null :: str,ShapeGraph -> ShapeGraphSet;
fassign_x_null(x,g) =
  {kill_x(x,g)};

fassign_xsel_null :: str,str,ShapeGraph -> ShapeGraphSet;
fassign_xsel_null(x,s,((S0,H0),is0) as g) =
  if !var_exists(x,g) || !var_sel_exists(x,s,g) then {g} else 
  // edge (nx,sel,nu) is guaranteed to be in H0 and must be removed
  let edge = heapedge_by_var_sel(x,s,H0); in
  case edge of (nx,sel,nu) =>
    let
      S1 = S0;
      H1 = {e !! (nv,sel1,nw) as e <-- H0, if !(nx=nv && sel=sel1)};
    in let
      /* if
       *  - nu was shared and
       *  - there is no ({},_,nu) edge and
       *  - there is no more than one (_,_,nu) edge then
       * nu is no longer shared.
       * otherweise is0 remains unchanged
       */
      is1 = if (nu ? is0)
            && !many_into(nu,H1)
            && {} = {e     !! (nk,_,nl) as e <-- H1, if (nk={}) && (nl=nu)} then
              is0 # nu
            else
              is0
            endif;
      in
        {((S1,H1),is1)};
  endcase
  endif;

fassign_x_new :: str,ShapeGraph -> ShapeGraphSet;
fassign_x_new(x,((S0,H0),is0) as g) =
  {((union(S0,{(x,{x})}),H0),is0)};

fassign_x_y :: str,str,ShapeGraph -> ShapeGraphSet;
fassign_x_y(x,y,((S0,H0),is0) as g) = 
  let
    S1  = union(
           {(z,gxy(x,y,nz)) !! (z,nz) <-- S0},                   // add x to all edges where y is already
           {(x,gxy(x,y,ny)) !! (y1,ny) <-- S0, if (y1 = y)});      // add a new edge (x,{x,y,...}) to where y pointed to
    H1  = {(gxy(x,y,nv),sel,gxy(x,y,nw)) !! (nv,sel,nw) <-- H0}; // add x to all edges where y is already
    is1 = {gxy(x,y,nz) !! nz <-- is0};
  in
  {((S1,H1),is1)};

fassign_xsel_y :: str,str,str,ShapeGraph -> ShapeGraphSet;
fassign_xsel_y(x,sel,y,((S0,H0),is0) as g) = 
  if !var_exists(x,g) || !var_exists(y,g) then {g} else
  let
    nx = node_by_var(x,g);
    ny = node_by_var(y,g);
  in
  let H1  = union(H0, {(nx,sel,ny)}); in
  let is1 = if many_into(ny,H1) then union(is0,{ny}) else is0 endif;
  in {((S0,H1),is1)}
  endif;

fassign_x_ysel :: str,str,str,ShapeGraph -> ShapeGraphSet;
fassign_x_ysel(x,y,sel,((S0,H0),is0) as g) = // it is guaranteed that x!=y
  /* three possibilities:
   * - there is no (_,{y,...}) <- S or no ({y,...},sel,_) <- H
   * - there is (_,{y,...}) <- S and ({y,...},sel,dest) <- H where dest != {}
   * - there is (_,{y,...}) <- S and ({y,...},sel,{}) <- H
   */
  if !var_exists(y,g) then
    // case 1: null dereferencing
    {g}
  else if !var_sel_exists(y,sel,g) then
    // case 1: non-existing selector
    {g}
  else
    case heapedge_by_var_sel(y,sel,H0) of
      (ny,_,{}) =>  // case 3
        materialise(x,y,sel,g);
      (ny,_,nu) => // case 2
        let
          // rename the location nu to include {x} and add the binding (x,union(nu,{x}))
          S1  = union({(z,hxu(x,nu,nz)) !! (z,nz) <-- S0}, {(x,hxu(x,nu,nu))});
          H1  = {(hxu(x,nu,nv),sel1,hxu(x,nu,nw)) !! (nv,sel1,nw) <-- H0};
          is1 = {hxu(x,nu,nz) !! nz <-- is0};
        in {((S1,H1),is1)};
    endcase
  endif
  endif;

materialise :: str,str,str,ShapeGraph -> ShapeGraphSet;
materialise(x,y,sel,((S0,H0),is0) as g) = 
  let
    S1         = union(S0,{(x,{x})});
    Hextern    = {e !! (v1,sel1,w1) as e <-- H0, if v1 != {} && w1 != {}};
    is1        = is0 # {};
  in let
    Hintern    = [e !! e <-- heapedge_subtract(H0,Hextern)];
  in let
    candidates = if {} ? is0 then
      sgs_flatten([gen_cand(x,S1,Hextern,Hintern,union(is1,is_shared)) !! is_shared <-- { {{}}, {{x}}, {{x},{}} } ])
    else
        gen_cand(x,S1,Hextern,Hintern,is0)
    endif;
  in 
    {sg !! ((S2,H2),is2) as sg <-- candidates, if is_compatible(sg) && kill_x(x,sg) = ((S0,H0),is0) && (x,{x}) ? S2 && ({y},sel,{x}) ? H2};


gen_cand :: str,StackEdgeSet,HeapEdgeSet,HeapEdgeList,NodeSet -> ShapeGraphSet;
gen_cand(x,S,H,(_,sel,_) as edge:cdr,is0) =
  let Hn = case edge of
    ({},_,{}) => 
      if {x} ? is0 then
        {
          {( {},sel, {})},
          {( {},sel,{x})},
          {({x},sel, {})},
          {({x},sel,{x})},

          {( {},sel, {}),( {},sel,{x})},
          {( {},sel, {}),({x},sel, {})},
          {( {},sel, {}),({x},sel,{x})},
          {( {},sel,{x}),({x},sel, {})},
          {( {},sel,{x}),({x},sel,{x})},
          {({x},sel,{x}),({x},sel, {})},
          
          {({},sel, {}),( {},sel,{x}),({x},sel, {})},
          {({},sel, {}),( {},sel,{x}),({x},sel,{x})},
          {({},sel, {}),({x},sel, {}),({x},sel,{x})},
          {({},sel,{x}),({x},sel,{x}),({x},sel, {})},
          
          {({},sel,{}),({},sel,{x}),({x},sel,{}),({x},sel,{x})}
        }
      else
        {
          {( {},sel, {})},
          {({x},sel, {})},

          {( {},sel, {}),({x},sel, {})}
        }
      endif;

    ({},_,y) =>
      if y ? is0 then
        {
          {( {},sel,y)},
          {({x},sel,y)},
          {( {},sel,y),({x},sel,y)}
        }
      else
        {
          {( {},sel,y)},
          {({x},sel,y)}
        }
      endif;

    (y,_,{}) =>
        {
          {(y,sel,{})},
          {(y,sel,{x})},
          {(y,sel,{x}), (y,sel,{})}
        };

  endcase; in
    sgs_flatten([gen_cand(x,S,union(H,new_edge),cdr,is0) !! new_edge <-- Hn]);

gen_cand(_,S,H,[],is0) = {((S,H),is0)};


// ----------------------------------------------------
// Auxiliary functions for low-level transfer functions
// ----------------------------------------------------

is_compatible :: ShapeGraph -> bool;
is_compatible(((S0,H0),is0) as g) =
  let alocs = union(union(aloc_S([x !! x <-- S0],{}), aloc_H([x !! x <-- H0],{})), is0); in
  check_inv1([(a,b) !! a <-- alocs, b <-- alocs]) &&
  // Inv2: if x points to a node, the nodes name must contain x (naming convention)
  {(x,nx) !! (x,nx) <-- S0, if x ? nx} = S0 &&
  check_inv3([((nv,sel,nw),(nv1,sel1,nw1)) !! (nv,sel,nw) <-- H0, (nv1,sel1,nw1) <-- H0, if nv = nv1 && sel = sel1 && nv != {}]) &&
  check_inv4([x !! x <-- is0],H0) &&
  check_inv5([nx1 !! (nv1,sel1,nx1) <-- H0, (nv2,sel2,nx2) <-- H0, if nx1 = nx2 && (sel1 != sel2 || nv1 != nv2) && nx1 != {}],is0);
  
aloc_S :: StackEdgeList,NodeSet -> NodeSet;
aloc_S((_,v):cdr,nodes) = aloc_S(cdr, union(nodes,{v}));
aloc_S(       [],nodes) = nodes;

aloc_H :: HeapEdgeList,NodeSet -> NodeSet;
aloc_H((v,_,v1):cdr,nodes) = aloc_H(cdr, union(nodes, {v,v1}));
aloc_H(          [],nodes) = nodes;

// Inv1: two nodes a,b are either the same or have no common variables */
check_inv1 :: NodeTupleList -> bool;
check_inv1((a,b):cdr) = if (a = b) || (intersect(a,b) = {}) then check_inv1(cdr) else false endif;
check_inv1(       []) = true;

// Inv3: nv,sel,nw  and  nv,sel,nw1: either nw and nw1 are the same node or nv 
// is the summary node. no node,sel pair may point to more than one node
// except the source is the summary node
check_inv3 :: HeapEdgeTupleList -> bool;
check_inv3(((nv,sel,nw),(nv1,sel1,nw1)):cdr) = if (nw = nw1) then check_inv3(cdr) else false endif;
check_inv3(         []) = true;

// Inv4: if nx is shared, there exists either {},sel,nx or 2+ edges pointing to nx */
check_inv4 :: NodeList, HeapEdgeSet -> bool;
check_inv4(nx:cdr, H) = 
  if 
    ({e !! (n1,_,m1) as e <-- H, if n1 = {} && m1 = nx} != {}) ||
    ({e !! (n2,sel2,m2) as e <-- H, (n3,sel3,m3) <-- H, if (m2 = m3) && ((sel2 != sel3) || (n2 != n3))} != {})
  then check_inv4(cdr,H) else false endif;
check_inv4(     [],_) = true;

// Inv5: if nv,sel,nx and nv1,sel1,nx are in the shapegraph, then nx is shared */
check_inv5 :: NodeList,NodeSet -> bool;
check_inv5(nx:cdr, shared) = if nx ? shared then check_inv5(cdr,shared) else false endif;
check_inv5(    [],      _) = true;


mybot::->dfi; 
mybot() = bot;

kill_x :: str,ShapeGraph -> ShapeGraph;
kill_x(x,((S0,H0),is0)) = let 
  S1  = {(z,rem(x,nz)) !! (z,nz) <-- S0, if !(z=x)}; 
  H1  = {(rem(x,nv),sel,rem(x,nw)) !! (nv,sel,nw) <-- H0};
  is1 = {rem(x,nx) !! nx <-- is0};
  in ((S1,H1),is1);

// remove x from Z  (called kx in Nielson)
rem :: str,VarSet -> VarSet;
rem(x,Z) = Z # x;
//rem(x,Z) = {v !! v <-- Z, if !(x=v) };

// add x to Z if y is already there
gxy :: str,str,VarSet -> VarSet;
gxy(x,y,Z) = if (y ? Z) then union(Z,{x}) else Z endif;

// add x to U if U = Z
hxu :: str,VarSet,VarSet -> VarSet;
hxu(x,U,Z) = if (Z = U) then union(U,{x}) else Z endif;

node_by_var :: str,ShapeGraph -> VarSet;
node_by_var(x,((S0,_),_) as g) = first_node([nk !! (k,nk) <-- S0, if (k=x)]);

many_into :: VarSet,HeapEdgeSet -> bool;
many_into(nu,edges) =
  !({} = {"two or more" !! (p1,s1,q1) <-- edges, (p2,s2,q2) <-- edges,
         if ((q1 = nu) && (q2 = nu) && !(p1=p2 && s1=s2))});
                              
var_exists :: str,ShapeGraph -> bool;
var_exists(x,((S0,_),_)) =  !({e !! (y,ny) as e <-- S0, if (x=y)} = {});

var_sel_exists :: str,str,ShapeGraph -> bool;
var_sel_exists(x,sel,((_,H0),_)) = !({e !! (nv,sv,_) as e <-- H0, if (x ? nv) && (sv = sel)} = {});

heapedge_by_var_sel :: str,str,HeapEdgeSet -> HeapEdge;
heapedge_by_var_sel(x,sel,edges) = first_heapedge([e !! (nv,sv,_) as e <-- edges, if (x ? nv) && (sv = sel)]);


/* Author: Viktor Pavlu
   E-mail: e0425543@student.tuwien.ac.at
   Year  : 2006
*/

// ----------------------------------------------------------------------
// SUPPORT FUNCTIONS
// CALLED BY APPLICATION

extract_stackedge_set :: ShapeGraph->StackEdgeSet;
extract_stackedge_set(((ev,_),_)) = ev;

extract_heapnodes::ShapeGraph -> NodeList;
extract_heapnodes(((ES,EH),_))  =
   [ x !! x <-- union(union({ a !! (a,_,_) <-- EH},{ c !! (_,_,c) <-- EH}),{b !! (_,b) <-- ES}) ];

extract_stackedges::ShapeGraph -> StackEdgeList;
extract_stackedges(((ES,_),_)) = [x !! x <-- ES];

extract_heapedges::ShapeGraph -> HeapEdgeList;
extract_heapedges(((_,EH),_)) = [x !! x <-- EH];

extract_is_shared::ShapeGraph -> NodeList;
extract_is_shared((_,iss)) = [x !! x <-- iss];


// AUXILIARY FUNCTIONS FOR SUPPORT FUNCTIONS

str_list_member::str,StrList->bool;
str_list_member(a,b:c) = if a=b then true else str_list_member(a,c) endif;
str_list_member(a,[])  = false;

mk_unique_str_list::StrList->StrList;
mk_unique_str_list(a:b) = if str_list_member(a,b) then mk_unique_str_list(b) else a: mk_unique_str_list(b) endif;
mk_unique_str_list([])  = [];


// ----------------------------------------------------------------------
// TRANSFORMATION FUNCTIONS:
//   transforms list of shape graphs where each selector may appear only
//   once per node (nnh) into a single shape graph where selectors may
//   point to more than one node at the same time (srw), and vice versa.

//
//  test wrappers
//

srw_extract_shapeGraphs_t :: ShapeGraph -> ShapeGraphList;
//extract_shapeGraphs_t(((ES,EH),IS)) = [x !! x <- srwSG_to_nnhSG((({("x",{"x"}),("x",{"x","y"}),("y",{"y"}),("y",{"x","y"}),("z",{"z"})},{({"x"},"next",{"z"}),({"x"},"next",{}),({},"next",{}),({"y"},"next",{})}),{}))];
//extract_shapeGraphs_t(((ES,EH),IS)) = srwSG_to_nnhSG((({("x",{"x"}),("z",{"z"}),("y",{"x","y"}),("x",{"x","y"})},{({"x"},"next",{"z"}),({"x"},"next",{}),({},"next",{}),({"y"},"next",{})}),{}));
//!!! ~/test/test1.C
srw_extract_shapeGraphs_t(x) = srw_extract_shapeGraphs(x); 

srw_extract_summaryGraph_t :: ShapeGraph -> ShapeGraphList;
//extract_summaryGraph_t(sg) = [(({("x",{"x","y"}),("y",{"y"}),("x",{"x"}),("y",{"x","y"}),("z",{"z"})},{({"x"},"next",{"z"}),({"x"},"next",{}),({},"next",{}),({"y"},"next",{})}),{})];
//extract_summaryGraph_t(sg) = [(({("x",{"x","y"}),("x",{"x"}),("y",{"x","y"}),("z",{"z"})},{({"x"},"next",{"z"}),({"x"},"next",{}),({},"next",{}),({"y"},"next",{})}),{})];
srw_extract_summaryGraph_t(sg) = srw_extract_summaryGraph(sg);


// -----------------------------------------
// functions for Sagiv/Reps/William analysis
// -----------------------------------------

//FIXME in main verwenden
//srw_extract_graphs :: ShapeGraph -> SrwNnhPair;
//srw_extract_graphs(sg) = (lift(sg),lift(srwSG_to_nnhSG(sg)));

//FIXME aus main rausnehmen
srw_extract_summaryGraph :: ShapeGraph -> ShapeGraphList;
srw_extract_summaryGraph(sg) = [sg];
srw_extract_shapeGraphs :: ShapeGraph -> ShapeGraphList;
srw_extract_shapeGraphs(sg) = [x !! x <-- srwSG_to_nnhSG(sg)];

// ---------------------------------------------
// functions for Nielson/Nielson/Hankin analysis
// ---------------------------------------------

//FIXME in main verwenden
//nielson_extract_graphs :: ShapeGraphSet -> SrwNnhPair;
//nielson_extract_graphs(sg) = (lift(nnhSG_to_srwSG(sg)), lift(sg));

//FIXME aus main rausnehmen
nielson_extract_summaryGraph :: ShapeGraphSet -> ShapeGraphList;
nielson_extract_summaryGraph(sg) = [nnhSG_to_srwSG(sg)];
nielson_extract_shapeGraphs :: ShapeGraphSet -> ShapeGraphList;
nielson_extract_shapeGraphs(sg) = [x !! x <-- sg];

// --------------------
// conversion functions
// --------------------

/*
 * converts a "Nielson/Nielson/Hankin shape graph" (a list of graphs where
 * each selector may appear at most once at a certain node) into a
 * "Sagiv/Reps/William shape graph" (a single graph where selectors
 * may point to more than one node simultaneously)
 */

nnhSG_to_srwSG :: ShapeGraphSet -> ShapeGraph;
nnhSG_to_srwSG(graphs) = rec_join_shapegraphs( (({},{}),{}), [x !! x <-- graphs]);

rec_join_shapegraphs :: ShapeGraph,ShapeGraphList -> ShapeGraph;
rec_join_shapegraphs(sg, []) = sg;
rec_join_shapegraphs(((S0,H0),is0), car:cdr) =
  case car of ((S1,H1),is1) =>
    let 
      new_S = union(S0,S1);
      new_H = union(H0,H1);
    in let
      new_is = nnh_compute_is(((new_S,new_H),union(is0,is1)));
    in
    rec_join_shapegraphs(((new_S,new_H),new_is), cdr);
  endcase;


/*
 * computes shared nodes 
 *  - Inv4: is = intersect(is, union({n !! ({},_,n)}, nodes_that_are_more_than_once_target_of_an_heapedge()))
 *  - Inv5: i s+= (nodes_that_are_mone_than_once_target_of_an_heapedge() / {})
 */
 
nnh_compute_is :: ShapeGraph -> NodeSet;
nnh_compute_is(((S,H),iss)) =
  union(
    /* Inv4: if nx is shared, then
     *  - Inv4a: ({},_,nx) must be one of the heapedges OR
     *  - Inv4b: nx must be the target of more than one heapedge
     */
    intersect(
      iss,
      union(
        {x !! x <-  dests_of_heapedges(heapedges_by_src({},H))},   // Inv 4a
        {y !! y <-- more_than_once(dests_of_heapedges(H))}         //Inv 4b
      )
    ),

    /* Inv5: nx is shared if two or more heapedges have nx as their
     * target (if nx != {})
     */
    nodes_target2plus(((S,H),iss))
  );


// nodes that are target of 2 (or more) heapedges, but not {}
nodes_target2plus :: ShapeGraph -> NodeSet;
nodes_target2plus(((_,H),_)) = more_than_once(dests_of_heapedges(H)) # {};

dests_of_heapedges :: HeapEdgeSet -> NodeList;
dests_of_heapedges(H) = [d !! (_,_,d) <-- H];

more_than_once :: NodeList -> NodeSet;
more_than_once(nodes) = rec_more_than_once(nodes,{},{});

rec_more_than_once :: NodeList,NodeSet,NodeSet -> NodeSet;
rec_more_than_once([],         _, result) = result;
rec_more_than_once(car:cdr, seen, result) = 
  if car ? seen then 
    rec_more_than_once(cdr, seen, union(result, {car}))
  else
    rec_more_than_once(cdr, union(seen, {car}), result)
  endif;




// converts a "Sagiv/Reps/William shape graph" (a single graph where selectors
// may point to more than one node simultaneously)
// into a "Nielson/Nielson/Hankin shape graph" (a set of graphs where
// each selector may point to at most one cell)

srwSG_to_nnhSG :: ShapeGraph -> ShapeGraphSet;
srwSG_to_nnhSG(((ES,EH),IS)) =
  {((ESn,EHn),IS) !!
    ESn <- transform_stackedges(ES),
    EHn <- transform_heapedges(
             reachable_heapedges({n !! (_,n) <-- ESn}, EH), // only pass reachable edges
                                 {n !! (_,n) <-- ESn})      // startnodes (reachable via ES)
    };

// -- transform the stackedges
transform_stackedges::StackEdgeSet->StackEdgeSetList;
transform_stackedges(ES) = rec_transform_stackedges(ES, {});

rec_transform_stackedges :: StackEdgeSet,StackEdgeSet -> StackEdgeSetList;
rec_transform_stackedges(      {}, res_Graph) = [res_Graph];
rec_transform_stackedges(in_Graph, res_Graph) =
  let
    var   = first(vars_by_stackedges(in_Graph));  // pick a variable var
  in let
    edges = stackedges_by_var(var,in_Graph);  // select all out-edges of var
  in
    [rg !! (_,node) as edge <-- edges, //"as edge" kann weggenommen werden
           rg <- rec_transform_stackedges(
//             stackedge_subtract(in_Graph, {edge}), //stackedges_by_vars(node,in_Graph)), //FIXME mit [b]
             stackedge_subtract(in_Graph, stackedges_by_vars(node,in_Graph)), //FIXME ohne [b]
             union(res_Graph, stackedges_by_dest(node, in_Graph))
           )];

// -- transform the heapedges
transform_heapedges::HeapEdgeSet,NodeSet->HeapEdgeSetList;
transform_heapedges(EH,startnodes) = rec_transform_heapedges(EH,startnodes,{});

rec_transform_heapedges :: HeapEdgeSet,NodeSet,HeapEdgeSet -> HeapEdgeSetList;
rec_transform_heapedges(      {},          _, res_Graph) = [res_Graph];
rec_transform_heapedges(in_Graph, startnodes, res_Graph) =
  let
    out_edges         = [e !! e <-- reachable_heapedges(startnodes, in_Graph)];
  in
    if out_edges = [] then
      [res_Graph]
    else
      let
        src_sel_pattern   = first_heapedge(out_edges);
      in let
        src               = src_of_heapedge(src_sel_pattern);
        sel               = sel_of_heapedge(src_sel_pattern);
      in let
        edges             = heapedges_by_src_sel(src,sel,in_Graph);
      in
        [rg !! (_,_,dest) as edge <-- edges,
               rg <- rec_transform_heapedges(
                       heapedge_subtract(in_Graph, edges),
                       union(startnodes, {dest}),
                       union(res_Graph, {edge})
                     )]
    endif;



// ----------------------------------------
// Auxiliary functions for graph conversion
// ----------------------------------------

first::StrList->str;
first(car:cdr) = car;

first_heapedge::HeapEdgeList->HeapEdge;
first_heapedge(car:cdr) = car;

first_node::NodeList -> VarSet;
first_node(car:cdr) = car;

shapeGraph_list_member::ShapeGraph,ShapeGraphList->bool;
shapeGraph_list_member(a,b:c) = if a=b then true else shapeGraph_list_member(a,c) endif;
shapeGraph_list_member(a,[])  = false;

mk_unique_shapeGraph_list::ShapeGraphList->ShapeGraphList;
mk_unique_shapeGraph_list(a:b) = if shapeGraph_list_member(a,b) then mk_unique_shapeGraph_list(b) else a: mk_unique_shapeGraph_list(b) endif;
mk_unique_shapeGraph_list([])  = [];


// all ev that originiate from <var>
stackedges_by_var::str,StackEdgeSet->StackEdgeSet;
stackedges_by_var(var,edges) = {e !! (v,_) as e <-- edges, if v = var};

// all ev that originate from any of <vars>
stackedges_by_vars::VarSet,StackEdgeSet->StackEdgeSet;
stackedges_by_vars(vars,edges) = {e !! (_,n) as e <-- edges, if !(intersect(vars,n) = {})};

// all stackedges that point to <node>
stackedges_by_dest::VarSet,StackEdgeSet->StackEdgeSet;
stackedges_by_dest(dest,edges) = {e !! (_,d) as e <-- edges, if d = dest};

vars_by_stackedges::StackEdgeSet->StrList;
vars_by_stackedges(ES) = mk_unique_str_list([v !! (v,n) <-- ES]);

stackedge_subtract::StackEdgeSet,StackEdgeSet -> StackEdgeSet;
stackedge_subtract(S1,S2) = {x!!x<--S1, if !(x ? S2)};

heapedge_subtract::HeapEdgeSet,HeapEdgeSet -> HeapEdgeSet;
heapedge_subtract(S1,S2) = {x!!x<--S1, if !(x ? S2)};



heapedges_by_src::VarSet,HeapEdgeSet -> HeapEdgeSet;
heapedges_by_src(src,edges) = {e !! (s,_,_) as e <-- edges, if s = src};

heapedges_by_dest::VarSet,HeapEdgeSet -> HeapEdgeSet;
heapedges_by_dest(dest,edges) = {e !! (_,_,d) as e <-- edges, if d = dest};

heapedges_by_src_sel::VarSet,str,HeapEdgeSet -> HeapEdgeSet;
heapedges_by_src_sel(src,sel,edges) = {e !! (srcx,selx,_) as e <-- edges, if srcx = src && selx = sel};

src_of_heapedge::HeapEdge->VarSet;
src_of_heapedge((src,_,_)) = src;

sel_of_heapedge::HeapEdge->str;
sel_of_heapedge((_,sel,_)) = sel;

dest_of_heapedge::HeapEdge->VarSet;
dest_of_heapedge((_,_,dest)) = dest;

reachable_heapedges::NodeSet,HeapEdgeSet -> HeapEdgeSet;
reachable_heapedges(nodes, es) =
  flatten_heapedge_set({heapedges_by_src(src, es) !! src <-- reachable_heapnodes(nodes,es)});

reachable_heapnodes::NodeSet,HeapEdgeSet -> NodeSet;
reachable_heapnodes(nodes,es) =
  let
    new_nodes = union({dest !! (src,_,dest) <-- es, if src ? nodes}, nodes);
  in
    if nodes != new_nodes then reachable_heapnodes(new_nodes,es) else new_nodes endif;

flatten_heapedge_set::HeapEdgeSetSet -> HeapEdgeSet;
flatten_heapedge_set(sets) = rec_flatten_heapedge_set([s !! s <-- sets],{});

rec_flatten_heapedge_set::HeapEdgeSetList,HeapEdgeSet -> HeapEdgeSet;
rec_flatten_heapedge_set(    [],set) = set;
rec_flatten_heapedge_set(s:sets,set) = rec_flatten_heapedge_set(sets, union(set,s));



// -- rest --

//extract_EH :: ShapeGraph->HeapEdgeSet;
//extract_EH(((_,es),_)) = es;

//extract_IS :: ShapeGraph -> NodeSet;
//extract_IS((_,IS)) = IS;

emptylist :: -> ShapeGraphList;
emptylist() = [];


// ----------------------------
// is_may_alias / is_must_alias
// -----------------------------

/*

test_alias :: dfi -> str;
test_alias(lifted_g) = let g = drop(lifted_g); in "<need two expressions to compare>"; 

is_no_alias :: Expression,Expression,dfi -> bool;
is_no_alias(a,b,lifted_sgs) = !is_may_alias(a,b,lifted_sgs);

is_may_alias :: Expression,Expression,dfi -> bool;
is_may_alias(a,b,lifted_sgs) = let sgs = drop(lifted_sgs); in {g !! g <-- sgs, if is_same_node("may",a,b,g)} != {};

is_must_alias :: Expression,Expression,dfi -> bool;
is_must_alias(a,b,lifted_sgs) = let sgs = drop(lifted_sgs); in {g !! g <-- sgs, if !is_same_node("must",a,b,g)} = {};
*/

is_same_node :: str,Expression,Expression,ShapeGraph -> bool;
is_same_node(may_or_must,a,b,(_,is0) as sg) =
  let 
    atail = get_tail_node(a,sg);
    btail = get_tail_node(b,sg);
  in
    if may_or_must = "may" then cmp_may(atail,btail,is0) else cmp_must(atail,btail) endif;

cmp_must :: NodeTuple,NodeTuple -> bool;
cmp_must((ay,az),(by,bz)) =
  if az = {} && bz = {} then
    ay != {"0$dummyvar"} && ay = by
  else
    if az = {"0$dummyvar"} || bz = {"0$dummyvar"} then false else az = bz endif
  endif;

cmp_may :: NodeTuple,NodeTuple,NodeSet -> bool;
cmp_may((ay,az),(by,bz),is0) =
  if az = {} && bz = {} then
    if {} ? is0 then true else ay != {"0$dummyvar"} && ay = by endif
  else
    if az = {"0$dummyvar"} || bz = {"0$dummyvar"} then false else az = bz endif
  endif;

get_tail_node :: Expression, ShapeGraph -> NodeTuple;
get_tail_node(e, sg) = rec_get_tail_node(e, expr_depth(e), sg, {"0$dummyvar"}, {"0$dummyvar"});

rec_get_tail_node :: Expression, snum, ShapeGraph, VarSet, VarSet -> NodeTuple;
rec_get_tail_node(_, 0, _, prev, act) = (prev,act);
rec_get_tail_node(e, e_cursor, g, prev, act) =
  let next = case expr_at(e,e_cursor) of
      // <act>.sel
      DotExp(PointerDerefExp(_),VarRefExp(na_sel)) =>
          node_by_src_sel(act,val-aststring(na_sel),g);

      // x.sel
      ArrowExp(VarRefExp(na_x),VarRefExp(na_sel)) =>
          node_by_src_sel(node_by_var(val-aststring(na_x),g), val-aststring(na_sel),g);

      // x
      VarRefExp(na_x) =>
          node_by_var(val-aststring(na_x),g);
        
      _ =>
          print("can not parse Expr: ")
          print(expr_at(e,e_cursor))
          print("\n")
          {"0$dummyvar"};
  endcase; in
    rec_get_tail_node(e, e_cursor - 1, g, act, next);


node_by_src_sel :: VarSet,str,ShapeGraph -> VarSet;
node_by_src_sel(x,sel,((_,H0),_)) = first_node([nk !! (x1,sel1,nk) <-- H0, if x1 = x && sel1 = sel]);


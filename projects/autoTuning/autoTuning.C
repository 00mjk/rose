/*!
 *
 * This is the code triage module for the empirical tuning framework. 
 *
 * It reads into the xml file generated by HPCToolKit or txt file by Gprof 
 * and annotates the AST with performance metrics from the filei. 
 *
 * The next step is code triage, which is based on the percentage of execution time of each non-scope statement.
 * A threshold is predefined, like 80%:  top hot statements account for at least 80% of execution time
 * will be specified as autotuning candidates. 
 *
 * Depending on different triage policies, several corresponding targets, mostly loops, 
 * are identified as tuning targets and outlined. 
 * It is possible two hot statements are enclosed within one target loop. 
 *
 * Liao, 1/28/2009: initial version
 * 4/29/2009: added support for gprof, new code triage based on threshold of execution percentage.
 */
#include "rose.h"
#include "autoTuningSupport.h"
#include <algorithm>

using namespace std;
using namespace GenUtil;
using namespace RoseHPCT;
using namespace Outliner;
using namespace autoTuning;

//!Customized comparison function to sort profile IR node with percentage metrics.
// sort based on percentage of exclusive wall clock
static bool compareProfNode(const RoseHPCT::IRNode* s1, const RoseHPCT::IRNode* s2)
{
  double v1, v2;
  v1 = s1->getMetricValue(m_percentage);
  v2 = s2->getMetricValue(m_percentage);
  return v1>v2; // we need decremental order:the biggest is put the first
}

int main(int argc, char * argv[]) 
{
  vector<string> argvList (argv, argv+argc);
  // recognize options for autotuning
  autotuning_command_processing(argvList);
  // options for outliner
  Outliner::commandLineProcessing(argvList);

  // Prepare AST with performance metrics attached.
  // -------------------------------------------------
  // Read into the profiling result files
  RoseHPCT::ProgramTreeList_t profiles = RoseHPCT::loadProfilingFiles(argvList);
  // Create the AST tree
  SgProject * project = frontend(argvList);
  //Attach metrics to AST , last parameter is for verbose
  RoseHPCT::attachMetrics(profiles, project,project->get_verbose()>0);

  // -------------------------------------------------
  // Find enough profile IR statement nodes exceeding a threshold for execution percentage
  //
  //x Sort profiling IR's statement nodes by percentage: descending order
  //  Have to transfer them into a container supporting random access in order to use std::sort()
  std::vector <const RoseHPCT::IRNode *> nodeVec, candidateVec;
  std::set<const RoseHPCT::IRNode *>:: const_iterator piter= RoseHPCT::profStmtNodes_.begin(); 
  for (;piter!=RoseHPCT::profStmtNodes_.end();piter++)
  {
    const RoseHPCT::IRNode * node = *piter;
    nodeVec.push_back(node);
  }
  // random access iterator is needed
  sort (nodeVec.begin(), nodeVec.end(), compareProfNode);
  // x. Find enough hot statements until a threshold is just exceeded. 
  double sum =0.0;
  for ( std::vector <const RoseHPCT::IRNode *>::const_iterator iter = nodeVec.begin(); iter!=nodeVec.end(); iter++)
  {
    //const RoseHPCT::IRNode * node = *iter;
    sum+= (*iter)->getMetricValue(m_percentage);
    if (autoTuning::enable_debug)
      cout<<"Candidate statement node:"<<(*iter)->toString()<<" "<<"sum="<<sum<<endl;
    // save stmt nodes until threshold is reached.
    ROSE_ASSERT(autoTuning::triage_threshold>0.5);
    candidateVec.push_back(*iter);
    if (sum>autoTuning::triage_threshold) 
      break;
  }

  // Find relevant SgNode matching the candidate profile statement IR nodes
  // -------------------------------------------------
  std::vector <SgNode* > candidateSgNodes; 
  for ( std::vector <const RoseHPCT::IRNode *>::const_iterator iter = candidateVec.begin(); iter!=candidateVec.end(); iter++)
  {
    std::set<SgLocatedNode *> matched_set =  RoseHPCT::profSageMap_[*iter];
    RoseHPCT::IRNode * irnode = const_cast<RoseHPCT::IRNode *> (*iter);
    // each candidate Profile IR node should have at least one matching ROSE AST node
    // if the SgProject has a SgSourceFile matching the profile node's file information
    if (matched_set.size()==0) 
    {
      RoseHPCT::Located * l = dynamic_cast<RoseHPCT::Located *> (irnode);
      ROSE_ASSERT(l);
      SgFilePtrList file_pointer_list = project->get_fileList();
      SgFilePtrList::iterator file_iter = file_pointer_list.begin();
      for (;file_iter!=file_pointer_list.end();file_iter++)
      {
        SgFile* file= *file_iter;
        if (isSgSourceFile(file))
        {
          string file_name = isSgSourceFile(file)->get_file_info()->get_filename();
          if (file_name == l->getFileNode()->getName())
          {
            cerr<<"Fatal error: cannot find a matching SgNode for a profile IR node:"<<(*iter)->toString()<<endl;
            ROSE_ASSERT(false); 
          }
        }
      }
    }
    // not stable ?
    //std::copy(matched_set.begin(), matched_set.end(), back_inserter(candidateSgNodes));
    for (std::set<SgLocatedNode *>::const_iterator src=matched_set.begin(); src!=matched_set.end(); src++)
    {
      //          cout<<"Found a match SgNode:"<<(*src)->unparseToString()<<
      //          "\n for prof Node:\n"<<(*iter)->toString()<<endl;
      candidateSgNodes.push_back(*src);
    }
  }

  // Find auto tuning targets based on candidate Sage statement nodes
  // -------------------------------------------------
  //  A std::set is used to insure only unique loops are kept
  //  since different hot statements may lead to a same target loop
  std::set<SgForStatement*> candidateSgLoops;
  if (autoTuning::enable_debug)
    cout<<"Candidate SgNode count="<<candidateSgNodes.size()<<endl;
  for (std::vector <SgNode* >::const_iterator iter = candidateSgNodes.begin();
      iter!=candidateSgNodes.end(); iter++)
  {
    SgNode* hot_node = *iter;
    if (autoTuning::enable_debug)
      cout<<hot_node->class_name()<<" "<<hot_node->unparseToString()<<endl;
    SgForStatement* outermost_loop= findTargetLoop(hot_node);
    if (outermost_loop!=NULL) 
    { 
      if (isOutlineable (outermost_loop))  
      {
        candidateSgLoops.insert(outermost_loop);
      }
      else
      {
        cerr<<"Warning: skip a target loop at line "<<outermost_loop->get_file_info()->get_line()<<" is not outlineable"<<endl;
      }
    }
    else
    {
      cerr<<"Warning: no handling for hot statements outside a for loop"<<endl;
      cerr<<hot_node->unparseToString()<<endl;
    }
  }
  // Finally outline the target loops one by one
  // -------------------------------------------------
  // What if the loops are nested together?
  // We rank candidate in descending way so the inner most loops will be outlined first
  // An implicit way to do bottom up traversal.
  // TODO: A safer way is to do a bottom up traversal and outline matched loops one by one
  for (std::set <SgForStatement*>::iterator iter = candidateSgLoops.begin(); iter!=candidateSgLoops.end(); iter++)
  {
    outline(*iter);
  }
#if 0
  // Old Code triage: 
  // -----------------------------------------------------
  // This step is better done after the file level performance metrics 
  // are generated, either by ROSE's propagation or by HPCToolKit's correlation command.
  // Alternative: bottom-up method: find hot statements, back track to their file names

  // find the hottest file name
  std::map<string, std::map< std::string, double > > 
    fileMetrics = generateFileMetricsMap(RoseHPCT::profFileNodes_);
  std::string hot_file = findHottestFile(fileMetrics); 
  bool hasOrigFileMetrics = false;
  if (fileMetrics.size()>0) 
    hasOrigFileMetrics = true;

  //Collect used metric names for later use
  std::vector <std::string> metricNames = collectMetricNames(fileMetrics);
  // We don't use global analysis with AST merge,
  // So a file name matching is necessary here.
  SgFilePtrList file_pointer_list = project->get_fileList();
  SgFilePtrList::iterator file_iter = file_pointer_list.begin();
  for (;file_iter!=file_pointer_list.end();file_iter++)
  {  
    SgFile* file= *file_iter;
    if (!isSgSourceFile(file)) 
      continue;
    // Does the current file math the file containing the target hot statement?   
    if (hasOrigFileMetrics&&
        file->get_file_info()->get_filenameString() != hot_file)
      continue;
    // cout<<"Found a matching file!"<<endl;

    // generate a map of map
    std::map<SgNode*, std::map< std::string, double > >  
      nodesWithMetrics = generateNodeMetricsMap(file,metricNames);
    // Find hottest statement then backtrack to hottest loops
    // This makes sense since HPCToolkit generates accumulative flat profiling metrics for each statements,
    // Metrics of statements within loops already consider loop iterations (and function calls).
    SgNode* hot_node=findHottestStatement(file, nodesWithMetrics);
    if (hot_node==NULL)  
    {
      cerr<<"No hot node is found."<<endl;
      continue;
    }

    // find the innermost, consecutive (may have bare SgBasicBlocks in between), 
    // enclosing loops of the hot statement
    // TODO handle Fortran
    SgForStatement* outermost_loop= findTargetLoop(hot_node);
    if (outermost_loop!=NULL) 
    { 
      // outline the target loop
      if (isOutlineable (outermost_loop))  
        outline(outermost_loop);
      else
      {
        cerr<<"Target loop at line "<<outermost_loop->get_file_info()->get_line()<<" is not outlineable, abort!"<<endl;
        ROSE_ASSERT(false);
      }
    }
    else
    {
      cerr<<"Warning: no handling for hot statements outside a for loop"<<endl;
      cerr<<hot_node->unparseToString()<<endl;
    }
  } // end for each file
#endif  
  // -------------------------------------------------------
  AstTests::runAllTests(project);
  project->unparse();
  return 0;
}

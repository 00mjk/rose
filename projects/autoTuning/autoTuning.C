/*!
 *
 * This is the code triage module for the empirical tuning system
 * It reads into the xml file generated by HPCToolKit and
 *    annotates the AST with performance metrics from the file 
 *
 *  We expect two kinds of xml input
 *  1. Raw statement level data without any propagation
 *  2. Correlated data which is already propagated by HPCToolKit, with scope level metrics 
 *
 *  For case 2, a hottest file is first identified and code triage is only done within that file 
 *  Ideally, this should be done during the linking phase so code triage can 
 *  have a global view.
 *  TODO: Try AST merge to obtain a global AST tree for all source files
 *
 * Liao, 1/28/2009
 */
#include "rose.h"
#include "autoTuningSupport.h"

using namespace std;
using namespace GenUtil;
using namespace RoseHPCT;
using namespace Outliner;
using namespace autoTuning;

int main(int argc, char * argv[]) 
{
  vector<string> argvList (argv, argv+argc);
  // recognize options for autotuning
  autotuning_command_processing(argvList);
  // options for outliner
  Outliner::commandLineProcessing(argvList);

  // Prepare AST with performance metrics attached.
  // -------------------------------------------------
  // Read into the XML files
  RoseHPCT::ProgramTreeList_t profiles = RoseHPCT::loadHPCTProfiles (argvList);
  // Create the AST tree
  SgProject * project = frontend(argvList);
  //Attach metrics to AST , last parameter is for verbose
  RoseHPCT::attachMetrics(profiles, project,project->get_verbose()>0);

  // Code triage: 
  // -----------------------------------------------------
  // This step is better done after the file level performance metrics 
  // are generated, either by ROSE's propagation or by HPCToolKit's correlation command.
  //
  // find the hottest file name
  std::map<string, std::map< std::string, double > > 
    fileMetrics = generateFileMetricsMap(RoseHPCT::profFileNodes_);
  std::string hot_file = findHottestFile(fileMetrics); 
  bool hasOrigFileMetrics = false;
  if (fileMetrics.size()>0) 
    hasOrigFileMetrics = true;

  //Collect used metric names for later use
  std::vector <std::string> metricNames = collectMetricNames(fileMetrics);

  // We don't use global analysis with AST merge,
  // So a file name matching is necessary here.
  SgFilePtrList file_pointer_list = project->get_fileList();
  SgFilePtrList::iterator file_iter = file_pointer_list.begin();
  for (;file_iter!=file_pointer_list.end();file_iter++)
  {  
    SgFile* file= *file_iter;
    if (!isSgSourceFile(file)) 
      continue;
    if (hasOrigFileMetrics&&
        file->get_file_info()->get_filenameString() != hot_file)
      continue;
    // cout<<"Found a matching file!"<<endl;

    // generate a map of map
    std::map<SgNode*, std::map< std::string, double > >  
      nodesWithMetrics = generateNodeMetricsMap(file,metricNames);
    // Find hottest statement then backtrack to hottest loops
    // This makes sense since HPCToolkit generates accumulative flat profiling metrics for each statements,
    // Metrics of statements within loops already consider loop iterations (and function calls).
    SgNode* hot_node=findHottestStatement(file, nodesWithMetrics);
    if (hot_node==NULL)  
    {
      cerr<<"No hot node is found."<<endl;
      continue;
    }

    // find the innermost, consecutive (may have bare SgBasicBlocks in between), 
    // enclosing loops of the hot statement
    // TODO handle Fortran
    SgForStatement* outermost_loop= findTargetLoop(hot_node);
    if (outermost_loop!=NULL) 
    { 
#if 1
      // outline the target loop
      if (isOutlineable (outermost_loop))  
        outline(outermost_loop);
      else
      {
        cerr<<"Target loop is not outlineable, abort!"<<endl;
        ROSE_ASSERT(false);
      }
#endif       
    }
    else
    {
      cerr<<"Warning: no handling for hot statements outside a for loop"<<endl;
      cerr<<hot_node->unparseToString()<<endl;
    }

  } // end for each file
  // -------------------------------------------------------
  //AstTests::runAllTests(project);
  project->unparse();
  return 0;
}

--#############################################################################################################################
--
-- The goal of this file is to obtain similarity sets whose functions are similar both syntactically and semantically.
-- The degree of syntactic similarity is ajusted by the "-t" switch of the findClones program. The degree of semantic similarity
-- is adjusted in the query below that constructs the semantic_clone_pairs view.
--
-- SQLite3 is deficient with respect to other relational database management systems in the functions it provides.  You must
-- download this C file (http://www.sqlite.org/contrib/download/extension-functions.c?get=25), compile it according to the
-- instructions contained in that file, and edit the following SQLite3 command so it contains the name of the compiled
-- extension (you may also need to first add the directory to your LD_LIBRARY_PATH on Linux, or equivalent on other systems,
-- or use an absolute path in the .load directive).  You might find it already compiled as part of ROSE in the
-- src/roseExtensions/sqlite3x/.libs directory.

.load @top_pwd@/src/roseExtensions/sqlite3x/.libs/libsqlitefunctions.so

--
-- Before computing the combined similarity, the data needs to be moved into a single database. One way to do that is to
-- follow these instructions.
--
--    1. In the projects/simulator directory, run semantic clone detection to get a clones.db file. The schema is documented
--       in clone_detection/Schema.sql and all tables are prefixed with "semantic_". The command is:
--
--         $ ./CloneDetection [--debug] $SPECIMEN
--
--    2. In the projects/BinaryCloneDetection directory, run the syntactic vector creation to generate a database named
--       syntactic.db.  The schema is undocumented and created from compiled C source code. There is a README in the
--       projects/BinaryCloneDetection directory.  The command is:
--
--         $ ./createVectorsBinary --database syntactic.db --tsv-directory $SPECIMEN --stride 1 --windowSize 10
--
--    3. In the projects/BinaryCloneDetection directory, run the syntactic clone detection.  This fills in the "clusters"
--       table of syntactic.db. The command is:
--
--         $ ./findClones --database syntactic.db -t 0.5
--
--    4. Back in the projects/simulator directory, load the syntactic clone database into the semantic clone database to
--       produce a combined database.
--
--         $ echo .dump |sqlite3 ../BinaryCloneDetection/syntactic.db |sqlite3 clones.db
--
--    5. Generate the semantic clusters by running the SQL query from this source file to create a semantic_clusters table.
--
--    6. Run the remaning queries from this SQL source file to combine the semantic and syntactic clusters, ultimately
--       producing the combined_simsets table.
--
--#############################################################################################################################
-- Associate semantic function IDs with syntactic function IDs in a "combined_functions" table.

-- Step 1: rename the columns of (syntactic) function_ids to match the semantic_functions table, and drop all but the base name
--         of all filename strings (specimens may have been specified with relative names that are different between syntactic
--         and semantic clone detection.
drop view if exists syntactic_functions;
create view syntactic_functions as
   select row_number as id,
          entry_va,
	  function_name as funcname,
	  rightstr(file, charindex('/',reverse(file),1)-1) as filename
       from function_ids;

-- Step 2: match up the function IDs based on the file and either the function name or function entry virtual address,
-- prefering name to address).  We'd like to use a full outer join, but alas, SQLite3 doesn't support this directly, so
-- we need to union two queries
drop view if exists combined_functions;
create view combined_functions as
    select a.id as syntactic_id, b.id as semantic_id
        from syntactic_functions a
        left join semantic_functions b on a.filename = b.filename and
	    ((a.funcname != '' and a.funcname = b.funcname) or
             (a.funcname  = '' and a.entry_va = b.entry_va))
    union all
    select a.id as syntactic_id, b.id as semantic_id
        from semantic_functions b
	left join syntactic_functions a on a.filename = b.filename and
            ((a.funcname != '' and a.funcname = b.funcname) or
	     (a.funcname  = '' and a.entry_va = b.entry_va))
        where a.id is null;

--#############################################################################################################################
-- Find all pairs of functions that are semantically or syntactically similar.  Similarity is reflexive and symmetric, so we
-- weed out the pairs that are not needed by storing only those where the first function ID is less than the second.
-- Similarity is also transitive, but we don't (currently) weed out the extra transitive pairs--i.e., for A==B==C, we store
-- all three pairs even though any two would suffice: (a,b), (a,c), and (b,c).  The extra transitive pairs are important in
-- the final step when we reconstruct the clusters from the pairs.

-- Create pairs of semantically similar functions based on fuzz testing results, which are stored in the semantic_fio
-- (function input/output) table.  The "similarity" column is the number of times this pair of functions produced the same
-- output when run with the same input.
drop view if exists semantic_clusters;
create view semantic_similarity as
    select a.func_id as func_id_1, b.func_id as func_id_2, count(*) as similarity
	from semantic_fio a
	join semantic_fio b on a.func_id < b.func_id and a.inputset_id = b.inputset_id and a.outputset_id = b.outputset_id
	group by a.func_id, b.func_id;

-- All pairs of functions that are semantically similar according to some similarity threshold (the "where" clause). Both
-- function IDs are semantic function IDs.
drop view if exists semantic_clone_pairs;
create view semantic_clone_pairs as
    select distinct func_id_1, func_id_2
        from semantic_similarity
	where similarity = (select count(*) from (select distinct id from semantic_inputvalues));

-- All pairs of functions that are syntactically similar.  The similarity threshold was specified to the C++ program that
-- created the syntactic "clusters" table.  Both function IDs are *semantic* function IDs; we ignore all pairs for which
-- either function of the pair was not considered by the semantic analysis.
drop view if exists syntactic_clone_pairs;
create view syntactic_clone_pairs as
    select distinct b.semantic_id as func_id_1, d.semantic_id as func_id_2
        from clusters a
	join combined_functions b on a.function_id = b.syntactic_id and b.semantic_id is not null
        join clusters c on a.cluster = c.cluster and a.function_id < c.function_id
	join combined_functions d on c.function_id = d.syntactic_id and d.semantic_id is not null;


--#############################################################################################################################
-- Find the pairs of functions that are represented both in semantic_clone_pairs and syntactic_clone_pairs, then combine these
-- into clusters.

-- All pairs of functions that appear as both a syntactic pair and a semantic pair.
drop view if exists combined_clone_pairs;
create view combined_clone_pairs as
    select * from semantic_clone_pairs
    intersect
    select * from syntactic_clone_pairs;


-- At this point we need to run:
--  $ ./clusters_from_pairs clones.db combined_clone_pairs combined_clusters

--#############################################################################################################################
--
-- The goal of this file is to obtain similarity sets whose functions are similar both syntactically and semantically.
-- The degree of syntactic similarity is ajusted by the "-t" switch of the findClones program. The degree of semantic similarity
-- is adjusted in the query below that constructs the semantic_clone_pairs view.
--
-- SQLite3 is deficient with respect to other relational database management systems in the functions it provides.  You must
-- download this C file (http://www.sqlite.org/contrib/download/extension-functions.c?get=25), compile it according to the
-- instructions contained in that file, and edit the following SQLite3 command so it contains the name of the compiled
-- extension (you may also need to first add the directory to your LD_LIBRARY_PATH on Linux, or equivalent on other systems,
-- or use an absolute path in the .load directive).  You might find it already compiled as part of ROSE in the
-- src/roseExtensions/sqlite3x/.libs directory.

.load @top_pwd@/src/roseExtensions/sqlite3x/.libs/libsqlitefunctions.so

--
-- Before computing the combined similarity, the data needs to be moved into a single database. One way to do that is to
-- follow these instructions.
--
--    1. In the projects/simulator directory, run semantic clone detection to get a clones.db file. The schema is documented
--       in clone_detection/Schema.sql and all tables are prefixed with "semantic_". The command is:
--
--         $ ./CloneDetection [--debug] $SPECIMEN
--
--    2. In the projects/BinaryCloneDetection directory, run the syntactic vector creation to generate a database named
--       syntactic.db.  The schema is undocumented and created from compiled C source code. There is a README in the
--       projects/BinaryCloneDetection directory.  The command is:
--
--         $ ./createVectorsBinary --database syntactic.db --tsv-directory $SPECIMEN --stride 1 --windowSize 10
--
--    3. In the projects/BinaryCloneDetection directory, run the syntactic clone detection.  This fills in the "clusters"
--       table of syntactic.db. The command is:
--
--         $ ./findClones --database syntactic.db -t 0.5
--
--    4. Back in the projects/simulator directory, load the syntactic clone database into the semantic clone database to
--       produce a combined database.
--
--         $ echo .dump |sqlite3 ../BinaryCloneDetection/syntactic.db |sqlite3 clones.db
--
--    5. Generate the semantic clusters by running the SQL query from this source file to create a semantic_clusters table.
--
--    6. Run the remaning queries from this SQL source file to combine the semantic and syntactic clusters, ultimately
--       producing the combined_simsets table.
--
--#############################################################################################################################
-- Associate semantic function IDs with syntactic function IDs in a "combined_functions" table.

-- Step 1: rename the columns of (syntactic) function_ids to match the semantic_functions table, and drop all but the base name
--         of all filename strings (specimens may have been specified with relative names that are different between syntactic
--         and semantic clone detection.
drop index if exists syntactic_functions_funcname;
drop index if exists syntacitc_functions_entry_va;

drop table if exists syntactic_functions;
create table syntactic_functions as
   select row_number as id,
          entry_va,
          function_name as funcname,
          rightstr(file, charindex('/',reverse(file),1)-1) as filename
       from function_ids;

-- Step 2: match up the function IDs based on the file and function entry virtual address. This should work fine most of the
-- time but will fail when the loader (used by the simulator that runs semantic analysis) chooses to map the specimen to a
-- different virtual address than specified in the specimen.  We cannot match on function name because (1) many functions will
-- not have names, (2) the same function name can appear many times in one specimen.  We also have to be careful because not
-- all functions will exist in both the syntactic and semantic analysis due to filtering by those analyses. SQLite3 doesn't
-- have a full outer join, so we use a union of two left joins.

-- Indexes used when creating the combined_functions table
create index if not exists syntactic_functions_funcname on syntactic_functions(funcname);
create index if not exists syntactic_functions_entry_va on syntactic_functions(entry_va);
create index if not exists semantic_functions_funcname on semantic_functions(funcname);
create index if not exists semantic_functions_entry_va on semantic_functions(entry_va);

-- Temporary table used only to construct combined_functions
drop table if exists combined_functions_tmp;
create temporary table combined_functions_tmp as
    select x.id as id, y.name as filename, x.funcname as funcname, x.entry_va as entry_va
        from semantic_functions as x join semantic_files as y on x.file_id = y.id;

-- The mapping between syntactic and semantic functions
drop table if exists combined_functions;
create table combined_functions as
    select a.id as syntactic_id, b.id as semantic_id
        from syntactic_functions as a 
        left join combined_functions_tmp as b
            on a.filename = b.filename and a.entry_va = b.entry_va
    union all
    select a.id as syntactic_id, b.id as semantic_id
        from combined_functions_tmp as b
        left join syntactic_functions as a
            on a.filename = b.filename and a.entry_va = b.entry_va
        where a.id is null;

-- Drop indexes that are no longer useful and only take up space
drop index syntactic_functions_funcname;
drop index syntactic_functions_entry_va;
drop index semantic_functions_funcname;
drop index semantic_functions_entry_va;

-- This index is useful later
drop index if exists combined_functions_syntactic_id;
create index combined_functions_syntactic_id on combined_functions(syntactic_id);

--#############################################################################################################################
-- Find all pairs of functions that are semantically or syntactically similar.  Similarity is reflexive and symmetric, so we
-- weed out the pairs that are not needed by storing only those where the first function ID is less than the second.
-- Similarity is also transitive, but we don't (currently) weed out the extra transitive pairs--i.e., for A==B==C, we store
-- all three pairs even though any two would suffice: (a,b), (a,c), and (b,c).  The extra transitive pairs are important in
-- the final step when we reconstruct the clusters from the pairs.

-- Create pairs of semantically similar functions based on fuzz testing results, which are stored in the semantic_fio
-- (function input/output) table.  The "similarity" column is the number of times this pair of functions produced the same
-- output when run with the same input.
create index if not exists semantic_fio_func_id on semantic_fio(func_id);
create index if not exists semantic_fio_inputgroup_id on semantic_fio(inputgroup_id);
create index if not exists semantic_fio_outputgroup_id on semantic_fio(outputgroup_id);
drop table if exists semantic_similarity;
create table semantic_similarity as
    select a.func_id as func_id_1, b.func_id as func_id_2, count(*) as similarity
        from semantic_fio a
        join semantic_fio b
            on a.inputgroup_id = b.inputgroup_id and a.outputgroup_id = b.outputgroup_id and a.func_id < b.func_id
        group by a.func_id, b.func_id;
drop index semantic_fio_func_id;
drop index semantic_fio_inputgroup_id;
drop index semantic_fio_outputgroup_id;

-- All pairs of functions that are semantically similar according to some similarity threshold (the "where" clause). Both
-- function IDs are semantic function IDs.
drop table if exists semantic_clone_pairs;
create table semantic_clone_pairs as
    select distinct func_id_1, func_id_2
        from semantic_similarity
        where similarity = (select count(*) from (select distinct id from semantic_inputvalues));

-- All pairs of functions that are syntactically similar.  This view is computed from the cluster_pairs table, which is
-- created by computeClusterPairs.  The function IDs in this new view are *semantic* function IDs; we ignore all pairs for
-- which either function of the pair was not considered by the semantic analysis.  The first function ID of the pair is
-- always smaller than the second ID (similarity is symmetric and reflexive, so we omit the redundant and naive relations).
drop table if exists syntactic_clone_pairs;
create table syntactic_clone_pairs as
    select distinct min(func1.semantic_id,func2.semantic_id) as func_id_1, max(func1.semantic_id,func2.semantic_id) as func_id_2
        from cluster_pairs as pair
        join combined_functions as func1 on pair.function_id_1 = func1.syntactic_id and func1.semantic_id is not null
        join combined_functions as func2 on pair.function_id_2 = func2.syntactic_id and func2.semantic_id is not null
        where pair.ratio_1 >= (select min(min_coverage) from run_parameters) and
              pair.ratio_2 >= (select min(min_coverage) from run_parameters);


--#############################################################################################################################
-- Find the pairs of functions that are represented both in semantic_clone_pairs and syntactic_clone_pairs, then combine these
-- into clusters.

-- All pairs of functions that appear as both a syntactic pair and a semantic pair.
drop table if exists combined_clone_pairs;
create table combined_clone_pairs as
    select * from semantic_clone_pairs
    intersect
    select * from syntactic_clone_pairs;

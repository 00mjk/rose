/* Emulates an executable. */
#include "rose.h"

/* Define one CPP symbol to determine whether this simulator can be compiled.  The definition of this one symbol depends on
 * all the header file prerequisites. */
#if defined(HAVE_ASM_LDT_H) && defined(HAVE_ELF_H) && \
    defined(HAVE_LINUX_TYPES_H) && defined(HAVE_LINUX_DIRENT_H) && defined(HAVE_LINUX_UNISTD_H)
#  define ROSE_ENABLE_SIMULATOR
#else
#  undef ROSE_ENABLE_SIMULATOR
#endif

#ifdef ROSE_ENABLE_SIMULATOR /* protects this whole file */


#include "x86print.h"
#include "VirtualMachineSemantics.h"
#include "BinaryLoaderElf.h"
#include <stdarg.h>

/* These are necessary for the system call emulation */
#include <asm/ldt.h>
#include <errno.h>
#include <fcntl.h>
#include <linux/futex.h>
#include <syscall.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/user.h>
#include <sys/wait.h>
#include <termios.h>
#include <unistd.h>

#ifndef HAVE_USER_DESC
typedef modify_ldt_ldt_s user_desc;
#endif


/* AS extra required headrs for system call simulation */
#include <sys/types.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/uio.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <fcntl.h>
#include <errno.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <linux/types.h>
#include <linux/dirent.h>
#include <sys/stat.h>
#include <sys/utsname.h>
#include <fcntl.h>
#include <signal.h>
#include <sys/mman.h>
#include <termios.h>
#include <sys/ioctl.h>
#include <asm/ldt.h>
#include <linux/unistd.h>

/* We use the VirtualMachineSemantics policy. That policy is able to handle a certain level of symbolic computation, but we
 * use it because it also does constant folding, which means that it's symbolic aspects are never actually used here. We only
 * have a few methods to specialize this way.   The VirtualMachineSemantics::Memory is not used -- we use a MemoryMap instead
 * since we're only operating on known addresses and values, and thus override all superclass methods dealing with memory. */
class EmulationPolicy: public VirtualMachineSemantics::Policy {
public:
    struct SegmentInfo {
        uint32_t base, limit;
        bool present;
        SegmentInfo(): base(0), limit(0), present(false) {}
        SegmentInfo(const user_desc &ud) {
            base = ud.base_addr;
            limit = ud.limit_in_pages ? (ud.limit << 12) | 0xfff : ud.limit;
            present = !ud.seg_not_present && ud.useable;
        }
    };

    /* Must be the same size and layout as struct sigaction on 32-bit linux */
    struct SignalAction {
        uint32_t        handler;
        sigset_t        mask;                   /* same size on 32- and 64-bit linux */
        uint32_t        flags;
    };

    /* Thrown by exit system calls. */
    struct Exit {
        explicit Exit(int status): status(status) {}
        int status;                             /* same value as returned by waitpid() */
    };

public:
    MemoryMap *map;                             /* Describes how specimen's memory is mapped to simulator memory */
    Disassembler *disassembler;                 /* Disassembler to use for obtaining instructions */
    Disassembler::InstructionMap icache;        /* Cache of disassembled instructions */
    uint32_t brk_va;                            /* Current value for brk() syscall; initialized by load() */
    static const size_t n_gdt=8192;             /* Number of global descriptor table entries */
    user_desc gdt[n_gdt];                       /* Global descriptor table */
    SegmentInfo segreg_shadow[6];               /* Shadow values of segment registers from GDT */
    uint32_t mmap_start;                        /* Minimum address to use when looking for mmap free space */
    bool mmap_recycle;                          /* If false, then never reuse mmap addresses */
    SignalAction signal_action[_NSIG+1];        /* Simulated actions for signal handling */
    uint64_t signal_mask;                       /* Set by sigsetmask() */
    std::vector<uint32_t> auxv;                 /* Auxv vector pushed onto initial stack; also used when dumping core */
    static const uint32_t brk_base=0x40000000;  /* Initial brk() value */

    /* When run under "setarch i386 -LRB3", the ld-linux.so.2 object is mapped at base address 0x40000000. We emulate that
     * behavior here. If the value is less than the highest address mapped by the main executable, then the latter is used
     * instead (see BinaryLoaderElf::rebase()) */
    static const rose_addr_t ld_linux_base_va = 0x40000000;


#if 0
    uint32_t gsOffset;
    void (*eipShadow)();
    uint32_t signalStack;
    std::vector<user_desc> thread_areas;
#endif
    

    /* Debugging, tracing, etc. */
    FILE *debug;                                /* Stream to which debugging output is sent (or NULL to suppress it) */
    bool trace_insn;                            /* Show each instruction that's executed */
    bool trace_state;                           /* Show machine state after each instruction */
    bool trace_mem;                             /* Show memory read/write operations */
    bool trace_mmap;                            /* Show changes in the memory map */
    bool trace_syscall;                         /* Show each system call */
    bool trace_loader;                          /* Show diagnostics for the program loading */

    EmulationPolicy()
        : map(NULL), disassembler(NULL), brk_va(0), mmap_start(0x40000000ul), mmap_recycle(false), signal_mask(0),
          debug(NULL), trace_insn(false), trace_state(false), trace_mem(false), trace_mmap(false), trace_syscall(false),
          trace_loader(false) {

        for (size_t i=0; i<VirtualMachineSemantics::State::n_gprs; i++)
            writeGPR((X86GeneralPurposeRegister)i, 0);
        for (size_t i=0; i<VirtualMachineSemantics::State::n_flags; i++)
            writeFlag((X86Flag)i, 0);
        writeIP(0);
        writeFlag(x86_flag_1, true_());
        writeGPR(x86_gpr_sp, 0xc0000000ul);

        memset(gdt, 0, sizeof gdt);
        gdt[0x23>>3].entry_number = 0x23>>3;
        gdt[0x23>>3].limit = 0x000fffff;
        gdt[0x23>>3].seg_32bit = 1;
        gdt[0x23>>3].read_exec_only = 1;
        gdt[0x23>>3].limit_in_pages = 1;
        gdt[0x23>>3].useable = 1;
        gdt[0x2b>>3].entry_number = 0x2b>>3;
        gdt[0x2b>>3].limit = 0x000fffff;
        gdt[0x2b>>3].seg_32bit = 1;
        gdt[0x2b>>3].limit_in_pages = 1;
        gdt[0x2b>>3].useable = 1;

        writeSegreg(x86_segreg_cs, 0x23);
        writeSegreg(x86_segreg_ds, 0x2b);
        writeSegreg(x86_segreg_es, 0x2b);
        writeSegreg(x86_segreg_ss, 0x2b);
        writeSegreg(x86_segreg_fs, 0x2b);
        writeSegreg(x86_segreg_gs, 0x2b);

        memset(signal_action, 0, sizeof signal_action);
    }

    /* Print machine register state for debugging */
    void dump_registers(FILE *f) const {
        fprintf(f, "  Machine state:\n");
        fprintf(f, "    eax=0x%08"PRIx64" ebx=0x%08"PRIx64" ecx=0x%08"PRIx64" edx=0x%08"PRIx64"\n",
                readGPR(x86_gpr_ax).known_value(), readGPR(x86_gpr_bx).known_value(),
                readGPR(x86_gpr_cx).known_value(), readGPR(x86_gpr_dx).known_value());
        fprintf(f, "    esi=0x%08"PRIx64" edi=0x%08"PRIx64" ebp=0x%08"PRIx64" esp=0x%08"PRIx64" eip=0x%08"PRIx64"\n",
                readGPR(x86_gpr_si).known_value(), readGPR(x86_gpr_di).known_value(),
                readGPR(x86_gpr_bp).known_value(), readGPR(x86_gpr_sp).known_value(),
                get_ip().known_value());
        for (int i=0; i<6; i++) {
            X86SegmentRegister sr = (X86SegmentRegister)i;
            fprintf(f, "    %s=0x%04"PRIx64" base=0x%08"PRIx32" limit=0x%08"PRIx32" present=%s\n",
                    segregToString(sr), readSegreg(sr).known_value(), segreg_shadow[sr].base, segreg_shadow[sr].limit,
                    segreg_shadow[sr].present?"yes":"no");
        }
        fprintf(f, "    flags: %s %s %s %s %s %s %s\n", 
                readFlag(x86_flag_of).known_value()?"ov":"nv", readFlag(x86_flag_df).known_value()?"dn":"up",
                readFlag(x86_flag_sf).known_value()?"ng":"pl", readFlag(x86_flag_zf).known_value()?"zr":"nz",
                readFlag(x86_flag_af).known_value()?"ac":"na", readFlag(x86_flag_pf).known_value()?"pe":"po", 
                readFlag(x86_flag_cf).known_value()?"cy":"nc");
    }

    /* Generate an ELF Core Dump on behalf of the specimen.  This is a real core dump that can be used with GDB and contains
     * the same information as if the specimen had been running natively and dumped its own core. In other words, the core
     * dump we generate here does not have references to the simulator even though it is being dumped by the simulator. */
    void dump_core(int signo);

    /* Recursively load an executable and its libraries libraries into memory, creating the MemoryMap object that describes
     * the mapping from the specimen's address space to the simulator's address space.
     *
     * There are two ways to load dynamic libraries:
     *   1. Load the dynamic linker (ld-linux.so) and simulate it in order to load the libraries.  This is the most accurate
     *      since it delegates the dynamic linking to the actual dynamic linker.  It thus allows different linkers to be
     *      used.
     *   2. Use Matt Brown's work to have ROSE itself resolve the dynamic linking issues.  This approach gives us better
     *      control over the finer details such as which directories are searched, etc. since we have total control over the
     *      linker.  However, Matt's work is not complete at this time [2010-07-20].
     *
     * We use the first approach. */
    SgAsmGenericHeader* load(const char *name);

    /* Initialize the stack for the specimen.  The argc and argv are the command-line of the specimen, not ROSE or the
     * simulator. */
    void initialize_stack(SgAsmGenericHeader*, int argc, char *argv[]);

    /* Returns instruction at current IP, disassembling it if necessary, and caching it. */
    SgAsmx86Instruction *current_insn();

    /* Returns an argument of a system call */
    uint32_t arg(int idx);

    /* Emulates a Linux system call from an INT 0x80 instruction. */
    void emulate_syscall();

    /* Print the name and arguments of a system call in a manner like strace */
    void syscall_enter(const char *name, const char *fmt, ...);

    /* Print the return value of a system call in a manner like strace */
    void syscall_leave(const char *format, ...);

    /* Initializes an ArgInfo object to pass to syscall printing functions. */
    void syscall_arginfo(char fmt, uint32_t val, ArgInfo *info, va_list ap);

    /* Returns the memory address in ROSE where the specified specimen address is located. */
    void *my_addr(uint32_t va);

    /* Reads a NUL-terminated string from specimen memory. The NUL is not included in the string. */
    std::string read_string(uint32_t va);

    /* Reads a vector of NUL-terminated strings from specimen memory. */
    std::vector<std::string> read_string_vector(uint32_t va);

    /* Called by X86InstructionSemantics. Used by x86_and instruction to set AF flag */
    VirtualMachineSemantics::ValueType<1> undefined_() {
        return 1;
    }

    /* Called by X86InstructionSemantics for the HLT instruction */
    void hlt() {
        fprintf(stderr, "hlt\n");
        abort();
    }

    /* Called by X86InstructionSemantics for the INT instruction */
    void interrupt(uint8_t num) {
        if (num != 0x80) {
            fprintf(stderr, "Bad interrupt\n");
            abort();
        }
        emulate_syscall();
    }

    /* Called by X86InstructionSemantics for the SYSENTER instruction */
    void sysenter() {
        emulate_syscall();
    }

    /* Called by X86InstructionSemantics */
    void startInstruction(SgAsmInstruction* insn) {
        if (debug && trace_insn) {
            if (isatty(fileno(debug))) {
                fprintf(debug, "\033[K\n[%07zu] %s\033[K\r\033[1A", get_ninsns(), unparseInstructionWithAddress(insn).c_str());
            } else {
                fprintf(debug, "[%07zu] 0x%08"PRIx64": %s\n", get_ninsns(), insn->get_address(), unparseInstruction(insn).c_str());
            }
        }
        VirtualMachineSemantics::Policy::startInstruction(insn);
#if 0
        if (ms.signalQueue.anySignalsWaiting()) {
            simulate_signal_check(ms, insn->get_address());
        }
#endif
    }

    /* Write value to a segment register and its shadow. */
    void writeSegreg(X86SegmentRegister sr, const VirtualMachineSemantics::ValueType<16> &val) {
        ROSE_ASSERT(3 == (val.known_value() & 7)); /*GDT and privilege level 3*/
        VirtualMachineSemantics::Policy::writeSegreg(sr, val);
        segreg_shadow[sr] = gdt[val.known_value()>>3];
        ROSE_ASSERT(segreg_shadow[sr].present);
    }

    /* Reads memory from the memory map rather than the super class. */
    template <size_t Len> VirtualMachineSemantics::ValueType<Len>
    readMemory(X86SegmentRegister sr, const VirtualMachineSemantics::ValueType<32> &addr,
               const VirtualMachineSemantics::ValueType<1> cond) {
        ROSE_ASSERT(0==Len % 8 && Len<=64);
        uint32_t base = segreg_shadow[sr].base;
        uint32_t offset = addr.known_value();
        ROSE_ASSERT(offset <= segreg_shadow[sr].limit);
        ROSE_ASSERT(offset + (Len/8) - 1 <= segreg_shadow[sr].limit);

        ROSE_ASSERT(cond.is_known());
        if (cond.known_value()) {
            uint8_t buf[Len/8];
            size_t nread = map->read(buf, base+offset, Len/8);
            if (nread!=Len/8) {
                fprintf(stderr, "read %zu byte%s failed at 0x%08"PRIx32"\n\n", Len/8, 1==Len/8?"":"s", base+offset);
                fprintf(stderr, "dumping specimen core and possibly our own...\n");
                dump_core(SIGSEGV);
                abort();
            }
            uint64_t result = 0;
            for (size_t i=0, j=0; i<Len; i+=8, j++)
                result |= buf[j] << i;
            if (debug && trace_mem) {
                fprintf(debug, "  readMemory<%zu>(0x%08"PRIx32"+0x%08"PRIx32"=0x%08"PRIx32") -> 0x%08"PRIx64"\n",
                        Len, base, offset, base+offset, VirtualMachineSemantics::ValueType<Len>(result).known_value());
            }
            return result;
        } else {
            return 0;
        }
    }

    /* Writes memory to the memory map rather than the super class. */
    template <size_t Len> void
    writeMemory(X86SegmentRegister sr, const VirtualMachineSemantics::ValueType<32> &addr,
                const VirtualMachineSemantics::ValueType<Len> &data,  VirtualMachineSemantics::ValueType<1> cond) {
        ROSE_ASSERT(0==Len % 8 && Len<=64);
        uint32_t base = segreg_shadow[sr].base;
        uint32_t offset = addr.known_value();
        ROSE_ASSERT(offset <= segreg_shadow[sr].limit);
        ROSE_ASSERT(offset + (Len/8) - 1 <= segreg_shadow[sr].limit);
        ROSE_ASSERT(data.is_known());
        ROSE_ASSERT(cond.is_known());
        if (cond.known_value()) {
            if (debug && trace_mem) {
                fprintf(debug, "  writeMemory<%zu>(0x%08"PRIx32"+0x%08"PRIx32"=0x%08"PRIx32", 0x%08"PRIx64")\n",
                        Len, base, offset, base+offset, data.known_value());
            }
            uint8_t buf[Len/8];
            for (size_t i=0, j=0; i<Len; i+=8, j++)
                buf[j] = (data.known_value() >> i) & 0xff;
            size_t nwritten = map->write(buf, base+offset, Len/8);
            if (nwritten!=Len/8) {
                fprintf(stderr, "write %zu byte%s failed at 0x%08"PRIx32"\n\n", Len/8, 1==Len/8?"":"s", base+offset);
                fprintf(stderr, "dumping specimen core and possibly our own...\n");
                dump_core(SIGSEGV);
                abort();
            }
        }
    }
};

/* Using the new interface is still about as complicated as the old interface because we need to perform only a partial link.
 * We want ROSE to link the interpreter (usually /lib/ld-linux.so) into the AST but not link in any other shared objects.
 * Then we want ROSE to map the interpreter (if present) and all main ELF Segments into the specimen address space but not
 * make any of the usual adjustments for ELF Sections that also specify a mapping. */

struct SimLoader: public BinaryLoaderElf {
public:
    SgAsmGenericHeader *interpreter;                    /* header linked into AST for .interp section */

    SimLoader(SgAsmInterpretation *interp, bool trace): interpreter(NULL) {
        if (trace) set_debug(stderr);
        set_perform_dynamic_linking(false);             /* we explicitly link in the interpreter and nothing else */
        set_perform_remap(true);                        /* map interpreter and main binary into specimen memory */
        set_perform_relocations(false);                 /* allow simulated interpreter to perform relocation fixups */

        /* Link the interpreter into the AST */
        SgAsmGenericHeader *header = interp->get_headers()->get_headers().front();
        std::string interpreter_name = find_interpreter(header);
        if (!interpreter_name.empty()) {
            SgBinaryComposite *composite = SageInterface::getEnclosingNode<SgBinaryComposite>(interp);
            ROSE_ASSERT(composite!=NULL);
            SgAsmGenericFile *ifile = createAsmAST(composite, interpreter_name);
            interpreter = ifile->get_headers()->get_headers().front();
        }
    }

    /* Finds the name of the interpreter (usually "/lib/ld-linux.so") if any */
    std::string find_interpreter(SgAsmGenericHeader *header) {
        struct: public SgSimpleProcessing {
            std::string interp_name;
            void visit(SgNode *node) {
                SgAsmElfSection *section = isSgAsmElfSection(node);
                SgAsmElfSegmentTableEntry *segment = section ? section->get_segment_entry() : NULL;
                if (segment && SgAsmElfSegmentTableEntry::PT_INTERP==segment->get_type()) {
                    char buf[section->get_size()];
                    section->read_content_local(0, buf, section->get_size());
                    interp_name = std::string(buf, section->get_size());
                }
            }
        } t1;
        t1.traverse(header, preorder);
        return t1.interp_name;
    }

    /* Returns ELF PT_LOAD Segments in order by virtual address. */
    virtual SgAsmGenericSectionPtrList get_remap_sections(SgAsmGenericHeader *header) {
        SgAsmGenericSectionPtrList retval;
        SgAsmGenericSectionPtrList sections = BinaryLoaderElf::get_remap_sections(header);
        for (SgAsmGenericSectionPtrList::iterator si=sections.begin(); si!=sections.end(); si++) {
            SgAsmElfSection *section = isSgAsmElfSection(*si);
            SgAsmElfSegmentTableEntry *entry = section ? section->get_segment_entry() : NULL;
            if (entry && entry->get_type()==SgAsmElfSegmentTableEntry::PT_LOAD)
                retval.push_back(section);
        }
        return retval;
    }

    /* Same as superclass but do not use anonymous mapping for high alignment area */
    virtual MappingContribution align_values(SgAsmGenericSection *section, MemoryMap *map,
                                             rose_addr_t *malign_lo_p, rose_addr_t *malign_hi_p,
                                             rose_addr_t *va_p, rose_addr_t *mem_size_p,
                                             rose_addr_t *offset_p, rose_addr_t *file_size_p,
                                             rose_addr_t *va_offset_p, bool *anon_lo_p, bool *anon_hi_p,
                                             ConflictResolution *resolve_p) {
        MappingContribution retval = BinaryLoaderElf::align_values(section, map, malign_lo_p, malign_hi_p, va_p,
                                                                   mem_size_p, offset_p, file_size_p, va_offset_p,
                                                                   anon_lo_p, anon_hi_p, resolve_p);
        //*anon_hi_p = false;
        return retval;
    }
};

SgAsmGenericHeader*
EmulationPolicy::load(const char *name)
{
    /* Link the main binary into the AST without further linking, mapping, or relocating. */
    if (debug)
        fprintf(debug, "loading %s...\n", name);
    char *frontend_args[4];
    frontend_args[0] = strdup("-");
    frontend_args[1] = strdup("-rose:read_executable_file_format_only"); /*delay disassembly until later*/
    frontend_args[2] = strdup(name);
    frontend_args[3] = NULL;
    SgProject *project = frontend(3, frontend_args);

    /* Find the best interpretation and file header.  Windows PE programs have two where the first is DOS and the second is PE
     * (we'll use the PE interpretation). */
    SgAsmInterpretation *interp = SageInterface::querySubTree<SgAsmInterpretation>(project, V_SgAsmInterpretation).back();
    SgAsmGenericHeader *fhdr = interp->get_headers()->get_headers().front();
    writeIP(fhdr->get_entry_rva() + fhdr->get_base_va());

    /* Link the interpreter into the AST */
    SimLoader *loader = new SimLoader(interp, trace_loader);

    /* If we found an interpreter then use its entry address as the start of simulation.  When running the specimen directly
     * in Linux with "setarch i386 -LRB3", the ld-linux.so.2 gets mapped to 0x40000000 even though the libs preferred
     * addresses start at zero.  We can accomplish the same thing simply by rebasing the library. */
    if (loader->interpreter) {
        loader->interpreter->set_base_va(ld_linux_base_va);
        writeIP(loader->interpreter->get_entry_rva() + loader->interpreter->get_base_va());
    }

    /* Map all segments into simulated memory */
    loader->load(interp);
    delete loader;
    loader = NULL;
    map = interp->get_map();

    /* Find a disassembler. */
    if (!disassembler)
        disassembler = Disassembler::lookup(interp)->clone();

    /* Initialize the brk value to be the lowest page-aligned address that is above the end of the highest mapped address but
     * below where ld-linux.so.2 was loaded, the stack, etc. */
    brk_va = ALIGN_UP(map->find_last_free(brk_base), PAGE_SIZE);

    return fhdr;
}

void EmulationPolicy::initialize_stack(SgAsmGenericHeader *_fhdr, int argc, char *argv[])
{
    /* We only handle ELF for now */
    SgAsmElfFileHeader *fhdr = isSgAsmElfFileHeader(_fhdr);
    ROSE_ASSERT(fhdr!=NULL);

    /* Allocate the stack */
    static const size_t stack_size = 0x01000000;
    size_t sp = readGPR(x86_gpr_sp).known_value();
    size_t stack_addr = sp - stack_size;
    MemoryMap::MapElement melmt(stack_addr, stack_size, MemoryMap::MM_PROT_READ|MemoryMap::MM_PROT_WRITE);
    melmt.set_name("stack");
    map->insert(melmt);

    /* Initialize the stack with specimen's argc and argv */
    std::vector<uint32_t> pointers;                     /* pointers pushed onto stack at the end of initialization */
    pointers.push_back(argc);
    for (int i=0; i<argc; i++) {
        size_t len = strlen(argv[i]) + 1; /*inc. NUL termination*/
        sp -= len;
        map->write(argv[i], sp, len);
        pointers.push_back(sp);
        if (trace_loader)
            fprintf(stderr, "argv[%d] %zu bytes at 0x%08zu = \"%s\"\n", i, len, sp, argv[i]);
    }
    pointers.push_back(0); /*the argv NULL terminator*/

    /* Initialize the stack with specimen's environment. For now we'll use the same environment as this simulator. */
    for (int i=0; true; i++) {
        if (!environ[i]) break;
        size_t len = strlen(environ[i]) + 1;
        sp -= len;
        map->write(environ[i], sp, len);
        pointers.push_back(sp);
        if (trace_loader)
            fprintf(stderr, "environ[%d] %zu bytes at 0x%08zu = \"%s\"\n", i, len, sp, environ[i]);
    }
    pointers.push_back(0); /*environment NULL terminator*/

    /* Initialize stack with auxv, where each entry is two words in the pointers vector. This information is only present for
     * dynamically linked executables. */
    if (fhdr->get_section_by_name(".interp")) {
        struct T1: public SgSimpleProcessing {
            rose_addr_t phdr_rva;
            T1(): phdr_rva(0) {}
            void visit(SgNode *node) {
                SgAsmElfSection *section = isSgAsmElfSection(node);
                SgAsmElfSegmentTableEntry *entry = section ? section->get_segment_entry() : NULL;
                if (0==phdr_rva && entry && entry->get_type()==SgAsmElfSegmentTableEntry::PT_PHDR)
                    phdr_rva = section->get_mapped_preferred_rva();
            }
        } t1;
        t1.traverse(fhdr, preorder);

        auxv.clear();
#if 0 /*FIXME: the simulator certainly doesn't have all these capabilities, but I'm not sure what the bit numbers are. */
        /* AT_HWCAP */
        auxv.push_back(16);
        auxv.push_back(0xbfebfbff); /*fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts
                                         * acpi mmx fxsr sse sse2 ss ht tm pbe */
        if (trace_loader)
            fprintf(stderr, "AT_HWCAP:         0x%08"PRIx32"\n", auxv.back());
#endif

        /* AT_PAGESZ */
        auxv.push_back(6);
        auxv.push_back(PAGE_SIZE);
        if (trace_loader)
            fprintf(stderr, "AT_PAGESZ:        %"PRId32"\n", auxv.back());

        /* AT_CLKTCK */
        auxv.push_back(17);
        auxv.push_back(100);
        if (trace_loader)
            fprintf(stderr, "AT_CLKTCK:        %"PRId32"\n", auxv.back());

        /* AT_PHDR */
        auxv.push_back(3); /*AT_PHDR*/
        auxv.push_back(t1.phdr_rva + fhdr->get_base_va());
        if (trace_loader)
            fprintf(stderr, "AT_PHDR:          0x%08"PRIx32"\n", auxv.back());

        /*AT_PHENT*/
        auxv.push_back(4);
        auxv.push_back(fhdr->get_phextrasz() + sizeof(SgAsmElfSegmentTableEntry::Elf32SegmentTableEntry_disk));
        if (trace_loader)
            fprintf(stderr, "AT_PHENT:         %"PRId32"\n", auxv.back());

        /* AT_PHNUM */
        auxv.push_back(5);
        auxv.push_back(fhdr->get_e_phnum());
        if (trace_loader)
            fprintf(stderr, "AT_PHNUM:         %"PRId32"\n", auxv.back());

        /* AT_BASE */
        auxv.push_back(7);
        auxv.push_back(ld_linux_base_va);
        if (trace_loader)
            fprintf(stderr, "AT_BASE:          0x%08"PRIx32"\n", auxv.back());

        /* AT_FLAGS */
        auxv.push_back(8);
        auxv.push_back(0);
        if (trace_loader)
            fprintf(stderr, "AT_FLAGS:         0x%08"PRIx32"\n", auxv.back());

        /* AT_ENTRY */
        auxv.push_back(9);
        auxv.push_back(fhdr->get_entry_rva() + fhdr->get_base_va());
        if (trace_loader)
            fprintf(stderr, "AT_ENTRY:         0x%08"PRIx32"\n", auxv.back());

        /* AT_UID */
        auxv.push_back(11);
        auxv.push_back(getuid());
        if (trace_loader)
            fprintf(stderr, "AT_UID:           %"PRId32"\n", auxv.back());

        /* AT_EUID */
        auxv.push_back(12);
        auxv.push_back(geteuid());
        if (trace_loader)
            fprintf(stderr, "AT_EUID:          %"PRId32"\n", auxv.back());

        /* AT_GID */
        auxv.push_back(13);
        auxv.push_back(getgid());
        if (trace_loader)
            fprintf(stderr, "AT_GID:           %"PRId32"\n", auxv.back());

        /* AT_EGID */
        auxv.push_back(14);
        auxv.push_back(getegid());
        if (trace_loader)
            fprintf(stderr, "AT_EGID:          %"PRId32"\n", auxv.back());

        /* AT_SECURE */
        auxv.push_back(23);
        auxv.push_back(false);
        if (trace_loader)
            fprintf(stderr, "AT_SECURE:        %"PRId32"\n", auxv.back());

        /*FIXME: AT_PLATFORM should be i386 but not sure of the number. Setting it to i686 causes ld.so to execute floating
         *       point instructions that are not handled by the simulator.  [RPM 2010-09-18] */
#if 0
        /* AT_PLATFORM */
        auxv.push_back(16);
        auxv.push_back(0xbffff04b); /*i686*/
        if (trace_loader)
            fprintf(stderr, "AT_PLATFORM:      0x%08"PRIx32"\n", auxv.back());
#endif
    }

    /* AT_NULL */
    auxv.push_back(0);
    auxv.push_back(0);
    pointers.insert(pointers.end(), auxv.begin(), auxv.end());

    /* Finalize stack initialization by writing all the pointers to data we've pushed:
     *    argc
     *    argv with NULL terminator
     *    environment with NULL terminator
     *    auxv pairs terminated with (AT_NULL,0)
     */
    sp &= ~3U; /*align to four-bytes*/
    sp -= 4 * pointers.size();
    map->write(&(pointers[0]), sp, 4*pointers.size());

    writeGPR(x86_gpr_sp, sp);
}

SgAsmx86Instruction *
EmulationPolicy::current_insn()
{
    rose_addr_t ip = readIP().known_value();

    /* Use the cached instruction if possible. */
    Disassembler::InstructionMap::iterator found = icache.find(ip);
    if (found!=icache.end()) {
        SgAsmx86Instruction *insn = isSgAsmx86Instruction(found->second);
        ROSE_ASSERT(insn!=NULL); /*shouldn't be possible due to check below*/
        size_t insn_sz = insn->get_raw_bytes().size();
        SgUnsignedCharList curmem(insn_sz);
        size_t nread = map->read(&curmem[0], ip, insn_sz);
        if (nread==insn_sz && curmem==insn->get_raw_bytes())
            return insn;
        icache.erase(found);
    }

    /* Disassemble (and cache) a new instruction */
    SgAsmx86Instruction *insn = NULL;
    try {
        insn = isSgAsmx86Instruction(disassembler->disassembleOne(map, ip));
    } catch (Disassembler::Exception &e) {
        std::cerr <<e <<"\n";
        std::cerr <<"dumping specimen core...\n";
        dump_core(SIGSEGV);
        throw;
    }
    ROSE_ASSERT(insn!=NULL); /*only happens if our disassembler is not an x86 disassembler!*/
    icache.insert(std::make_pair(ip, insn));
    return insn;
}

void
EmulationPolicy::dump_core(int signo)
{
    fprintf(stderr, "memory map at time of core dump:\n");
    map->dump(stderr, "  ");

    SgAsmGenericFile *ef = new SgAsmGenericFile;
    ef->set_truncate_zeros(false);

    SgAsmElfFileHeader *fhdr = new SgAsmElfFileHeader(ef);
    fhdr->get_exec_format()->set_purpose(SgAsmExecutableFileFormat::PURPOSE_CORE_DUMP);
    fhdr->add_entry_rva(rose_rva_t(0, NULL));

    SgAsmElfSegmentTable *segtab = new SgAsmElfSegmentTable(fhdr);
    
    /*========================================================================================================================
     * NOTE section
     *======================================================================================================================== */

    SgAsmElfNoteSection *notes = new SgAsmElfNoteSection(fhdr);
    segtab->add_section(notes);
    notes->get_segment_entry()->set_type(SgAsmElfSegmentTableEntry::PT_NOTE);
    
    /* Note CORE.PRSTATUS(1)              (144 bytes) */
    struct prstatus {
        uint32_t signo;                 /* signal number */
        uint32_t code;                  /* extra signal code */
        uint32_t err_num;
        uint32_t cursig;                /* current signal; 2-bytes followed by 2 bytes of zero padding */
        uint32_t sigpend;               /* pending signals */
        uint32_t sighold;               /* set of held signals */
        uint32_t pid;
        uint32_t ppid;
        uint32_t pgrp;
        uint32_t sid;
        uint32_t user_sec;              /* user time */
        uint32_t user_usec;
        uint32_t sys_sec;               /* system time */
        uint32_t sys_usec;
        uint32_t cuser_sec;             /* cummulative user time */
        uint32_t cuser_usec;
        uint32_t csys_sec;              /* cummulative system time */
        uint32_t csys_usec;
        uint32_t bx;                    /* general purpose registers */
        uint32_t cx;
        uint32_t dx;
        uint32_t si;
        uint32_t di;
        uint32_t bp;
        uint32_t ax;
        uint32_t ds;
        uint32_t es;
        uint32_t fs;
        uint32_t gs;
        uint32_t orig_ax;               /* ax value before syscall? */
        uint32_t ip;
        uint32_t cs;
        uint32_t flags;
        uint32_t sp;
        uint32_t ss;
        uint32_t fpvalid;               /* is math coprocessor being used? */
    } __attribute__((packed));
    struct prstatus prstatus;
    ROSE_ASSERT(144==sizeof prstatus);
    memset(&prstatus, 0, sizeof prstatus);
    prstatus.signo = prstatus.cursig = signo;
    prstatus.pid = getpid();
    prstatus.ppid = getppid();
    prstatus.pgrp = getpgrp();
    prstatus.sid = getsid(0);
    prstatus.bx = readGPR(x86_gpr_bx).known_value();
    prstatus.cx = readGPR(x86_gpr_cx).known_value();
    prstatus.dx = readGPR(x86_gpr_dx).known_value();
    prstatus.si = readGPR(x86_gpr_si).known_value();
    prstatus.di = readGPR(x86_gpr_di).known_value();
    prstatus.bp = readGPR(x86_gpr_bp).known_value();
    prstatus.ax = readGPR(x86_gpr_ax).known_value();
    prstatus.ds = readSegreg(x86_segreg_ds).known_value();
    prstatus.es = readSegreg(x86_segreg_es).known_value();
    prstatus.fs = readSegreg(x86_segreg_fs).known_value();
    prstatus.gs = readSegreg(x86_segreg_gs).known_value();
    prstatus.orig_ax = readGPR(x86_gpr_ax).known_value();
    prstatus.ip = readIP().known_value();
    prstatus.cs = readSegreg(x86_segreg_cs).known_value();
    prstatus.flags = 0;
#define ADD_PRSTATUS_FLAG(NAME, BITPOS) \
    prstatus.flags |= readFlag(NAME).is_known() ? readFlag(NAME).known_value() << (BITPOS) : 0
    ADD_PRSTATUS_FLAG(x86_flag_cf, 0);
    ADD_PRSTATUS_FLAG(x86_flag_1, 1);
    ADD_PRSTATUS_FLAG(x86_flag_pf, 2);
    ADD_PRSTATUS_FLAG(x86_flag_3, 3);
    ADD_PRSTATUS_FLAG(x86_flag_af, 4);
    ADD_PRSTATUS_FLAG(x86_flag_5, 5);
    ADD_PRSTATUS_FLAG(x86_flag_zf, 6);
    ADD_PRSTATUS_FLAG(x86_flag_sf, 7);
    ADD_PRSTATUS_FLAG(x86_flag_tf, 8);
    ADD_PRSTATUS_FLAG(x86_flag_if, 9);
    ADD_PRSTATUS_FLAG(x86_flag_df, 10);
    ADD_PRSTATUS_FLAG(x86_flag_of, 11);
    ADD_PRSTATUS_FLAG(x86_flag_iopl0, 12);
    ADD_PRSTATUS_FLAG(x86_flag_iopl1, 13);
    ADD_PRSTATUS_FLAG(x86_flag_nt, 14);
    ADD_PRSTATUS_FLAG(x86_flag_15, 15);
    ADD_PRSTATUS_FLAG(x86_flag_rf, 16);
    ADD_PRSTATUS_FLAG(x86_flag_vm, 17);
    ADD_PRSTATUS_FLAG(x86_flag_ac, 18);
    ADD_PRSTATUS_FLAG(x86_flag_vif, 19);
    ADD_PRSTATUS_FLAG(x86_flag_vip, 20);
    ADD_PRSTATUS_FLAG(x86_flag_id, 21);
#undef ADD_PRSTATUS_FLAG
    prstatus.sp = readGPR(x86_gpr_sp).known_value();
    prstatus.ss = readSegreg(x86_segreg_ss).known_value();
    prstatus.fpvalid = 0;     /*ROSE doesn't support floating point yet*/

    SgAsmElfNoteEntry *prstatus_note = new SgAsmElfNoteEntry(notes);
    prstatus_note->get_name()->set_string("CORE");
    prstatus_note->set_type(1); /*ET_PRSTATUS*/
    prstatus_note->set_payload(&prstatus, sizeof prstatus);
            
    /* Note CORE.PRPSINFO(3)              (124 bytes) */
    struct {
        uint8_t state;                                          /* numeric process state */
        uint8_t sname;                                          /* char for state (is this what ps(1) prints? */
        uint8_t zombie;
        uint8_t nice;                                           /* nice value */
        uint32_t flags;
        uint16_t uid;
        uint16_t gid;
        uint32_t pid;
        uint32_t ppid;
        uint32_t pgrp;
        uint32_t sid;
        char fname[16];                                         /* filename of executable */
        char psargs[80];                                        /* initial part of arg list */
    } __attribute__((packed)) prpsinfo;
    ROSE_ASSERT(124==sizeof prpsinfo);
    memset(&prpsinfo, 0, sizeof prpsinfo);
    prpsinfo.state = 0;                                         /* runable */
    prpsinfo.sname = 'R';
    prpsinfo.zombie = 0;
    prpsinfo.nice = getpriority(PRIO_PROCESS, getpid());
    prpsinfo.flags = 0;                                         /* see linux/sched.h PF_* bits */
    prpsinfo.uid = geteuid();
    prpsinfo.gid = getegid();
    prpsinfo.ppid = getppid();
    prpsinfo.pgrp = getpgrp();
    prpsinfo.sid = getsid(0);
    strncpy(prpsinfo.fname, "/home/matzke/syscall_tst_18", sizeof(prpsinfo.fname));   /*FIXME*/
    strncpy(prpsinfo.psargs, "/home/matzke/syscall_tst_18", sizeof(prpsinfo.psargs)); /*FIXME*/
    
    SgAsmElfNoteEntry *prpsinfo_note = new SgAsmElfNoteEntry(notes);
    prpsinfo_note->get_name()->set_string("CORE");
    prpsinfo_note->set_type(3); /*ET_PRPSINFO*/
    prpsinfo_note->set_payload(&prpsinfo, sizeof prpsinfo);

    /* Note CORE.AUXV(6)                  (144 bytes) */
    SgAsmElfNoteEntry *auxv_note = new SgAsmElfNoteEntry(notes);
    auxv_note->get_name()->set_string("CORE");
    auxv_note->set_type(6);
    auxv_note->set_payload(&auxv[0], 4*auxv.size());

    /* Note CORE.PRFPREG(2)               (108 bytes) */
    /* Note LINUX.PRXFPREG(0x45e62b7f)    (512 bytes) */
    /* Note LINUX.386_TLS(0x200)          (48 bytes)  i386 TLS slots (struct user_desc)*/
    
    /*========================================================================================================================
     * LOAD sections
     *======================================================================================================================== */

    class SegmentBuilder: public SgAsmElfSection {
        MemoryMap       *map;                                   /* memory map for specimen's process address space */
    public:
        SegmentBuilder(SgAsmElfFileHeader *fhdr, MemoryMap *map, rose_addr_t va, rose_addr_t sz, unsigned perms)
            : SgAsmElfSection(fhdr), map(map) {
            set_purpose(SgAsmGenericSection::SP_PROGRAM);       /* Program-supplied text, data, etc. */
            set_offset(ALIGN_UP(get_offset(), 4096));
            set_size(sz);
            set_file_alignment(4096);
            set_mapped_alignment(4096);
            set_mapped_preferred_rva(va); /*va==rva for ELF*/
            set_mapped_size(sz);
            set_mapped_rperm(0!=(perms & MemoryMap::MM_PROT_READ));
            set_mapped_wperm(0!=(perms & MemoryMap::MM_PROT_WRITE));
            set_mapped_xperm(0!=(perms & MemoryMap::MM_PROT_EXEC));
        }
        virtual void unparse(std::ostream &f) const {
            uint8_t buf[8192];
            rose_addr_t cur_va = get_mapped_preferred_va();     /* current virtual address */
            rose_addr_t nremain = get_mapped_size();            /* bytes remaining to be written to the file */
            rose_addr_t offset = 0;                             /* byte offset with respect to beginning of section */
            while (nremain>0) {
                rose_addr_t to_write = std::min(nremain, (rose_addr_t)sizeof buf);
                size_t nread = map->read(buf, cur_va, to_write);
                ROSE_ASSERT(nread==to_write);
                offset = write(f, offset, to_write, buf);
                cur_va += to_write;
                nremain -= to_write;
            }
        }
    };

    /* We dump everything to the core file, although linux (by default) skips private and shared mappings that have backing
     * store. */
    const std::vector<MemoryMap::MapElement> &elmts = map->get_elements();
    std::vector<MemoryMap::MapElement>::const_iterator ei=elmts.begin();
    while (ei!=elmts.end()) {
        rose_addr_t va = ei->get_va();
        rose_addr_t sz = ei->get_size();
        unsigned perms = ei->get_mapperms();

        /* Combine elmts[i] with as many following elements as possible. */
        std::vector<MemoryMap::MapElement>::const_iterator ej=ei+1;
        while (ej!=elmts.end() && va+sz==ej->get_va() && perms==ej->get_mapperms())
            sz += (ej++)->get_size();
        ei = ej;

        /* Create a segment */
        SgAsmElfSection *segment = new SegmentBuilder(fhdr, map, va, sz, perms);
        segtab->add_section(segment);
        segment->get_segment_entry()->set_type(SgAsmElfSegmentTableEntry::PT_LOAD);
    }

    /*========================================================================================================================
     * Generate the core file.
     *======================================================================================================================== */

    /*FIXME: will replace with a more suitable name when working*/    
    SgAsmExecutableFileFormat::unparseBinaryFormat("x-core.rose", ef);
    //deleteAST(ef); /*FIXME [RPM 2010-09-18]*/
}

void *
EmulationPolicy::my_addr(uint32_t va)
{
    /* Read from specimen in order to make sure that the memory is allocated and mapped into ROSE. */
    uint32_t word;
    size_t nread = map->read(&word, va, sizeof word);
    ROSE_ASSERT(nread==sizeof word);

    /* Obtain mapping information */
    const MemoryMap::MapElement *me = map->find(va);
    ROSE_ASSERT(me!=NULL); /*because the map->read() was successful above*/
    uint8_t *base = (uint8_t*)me->get_base();
    size_t offset = me->get_va_offset(va);
    return base+offset;
}

std::string
EmulationPolicy::read_string(uint32_t va)
{
    std::string retval;
    while (1) {
        uint8_t byte;
        size_t nread = map->read(&byte, va++, 1);
        ROSE_ASSERT(1==nread); /*or we've read past the end of the mapped memory*/
        if (!byte)
            return retval;
        retval += byte;
    }
}

std::vector<std::string>
EmulationPolicy::read_string_vector(uint32_t va)
{
    std::vector<std::string> vec;
    size_t size = 4;
    while(1) {
      char buf[size];
      size_t nread = map->read(buf, va, size);

      ROSE_ASSERT(nread == size);

      uint64_t result = 0;
      for (size_t i=0, j=0; i<size; i+=8, j++)
                result |= buf[j] << i;

      //FIXME (?) is this the correct test for memory being null?
      if ( result == 0 ) break;

      vec.push_back(read_string( result  ));
      
      va+=4;
    }
    return vec;
}

void
EmulationPolicy::emulate_syscall()
{
    /* Warning: use hard-coded values here rather than the __NR_* constants from <sys/unistd.h> because the latter varies
     *          according to whether ROSE is compiled for 32- or 64-bit.  We always want the 32-bit syscall numbers. */
    unsigned callno = readGPR(x86_gpr_ax).known_value();
    switch (callno) {
        case 3: { /*read*/
            syscall_enter("read", "dpd");
            int fd=arg(0);
            uint32_t buf_va=arg(1), size=arg(2);
            char buf[size];
            ssize_t nread = read(fd, buf, size);
            if (nread<0) {
                writeGPR(x86_gpr_ax, -errno);
            } else {
                writeGPR(x86_gpr_ax, nread);
                map->write(buf, buf_va, nread);
            }
            syscall_leave("d");
            break;
        }

        case 4: { /*write*/
            syscall_enter("write", "dpd");
            int fd=arg(0);
            uint32_t buf_va=arg(1);
            size_t size=arg(2);
            uint8_t buf[size];
            size_t nread = map->read(buf, buf_va, size);
            ROSE_ASSERT(nread==size);
            ssize_t nwritten = write(fd, buf, size);
            if (-1==nwritten) {
                writeGPR(x86_gpr_ax, -errno);
            } else {
                writeGPR(x86_gpr_ax, nwritten);
            }
            syscall_leave("d");
            break;
        }

        case 5: { /*open*/
            static const Translate oflags[] = { TF(O_RDWR), TF(O_RDONLY), TF(O_WRONLY),
                                                TF(O_CREAT), TF(O_EXCL), TF(O_NONBLOCK), TF(O_NOCTTY), TF(O_TRUNC),
                                                TF(O_APPEND), TF(O_NDELAY), TF(O_ASYNC), TF(O_FSYNC), TF(O_SYNC), TF(O_NOATIME),
                                                T_END };
            syscall_enter("open", "sf", oflags);
            uint32_t filename_va=arg(0);
            std::string filename = read_string(filename_va);
            uint32_t flags=arg(1), mode=(flags & O_CREAT)?arg(2):0;
            int fd = open(filename.c_str(), flags, mode);

            if( fd <= 256 ) // 256 is getdtablesize() in the simulator
                writeGPR(x86_gpr_ax, fd<0 ? -errno : fd);
            else {
                writeGPR(x86_gpr_ax, -EMFILE);
                close(fd);
            }
            syscall_leave("d");
            break;
        }

        case 6: { /*close*/
            syscall_enter("close", "d");
            int fd=arg(0);
            if (1==fd || 2==fd) {
                /* ROSE is using these */
                writeGPR(x86_gpr_ax, -EPERM);
            } else {
                int status = close(fd);
                writeGPR(x86_gpr_ax, status<0 ? -errno : status);
            }
            syscall_leave("d");
            break;
        }

        case 7: { // waitpid
            static const Translate wflags[] = { TF(WNOHANG), TF(WUNTRACED), T_END };
            syscall_enter("waitpid", "dpf", wflags);
            pid_t pid=arg(0);
            uint32_t status=arg(1), options=arg(2);
            int sys_status;
            int result = waitpid(pid, &sys_status, options);
            if (result == -1) {
                result = -errno;
            } else {
                if (status) {
                  uint32_t status_le;
                  SgAsmExecutableFileFormat::host_to_le(status, &status_le);
                  size_t nwritten = map->write(&status_le, sys_status, 4);
                  ROSE_ASSERT(4==nwritten);
                }
            }
            writeGPR(x86_gpr_ax, result);
            syscall_leave("d");
            break;
        }
                
        case 10: { /*0xa, unlink*/
            syscall_enter("unlink", "s");
            uint32_t filename_va = arg(0);
            std::string filename = read_string(filename_va);
            int result = unlink(filename.c_str());
            if (result == -1) 
                result = -errno;
            writeGPR(x86_gpr_ax, result);
            syscall_leave("d");
            break;
        }

	case 11: { /* 0xb, execve */
            syscall_enter("execve", "spp");
            std::string filename = read_string(arg(0));
            std::vector<std::string > argv = read_string_vector(arg(1));
            std::vector<std::string > envp = read_string_vector(arg(2));
            std::vector<char*> sys_argv;
            for (unsigned int i = 0; i < argv.size(); ++i) sys_argv.push_back(&argv[i][0]);
            sys_argv.push_back(NULL);
            std::vector<char*> sys_envp;
            for (unsigned int i = 0; i < envp.size(); ++i) sys_envp.push_back(&envp[i][0]);
            sys_envp.push_back(NULL);
            int result;
            if (std::string(&filename[0]) == "/usr/bin/man") {
                result = -EPERM;
            } else {
                result = execve(&filename[0], &sys_argv[0], &sys_envp[0]);
                if (result == -1) result = -errno;
            }
            writeGPR(x86_gpr_ax, result);
            syscall_leave("d");
            break;
        }

	case 12: { /* 0xc, chdir */
            syscall_enter("chdir", "s");
	    uint32_t path = arg(0);
            std::string sys_path = read_string(path);

	    int result = chdir(sys_path.c_str());
            if (result == -1) result = -errno;
            writeGPR(x86_gpr_ax, result);

            syscall_leave("d");
            break;
	}



        case 13: { /*0xd, time */
            syscall_enter("time", "p");
            uint32_t t = arg(0);
            time_t result = time(NULL);
            if (t) {
              uint32_t t_le;
              SgAsmExecutableFileFormat::host_to_le(t, &t_le);
              size_t nwritten = map->write(&t_le, result, 4);
              ROSE_ASSERT(4==nwritten);    }
            writeGPR(x86_gpr_ax, result);
            syscall_leave("t");
            break;
        }

        case 14: { /*0xe, mknod*/
            syscall_enter("mknod", "sdd");
            uint32_t path_va = arg(0);
            uint32_t mode = arg(1);
            uint32_t dev = arg(2);
            std::string path = read_string(path_va);
            int result = mknod(path.c_str(),mode,dev);
            writeGPR(x86_gpr_ax, result<0 ? -errno : result);
            syscall_leave("d");
            break;
        }

	case 15: { /* 0xf, chmod */
            syscall_enter("chmod", "sd");
	    uint32_t filename = arg(0);
            std::string sys_filename = read_string(filename);
	    mode_t mode = arg(1);

	    int result = chmod(sys_filename.c_str(), mode);
            if (result == -1) result = -errno;
            writeGPR(x86_gpr_ax, result);

            syscall_leave("d");
            break;
	}


        case 20: { /*0x14, getpid*/
            syscall_enter("getpid", "");
            writeGPR(x86_gpr_ax, getpid());
            syscall_leave("d");
            break;
        }

        case 24: { /*0x18, getuid*/
            syscall_enter("getuid", "");
            writeGPR(x86_gpr_ax, getuid());
            syscall_leave("d");
            break;
        }

        case 33: { /*0x21, access*/
            static const Translate flags[] = { TF(R_OK), TF(W_OK), TF(X_OK), TF(F_OK), T_END };
            syscall_enter("access", "sf", flags);
            uint32_t name_va=arg(0);
            std::string name = read_string(name_va);
            int mode=arg(1);
            int result = access(name.c_str(), mode);
            if (result<0) result = -errno;
            writeGPR(x86_gpr_ax, result);
            syscall_leave("d");
            break;
        }

	case 37: { /* 0x25, kill */
            syscall_enter("kill", "dd");
            pid_t pid = readGPR(x86_gpr_bx).known_value();
            int   sig = readGPR(x86_gpr_cx).known_value();
            int result = kill(pid, sig);
            if (result == -1) result = -errno;
            writeGPR(x86_gpr_ax, result);
            syscall_leave("d");
            break;
        }

	case 39: { /* 0x27, mkdir */
            syscall_enter("mkdir", "sd");
	    uint32_t pathname = arg(0);
            std::string sys_pathname = read_string(pathname);
	    mode_t mode = arg(1);

	    int result = mkdir(sys_pathname.c_str(), mode);
            if (result == -1) result = -errno;
            writeGPR(x86_gpr_ax, result);

            syscall_leave("d");
            break;
	}

	case 40: { /* 0x28, rmdir */
            syscall_enter("rmdir", "s");
	    uint32_t pathname = arg(0);
            std::string sys_pathname = read_string(pathname);

	    int result = rmdir(sys_pathname.c_str());
            if (result == -1) result = -errno;
            writeGPR(x86_gpr_ax, result);

            syscall_leave("d");
            break;
	}

        case 41: { /*0x29, dup*/
            syscall_enter("dup", "d");
            uint32_t fd = arg(0);
            int result = dup(fd);
            if (-1==result) result = -errno;
            writeGPR(x86_gpr_ax, result);
            syscall_leave("d");
            break;
        }

        case 45: { /*0x2d, brk*/
            syscall_enter("brk", "x");
            uint32_t newbrk = ALIGN_DN(arg(0), PAGE_SIZE);
            int retval = 0;

            if (newbrk >= 0xb0000000ul) {
                retval = -ENOMEM;
            } else {
                if (newbrk > brk_va) {
                    MemoryMap::MapElement melmt(brk_va, newbrk-brk_va, MemoryMap::MM_PROT_READ|MemoryMap::MM_PROT_WRITE);
                    melmt.set_name("brk syscall");
                    map->insert(melmt);
                    brk_va = newbrk;
                } else if (newbrk>0 && newbrk<brk_va) {
                    map->erase(MemoryMap::MapElement(newbrk, brk_va-newbrk));
                    brk_va = newbrk;
                }
                retval= brk_va;
            }
            if (debug && newbrk!=0 && trace_mmap) {
                fprintf(debug, "  memory map after brk syscall:\n");
                map->dump(debug, "    ");
            }

            writeGPR(x86_gpr_ax, retval);
            syscall_leave("p");
            break;
        }

        case 47: { /*0x2f, getgid*/
            syscall_enter("getgid", "");
            writeGPR(x86_gpr_ax, getgid());
            syscall_leave("d");
            break;
        }

        case 49: { /*0x31, geteuid*/
            syscall_enter("geteuid", "");
            writeGPR(x86_gpr_ax, geteuid());
            syscall_leave("d");
            break;
        }

        case 50: { /*0x32, getegid*/
            syscall_enter("getegid", "");
            writeGPR(x86_gpr_ax, getegid());
            syscall_leave("d");
            break;
        }

        case 54: { /*0x36, ioctl*/
            syscall_enter("ioctl", "ddd");
            int fd=arg(0);
            uint32_t cmd=arg(1), arg2=arg(2);
            int result = -ENOSYS;
            switch (cmd) {
                case TCGETS: { /*tcgetattr*/
                    struct termios ti;
                    result = tcgetattr(fd, &ti);
                    if (-1==result) {
                        result = -errno;
                    } else {
                        /* The Linux kernel and glibc have different definitions for termios, with very different sizes (39
                         * bytes vs 60) */                  
                        size_t nwritten = map->write(&ti, arg2, 39);
                        ROSE_ASSERT(39==nwritten);
                    }
                    break;
                }
                    
                case TIOCGPGRP: { /*tcgetpgrp*/
                    pid_t pgrp = tcgetpgrp(fd);
                    if (-1==pgrp) {
                        result = -errno;
                    } else {
                        uint32_t pgrp_le;
                        SgAsmExecutableFileFormat::host_to_le(pgrp, &pgrp_le);
                        size_t nwritten = map->write(&pgrp_le, arg2, 4);
                        ROSE_ASSERT(4==nwritten);
                        result = 0;
                    }
                    break;
                }
                    
                case TIOCSPGRP: { /*tcsetpgrp*/
                    uint32_t pgid_le;
                    size_t nread = map->read(&pgid_le, arg2, 4);
                    ROSE_ASSERT(4==nread);
                    pid_t pgid = SgAsmExecutableFileFormat::le_to_host(pgid_le);
                    result = tcsetpgrp(fd, pgid);
                    if (-1==result)
                        result = -errno;
                    break;
                }

                case TIOCGWINSZ: {
                    struct winsize ws;
                    result = ioctl(fd, TIOCGWINSZ, &ws);
                    if (-1==result) {
                        result = -errno;
                    } else {
                        size_t nwritten = map->write(&ws, arg2, sizeof ws);
                        ROSE_ASSERT(nwritten==sizeof ws);
                    }
                    break;
                }
                    
                default:
                    fprintf(stderr, "  unhandled ioctl: %u\n", cmd);
                    abort();
            }
            writeGPR(x86_gpr_ax, result);
            syscall_leave("d");
            break;
        }

        case 57: { /*0x39, setpgid*/
            syscall_enter("setpgid", "dd");
            uint32_t pid=arg(0), pgid=arg(1);
            int result = setpgid(pid, pgid);
            if (-1==result) { result = -errno; }
            writeGPR(x86_gpr_ax, result);
            syscall_leave("d");
            break;
        }

        case 64: { /*0x40, getppid*/
            syscall_enter("getppid", "");
            writeGPR(x86_gpr_ax, getppid());
            syscall_leave("d");
            break;
        }

        case 65: { /*0x41, getpgrp*/
            syscall_enter("getpgrp", "");
            writeGPR(x86_gpr_ax, getpgrp());
            syscall_leave("d");
            break;
        }

        case 78: { /*0x4e, gettimeofday*/       
            syscall_enter("gettimeofday", "p");
            uint32_t tp = arg(0);
            struct timeval sys_t;
            int result = gettimeofday(&sys_t, NULL);
            if (result == -1) {
                result = -errno;
            } else {
                writeMemory<32>(x86_segreg_ds, tp, sys_t.tv_sec, true_() );
                writeMemory<32>(x86_segreg_ds, tp + 4, sys_t.tv_usec, true_() );
            }
            writeGPR(x86_gpr_ax, result);
            syscall_leave("d");
            break;
        }

        case 83: { /*0x53, symlink*/
            syscall_enter("symlink", "ss");
            uint32_t oldpath=arg(0), newpath=arg(1);
            std::string sys_oldpath = read_string(oldpath);
            std::string sys_newpath = read_string(newpath);
            int result = symlink(sys_oldpath.c_str(),sys_newpath.c_str());
            if (result == -1) result = -errno;
            writeGPR(x86_gpr_ax, result);
            syscall_leave("d");
            break;
        }

        case 85: { /*0x55, readlink*/
            syscall_enter("readlink", "spd");
            uint32_t path=arg(0), buf=arg(1), bufsize=arg(2);
            char sys_buf[bufsize];
            std::string sys_path = read_string(path);
            int result = readlink(sys_path.c_str(), sys_buf, bufsize);
            if (result == -1) {
                result = -errno;
            } else {
                size_t nwritten = map->write(sys_buf, buf, result);
                ROSE_ASSERT(nwritten == (size_t)result);
            }
            writeGPR(x86_gpr_ax, result);
            syscall_leave("d");
            break;
        }
            
        case 91: { /*0x5b, munmap*/
            syscall_enter("munmap", "pd");
            uint32_t va=arg(0);
            uint32_t sz=arg(1);
            uint32_t aligned_va = ALIGN_DN(va, PAGE_SIZE);
            uint32_t aligned_sz = ALIGN_UP(sz+va-aligned_va, PAGE_SIZE);
            map->erase(MemoryMap::MapElement(aligned_va, aligned_sz));
            if (debug && trace_mmap) {
                fprintf(debug, " memory map after munmap syscall:\n");
                map->dump(debug, "    ");
            }
            writeGPR(x86_gpr_ax, 0);
            syscall_leave("d");
            break;
        }

        case 102: { // socketcall
            syscall_enter("socketcall", "dp");
            //uint32_t call=arg(0), args=arg(1);
            writeGPR(x86_gpr_ax, -ENOSYS);
            syscall_leave("d");
            break;
        }

        case 114: { /*0x72, wait4*/
            static const Translate wflags[] = { TF(WNOHANG), TF(WUNTRACED), T_END };
            syscall_enter("wait4", "dpfp", wflags);
            uint32_t pid=arg(0), status_ptr=arg(1), options=arg(2), rusage_ptr=arg(3);
            uint32_t status;
            size_t nread = map->read(&status, status_ptr, 4);
            ROSE_ASSERT(nread == 4);
            struct rusage sys_rusage;
            int result = wait4(pid, &status, options, &sys_rusage);
            if( result == -1) {
                result = -errno;
            } else {
                if (status_ptr != 0) {
                    size_t nwritten = map->write(&status, status_ptr, 4);
                    ROSE_ASSERT(nwritten == 4);
                }
                if (rusage_ptr != 0) {
                    size_t nwritten = map->write(&sys_rusage, rusage_ptr, sizeof(struct rusage));
                    ROSE_ASSERT(nwritten == sizeof(struct rusage));
                }
            }
            writeGPR(x86_gpr_ax, result);
            syscall_leave("d");
            break;
        }

        case 122: { /*0x7a, uname*/
            syscall_enter("uname", "p");
            uint32_t dest_va=arg(0);
            char buf[6*65];
            memset(buf, ' ', sizeof buf);
            strcpy(buf+0*65, "Linux");                                  /*sysname*/
            strcpy(buf+1*65, "mymachine.example.com");                  /*nodename*/
            strcpy(buf+2*65, "2.6.9");                                  /*release*/
            strcpy(buf+3*65, "#1 SMP Wed Jun 18 12:35:02 EDT 2008");    /*version*/
            strcpy(buf+4*65, "i386");                                   /*machine*/
            strcpy(buf+5*65, "example.com");                            /*domainname*/
            size_t nwritten = map->write(buf, dest_va, sizeof buf);
            if( nwritten <= 0 ) {
              writeGPR(x86_gpr_ax, -EFAULT);
              break;
            }

            ROSE_ASSERT(nwritten==sizeof buf);
            writeGPR(x86_gpr_ax, 0);
            syscall_leave("d");
            break;
        }

	case 133: { /* 0x85, fchdir */
            syscall_enter("fchdir", "d");
	    uint32_t file_descriptor = arg(0);

	    int result = fchdir(file_descriptor);
            if (result == -1) result = -errno;
            writeGPR(x86_gpr_ax, result);

            syscall_leave("d");
            break;
	}

        case 125: { /*0x7d, mprotect*/
            static const Translate pflags[] = { TF(PROT_READ), TF(PROT_WRITE), TF(PROT_EXEC), TF(PROT_NONE), T_END };
            syscall_enter("mprotect", "pdf", pflags);
            uint32_t va=arg(0), size=arg(1), perms=arg(2);
            unsigned rose_perms = ((perms & PROT_READ) ? MemoryMap::MM_PROT_READ : 0) |
                                  ((perms & PROT_WRITE) ? MemoryMap::MM_PROT_WRITE : 0) |
                                  ((perms & PROT_EXEC) ? MemoryMap::MM_PROT_EXEC : 0);
            if (va % PAGE_SIZE) {
                writeGPR(x86_gpr_ax, -EINVAL);
                break;
            }
            uint32_t aligned_sz = ALIGN_UP(size, PAGE_SIZE);

            try {
                map->mprotect(MemoryMap::MapElement(va, aligned_sz, rose_perms));
            } catch (const MemoryMap::NotMapped &e) {
                writeGPR(x86_gpr_ax, -EFAULT);
                break;
            }

            writeGPR(x86_gpr_ax, 0);

            syscall_leave("d");
            if (debug && trace_mmap) {
                fprintf(debug, "  memory map after mprotect syscall:\n");
                map->dump(debug, "    ");
            }
            break;
        }

        case 146: { /*0x92, writev*/
            syscall_enter("writev", "dpd");
            uint32_t fd=arg(0), iov_va=arg(1);
            int niov=arg(2);
            uint32_t retval = 0;
            for (int i=0; i<niov; i++) {
                uint32_t buf_va_le;
                size_t nread = map->read(&buf_va_le, iov_va+i*8+0, 4);
                ROSE_ASSERT(4==nread);
                uint32_t buf_va = SgAsmExecutableFileFormat::le_to_host(buf_va_le);
                
                uint32_t buf_sz_le;
                nread = map->read(&buf_sz_le, iov_va+i*8+4, 4);
                ROSE_ASSERT(4==nread);
                uint32_t buf_sz = SgAsmExecutableFileFormat::le_to_host(buf_va_le);

                if (debug)
                    fprintf(debug, "    #%d: va=0x%08"PRIx32", size=0x%08"PRIx32"\n", i, buf_va, buf_sz);
                uint8_t buf[buf_sz];
                nread = map->read(buf, buf_va, buf_sz);
                ROSE_ASSERT(nread==buf_sz);
                ssize_t nwritten = write(fd, buf, buf_sz);
                if (-1==nwritten) {
                    retval = -errno;
                    break;
                } else if (nwritten<buf_sz) {
                    retval += nwritten;
                    break;
                } else {
                    retval += nwritten;
                }
            }
            writeGPR(x86_gpr_ax, retval);
            syscall_leave("d");
            break;
        }

        case 174: { /*0xae, rt_sigaction*/
            syscall_enter("rt_sigaction", "dppd");
            int signum=arg(0);
            uint32_t action_va=arg(1), oldact_va=arg(2);
            //size_t sigsetsize=arg(3);


            if (signum<1 || signum>_NSIG) {
                writeGPR(x86_gpr_ax, -EINVAL);
                break;
            }

            SignalAction saved = signal_action[signum];
            if (action_va) {
                size_t nread = map->read(signal_action+signum, action_va, sizeof saved);
                ROSE_ASSERT(nread==sizeof(*signal_action));
            }
            if (oldact_va) {
                size_t nwritten = map->write(&saved, oldact_va, sizeof saved);
                ROSE_ASSERT(nwritten==sizeof(*signal_action));
            }

            writeGPR(x86_gpr_ax, 0);
            syscall_leave("d");
            break;
        }

        case 175: { /*0xaf, rt_sigprocmask*/
            static const Translate flags[] = { TF(SIG_BLOCK), TF(SIG_UNBLOCK), TF(SIG_SETMASK), T_END };
            syscall_enter("rt_sigprocmask", "fpp", flags);

            int how=arg(0);
            uint32_t set_va=arg(1), get_va=arg(2);
            //size_t sigsetsize=arg(3);

            uint64_t saved=signal_mask, sigset=0;
            size_t nread = map->read(&sigset, set_va, sizeof sigset);
            ROSE_ASSERT(nread==sizeof sigset);

            if (0==how) {
                /* SIG_BLOCK */
                signal_mask |= sigset;
            } else if (1==how) {
                /* SIG_UNBLOCK */
                signal_mask &= ~sigset;
            } else if (2==how) {
                /* SIG_SETMASK */
                signal_mask = sigset;
            } else {
                writeGPR(x86_gpr_ax, -EINVAL);
                break;
            }

            if (get_va) {
                size_t nwritten = map->write(&saved, get_va, sizeof saved);
                ROSE_ASSERT(nwritten==sizeof saved);
            }
            writeGPR(x86_gpr_ax, 0);
            syscall_leave("d");
            break;
        }

	case 183: { /* 0xb7, getcwd */
            syscall_enter("getcwd", "pd");
            
	    uint32_t buf_va=arg(0), size=arg(1);
            char buf[size];
            char* ret_buf = getcwd(buf, size);
	    if (ret_buf == 0) {
              //Buffer is not big enough
	      errno=ERANGE;
	      writeGPR(x86_gpr_ax, 0);
             }else{ 
              writeGPR(x86_gpr_ax, buf_va);
             } 

	    //As an extension to the POSIX.1-2001 standard, 
	    //Linux (libc4, libc5, glibc) getcwd() allocates the 
	    //buffer dynamically using malloc() if buf is NULL on call. 
	    //In this case, the allocated buffer has the length size 
	    //unless size is zero, when buf is allocated as big as necessary. 
	    uint8_t byte;
            size_t nread = map->read(&byte, buf_va, 1);
	    if(!byte){
             map->write(buf, buf_va, size);
            }

            syscall_leave("d");
            break;
	}

        case 191: { /*0xbf, ugetrlimit*/
            syscall_enter("ugetrlimit", "dp");
            int resource=arg(0);
            uint32_t rl_va=arg(1);
            struct rlimit rl;
            int status = getrlimit(resource, &rl);
            if (status<=0) {
                writeGPR(x86_gpr_ax, -errno);
            } else {
                if (rl_va) {
                    size_t nwritten = map->write(&rl, rl_va, sizeof rl);
                    ROSE_ASSERT(nwritten==sizeof rl);
                }
                writeGPR(x86_gpr_ax, 0);
            }
            syscall_leave("d");
            break;
        }

        case 192: { /*0xc0, mmap2*/
            static const Translate pflags[] = { TF(PROT_READ), TF(PROT_WRITE), TF(PROT_EXEC), TF(PROT_NONE), T_END };
            static const Translate mflags[] = { TF(MAP_SHARED), TF(MAP_PRIVATE), TF(MAP_ANONYMOUS), TF(MAP_DENYWRITE),
                                                TF(MAP_EXECUTABLE), TF(MAP_FILE), TF(MAP_FIXED), TF(MAP_GROWSDOWN),
                                                TF(MAP_LOCKED), TF(MAP_NONBLOCK), TF(MAP_NORESERVE),
#ifdef MAP_32BIT
                                                TF(MAP_32BIT),
#endif
                                                TF(MAP_POPULATE), T_END };
            syscall_enter("mmap2", "pdffdd", pflags, mflags);
            uint32_t start=arg(0), size=arg(1), prot=arg(2), flags=arg(3), fd=arg(4), offset=arg(5)*PAGE_SIZE;
            size_t aligned_size = ALIGN_UP(size, PAGE_SIZE);
            void *buf = NULL;
            unsigned rose_perms = ((prot & PROT_READ) ? MemoryMap::MM_PROT_READ : 0) |
                                  ((prot & PROT_WRITE) ? MemoryMap::MM_PROT_WRITE : 0) |
                                  ((prot & PROT_EXEC) ? MemoryMap::MM_PROT_EXEC : 0);
            prot |= PROT_READ | PROT_WRITE | PROT_EXEC; /* ROSE takes care of permissions checking */

            if (!start) {
                try {
                    start = map->find_free(mmap_start, aligned_size, PAGE_SIZE);
                } catch (const MemoryMap::NoFreeSpace &e) {
                    writeGPR(x86_gpr_ax, -ENOMEM);
                    goto mmap2_done;
                }
            }
            if (!mmap_recycle)
                mmap_start = std::max(mmap_start, start);

            if (flags & MAP_ANONYMOUS) {
                buf = mmap(NULL, size, prot, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
            } else {
                buf = mmap(NULL, size, prot, flags & ~MAP_FIXED, fd, offset);
            }
            if (MAP_FAILED==buf) {
                writeGPR(x86_gpr_ax, -errno);
            } else {
                MemoryMap::MapElement melmt(start, aligned_size, buf, 0, rose_perms);
                melmt.set_name("mmap2 syscall");
                map->erase(melmt); /*clear space space first to avoid MemoryMap::Inconsistent exception*/
                map->insert(melmt);
                writeGPR(x86_gpr_ax, start);
            }

        mmap2_done:
            syscall_leave("p");
            if (debug && trace_mmap) {
                fprintf(debug, "  memory map after mmap2 syscall:\n");
                map->dump(debug, "    ");
            }

            break;
        }

        case 195:       /*0xc3, stat64*/
        case 196:       /*0xc4, lstat64*/
        case 197: {     /*0xc5, fstat64*/
            /* We need to be a bit careful with xstat64 calls. The C library invokes one of the xstat64 system calls, which
             * writes a kernel data structure into a temporary buffer, and which the C library then massages into a struct
             * stat64. When simulating, we don't want the C library to monkey with the data returned from the system call
             * because the simulated C library will do the monkeying (it must only happen once).
             *
             * Therefore, we will invoke the system call directly, bypassing the C library, and then copy the result into
             * specimen memory.  Fortunately, the kernel data structure that's returned has the same layout on AMD64 (which is
             * probably how ROSE is running) and i386 (which is probably how the specimen is running).
             *
             * For some unknown reason, if we invoke the system call with buf allocated on the stack we'll get -EFAULT (-14)
             * as the result; if we allocate it statically there's no problem.  Also, just in case the size is different than
             * we think, we'll allocate a guard area above the kernel_stat and check that the syscall didn't write into it. */
            if (195==callno || 196==callno) {
                syscall_enter(195==callno?"stat64":"lstat64", "sp");
            } else {
                syscall_enter("fstat64", "dp");
            }

#ifdef SYS_stat64       /* x86sim must be running on i386 */
            ROSE_ASSERT(4==sizeof(long));
            int host_callno = 195==callno ? SYS_stat64 : (196==callno ? SYS_lstat64 : SYS_fstat64);
            static const size_t kernel_stat_size = 96;
#else                   /* x86sim must be running on amd64 */
            ROSE_ASSERT(8==sizeof(long));
            int host_callno = 195==callno ? SYS_stat : (196==callno ? SYS_lstat : SYS_fstat);
            static const size_t kernel_stat_size = 144;
#endif

            static uint8_t kernel_stat[kernel_stat_size+100];
            memset(kernel_stat, 0xff, sizeof kernel_stat);
            int result = 0xdeadbeef;

#if 1
            if (195==callno || 196==callno) {
                std::string name = read_string(arg(0));
                result = syscall(host_callno, (unsigned long)name.c_str(), (unsigned long)kernel_stat);
            } else {
                result = syscall(host_callno, (unsigned long)arg(0), (unsigned long)kernel_stat);
            }
            if (-1==result)
                result = -errno;
#else
            if (195==callno || 196==callno) {
                std::string name = read_string(arg(0));
                asm volatile("int $0x80"
                             : "=a"(result)
                             : "0"(host_callno), "b"(name.c_str()), "c"(kernel_stat64)
                             : "memory");
            } else {
                asm volatile("int $0x80"
                             : "=a"(result)
                             : "0"(host_callno), "b"(arg(0)), "c"(kernel_stat64)
                             : "memory");
            }
#endif
            /* Check for overflow */
            for (size_t i=kernel_stat_size; i<sizeof kernel_stat; i++)
                ROSE_ASSERT(0xff==kernel_stat[i]);

            if (result>=0) {
                /* Check that the kernel initialized as much data as we thought it should.  We initialized the kernel_stat to
                 * all 0xff bytes before making the system call.  The last data member of kernel_stat is either an 8-byte
                 * inode (i386) or zero (amd64), which in either case the high order byte is almost certainly not 0xff. */
                ROSE_ASSERT(0xff!=kernel_stat[kernel_stat_size-1]);
                
                /* On amd64 we need to translate the 64-bit struct to a 32-bit struct. We do it in place. */
                if (144==kernel_stat_size) {
                    if (debug && trace_syscall)
                        fprintf(debug, "[64-to-32] ");
                    /* quadword-0 (st_dev)                   <-- (st_dev)     no change         */
                    /* quadword-1 (0xffffffff, st_ino[4])    <-- (ino)        postponed to qw-B */
                    /* quadword-2 (mode[4], nlink[4])        <-- (nlink)                        */
                    memmove(kernel_stat+20, kernel_stat+16, 4);                 /*nlink*/
                    memmove(kernel_stat+16, kernel_stat+24, 4);                 /*mode*/
                    /* quadword-3 (user[4],group[4])         <-- (mode[4],user[4])              */
                    memmove(kernel_stat+24, kernel_stat+28, 4);                 /*user*/
                    memmove(kernel_stat+28, kernel_stat+32, 4);                 /*group*/
                    /* quadword-4 (rdev[4],zero?)            <-- (group[4],zero[4])             */
                    memset(kernel_stat+32, 0, 8);                               /*rdev (FIXME)*/
                    /* quadword-5 (0xffffffff,size[lo4])     <-- (zero?)                        */
                    memset(kernel_stat+40, 0xff, 4);                            /*0xfffffff*/
                    memmove(kernel_stat+44, kernel_stat+48, 4);                 /*size[lo4]*/
                    /* quadword-6 (size[hi4],blksize)        <-- (size)                         */
                    memmove(kernel_stat+48, kernel_stat+52, 4);                 /*size[hi4]*/
                    memmove(kernel_stat+52, kernel_stat+56, 4);                 /*blksize*/
                    /* quadword-7 (nblocks[4],zero?)         <-- (blksize)                      */
                    memmove(kernel_stat+56, kernel_stat+64, 8);                 /*nblocks*/
                    /* quadword-8 (atim.sec[4],atim.nsec[4]) <-- (nblocks)                      */
                    memmove(kernel_stat+64, kernel_stat+72, 4);                 /*atim.sec*/
                    memmove(kernel_stat+68, kernel_stat+80, 4);                 /*atim.nsec*/
                    /* quadword-9 (mtim.sec[4],mtim.nsec[4]) <-- (atim.sec)                     */
                    memmove(kernel_stat+72, kernel_stat+88, 4);                 /*mtim.sec*/
                    memmove(kernel_stat+76, kernel_stat+96, 4);                 /*mtim.nsec*/
                    /* quadword-A (ctim.sec[4],ctim.nsec[4]) <-- (atim.nsec)                    */
                    memmove(kernel_stat+80, kernel_stat+104, 4);                /*ctim.sec*/
                    memmove(kernel_stat+84, kernel_stat+112, 4);                /*ctim.nsec*/
                    /* quadword-B (ino)                      <-- (mtim.sec)        also do qw-0 */
                    memmove(kernel_stat+88, kernel_stat+8, 8);                  /*ino[8]*/
                    memmove(kernel_stat+12, kernel_stat+8, 4);                  /*ino[4]*/
                    memset(kernel_stat+8, 0xff, 4);                             /*0xffffffff*/
                    /* quadword-C (unused)                   <-- (mtim.nsec)                    */
                    /* quadword-D (unused)                   <-- (ctim.sec)                     */
                    /* quadword-E (unused)                   <-- (ctim.nsec)                    */
                    /* quadword-F (unused)                   <-- (zero?)                        */
                    /* quadword-G (unused)                   <-- (zero?)                        */
                    /* quadword-H (unused)                   <-- (zero?)                        */
                }
            }

            map->write(kernel_stat, arg(1), 96);
            writeGPR(x86_gpr_ax, result);
            syscall_leave("d");
            break;
        }

	case 199: { /*0xc7, getuid32 */
            syscall_enter("getuid32", "");
            uid_t id = getuid();
            writeGPR(x86_gpr_ax, id);
            syscall_leave("d");
	    break;
	}

	case 200: { /*0xc8, getgid32 */
            syscall_enter("getgid32", "");
            uid_t id = getgid();
            writeGPR(x86_gpr_ax, id);
            syscall_leave("d");
            break;
        }

	case 201: { /*0xc9, geteuid32 */
            syscall_enter("geteuid32", "");
            uid_t id = geteuid();
            writeGPR(x86_gpr_ax, id);
            syscall_leave("d");
            break;
        }

        case 202: { /*0xca, getegid32 */
            syscall_enter("getegid32", "");
            uid_t id = getegid();
            writeGPR(x86_gpr_ax, id);
            syscall_leave("d");
            break;
        }

	case 212: { /*0xd4, chown */
            syscall_enter("chown", "sdd");
	    std::string filename = read_string(arg(0));
            uid_t user = arg(1);
	    gid_t group = arg(2);
	    int result = chown(filename.c_str(),user,group);
            writeGPR(x86_gpr_ax, result);
            syscall_leave("d");
            break;
        }
        case 221: { // fcntl
            syscall_enter("fcntl64", "ddp");
            uint32_t fd=arg(0), cmd=arg(1), other_arg=arg(2);
            int result = -EINVAL;
            switch (cmd) {
                case F_DUPFD: {
                    result = fcntl(fd, cmd, (long)other_arg);
                    if (result == -1) result = -errno;
                    break;
                }
                case F_SETFD: {
                    result = fcntl(fd, cmd, (long)other_arg);
                    if (result == -1) result = -errno;
                    break;
                }
                default: {
                    result = -EINVAL;
                    break;
                }
            }
            writeGPR(x86_gpr_ax, result);
            syscall_leave("d");
            break;
        }

        case 224: { /*0xe0, gettid*/
            // We have no concept of threads
            syscall_enter("gettid", "");
            writeGPR(x86_gpr_ax, getpid());
            syscall_leave("d");
            break;
       }

        case 240: { /*0xf0, futex*/
            static const Translate opflags[] = {
#ifdef FUTEX_CMD_MASK
                TF(FUTEX_PRIVATE_FLAG),
                TF2(FUTEX_CMD_MASK, FUTEX_WAIT),
                TF2(FUTEX_CMD_MASK, FUTEX_WAKE),
                TF2(FUTEX_CMD_MASK, FUTEX_FD),
                TF2(FUTEX_CMD_MASK, FUTEX_REQUEUE),
                TF2(FUTEX_CMD_MASK, FUTEX_CMP_REQUEUE),
                TF2(FUTEX_CMD_MASK, FUTEX_WAKE_OP),
                TF2(FUTEX_CMD_MASK, FUTEX_LOCK_PI),
                TF2(FUTEX_CMD_MASK, FUTEX_UNLOCK_PI),
                TF2(FUTEX_CMD_MASK, FUTEX_TRYLOCK_PI),
#ifdef FUTEX_WAIT_BITSET
                TF2(FUTEX_CMD_MASK, FUTEX_WAIT_BITSET),
#endif
#ifdef FUTEX_WAKE_BITSET
                TF2(FUTEX_CMD_MASK, FUTEX_WAKE_BITSET),
#endif
#endif
                T_END };
            syscall_enter("futex", "pfdppd", opflags);
            //uint32_t addr1=arg(0), op=arg(1), val1=arg(2), ptimeout=arg(3), addr2=arg(4), val3=arg(5);
            writeGPR(x86_gpr_ax, -ENOSYS);
            syscall_leave("d");
            fprintf(stderr, "futex syscall is returning ENOSYS for now.\n"); /*FIXME*/
            break;
        }
            
        case 243: { /*0xf3, set_thread_area*/
            syscall_enter("set_thread_area", "p");
            uint32_t u_info_va=arg(0);
            user_desc ud;
            size_t nread = map->read(&ud, u_info_va, sizeof ud);
            ROSE_ASSERT(nread==sizeof ud);
#if 1 /*FIXME: should be using syscall_enter*/
            if (debug && trace_syscall) {
                fprintf(debug, "  set_thread_area({%d, 0x%08lx, 0x%08x, %s, %u, %s, %s, %s, %s})\n",
                        (int)ud.entry_number, (unsigned long)ud.base_addr, ud.limit,
                        ud.seg_32bit ? "32bit" : "16bit",
                        ud.contents, ud.read_exec_only ? "read_exec" : "writable",
                        ud.limit_in_pages ? "page_gran" : "byte_gran",
                        ud.seg_not_present ? "not_present" : "present",
                        ud.useable ? "usable" : "not_usable");
            }
#endif
            if (ud.entry_number==(unsigned)-1) {
                for (ud.entry_number=0x33>>3; ud.entry_number<n_gdt; ud.entry_number++) {
                    if (!gdt[ud.entry_number].useable) break;
                }
                ROSE_ASSERT(ud.entry_number<8192);
                if (debug && trace_syscall)
                    fprintf(debug, "  assigned entry number = %d\n", (int)ud.entry_number);
            }
            gdt[ud.entry_number] = ud;
            size_t nwritten = map->write(&ud, u_info_va, sizeof ud);
            ROSE_ASSERT(nwritten==sizeof ud);
            writeGPR(x86_gpr_ax, 0);
            /* Reload all the segreg shadow values from the (modified) descriptor table */
            for (size_t i=0; i<6; i++)
                writeSegreg((X86SegmentRegister)i, readSegreg((X86SegmentRegister)i));
            syscall_leave("d");
            break;
        }

        case 252: { /*0xfc, exit_group*/
            syscall_enter("exit_group", "d");
            if (debug && trace_syscall) fputs("(throwing...)\n", debug);
            int status=arg(0);
            throw Exit(__W_EXITCODE(status, 0));
        }

        case 258: { /*0x102, set_tid_address*/
            syscall_enter("set_tid_address", "p");
            uint32_t tid_va=arg(0);
            
            /* We want the 32-bit value to be updated by Linux, but if we're running on a 64-bit system then Linux will also
             * update the following 32-bits (probably initializing them to zero).  Therefore we'll create 64 bits memory for
             * Linux to update and map the low-order 32-bits into the specimen. */
            int *tidptr = NULL;
            if (sizeof(int)>4) {
                tidptr = new int;
                *tidptr = 0;
                size_t nread = map->read(tidptr, tid_va, 4);
                ROSE_ASSERT(4==nread);
                const MemoryMap::MapElement *orig = map->find(tid_va);
                MemoryMap::MapElement submap(tid_va, 4, tidptr, 0, orig->get_mapperms());
                submap.set_name("set_tid_address");
                map->insert(submap);
            } else {
                tidptr = (int*)my_addr(tid_va);
            }

            syscall(SYS_set_tid_address, tidptr);
            writeGPR(x86_gpr_ax, getpid());

            syscall_leave("d");
            if (debug && trace_mmap) {
                fprintf(debug, "  memory map after set_tid_address syscall:\n");
                map->dump(debug, "    ");
            }
            break;
        }

        case 270: { /*0x10e tgkill*/
            syscall_enter("tgkill", "ddd");
            uint32_t /*tgid=arg(0), pid=arg(1),*/ sig=arg(2);
            // TODO: Actually check thread group and kill properly
            if (debug && trace_syscall) fputs("(throwing...)\n", debug);
            throw Exit(__W_EXITCODE(0, sig));
            break;

        }

	case 306: { /* 0x132, fchmodat */
            syscall_enter("fchmodat", "dsd");
	    int dirfd = arg(0);
	    uint32_t path = arg(1);
            std::string sys_path = read_string(path);
	    mode_t mode = arg(2);
	    int flags = arg(3);

	    int result = fchmodat(dirfd, sys_path.c_str(), mode, flags);
            if (result == -1) result = -errno;
            writeGPR(x86_gpr_ax, result);

            syscall_leave("d");
            break;
	}

        case 311: { /*0x137, set_robust_list*/
            syscall_enter("set_robust_list", "pd");
            uint32_t head_va=arg(0), len=arg(1);
            void *head = my_addr(head_va);
            
            /* Allow Linux to update the specimen's memory directly. */
            int status = syscall(SYS_set_robust_list, head, len);
            if (status<0) {
                writeGPR(x86_gpr_ax, -errno);
            } else {
                writeGPR(x86_gpr_ax, 0);
            }
            syscall_leave("d");
            break;
        }

        default: {
            fprintf(stderr, "syscall_%u(", callno);
            for (int i=0; i<6; i++)
                fprintf(stderr, "%s0x%08"PRIx32, i?", ":"", arg(i));
            fprintf(stderr, ") is not implemented yet\n\n");
            fprintf(stderr, "dumping specimen core...\n");
            dump_core(SIGSYS);
            abort();
        }
    }
}

void
EmulationPolicy::syscall_arginfo(char format, uint32_t val, ArgInfo *info, va_list ap)
{
    ROSE_ASSERT(info!=NULL);
    info->val = val;
    switch (format) {
        case 'f':       /*flags*/
        case 'e':       /*enum*/
            info->xlate = va_arg(ap, const Translate*);
            break;
        case 's':       /*NUL-terminated string*/
            info->str = read_string(val);
            break;
    }
}

void
EmulationPolicy::syscall_enter(const char *name, const char *format, ...)
{
    va_list ap;
    va_start(ap, format);

    if (debug && trace_syscall) {
        ArgInfo args[6];
        for (size_t i=0; format[i]; i++)
            syscall_arginfo(format[i], arg(i), args+i, ap);
        print_enter(debug, name, format, args);
    }
    
    va_end(ap);
}

void
EmulationPolicy::syscall_leave(const char *format, ...) 
{
    va_list ap;
    va_start(ap, format);

    ROSE_ASSERT(1==strlen(format));
    if (debug && trace_syscall) {
        ArgInfo info;
        uint32_t value = readGPR(x86_gpr_ax).known_value();
        syscall_arginfo(format[0], value, &info, ap);
        print_leave(debug, format[0], &info);
    }
}


uint32_t
EmulationPolicy::arg(int idx)
{
    switch (idx) {
        case 0: return readGPR(x86_gpr_bx).known_value();
        case 1: return readGPR(x86_gpr_cx).known_value();
        case 2: return readGPR(x86_gpr_dx).known_value();
        case 3: return readGPR(x86_gpr_si).known_value();
        case 4: return readGPR(x86_gpr_di).known_value();
        case 5: return readGPR(x86_gpr_bp).known_value();
        default: assert(!"invalid argument number"); abort();
    }
}

int
main(int argc, char *argv[])
{
    typedef X86InstructionSemantics<EmulationPolicy, VirtualMachineSemantics::ValueType> Semantics;
    EmulationPolicy policy;
    Semantics t(policy);
    uint32_t dump_at = 0;               /* dump core the first time we hit this address, before the instruction is executed */
    std::string dump_name = "core";

    /* Parse command-line */
    int argno = 1;
    while (argno<argc && '-'==argv[argno][0]) {
        if (!strcmp(argv[argno], "--")) {
            argno++;
            break;
        } else if (!strncmp(argv[argno], "--debug=", 8)) {
            policy.debug = stderr;
            char *s = argv[argno]+8;
            while (s && *s) {
                char *comma = strchr(s, ',');
                std::string word(s, comma?comma-s:strlen(s));
                s = comma ? comma+1 : NULL;
                if (word=="all") {
                    policy.trace_insn = true;
                    policy.trace_state = true;
                    policy.trace_mem = true;
                    policy.trace_mmap = true;
                    policy.trace_syscall = true;
                    policy.trace_loader = true;
                } else if (word=="insn") {
                    policy.trace_insn = true;
                } else if (word=="state") {
                    policy.trace_state = true;
                } else if (word=="mem") {
                    policy.trace_mem = true;
                } else if (word=="mmap") {
                    policy.trace_mmap = true;
                } else if (word=="syscall") {
                    policy.trace_syscall = true;
                } else if (word=="loader") {
                    policy.trace_loader = true;
                } else {
                    fprintf(stderr, "%s: debug words must be from the set: insn, state, mem, mmap, syscall\n", argv[0]);
                    exit(1);
                }
            }
            argno++;
        } else if (!strcmp(argv[argno], "--debug")) {
            policy.debug = stderr;
            policy.trace_insn = true;
            policy.trace_syscall = true;
            argno++;
        } else if (!strncmp(argv[argno], "--dump=", 7)) {
            char *rest;
            errno = 0;
            dump_at = strtoul(argv[argno]+7, &rest, 0);
            if (rest==argv[argno]+7 || errno!=0) {
                fprintf(stderr, "%s: --dump=N requires an address, N\n", argv[0]);
                exit(1);
            }
            if (','==rest[0] && rest[1])
                dump_name = rest+1;
            argno++;
        } else {
            fprintf(stderr, "usage: %s [--debug] PROGRAM ARGUMENTS...\n", argv[0]);
            exit(1);
        }
    }
    ROSE_ASSERT(argc-argno>=1); /* usage: executable name followed by executable's arguments */
    SgAsmGenericHeader *fhdr = policy.load(argv[argno]); /*header for main executable, not libraries*/
    policy.initialize_stack(fhdr, argc-argno, argv+argno);

    /* Debugging */
    if (policy.debug && policy.trace_mmap) {
        fprintf(policy.debug, "memory map after program load:\n");
        policy.map->dump(policy.debug, "  ");
    }

    /* Execute the program */
    bool seen_entry_va = false;
    while (true) {
        try {
            if (dump_at!=0 && dump_at == policy.readIP().known_value()) {
                fprintf(stderr, "Reached dump point. Dumping specimen core...\n");
                policy.dump_core(SIGABRT);
                dump_at = 0;
            }
            SgAsmx86Instruction *insn = policy.current_insn();
            if (policy.debug && policy.trace_mmap &&
                !seen_entry_va && insn->get_address()==fhdr->get_base_va()+fhdr->get_entry_rva()) {
                fprintf(policy.debug, "memory map at program entry:\n");
                policy.map->dump(policy.debug, "  ");
                seen_entry_va = true;
            }
            t.processInstruction(insn);
            if (policy.debug && policy.trace_state)
                policy.dump_registers(policy.debug);
        } catch (const Semantics::Exception &e) {
            std::cerr <<e <<"\n\n";
            abort();
        } catch (const VirtualMachineSemantics::Policy::Exception &e) {
            std::cerr <<e <<"\n\n";
            abort();
        } catch (const EmulationPolicy::Exit &e) {
            /* specimen has exited */
            if (WIFEXITED(e.status)) {
                fprintf(stderr, "specimen exited with status %d\n", WEXITSTATUS(e.status));
		if( WEXITSTATUS(e.status) )
                   exit( WEXITSTATUS(e.status) );
            } else if (WIFSIGNALED(e.status)) {
                fprintf(stderr, "specimen exited due to signal %d (%s)%s\n",
                        WTERMSIG(e.status), strsignal(WTERMSIG(e.status)), 
                        WCOREDUMP(e.status)?" core dumped":"");
                /* Eventually we'll put this where the signal is thrown. [RPM 2010-09-18] */
                policy.dump_core(WTERMSIG(e.status));
            } else if (WIFSTOPPED(e.status)) {
                fprintf(stderr, "specimen is stopped due to signal %d (%s)\n", 
                        WSTOPSIG(e.status), strsignal(WSTOPSIG(e.status)));
            }
            break;
        }
    }
    return 0;
}

#else
int main(int, char *argv[])
{
    std::cerr <<argv[0] <<": not supported on this platform" <<std::endl;
    return 1;
}

#endif /* ROSE_ENABLE_SIMULATOR */

$CXX  /* Generate Compiler Module */
COMPILER AGPP

using namespace std;

#include "crt.h"

#include "agppp.hpp"
#include "agpps.hpp"

#include <stdlib.h>
#include <iostream>
#include <list>
#include <string>

int global_len;
int global_pos;

list<string> terminalsList;

#define semActionIndent "      "
#define MAXSEMLEN 2000

bool isTerminal(string s) {
  for(list<string>::iterator i=terminalsList.begin();
      i!=terminalsList.end();
      i++) {
    if(s==*i) return true;
  }
  return false;
}

string
generateTerminalInit(string terminalName) {
  string s;
  s="(. "+terminalName+"* astNode = dynamic_cast<class "+terminalName+"*>(dynamic_cast<slangScanner*>(Scanner)->getCurrentAstToken().node); .)\n";
  return s;
}

string
generateLock(string restructureObjectName) {
  string s;
  s="(. "+restructureObjectName+"->lock(astNode); .)\n";
  return s;
}

string
generateUnlock(string restructureObjectName) {
  string s;
  s="(. "+restructureObjectName+"->unlock(astNode) .)\n";
  return s;
}

/*
static void FixString(char *name)
{
  int i, j, len, spaces, start;
  len = strlen(name);
  if (len == 2) { SemError(129); return; }
  if (ignore_case) upcase(name);
  spaces = FALSE; start = name[0];
  for (i = 1; i <= len-2; i++) {
    if (name[i] > 0 && name[i] <= ' ') spaces = TRUE;
    if (name[i] == '\\') {
      if (name[i+1] == '\\' || name[i+1] == '\'' || name[i+1] == '\"') {
        for (j = i; j < len; j++) name[j] = name[j+1]; len--;
      }
    }
  }
  if (spaces) SemError(124);
}
*/
/**************************************************************************/

CHARACTERS
  letter   = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_" .
  digit    = "0123456789" .
  cntl     = CHR(0)..CHR(31).
  tab      = CHR(9) .
  eol      = CHR(13).
  lf       = CHR(10) .
  back     = CHR(92) .
  noQuote1 = ANY - '"' - cntl - back .
  noQuote2 = ANY - "'" - cntl - back .
  graphic  = ANY - cntl .

IGNORE tab + eol + lf

TOKENS
  ident     = letter {letter | digit} .
  string    =   '"' {noQuote1 | back graphic } '"'
              | "'" {noQuote2 | back graphic } "'" .
  badstring =   '"' {noQuote1 | back graphic } ( eol | lf )
              | "'" {noQuote2 | back graphic } ( eol | lf ) .
  number    = digit {digit} .

NAMES
  Range   = "..".

PRAGMAS
  Options = "$" {letter}.
                                (. char s[100];
                                   LookAheadString(s, sizeof(s)-1);
                                   cout << s << "\n";
                                 .)

COMMENTS
  FROM "/*" TO "*/" NESTED

PRODUCTIONS

AGPP =                            (. Name name1, compiler_name; .)
                                (. long P; char semstring[MAXSEMLEN];
                                   int Len; .)


   "COMPILER"                   (. P = LexPos()/*+8*/; .)
   Ident<compiler_name>         (. global_pos  = LookAheadPos();
                                   
                                .)
   { ANY }                      (. global_len  =
                                     (int) (LookAheadPos()-global_pos); .)
                                (. Len = (int) (LookAheadPos() - P); GetString(P,semstring,Len); cout << semstring << "\n\n"; .)
   { Declaration }
   SYNC                         

   "PRODUCTIONS"                
                                (. cout << "\nPRODUCTIONS\n"; .)
   { Rule }
   "END" Ident<name1> "."       (. cout << "END " << name1 << " .\n"; .)
   .

Rule =                         (. Name name1; int attr, sem,exp,n1; .)
      Ident<name1>             (. cout << name1 << " "; .)
      [ Attribs<&attr> ]
      "="                      (. cout << "= "; .)
      Rhs { "|" (. cout << "| " .) Rhs }
      "."                      (. cout << ".\n"; .)
      .

Rhs =                           (. Name name1; int attr; int n1; .)
      ( [ SemTextList<&n1> ]
        Ident<name1>            (. cout << name1 << " ";
				   if(isTerminal(name1)) {
                                   string t=generateTerminalInit(name1);
                                   string l=generateLock("subst");
                                   cout << "(. { .)"+t+l << endl;
                                   }
                                 .)  
      [ Attribs<&attr> ]        
      [ SemTextList<&n1> ]
      )
      [
      string                    (. cout << "\"(\" "; .)
      [
      (
      "{" (. cout << "{ "; .) [ SemTextList<&n1> ] NonTerminalExp "}" (. cout << "}"; .)
      |
      NonTerminalExpList { "|" (. cout << "\n| "; .) NonTerminalExpList }
      )
      ]
      string (. cout << "\")\""; .)
      [ SemTextList<&n1> ]
      ]
           (. if(isTerminal(name1)) { 
		string ul=generateUnlock("subst");
                cout << ul+"(. } .)"; 
              } 
           .)
           (. cout << "\n";      .)
      .

NonTerminalExpList = (. int n1; .) [ SemTextList<&n1> ] NonTerminalExp { NonTerminalExp }
      .

NonTerminalExp = (. Name name; int n1;.)
        "[" (.  cout << "[ "; .) [ SemTextList<&n1> ] NonTerminal "]" (. cout << "]"; .) [ SemTextList<&n1> ]
      | NonTerminal
      .

NonTerminal =                   (. int attr,n1; Name name1; .)
      Ident<name1>              (. cout << name1 << " "; .)
      [ Attribs<&attr> ]
      [ SemTextList<&n1> ]
      .

Declaration =             
    "TOKENS" (. cout << "TOKENS\n"; .)  { TokenDecl }
   .

TokenDecl =              (. char name[MAX_STR_LEN]; .)
   (  Ident<name> (. cout << name << "\n"; terminalsList.push_back(name); .)
   )
   .

/*
Symbol<char *name> =
    ( Ident<name>               
    | String<name>            
    )
    .
*/

Ident<char *s> =
   ident                        (. LexString(s, MAX_ID_LEN-1) .)
   .

/*
String<char *s> =
   string                       (. LexString(s, MAX_STR_LEN-1);
                                   /* FixString(s); */ .)
   .
*/

Attribs<int *n> =
                                (. long P; char semstring[MAXSEMLEN];
                                   int Len, Line, Col; .)
     "<"                          (. P = LexPos(); .)
     { ANY | badstring            (. .)
     }
     ">"                          (. Len = (int) (LexPos() - P);
                                     GetString(P,semstring,Len); cout << semstring << "> ";
                                   .)
   |
     "<."                         (. P = LexPos(); .)
     { ANY | badstring            (. .)
     }
     ".>"                         (. Len = (int) (LexPos() - P);
                                     GetString(P,semstring,Len); cout << semstring << ".> ";
                                  .)

   .

SemTextList<int *n> =
   SemText<n> { SemText<n> }
   .

SemText<int *n> =
                                (. long P; char semstring[MAXSEMLEN];
                                   int Len, Line, Col; .)
   "(."                         (. 
                                   P = LexPos()/*+2*/; .)
             
   {   ANY                      
     | badstring                (. SemError(102); .)
     | "(."                     (. SemError(109); .)
   }                           

   ".)"                         (. Len = (int) (LexPos() - P);
                                   GetString(P,semstring,Len); cout << semstring << ".)\n";
                                .)
   .

END AGPP.

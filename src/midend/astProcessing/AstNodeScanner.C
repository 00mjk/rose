
#include "AstNodeScanner.h"
#include <iostream>

// DQ (12/31/2005): This is OK if not declared in a header file
using namespace std;

SgNode* currentAstNode;

#define Scan_Ch        Ch
#define Scan_NextCh    NextCh
#define Scan_ComEols   ComEols
#define Scan_CurrLine  CurrLine
#define Scan_CurrCol   CurrCol
#define Scan_LineStart LineStart
#define Scan_BuffPos   BuffPos
#define Scan_NextLen   NextSym.Len

int slangScanner::STATE0[] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,8,10,0,7,4,9,2,2,2,2,2,2,2,2,2,2,5,3,
                  12,11,13,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
                  1,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
                  1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};

int slangScanner::CheckLiteral(int id)
{ 
  assert(0);
  cout << "PANIC!!! CHECK LITERAL!!!" << endl;
  char c;
  c =  CurrentCh(NextSym.Pos);
  return id;
}

int slangScanner::Comment()
{ 
  assert(0);
  cout << "PANIC!!! COMMENT!!!" << endl;
  int Level, StartLine, OldCol;
  long OldLineStart;

  Level = 1; StartLine = CurrLine;
  OldLineStart = LineStart; OldCol = CurrCol;
  if (Scan_Ch == '(') { /* 1 */
  	Scan_NextCh();
  	if (Scan_Ch == '*') { /* 2 */
  		Scan_NextCh();
  		while (1) {
  			if (Scan_Ch== '*') { /* 5 */
  				Scan_NextCh();
  				if (Scan_Ch == ')') { /* 6 */
  					Level--; Scan_NextCh(); Scan_ComEols = Scan_CurrLine - StartLine;
  					if(Level == 0) return 1;
  				} /* 6 */ 
  			} else  /* 5 */
  			if (Scan_Ch == '(') {
  				Scan_NextCh();
  				if (Scan_Ch == '*') { Level++; Scan_NextCh(); }
  			} else /* 5 */
  			if (Scan_Ch == EOF_CHAR) return 0;
  			else Scan_NextCh();
  		} /* while */
  	} else { /* 2 */
  		if (Scan_Ch == LF_CHAR) { Scan_CurrLine--; Scan_LineStart = OldLineStart; }
  		Scan_BuffPos -= 2; Scan_CurrCol = OldCol - 1; Scan_NextCh();
  	} /* 2 */
  } /* 1*/
  
  return 0;
}

int cocoAstNodeCode(SgNode* node) {
  int i=node->variantT();
  int code=0;

  switch(i) {
    // this include file is generated by ROSETTA in <compile_tree>/ROSETTA/src
    // and copied to the AstProcessingLib directory when make is run
    // (similar to all the files which are generated for SAGE)
    #include "Cxx_GrammarCocoSymbolsMapping.C"
  case V_SgClassDeclaration:
    //cout << "SCANNER FIX : SgClassDeclaration:" << i << endl;
    code=SgClassDeclarationSym;
    break;
  case V_SgClassDefinition:
    //cout << "SCANNER FIX : SgClassDefinition:" << i << endl;
    code=SgClassDefinitionSym;
    break;
  case V_SgFunctionDeclaration: // this is NOT included in the generated code. TypeHierarchy needs to be fixed.
    //cout << "SCANNER FIX : FunctionDeclaration:" << i << endl;
    code=SgFunctionDeclarationSym;
    break;
  case V_SgFunctionSymbol:
    //cout << "SCANNER FIX : FunctionSymbol:" << i << endl;
    code=SgFunctionSymbolSym;
    break;
  default:
    ;//cout << "DEFAULT CASE:" << i << endl;
  }
  //cout << "return code :" << code << endl;
  return code;
}


int slangScanner::Get() { 
  ATContainer::iterator inputIteratorCopy=inputIteratorStart;
  if(inputIteratorStart!=inputIteratorEnd) {
    currentAstToken=lookAheadAstToken;
    lookAheadAstToken=*inputIteratorStart;
    inputIteratorStart++;
  }
  else {
    //cout << "G:EOF_Sym";
    return EOF_Sym;
  }
  //cout << "G:" << currentAstToken.scannerSymbol;
  //currentAstToken=*inputIteratorCopy;
  if(currentAstToken.scannerSymbol!=LparenSym && currentAstToken.scannerSymbol!=RparenSym) {
    currentAstNode=currentAstToken.node;
    { 
      //cout << "cococode:(" << currentAstToken.scannerSymbol << ":" << currentAstNode << ":" << (currentAstNode?currentAstNode->sage_class_name():string("")) << ")" << endl; 
    }
  } else {
    currentAstNode=0;
  }
  return lookAheadAstToken.scannerSymbol;
}

AstToken
slangScanner::getCurrentAstToken() {
  return currentAstToken;
}

AstToken
slangScanner::getLookAheadAstToken() {
  return lookAheadAstToken;
}

slangScanner::slangScanner(SgNode* node) {
  if(SgProject* startNode=dynamic_cast<SgProject*>(node))
    tokenstream=new ATContainer(startNode);
  if(SgFile* startNode=dynamic_cast<SgFile*>(node))
    tokenstream=new ATContainer(startNode);
  if(SgNode* startNode=dynamic_cast<SgNode*>(node))
    tokenstream=new ATContainer(startNode);
  inputIteratorStart=tokenstream->begin();
  inputIteratorEnd=tokenstream->end();

#if 0
  cout << "STREAM GENERATED:" << endl;
  for(ATContainer::iterator i=tokenstream->begin();i!=tokenstream->end();i++) {
    AstToken t=*i;
    switch(t.scannerSymbol) {
    case LparenSym:
      cout << "("; break;
    case RparenSym:
      cout << ")"; break;
    default: {
      if(t.node==0) cout << "0 ";
      else cout << t.node->variantT() << " ";
    }
    }
  }
  cout << endl << "STREAM GENERATION FINISHED" << endl;
#endif

}

  slangScanner::~slangScanner() {
    delete tokenstream;
  }
  void slangScanner::Reset() { 
    inputIteratorStart=tokenstream->begin(); 
  }

/**************************************************/


__Dummy*
ATContainer::evaluateInheritedAttribute(SgNode* astNode, __Dummy* d) {
  
  AstToken t0(cocoAstNodeCode(astNode),astNode);
  this->push_back(t0);
  //cout << astNode->variantT() << " ";
  AstToken t1(LparenSym);
  this->push_back(t1);
  //cout << "(";
  return d; // dummy 
}

__Dummy*
ATContainer::evaluateSynthesizedAttribute(SgNode* astNode, __Dummy* d, SubTreeSynthesizedAttributes l) {
  
  AstToken tn(RparenSym);
  this->push_back(tn);
  //cout << "[" << astNode->get_traversalSuccessorContainer().size() << "]) ";
  __Dummy* syn = 0;
  return syn; // dummy
}

/*
ATContainer::ATContainer(SgProject* node) {
  __Dummy d;
  traverseInputFiles(node, &d);
}
ATContainer::ATContainer(SgFile* node) {
  __Dummy d;
  traverseWithinFile(node, &d);
}
*/
ATContainer::ATContainer(SgNode* node) {
  __Dummy d;
  //ROSE_ASSERT(dynamic_cast<SgProject*>(node));
  //ROSE_ASSERT(dynamic_cast<SgFile*>(node));
  traverse(node, &d);
}

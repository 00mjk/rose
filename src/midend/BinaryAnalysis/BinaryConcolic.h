#ifndef ROSE_BinaryAnalysis_Concolic_H
#define ROSE_BinaryAnalysis_Concolic_H

#include <boost/filesystem.hpp>
#include <boost/serialization/access.hpp>
#include <boost/serialization/nvp.hpp>
#include <RoseException.h>
#include <Sawyer/BiMap.h>
#include <Sawyer/SharedObject.h>
#include <Sawyer/SharedPointer.h>
#include <Sawyer/Synchronization.h>
#include <memory>
#include <rose_isnan.h>
#include <stdexcept>
#include <string>
#include <vector>

namespace Rose {
namespace BinaryAnalysis {

/** Concolic testing system.
 *
 *  This namespace defines a framework for writing concolic testing systems. A system consists of these main parts:
 *
 *  @li A @em{database} stores all information about the state of the system.  All state is localized to the database; the
 *      functional parts of the  system are stateless. This allows a long-running concolic test to be interrupted and restarted
 *      later.
 *
 *  @li A @em{test case} describes what to run and how to run it. This includes such things as the command-line, input files,
 *      virtual memory characteristics, system call handling, etc.
 *
 *  @li A @em{manager} reads the database and runs the other functional parts of the system, perhaps in parallel. The manager
 *      is also responsible for ranking and deduplication of test cases. The ranking uses a user-defined metric computed by the
 *      concrete executer (described below) to decide which test case to run next in the symbolic executer (defined below). The
 *      deduplication removes test cases generated by the symbolic executor if they already exist in the database (perhaps
 *      using approximate comparisons).
 *
 *  @li A @em{concrete executor} executes a test case concretely and measures certain user-defined characteristics. The results
 *      are saved in the database.
 *
 *  @li A @em{symolic executor} executes a test case symbolically and generates new test cases that are inserted into the database. */
namespace Concolic {

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Flags and enums
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

namespace Update {
enum Flag { NO, YES };
} // namespace

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Exceptions, errors, etc.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

extern Sawyer::Message::Facility mlog;

/** Base class for exceptions for concolic testing. */
class Exception: public Rose::Exception {
public:
    explicit Exception(const std::string &mesg): Rose::Exception(mesg) {}
    ~Exception() throw () {}
};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Specimens
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/** Binary specimen. */
class Specimen: public Sawyer::SharedObject {
public:
    /** Referenc-counting pointer to a @ref Specimen. */
    typedef Sawyer::SharedPointer<Specimen> Ptr;

private:
    mutable SAWYER_THREAD_TRAITS::Mutex mutex_;         // protects the following data members
    std::string name_;                                  // name of specimen (e.g., for debugging)
    std::vector<uint8_t> specimen_;                     // content of the binary executable file

private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        s & BOOST_SERIALIZATION_NVP(specimen_);
    }
    
protected:
    Specimen() {}

public:
    /** Allocating constructor. */
    static Ptr instance(const boost::filesystem::path &executableName);

    /** Open an executable file.
     *
     *  The contents of the executable file are copied into this object when the file is opened.  After the file is opened
     *  successfully, the @ref isEmpty predicate returns false.  Throws an @ref Exception if the file cannot be opened.
     *
     *  Thread safety: This method is thread-safe. */
    void open(const boost::filesystem::path &executableName);

    /** Close the executable file.
     *
     *  Removes all content from this object, or does nothing if @ref isEmpty returns true. After this call, @ref isEmpty
     *  returns true. Throws an @ref Exception if this object is already non-empty.
     *
     *  Thread safety: This method is thread-safe. */
    void close();

    /** Test whether this object is empty.
     *
     *  Returns true if a binary executable is associated with this specimen, false otherwise. See also, @ref open and @ref close.
     *
     *  Thread safety: This method is thread-safe. */
    bool isEmpty() const { return specimen_.empty(); }

    /** Property: Specimen name.
     *
     *  This should be a printable name, such as a file name. It's used mostly for informational purposes such as
     *  debugging. There is no requirement that names be unique or non-empty.
     *
     *  Thread safety: This methods is thread-safe.
     *
     * @{ */
    std::string name() const;                           // value return is intentional for thread safety
    void name(const std::string&);
    /** @} */
};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Test cases
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/** Information about how to run a specimen. */
class TestCase: public Sawyer::SharedObject {
public:
    /** Reference counting pointer to a @ref TestCase. */
    typedef Sawyer::SharedPointer<TestCase> Ptr;

private:
    mutable SAWYER_THREAD_TRAITS::Mutex mutex_;         // protects the following data members
    std::string name_;                                  // name for debugging
    Specimen::Ptr specimen_;                            // the thing to run

protected:
    TestCase() {}

public:
    /** Allocating default constructor. */
    static Ptr instance() {
        return Ptr(new TestCase);
    }

    /** Allocating constructor. */
    static Ptr instance(const Specimen::Ptr &specimen);

    /** Property: Test case name.
     *
     *  This should be a printable name, such as a specimen name and/or serial number. It's used mostly for informational
     *  purposes such as debugging. There is no requirement that the name be unique or non-empty.
     *
     *  Thread safety: This method is thread safe.
     *
     * @{ */
    std::string name() const;                           // value return is intentional for thread safety
    void name(const std::string&);
    /** @} */

    /** Property: Specimen.
     *
     *  The specimen that is being examined by this test case.
     *
     *  Thread safety: This method is thread safe.
     *
     * @{ */
    Specimen::Ptr specimen() const;
    void specimen(const Specimen::Ptr&);
    /** @} */
};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Concrete executors and their results
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/** Base class for executing test cases concretely.
 *
 *  The user is expected to subclass this object in order to define the specifics of how to execute a test case concretely,
 *  measure some properties of the execution, and return those properties. A basic @ref LinuxExecutor subclass is already
 *  provided to give an example of how to run a program and measure its exit status. Other more complex executors might do
 *  things like measure code coverage.
 *
 *  ConcreteExecutor objects are expected to be used in single-threaded applications. Supporting multi-threaded concrete
 *  executors would be difficult since calling fork[2] from multi-threaded C++ programs is fraught with danger. Therefore, none
 *  of the methods in this API are thread-safe. */
class ConcreteExecutor: public Sawyer::SharedObject {
public:
    /** Reference counting pointer to a @ref ConcreteExecutor. */
    typedef Sawyer::SharedPointer<ConcreteExecutor> Ptr;

    /** Base class for user-defined concrete execution results.
     *
     *  Regardless of what data a subclass might add, all concrete execution results have a floating-point "rank" used to sort
     *  them when creating the list of test cases that should next run symbolically. The convention is that those with lower
     *  ranks will run before those with higher ranks, although subclasses of @ref ExecutionManager can override this. The rank
     *  should be a real number (not NaN).
     *
     *  The subclasses must provide boost::serialization support which is used to store the user-defined results in the
     *  database and to reconstitute results objects from the database. Since this is a relatively expensive operation, the
     *  rank is also stored separately within the database. */
    class Result {
    private:
        double rank_;

    public:
        explicit Result(double rank): rank_(rank) {
            ASSERT_forbid(rose_isnan(rank));
        }
        virtual ~Result() {}

    private:
        friend class boost::serialization::access;

        template<class S>
        void serialize(S &s, const unsigned /*version*/) {
            s & BOOST_SERIALIZATION_NVP(rank_);
        }
    };

protected:
    // Allocating constructors should be implemente by the non-abstract subclasses.
    ConcreteExecutor() {}
    
public:
    /** Execute one test case synchronously.
     *
     *  Returns the results from running the test concretely. Results are user-defined. The return value is never a null
     *  pointer. */
    virtual std::unique_ptr<Result> execute(const TestCase::Ptr&) = 0;
};


/** Concrete executor for Linux ELF executables. */
class LinuxExecutor: public ConcreteExecutor {
public:
    /** Reference counting pointer to a @ref LinuxExecutor. */
    typedef Sawyer::SharedPointer<LinuxExecutor> Ptr;

    /** Base class for user-defined Linux concrete execution results. */
    class Result: public ConcreteExecutor::Result {
    protected:
        int exitStatus_;                                /**< Exit status as returned by waitpid[2]. */

    private:
        friend class boost::serialization::access;

        template<class S>
        void serialize(S &s, const unsigned /*version*/) {
            s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(ConcreteExecutor::Result);
            s & BOOST_SERIALIZATION_NVP(exitStatus_);
        }
        
    public:
        Result(int exitStatus);

        /** Property: Exit status of the executable.
         *
         *  The executable exit status is the value returned by waitpid[2] and contains not only the argument of the program's
         *  "exit" function, but also information about whether the program called exit or was terminated by a signal, and
         *  whether the signal produced a core dump.
         *
         * @{ */
        int exitStatus() const { return exitStatus_; }
        void exitStatus(int x) { exitStatus_ = x; }
        /** @} */
    };

protected:
    bool useAddressRandomization_;                      // enable/disable address space randomization in the OS

protected:
    LinuxExecutor()
        : useAddressRandomization_(false) {}

public:
    /** Allocating constructor. */
    static Ptr instance() {
        return Ptr(new LinuxExecutor);
    }

    /** Property: Address space randomization.
     *
     *  This property controls whether the specimen is executed with or without OS address space randomization. It's usually
     *  better to turn off randomization for repeatable results, and it is therefore off by default.
     *
     * @{ */
    bool useAddressRandomization() const { return useAddressRandomization_; }
    void useAddressRandomization(bool b) { useAddressRandomization_ = b; }
    /** @} */

    virtual std::unique_ptr<ConcreteExecutor::Result> execute(const TestCase::Ptr&) ROSE_OVERRIDE;
};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Symbolic executors
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class SymbolicExecutor: public Sawyer::SharedObject {
public:
    /** Reference counting pointer to @ref SymbolicExecutor. */
    typedef Sawyer::SharedPointer<SymbolicExecutor> Ptr;

protected:
    SymbolicExecutor() {}

public:
    /** Allcoating constructor. */
    static Ptr instance() {
        return Ptr(new SymbolicExecutor);
    }

    /** Execute the test case.
     *
     *  Executes the test case to produce new test cases. */
    std::vector<TestCase::Ptr> execute(const TestCase::Ptr&);

    // TODO: Lots of properties to control the finer aspects of executing a test case!
};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Test suites
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/** Test suite.
 *
 *  A @em{test suite} is a coherent collection of test cases. The test suite usuall starts with a single "seed" test case and
 *  contains additional test cases generated by the symbolic executor. All test cases within a test suite use the same concrete
 *  executor and measure the same user-defined execution properties. For example, the database might contain one test suite
 *  based on "/bin/grep" and another test suite running "/bin/cat".  Or it might have two test suites both running "/bin/grep"
 *  but one always using "--extended-regexp" and the other always using "--basic-regexp".  Or it might have two test suites
 *  both running "/bin/cat" but one measures exit status and the other measures code coverage. */
class TestSuite: public Sawyer::SharedObject {
public:
    /** Reference counting pointer to @ref TestSuite. */
    typedef Sawyer::SharedPointer<TestSuite> Ptr;

private:
    mutable SAWYER_THREAD_TRAITS::Mutex mutex_;         // protects the following data members
    std::string name_;                                  // unique and non-empty within a database

protected:
    TestSuite() {}

public:
    /** Allocating constructor. */
    static Ptr instance(const std::string &name = "");

    /** Property: Name.
     *
     *  Within a database, a test suite must have a unique non-empty name. However this is not a requirement when the test
     *  suite exists only in memory. The constraints are enforced when the test suite is added to the database.
     *
     *  Thread safety: This method is thread safe.
     *
     * @{ */
    std::string name() const;                           // value return is intentional for thread safety
    void name(const std::string&);
    /** @} */
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Databases
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/** Database.
 *
 *  A database holds the entire state for a concolic testing system consisting of one or more test suites. A @ref Database
 *  object is always connected to exactly one database and limits the scope of its operations to exactly one test suite (except
 *  where noted).
 *
 *  A @ref Database object refers to persistent storage through a URL using ROSE's SqlDatabase layer. This supports both
 *  PostgreSQL databases and SQLite3 databases the the possibility of adding other RDMSs later.
 *
 *  Objects within a database have an ID number, and these ID numbers are type-specific. When an object is inserted (copied)
 *  into a database a new ID number is returned. The @ref Database object memoizes the association between object IDs and
 *  objects. */
class Database: public Sawyer::SharedObject, boost::noncopyable {
public:
    /** Reference counting pointer to @ref Database. */
    typedef Sawyer::SharedPointer<Database> Ptr;

    /** Base class for object IDs */
    typedef Sawyer::Optional<int> ObjectId;
    
    /** ID numbers for test suites. */
    struct TestSuiteId: ObjectId {};

    /** ID numbers for specimens. */
    struct SpecimenId: ObjectId {};

    /** ID numbers for test cases. */
    struct TestCaseId: ObjectId {};

private:
    Sawyer::Container::BiMap<SpecimenId, Specimen::Ptr> specimens_;
    Sawyer::Container::BiMap<TestCaseId, TestCase::Ptr> testCases_;
    Sawyer::Container::BiMap<TestSuiteId, TestSuite::Ptr> testSuites_;
    TestSuiteId testSuiteId_;                           // database scope is restricted to this single test suite
    
protected:
    Database() {}

public:
    /** Open an existing database.
     *
     *  Throws an @ref Exception if the database does not exist. */
    static Ptr instance(const std::string &url);

    /** Create a new database and test suite.
     *
     *  For database management systems that support it, a new database is created, possibly overwriting any previous data if
     *  the database already existed. SQLite3 databases can be created this way because they're just files in the local
     *  filesystem, but PostgreSQL databases need to be created through the DBMS. Throws an @ref Exception if the new database
     *  could not be created.
     *
     *  Once the database is created, a new test suite with the given name is created. */
    static Ptr create(const std::string &url, const std::string &testSuiteName);

    //------------------------------------------------------------------------------------------------------------------------
    // Test suites
    //------------------------------------------------------------------------------------------------------------------------

    /** All test suites.
     *
     *  Returns information about all the test suites that exist in this database. This is essentially the table of contents
     *  for the database. */
    std::vector<TestSuiteId> testSuites();

    /** Property: the current test suite.
     *
     *  If the database has a current test suite, then queries are limited in scope to return results associated with that test
     *  suite.  Setting the test suite property also updates the database with information about the test suite, creating the
     *  test suite if necessary.
     *
     * @{ */
    TestSuite::Ptr testSuite();
    TestSuiteId testSuite(const TestSuite::Ptr&);
    /** @} */

    //------------------------------------------------------------------------------------------------------------------------
    // Specimens
    //------------------------------------------------------------------------------------------------------------------------

    /** All specimens.
     *
     *  If this database object has a current test suite, then the return value is limited to specimens used by that test
     *  suite, otherwise all specimens are returned. */
    std::vector<SpecimenId> specimens();
    
    //------------------------------------------------------------------------------------------------------------------------
    // Test cases
    //------------------------------------------------------------------------------------------------------------------------

    /** All test cases.
     *
     *  If this database object has a current test suite, then the return value is limited to test cases used by that test
     *  suite, otherwise all test cases are returned. */
    std::vector<TestCaseId> testCases();

    //------------------------------------------------------------------------------------------------------------------------
    // Overloaded methods for all objects.
    //------------------------------------------------------------------------------------------------------------------------

    /** Reconstitute a object from a database ID.
     *
     *  The association between object and ID is memoized. If @p update is yes and a memoized object is being returned, then
     *  also updates the object with the current values from the database.
     *
     * @{ */
    TestSuite::Ptr object(TestSuiteId, Update::Flag update = Update::YES);
    TestCase::Ptr object(TestCaseId, Update::Flag update = Update::YES);
    Specimen::Ptr object(SpecimenId, Update::Flag update = Update::YES);
    /** @} */

    /** Returns an ID number for an object, optionally writing to the database.
     *
     *  If the object exists in the database (i.e., returned as the result of some query) then its ID is returned and the
     *  database is optionally updated. On the other hand, if the object does not exist in the database then it will be created
     *  only if @p update is yes and its new ID is returned. If the object doesn't exist and isn't created then an invalid ID
     *  is returned.
     *
     * @{ */
    TestSuiteId id(const TestSuite::Ptr&, Update::Flag update = Update::YES);
    TestCaseId id(const TestCase::Ptr&, Update::Flag update = Update::YES);
    SpecimenId id(const Specimen::Ptr&, Update::Flag update = Update::YES);
    /** @} */
};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Execution manager
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/** Base class for managing an entire concolic testing run.
 *
 *  An @ref ExecutionManager is responsible for running an entire test suite either starting from scratch or restarting from a
 *  previous state that was saved in a database. */
class ExecutionManager: boost::noncopyable, public Sawyer::SharedObject {
public:
    /** Reference counting pointer to an @ref ExecutionManager. */
    typedef Sawyer::SharedPointer<ExecutionManager> Ptr;

private:
    Database::Ptr database_;

protected:
    // Subclasses should implement allocating constructors
    explicit ExecutionManager(const Database::Ptr &db)
        : database_(db) {
        ASSERT_not_null(db);
    }
    
public:
    virtual ~ExecutionManager() {}

    /** Property: Database.
     *
     *  The database used by this manager.  The database is set in the constructor and cannot be changed later. */
    Database::Ptr database() const;

    /** Next test case for concrete execution.
     *
     *  Returns up to @p n (default unlimited) test cases that need to be run concretely. A test case needs to be run
     *  concretely if it has no results from a previous concrete run.
     *
     * @{ */
    virtual std::vector<Database::TestCaseId> pendingConcreteResults(size_t n = (size_t)(-1));
    Database::TestCaseId pendingConcreteResult() /*final*/;
    /** @} */

    /** Insert results of a concrete run.
     *
     *  Inserts into the database the results of a concrete run of a test case. Concrete test results always have two parts: a
     *  floating point number for ranking relative to other concrete results, and the result details.  The detailed results are
     *  user defined and stored in the database in XML format, while the rank is duplicated in a floating point field. */
    virtual void insertConcreteResults(const TestCase::Ptr&, const ConcreteExecutor::Result &details);

    /** Next test case for symbolic execution.
     *
     *  Returns up to @p n (default unlimited) test cases that need to be run symbolically. A test case needs to be run
     *  symbolically if it is not marked as having completed the symbolic run.
     *
     * @{ */
    virtual std::vector<Database::TestCaseId> pendingSymbolicResults(size_t n = (size_t)(-1));
    Database::TestCaseId pendingSymbolicResult() /*final*/;
    /** @} */

    /** Insert results from a symbolic execution.
     *
     *  When a symbolic execution completes it will have produced some number of new test cases that should be inserted into
     *  the database. The subclass is reponsible for pruning the list of produced test cases by removing those that have been
     *  tested already or which wouldn't contribute any new results. */
    virtual void insertSymbolicResults(const TestCase::Ptr &original, const std::vector<TestCase::Ptr> &newCases);

    /** Predicate to determine whether testing is completed.
     *
     *  Testing is done when there are no more test cases that need concrete or symbolic results. */
    virtual bool isFinished() const;

    /** Start running.
     *
     *  Runs concrete and symbolic executors until the application is interrupted or there's nothing left to do. Subclasses
     *  will likely reimplement this method in order to do parallel processing, limit execution time, etc. */
    virtual void run() = 0;
};

// Example execution manager...

/** Concolic teting of Linux executables.
 *
 *  Tests a single Linux executable. The concrete ranking metric is only whether the executable exited with zero status or
 *  not. */
class LinuxExitStatus: public ExecutionManager {
public:
    /** Reference counting pointer to @ref LinuxExitStatus. */
    typedef Sawyer::SharedPointer<LinuxExitStatus> Ptr;

protected:
    explicit LinuxExitStatus(const Database::Ptr &db): ExecutionManager(db) {}

public:
    /** Start a new round of concolic testing.
     *
     *  Creates a new database that will hold a single new test suite for the specified executable. The single seeding test
     *  case invokes the executable with the specified arguments. The actual run is not commenced until @ref run is called. */
    static Ptr create(const std::string databaseUrl, const boost::filesystem::path &executableName,
                      const std::vector<std::string> &arguments);

    /** Resume concolic testing using the specified database.
     *
     *  If a test suite name is specified then it must exist in the database. If no test suite name is specified then the
     *  database must contain exactly one test suite which is the one that will be used. The actual run is not commenced until
     *  @ref run is called. */
    static Ptr instance(const std::string databaseUri, const std::string &testSuiteName = "");

    virtual void run() ROSE_OVERRIDE;
};

} // namespace
} // namespace
} // namespace
#endif

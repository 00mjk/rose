/** 
 * \file lib/sage/driver.cpp
 *
 * \author Tristan Vanderbruggen
 *
 */

#include "MFB/Sage/driver.hpp"
#include "MFB/Sage/api.hpp"

#include "sage3basic.h"

#include <boost/filesystem.hpp>

#ifndef PATCHING_SAGE_BUILDER_ISSUES
#  define PATCHING_SAGE_BUILDER_ISSUES 1
#endif

namespace MFB {

/*!
 * \addtogroup grp_mfb_sage_driver
 * @{
*/

bool ignore(const std::string & name) {
  return name.find("__builtin") == 0;
}

bool ignore(SgScopeStatement * scope) {
  return isSgBasicBlock(scope);
}

template <>
void Driver<Sage>::loadSymbolsFromPair<SgDeclarationStatement>(unsigned long file_id, SgSourceFile * header_file, SgSourceFile * source_file) {
  loadSymbolsFromPair<SgNamespaceDeclarationStatement>(file_id, header_file, source_file);
  loadSymbolsFromPair<SgFunctionDeclaration>(file_id, header_file, source_file);
  loadSymbolsFromPair<SgClassDeclaration>(file_id, header_file, source_file);
  loadSymbolsFromPair<SgVariableDeclaration>(file_id, header_file, source_file);
  loadSymbolsFromPair<SgMemberFunctionDeclaration>(file_id, header_file, source_file);
}

Driver<Sage>::Driver(SgProject * project_) :
  project(project_),
  file_id_counter(1), // 0 is reserved
  file_pair_map(),
  standalone_source_file_map(),
  file_to_id_map(),
  p_symbol_to_file_id_map(),
  p_valid_symbols(),
  p_parent_map(),
  p_namespace_symbols(),
  p_function_symbols(),
  p_class_symbols(),
  p_variable_symbols(),
  p_member_function_symbols()
{ 
  assert(project != NULL);

  if (!CommandlineProcessing::isCppFileNameSuffix("hpp"))
    CommandlineProcessing::extraCppSourceFileSuffixes.push_back("hpp");
}

unsigned long Driver<Sage>::createPairOfFiles(const std::string & name) {
  std::string filename;

  filename = name + ".hpp";
  assert(!boost::filesystem::exists(filename));
  SgSourceFile * header_file = isSgSourceFile(SageBuilder::buildFile(filename, filename, project));
  SageInterface::attachComment(header_file, "/* File generated by Driver<Model>::createPairOfFiles(\"" + name + "\") */");

  filename = name + ".cpp";
  assert(!boost::filesystem::exists(filename));
  SgSourceFile * source_file = isSgSourceFile(SageBuilder::buildFile(filename, filename, project));
  SageInterface::attachComment(source_file, "/* File generated by Driver<Model>::createPairOfFiles(\"" + name + "\") */");

  unsigned long id = addPairOfFiles(header_file, source_file);

  addIncludeDirectives(source_file, id);

  return id;
}

unsigned long Driver<Sage>::loadPairOfFiles(const std::string & name, const std::string & header_path, const std::string & source_path) {
  std::string filename;

  std::cout << "Load : " << name << " from header-path=\"" << header_path << "\" and source-path=\"" << source_path << "\"." << std::endl;

  filename = name + ".hpp";
  assert(boost::filesystem::exists(header_path + filename));
  SgSourceFile * header_file = isSgSourceFile(SageBuilder::buildFile(header_path + filename, std::string("rose_") + filename, project)); // FIXME could extract the header from the source file...

  filename = name + ".cpp";
  assert(boost::filesystem::exists(source_path + filename));
  SgSourceFile * source_file = isSgSourceFile(SageBuilder::buildFile(source_path + filename, std::string("rose_") + filename, project));

  unsigned long id = addPairOfFiles(header_file, source_file);

  loadSymbolsFromPair<SgDeclarationStatement>(id, header_file, source_file);

  return id;
}

unsigned long Driver<Sage>::addPairOfFiles(SgSourceFile * header_file, SgSourceFile * source_file) {
  unsigned long id = file_id_counter++;

  file_pair_map.insert(std::pair<unsigned long, std::pair<SgSourceFile *, SgSourceFile *> >(id, std::pair<SgSourceFile *, SgSourceFile *>(header_file, source_file)));

  file_to_id_map.insert(std::pair<SgSourceFile *, unsigned long>(header_file, id));
  file_to_id_map.insert(std::pair<SgSourceFile *, unsigned long>(source_file, id));

  // Create the set of accesible files from these files. Add this file pair.
  file_id_to_accessible_file_id_map.insert(std::pair<SgSourceFile *, std::set<unsigned long> >(header_file,  std::set<unsigned long>())).first->second.insert(id);
  file_id_to_accessible_file_id_map.insert(std::pair<SgSourceFile *, std::set<unsigned long> >(source_file, std::set<unsigned long>())).first->second.insert(id);

  return id;
}

unsigned long Driver<Sage>::createStandaloneSourceFile(const std::string & name, std::string suffix) {
  std::string filename = name + "." + suffix;
  SgSourceFile * file = isSgSourceFile(SageBuilder::buildFile(filename, filename, project));
  SageInterface::attachComment(file, "/* File generated by Driver<Model>::createStandaloneSourceFile(\"" + name + "\") */");

  return addStandaloneSourceFile(file);
}

unsigned long Driver<Sage>::addStandaloneSourceFile(SgSourceFile * source_file) {
  unsigned long id = file_id_counter++;

  standalone_source_file_map.insert(std::pair<unsigned long, SgSourceFile *>(id, source_file));

  file_to_id_map.insert(std::pair<SgSourceFile *, unsigned long>(source_file, id));

  // Create the set of accesible files from this file. Add this file.
  file_id_to_accessible_file_id_map.insert(std::pair<SgSourceFile *, std::set<unsigned long> >(source_file, std::set<unsigned long>())).first->second.insert(id);

  return id;
}

void Driver<Sage>::addIncludeDirectives(SgSourceFile * target_file, unsigned long to_be_included_file_id) {
  std::string to_be_included_file_name;

  std::map<unsigned long, std::pair<SgSourceFile *, SgSourceFile *> >::iterator it_file_pair = file_pair_map.find(to_be_included_file_id);
  assert(it_file_pair != file_pair_map.end()); // Need to be from a pair header and source, not a standalone source file

  SgSourceFile * header_file = it_file_pair->second.first;
  assert(header_file != NULL);

  to_be_included_file_name = header_file->getFileName(); // FIXME path??

  SageInterface::insertHeader(target_file, to_be_included_file_name);
}

void Driver<Sage>::addExternalHeader(unsigned long file_id, std::string header_name, bool is_system_header) {
  std::map<unsigned long, std::pair<SgSourceFile *, SgSourceFile *> >::iterator it_file_pair = file_pair_map.find(file_id);
  std::map<unsigned long, SgSourceFile *>::iterator it_standalone_source_file = standalone_source_file_map.find(file_id);
  
  assert( (it_file_pair != file_pair_map.end()) xor (it_standalone_source_file != standalone_source_file_map.end()) );
  
  SgSourceFile * file = NULL;
  if (it_file_pair != file_pair_map.end())
    file = it_file_pair->second.first; // FIXME add it to the header by default should add system to add it to the source
  else if (it_standalone_source_file != standalone_source_file_map.end())
    file = it_standalone_source_file->second;
  else assert(false);

  assert(file != NULL);

  SageInterface::insertHeader(file, header_name);
}

void Driver<Sage>::addPointerToTopParentDeclaration(SgSymbol * symbol, SgSourceFile * file) {
  SgSymbol * parent = symbol;
  std::map<SgSymbol *, SgSymbol *>::const_iterator it_parent = p_parent_map.find(symbol);
  assert(it_parent != p_parent_map.end());
  while (it_parent->second != NULL) {
    parent = it_parent->second;
    it_parent = p_parent_map.find(parent);
    assert(it_parent != p_parent_map.end());
  }
  assert(parent != NULL);

  SgDeclarationStatement * decl_to_add = NULL;
  SgVariableSymbol * var_sym = isSgVariableSymbol(parent);
  if (var_sym != NULL) {
    assert(var_sym == symbol);

    SgInitializedName * init_name = isSgInitializedName(var_sym->get_symbol_basis());
    assert(init_name != NULL);

    // TODO
  }
  else
    decl_to_add = isSgDeclarationStatement(parent->get_symbol_basis());
  assert(decl_to_add != NULL);

  SgGlobal * global_scope = file->get_globalScope();
  assert(global_scope != NULL);

  const std::vector<SgDeclarationStatement *> & declaration_list = global_scope->getDeclarationList();
  if (find(declaration_list.begin(), declaration_list.end(), decl_to_add) == declaration_list.end())
    SageInterface::prependStatement(decl_to_add, global_scope);
}

api_t * Driver<Sage>::getAPI(unsigned long file_id) const {
  api_t * api = new api_t();

  // Namespaces are not local to a file. If a namespace have been detected in any file, it will in the API
  std::set<SgNamespaceSymbol *>::const_iterator it_namespace_symbol;
  for (it_namespace_symbol = p_namespace_symbols.begin(); it_namespace_symbol != p_namespace_symbols.end(); it_namespace_symbol++)
    api->namespace_symbols.insert(*it_namespace_symbol);

  std::map<SgSymbol *, unsigned long>::const_iterator it_sym_decl_file_id;

  std::set<SgFunctionSymbol *>::const_iterator it_function_symbol;
  for (it_function_symbol = p_function_symbols.begin(); it_function_symbol != p_function_symbols.end(); it_function_symbol++) {
    it_sym_decl_file_id = p_symbol_to_file_id_map.find(*it_function_symbol);
    assert(it_sym_decl_file_id != p_symbol_to_file_id_map.end());

    if (it_sym_decl_file_id->second == file_id)
      api->function_symbols.insert(*it_function_symbol);
  }

  std::set<SgClassSymbol *>::const_iterator it_class_symbol;
  for (it_class_symbol = p_class_symbols.begin(); it_class_symbol != p_class_symbols.end(); it_class_symbol++) {
    it_sym_decl_file_id = p_symbol_to_file_id_map.find(*it_class_symbol);
    assert(it_sym_decl_file_id != p_symbol_to_file_id_map.end());

    if (it_sym_decl_file_id->second == file_id)
      api->class_symbols.insert(*it_class_symbol);
  }

  std::set<SgVariableSymbol *>::const_iterator it_variable_symbol;
  for (it_variable_symbol = p_variable_symbols.begin(); it_variable_symbol != p_variable_symbols.end(); it_variable_symbol++) {
    it_sym_decl_file_id = p_symbol_to_file_id_map.find(*it_variable_symbol);
    assert(it_sym_decl_file_id != p_symbol_to_file_id_map.end());

    if (it_sym_decl_file_id->second == file_id)
      api->variable_symbols.insert(*it_variable_symbol);
  }

  std::set<SgMemberFunctionSymbol *>::const_iterator it_member_function_symbol;
  for (it_member_function_symbol = p_member_function_symbols.begin(); it_member_function_symbol != p_member_function_symbols.end(); it_member_function_symbol++) {
    it_sym_decl_file_id = p_symbol_to_file_id_map.find(*it_member_function_symbol);
    assert(it_sym_decl_file_id != p_symbol_to_file_id_map.end());

    if (it_sym_decl_file_id->second == file_id)
      api->member_function_symbols.insert(*it_member_function_symbol);
  }

  return api;
}

api_t * Driver<Sage>::getAPI(const std::set<unsigned long> & file_ids) const {
  assert(file_ids.size() > 0);

  std::set<unsigned long>::const_iterator it = file_ids.begin();

  api_t * api = getAPI(*it);
  it++;

  while (it != file_ids.begin()) {
    api_t * tmp = getAPI(*it);
    merge_api(api, tmp);
    delete tmp;
  }

  return api;
}

/** @} */

}


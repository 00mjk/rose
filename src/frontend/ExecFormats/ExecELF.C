/* Copyright 2008 Lawrence Livermore National Security, LLC */

#include "rose.h"
#define __STDC_FORMAT_MACROS
#include <inttypes.h>
    
/* Truncate an address, ADDR, to be a multiple of the alignment, ALMNT, where ALMNT is a power of two and of the same
 * unsigned datatype as the address. */
#define ALIGN(ADDR,ALMNT) ((ADDR) & ~((ALMNT)-1))

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// File headers
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/** Construct a new ELF File Header with default values. The new section is placed at file offset zero and the size is
 *  initially one byte (calling parse() will extend it as necessary). Setting the initial size of non-parsed sections to a
 *  positive value works better when adding sections to the end-of-file since the sections will all have different starting
 *  offsets and therefore SgAsmGenericFile::shift_extend will know what order the sections should be in when they are
 *  eventually resized. */
void
SgAsmElfFileHeader::ctor()
{
    ROSE_ASSERT(get_file()!=NULL);
    ROSE_ASSERT(get_size()>0);

    set_name(new SgAsmBasicString("ELF File Header"));
    set_synthesized(true);
    set_purpose(SP_HEADER);

    /* Magic number */
    p_magic.clear();
    p_magic.push_back(0x7f);
    p_magic.push_back('E');
    p_magic.push_back('L');
    p_magic.push_back('F');

    /* Executable Format */
    ROSE_ASSERT(p_exec_format!=NULL);
    p_exec_format->set_family(FAMILY_ELF);
    p_exec_format->set_purpose(PURPOSE_EXECUTABLE);
    p_exec_format->set_sex(ORDER_LSB);
    p_exec_format->set_word_size(4);
    p_exec_format->set_version(1);
    p_exec_format->set_is_current_version(true);
    p_exec_format->set_abi(ABI_UNSPECIFIED);
    p_exec_format->set_abi_version(0);

    p_isa = ISA_IA32_386;
    p_e_ident_data_encoding = 1;  /*LSB*/
    p_e_ident_padding = SgUnsignedCharList(9, '\0');
}

/** Return true if the file looks like it might be an ELF file according to the magic number. */
bool
SgAsmElfFileHeader::is_ELF(SgAsmGenericFile *file)
{
    /* Turn off byte reference tracking for the duration of this function. We don't want our testing the file contents to
     * affect the list of bytes that we've already referenced or which we might reference later. */
    bool was_tracking = file->get_tracking_references();
    file->set_tracking_references(false);

    try {
        unsigned char magic[4];
        file->read_content(0, magic, sizeof magic);
        if (0x7f!=magic[0] || 'E'!=magic[1] || 'L'!=magic[2] || 'F'!=magic[3])
            throw 1;
    } catch (...) {
        file->set_tracking_references(was_tracking);
        return false;
    }
    file->set_tracking_references(was_tracking);
    return true;
}

/** Convert ELF "machine" identifier to generic instruction set architecture value. */
SgAsmExecutableFileFormat::InsSetArchitecture
SgAsmElfFileHeader::machine_to_isa(unsigned machine) const
{
    switch (p_e_machine) {                                /* These come from the Portable Formats Specification v1.1 */
      case 0:        return ISA_UNSPECIFIED;
      case 1:        return ISA_ATT_WE_32100;
      case 2:        return ISA_SPARC_Family;
      case 3:        return ISA_IA32_386;
      case 4:        return ISA_M68K_Family;
      case 5:        return ISA_M88K_Family;
      case 7:        return ISA_I860_Family;
      case 8:        return ISA_MIPS_Family;
      case 20:
        // Note that PowerPC has: p_e_machine = 20 = 0x14, using both gcc on BGL and xlc on BGL.
        // However, these don't seem like correct values for PowerPC.
        return ISA_PowerPC;
      case 40:       return ISA_ARM_Family;
      case 62:       return ISA_X8664_Family;
      default:
        /*FIXME: There's a whole lot more. See Dan's Elf reader. */
        // DQ (10/12/2008): Need more information to address PowerPC support.
        fprintf(stderr, "Warning: SgAsmElfFileHeader::parse::p_e_machine = 0x%lx (%lu)\n", p_e_machine, p_e_machine);
        return ISA_OTHER;
    }
}

/** Convert architecture value to an ELF "machine" value. */
unsigned
SgAsmElfFileHeader::isa_to_machine(SgAsmExecutableFileFormat::InsSetArchitecture isa) const
{
    switch (isa) {
      case ISA_UNSPECIFIED:
      case ISA_OTHER:        return p_e_machine;
      case ISA_ATT_WE_32100: return 1;
      case ISA_IA32_386:     return 3;
      case ISA_PowerPC:      return 20;  /*see note in machine_to_isa()*/
      default:
        switch (isa & ISA_FAMILY_MASK) {
          case ISA_SPARC_Family: return 2;
          case ISA_M68K_Family:  return 4;
          case ISA_M88K_Family:  return 5;
          case ISA_I860_Family:  return 7;
          case ISA_MIPS_Family:  return 8;
          case ISA_ARM_Family:   return 40;
          case ISA_X8664_Family: return 62;
          default:
            return p_e_machine;
        }
    }
}

/** Initialize this header with information parsed from the file and construct and parse everything that's reachable from the
 *  header. Since the size of the ELF File Header is determined by the contents of the ELF File Header as stored in the file,
 *  the size of the ELF File Header will be adjusted upward if necessary. The ELF File Header should have been constructed
 *  such that SgAsmElfFileHeader::ctor() was called. */
SgAsmElfFileHeader*
SgAsmElfFileHeader::parse()
{
    SgAsmGenericHeader::parse();

    /* Read 32-bit header for now. Might need to re-read as 64-bit later. */
    Elf32FileHeader_disk disk32;
    if (sizeof(disk32)>get_size())
        extend(sizeof(disk32)-get_size());
    read_content_local(0, &disk32, sizeof disk32, false); /*zero pad if we read EOF*/

    /* Check magic number early */
    if (disk32.e_ident_magic[0]!=0x7f || disk32.e_ident_magic[1]!='E' ||
        disk32.e_ident_magic[2]!='L'  || disk32.e_ident_magic[3]!='F')
        throw FormatError("Bad ELF magic number");

    /* File byte order should be 1 or 2. However, we've seen at least one example that left the byte order at zero, implying
     * that it was the native order. We don't have the luxury of decoding the file on the native machine, so in that case we
     * try to infer the byte order by looking at one of the other multi-byte fields of the file. */
    ByteOrder sex;
    if (1 == disk32.e_ident_data_encoding) {
        sex = ORDER_LSB;
    } else if (2==disk32.e_ident_data_encoding) {
        sex = ORDER_MSB;
    } else if ((disk32.e_type & 0xff00)==0xff00) {
        /* One of the 0xffxx processor-specific flags in native order */
        if ((disk32.e_type & 0x00ff)==0xff)
            throw FormatError("invalid ELF header byte order"); /*ambiguous*/
        sex = host_order();
    } else if ((disk32.e_type & 0x00ff)==0x00ff) {
        /* One of the 0xffxx processor specific orders in reverse native order */
        sex = host_order()==ORDER_LSB ? ORDER_MSB : ORDER_LSB;
    } else if ((disk32.e_type & 0xff00)==0) {
        /* One of the low-valued file types in native order */
        if ((disk32.e_type & 0x00ff)==0)
            throw FormatError("invalid ELF header byte order"); /*ambiguous*/
        sex = host_order();
    } else if ((disk32.e_type & 0x00ff)==0) {
        /* One of the low-valued file types in reverse native order */
        sex = host_order() == ORDER_LSB ? ORDER_MSB : ORDER_LSB;
    } else {
        /* Ambiguous order */
        throw FormatError("invalid ELF header byte order");
    }
    ROSE_ASSERT(p_exec_format != NULL);
    p_exec_format->set_sex(sex);
    p_e_ident_data_encoding = disk32.e_ident_data_encoding; /*save original value*/

    /* Decode header to native format */
    rva_t entry_rva, sectab_rva, segtab_rva;
    if (1 == disk32.e_ident_file_class) {
        p_exec_format->set_word_size(4);

	p_e_ident_padding.clear();
        for (size_t i=0; i<sizeof(disk32.e_ident_padding); i++)
             p_e_ident_padding.push_back(disk32.e_ident_padding[i]);

        p_e_ident_file_class    = disk_to_host(sex, disk32.e_ident_file_class);
        p_e_ident_file_version  = disk_to_host(sex, disk32.e_ident_file_version);
        p_e_type                = disk_to_host(sex, disk32.e_type);
        p_e_machine             = disk_to_host(sex, disk32.e_machine);
	p_exec_format->set_version(disk_to_host(sex, disk32.e_version));
        entry_rva               = disk_to_host(sex, disk32.e_entry);
        segtab_rva              = disk_to_host(sex, disk32.e_phoff);
        sectab_rva              = disk_to_host(sex, disk32.e_shoff);
        p_e_flags               = disk_to_host(sex, disk32.e_flags);
        p_e_ehsize              = disk_to_host(sex, disk32.e_ehsize);

        p_e_phnum               = disk_to_host(sex, disk32.e_phnum);
        if (p_e_phnum>0) {
            p_phextrasz         = disk_to_host(sex, disk32.e_phentsize);
            ROSE_ASSERT(p_phextrasz>=sizeof(SgAsmElfSegmentTableEntry::Elf32SegmentTableEntry_disk));
            p_phextrasz -= sizeof(SgAsmElfSegmentTableEntry::Elf32SegmentTableEntry_disk);
        } else {
            p_phextrasz = 0;
        }

        p_e_shnum               = disk_to_host(sex, disk32.e_shnum);
        if (p_e_shnum>0) {
            p_shextrasz         = disk_to_host(sex, disk32.e_shentsize);
            ROSE_ASSERT(p_shextrasz>=sizeof(SgAsmElfSectionTableEntry::Elf32SectionTableEntry_disk));
            p_shextrasz -= sizeof(SgAsmElfSectionTableEntry::Elf32SectionTableEntry_disk);
        } else {
            p_shextrasz = 0;
        }

        p_e_shstrndx            = disk_to_host(sex, disk32.e_shstrndx);
    } else if (2 == disk32.e_ident_file_class) {
        /* We guessed wrong. This is a 64-bit header, not 32-bit. */
        p_exec_format->set_word_size(8);
        Elf64FileHeader_disk disk64;
        if (sizeof(disk64)>get_size())
            extend(sizeof(disk64)-get_size());
        read_content_local(0, &disk64, sizeof disk64, false); /*zero pad at EOF*/

	p_e_ident_padding.clear();
        for (size_t i=0; i<sizeof(disk64.e_ident_padding); i++)
             p_e_ident_padding.push_back(disk64.e_ident_padding[i]);

        p_e_ident_file_class    = disk_to_host(sex, disk64.e_ident_file_class);
        p_e_ident_file_version  = disk_to_host(sex, disk64.e_ident_file_version);
        p_e_type                = disk_to_host(sex, disk64.e_type);
        p_e_machine             = disk_to_host(sex, disk64.e_machine);
	p_exec_format->set_version(disk_to_host(sex, disk64.e_version));
        entry_rva               = disk_to_host(sex, disk64.e_entry);
        segtab_rva              = disk_to_host(sex, disk64.e_phoff);
        sectab_rva              = disk_to_host(sex, disk64.e_shoff);
        p_e_flags               = disk_to_host(sex, disk64.e_flags);
        p_e_ehsize              = disk_to_host(sex, disk64.e_ehsize);

        p_e_phnum               = disk_to_host(sex, disk64.e_phnum);
        if (p_e_phnum>0) {
            p_phextrasz         = disk_to_host(sex, disk64.e_phentsize);
            ROSE_ASSERT(p_phextrasz>=sizeof(SgAsmElfSegmentTableEntry::Elf64SegmentTableEntry_disk));
            p_phextrasz -= sizeof(SgAsmElfSegmentTableEntry::Elf64SegmentTableEntry_disk);
        } else {
            p_phextrasz = 0;
        }

        p_e_shnum               = disk_to_host(sex, disk64.e_shnum);
        if (p_e_shnum>0) {
            p_shextrasz         = disk_to_host(sex, disk64.e_shentsize);
            ROSE_ASSERT(p_shextrasz>=sizeof(SgAsmElfSectionTableEntry::Elf64SectionTableEntry_disk));
            p_shextrasz -= sizeof(SgAsmElfSectionTableEntry::Elf64SectionTableEntry_disk);
        } else {
            p_shextrasz = 0;
        }

        p_e_shstrndx            = disk_to_host(sex, disk64.e_shstrndx);
    } else {
        throw FormatError("invalid ELF header file class");
    }
    
    /* Magic number. disk32 and disk64 have header bytes at same offset */
    p_magic.clear();
    for (size_t i=0; i<sizeof(disk32.e_ident_magic); i++)
        p_magic.push_back(disk32.e_ident_magic[i]);
    
    /* File format */
    p_exec_format->set_family(FAMILY_ELF);
    switch (p_e_type) {
      case 0:
        p_exec_format->set_purpose(PURPOSE_UNSPECIFIED);
        break;
      case 1:
      case 3:
        p_exec_format->set_purpose(PURPOSE_LIBRARY);
        break;
      case 2:
        p_exec_format->set_purpose(PURPOSE_EXECUTABLE);
        break;
      case 4:
        p_exec_format->set_purpose(PURPOSE_CORE_DUMP);
        break;
      default:
        if (p_e_type >= 0xff00 && p_e_type <= 0xffff) {
            p_exec_format->set_purpose(PURPOSE_PROC_SPECIFIC);
        } else {
            p_exec_format->set_purpose(PURPOSE_OTHER);
        }
        break;
    }
    p_exec_format->set_is_current_version(1 == p_exec_format->get_version());
    p_exec_format->set_abi(ABI_UNSPECIFIED);                 /* ELF specifies a target architecture rather than an ABI */
    p_exec_format->set_abi_version(0);

    /* Target architecture */
    set_isa(machine_to_isa(p_e_machine));

    /* Read the optional section and segment tables and the sections to which they point. An empty section or segment table is
     * treated as if it doesn't exist. This seems to be compatible with the loader since the 45-bit "tiny" ELF executable
     * stores a zero in the e_shnum member and a completely invalid value in the e_shoff member. */
    if (sectab_rva>0 && get_e_shnum()>0) {
        SgAsmElfSectionTable *tab = new SgAsmElfSectionTable(this);
        tab->set_offset(sectab_rva.get_rva());
        tab->parse();
    }
    if (segtab_rva>0 && get_e_phnum()>0) {
        SgAsmElfSegmentTable *tab = new SgAsmElfSegmentTable(this);
        tab->set_offset(segtab_rva.get_rva());
        tab->parse();
    }
    
    /* Associate the entry point with a particular section. */
    entry_rva.bind(this);
    add_entry_rva(entry_rva);

    /* Use symbols from either ".symtab" or ".dynsym" */
    SgAsmElfSymbolSection *symtab = dynamic_cast<SgAsmElfSymbolSection*>(get_section_by_name(".symtab"));
    if (!symtab)
        symtab = dynamic_cast<SgAsmElfSymbolSection*>(get_section_by_name(".dynsym"));
    if (symtab) {
        std::vector<SgAsmElfSymbol*> & symbols = symtab->get_symbols()->get_symbols();
        for (size_t i=0; i<symbols.size(); i++)
            add_symbol(symbols[i]);
    }
    
    return this;
}

/* Maximum page size according to the ABI. This is used by the loader when calculating the program base address. Since parts
 * of the file are mapped into the process address space those parts must be aligned (both in the file and in memory) on the
 * largest possible page boundary so that any smaller page boundary will also work correctly. */
uint64_t
SgAsmElfFileHeader::max_page_size()
{
    /* FIXME:
     *    System V max page size is 4k.
     *    IA32 is 4k
     *    x86_64 is 2MB
     * Other systems may vary! */
    return 4*1024;
}

/* Get the list of sections defined in the ELF Section Table */
SgAsmGenericSectionPtrList
SgAsmElfFileHeader::get_sectab_sections()
{
    SgAsmGenericSectionPtrList retval;
    SgAsmGenericSectionPtrList sections = get_sections()->get_sections();
    for (size_t i=0; i<sections.size(); i++) {
        SgAsmElfSection *elfsec = dynamic_cast<SgAsmElfSection*>(sections[i]);
        if (elfsec && elfsec->get_section_entry()!=NULL)
            retval.push_back(elfsec);
    }
    return retval;
}

/* Get the list of sections defined in the ELF Segment Table */
SgAsmGenericSectionPtrList
SgAsmElfFileHeader::get_segtab_sections()
{
    SgAsmGenericSectionPtrList retval;
    SgAsmGenericSectionPtrList sections = get_sections()->get_sections();
    for (size_t i=0; i<sections.size(); i++) {
        SgAsmElfSection *elfsec = dynamic_cast<SgAsmElfSection*>(sections[i]);
        if (elfsec && elfsec->get_segment_entry()!=NULL)
            retval.push_back(elfsec);
    }
    return retval;
}

/* Encode Elf header disk structure */
void *
SgAsmElfFileHeader::encode(ByteOrder sex, Elf32FileHeader_disk *disk) const
{
    ROSE_ASSERT(p_magic.size() == NELMTS(disk->e_ident_magic));
    for (size_t i=0; i<NELMTS(disk->e_ident_magic); i++)
        disk->e_ident_magic[i] = p_magic[i];
    host_to_disk(sex, p_e_ident_file_class, &(disk->e_ident_file_class));
    host_to_disk(sex, p_e_ident_data_encoding, &(disk->e_ident_data_encoding));
    host_to_disk(sex, p_e_ident_file_version, &(disk->e_ident_file_version));
    ROSE_ASSERT(p_e_ident_padding.size() == NELMTS(disk->e_ident_padding));
    for (size_t i=0; i<NELMTS(disk->e_ident_padding); i++)
        disk->e_ident_padding[i] = p_e_ident_padding[i];
    host_to_disk(sex, p_e_type, &(disk->e_type));
    host_to_disk(sex, p_e_machine, &(disk->e_machine));
    host_to_disk(sex, p_exec_format->get_version(), &(disk->e_version));
    host_to_disk(sex, get_entry_rva(), &(disk->e_entry));
    if (get_segment_table()) {
        host_to_disk(sex, get_segment_table()->get_offset(), &(disk->e_phoff));
    } else {
        host_to_disk(sex, 0, &(disk->e_phoff));
    }
    if (get_section_table()) {
        host_to_disk(sex, get_section_table()->get_offset(), &(disk->e_shoff));
    } else {
        host_to_disk(sex, 0, &(disk->e_shoff));
    }
    host_to_disk(sex, p_e_flags,               &(disk->e_flags));
    host_to_disk(sex, p_e_ehsize,              &(disk->e_ehsize));

    if (p_e_phnum>0) {
        host_to_disk(sex, p_phextrasz+sizeof(SgAsmElfSegmentTableEntry::Elf32SegmentTableEntry_disk), &(disk->e_phentsize));
    } else {
        host_to_disk(sex, 0, &(disk->e_phentsize));
    }
    if (p_e_shnum>0) {
        host_to_disk(sex, p_shextrasz+sizeof(SgAsmElfSectionTableEntry::Elf32SectionTableEntry_disk), &(disk->e_shentsize));
    } else {
        host_to_disk(sex, 0, &(disk->e_shentsize));
    }
    host_to_disk(sex, p_e_phnum,               &(disk->e_phnum));
    host_to_disk(sex, p_e_shnum,               &(disk->e_shnum));
    host_to_disk(sex, p_e_shstrndx,            &(disk->e_shstrndx));

    return disk;
}
void *
SgAsmElfFileHeader::encode(ByteOrder sex, Elf64FileHeader_disk *disk) const
{
    ROSE_ASSERT(p_magic.size() == NELMTS(disk->e_ident_magic));
    for (size_t i=0; i < NELMTS(disk->e_ident_magic); i++)
        disk->e_ident_magic[i] = p_magic[i];
    host_to_disk(sex, p_e_ident_file_class, &(disk->e_ident_file_class));
    host_to_disk(sex, p_e_ident_data_encoding, &(disk->e_ident_data_encoding));
    host_to_disk(sex, p_e_ident_file_version,&(disk->e_ident_file_version));
    ROSE_ASSERT(p_e_ident_padding.size() == NELMTS(disk->e_ident_padding));
    for (size_t i=0; i<NELMTS(disk->e_ident_padding); i++)
        disk->e_ident_padding[i] = p_e_ident_padding[i];
    host_to_disk(sex, p_e_type, &(disk->e_type));
    host_to_disk(sex, p_e_machine, &(disk->e_machine));
    host_to_disk(sex, p_exec_format->get_version(), &(disk->e_version));
    host_to_disk(sex, get_entry_rva(),         &(disk->e_entry));
    if (get_segment_table()) {
        host_to_disk(sex, get_segment_table()->get_offset(), &(disk->e_phoff));
    } else {
        host_to_disk(sex, 0, &(disk->e_phoff));
    }
    if (get_section_table()) {
        host_to_disk(sex, get_section_table()->get_offset(), &(disk->e_shoff));
    } else {
        host_to_disk(sex, 0, &(disk->e_shoff));
    }
    host_to_disk(sex, p_e_flags,               &(disk->e_flags));
    host_to_disk(sex, p_e_ehsize,              &(disk->e_ehsize));
    host_to_disk(sex, p_phextrasz+sizeof(SgAsmElfSegmentTableEntry::Elf64SegmentTableEntry_disk), &(disk->e_phentsize));
    host_to_disk(sex, p_e_phnum,               &(disk->e_phnum));
    host_to_disk(sex, p_shextrasz+sizeof(SgAsmElfSectionTableEntry::Elf64SectionTableEntry_disk), &(disk->e_shentsize));
    host_to_disk(sex, p_e_shnum,               &(disk->e_shnum));
    host_to_disk(sex, p_e_shstrndx,            &(disk->e_shstrndx));

    return disk;
}

/* Update prior to unparsing */
bool
SgAsmElfFileHeader::reallocate()
{
    /* Reallocate superclass. This also calls reallocate() for all the sections associated with this ELF File Header. */
    bool reallocated = SgAsmGenericHeader::reallocate();

    /* Resize header based on current word size */
    addr_t need;
    if (4==get_word_size()) {
        need = sizeof(Elf32FileHeader_disk);
    } else if (8==get_word_size()) {
        need = sizeof(Elf64FileHeader_disk);
    } else {
        throw FormatError("unsupported ELF word size");
    }
    if (need < get_size()) {
        if (is_mapped()) {
            ROSE_ASSERT(get_mapped_size()==get_size());
            set_mapped_size(need);
        }
        set_size(need);
        reallocated = true;
    } else if (need > get_size()) {
        get_file()->shift_extend(this, 0, need-get_size(), SgAsmGenericFile::ADDRSP_ALL, SgAsmGenericFile::ELASTIC_HOLE);
        reallocated = true;
    }

    /* Update ELF-specific file class data member from generic data. */
    switch(get_word_size()) {
      case 4:
        p_e_ident_file_class = 1;
        break;
      case 8:
        p_e_ident_file_class = 2;
        break;
      default:
        ROSE_ASSERT(!"invalid word size");
        break;
    }

    /* Byte order. According to the spec, valid values are 1 (little-endian) and 2 (big-endian). However, we've seen cases
     * where a value of zero is used to indicate "native" order (loader assumes words are in the order of the machine on which
     * the loader is running, and the ROSE ELF parser determines the order by looking at other fields in the header). Any
     * original value other than 1 or 2 will be written to the new output; otherwise we choose 1 or 2 based on the currently
     * defined byte order. */
    if (p_e_ident_data_encoding==1 || p_e_ident_data_encoding==2) {
        p_e_ident_data_encoding = ORDER_LSB==get_sex() ? 1 : 2;
    }

    /* Update ELF-specific file type from generic data. */
    switch (p_exec_format->get_purpose()) {
      case PURPOSE_UNSPECIFIED:
      case PURPOSE_PROC_SPECIFIC:
      case PURPOSE_OS_SPECIFIC:
      case PURPOSE_OTHER:
        /* keep as is */
        break;
      case PURPOSE_LIBRARY:
        if (p_e_type==1 || p_e_type==3) {
            /* keep as is */
        } else {
            p_e_type = 1;
        }
        break;
      case PURPOSE_EXECUTABLE:
        p_e_type = 2;
        break;
      case PURPOSE_CORE_DUMP:
        p_e_type = 4;
    }

    /* Update ELF machine type. */
    p_e_machine = isa_to_machine(get_isa());

    /* The ELF header stores its own size */
    p_e_ehsize = get_size();

    return reallocated;
}

/* Write ELF contents back to a file. */
void
SgAsmElfFileHeader::unparse(std::ostream &f) const
{
    /* Write unreferenced areas back to the file before anything else. */
    unparse_holes(f);

    /* Write the ELF segment table and segments first since they generally overlap with more specific things which may have
     * been modified when walking the AST. (We generally don't modify segments, just the more specific sections.) */
    if (p_segment_table) {
        ROSE_ASSERT(p_segment_table->get_header()==this);
        p_segment_table->unparse(f);
    }

    /* Write the ELF section table and, indirectly, the sections themselves. */
    if (p_section_table) {
        ROSE_ASSERT(p_section_table->get_header()==this);
        p_section_table->unparse(f);
    }
    
    /* Encode and write the ELF file header */
    Elf32FileHeader_disk disk32;
    Elf64FileHeader_disk disk64;
    void *disk = NULL;
    size_t struct_size = 0;
    if (4 == get_word_size()) {
        disk = encode(get_sex(), &disk32);
        struct_size = sizeof(disk32);
    } else if (8 == get_word_size()) {
        disk = encode(get_sex(), &disk64);
        struct_size = sizeof(disk64);
    } else {
        ROSE_ASSERT(!"unsupported word size");
    }
    write(f, p_offset, struct_size, disk);
}

/* Print some debugging info */
void
SgAsmElfFileHeader::dump(FILE *f, const char *prefix, ssize_t idx) const
{
    char p[4096];
    if (idx>=0) {
        sprintf(p, "%sElfFileHeader[%zd].", prefix, idx);
    } else {
        sprintf(p, "%sElfFileHeader.", prefix);
    }
    int w = std::max(1, DUMP_FIELD_WIDTH-(int)strlen(p));

    SgAsmGenericHeader::dump(f, p, -1);
    const char *class_s = 1==p_e_ident_file_class ? " (32-bit)" :
                          2==p_e_ident_file_class ? " (64-bit)" : "";
    fprintf(f, "%s%-*s = %u%s\n",                           p, w, "e_ident_file_class",     p_e_ident_file_class, class_s);
    fprintf(f, "%s%-*s = %u\n",                             p, w, "e_ident_file_version",   p_e_ident_file_version);
    for (size_t i=0; i < p_e_ident_padding.size(); i++)
        fprintf(f, "%s%-*s = [%zu] %u\n",                   p, w, "e_ident_padding",     i, p_e_ident_padding[i]);
    fprintf(f, "%s%-*s = %lu\n",                            p, w, "e_type",                 p_e_type);
    fprintf(f, "%s%-*s = %lu\n",                            p, w, "e_machine",              p_e_machine);
    fprintf(f, "%s%-*s = 0x%08lx\n",                        p, w, "e_flags",                p_e_flags);
    fprintf(f, "%s%-*s = 0x%08lx (%lu) bytes\n",            p, w, "e_ehsize",               p_e_ehsize, p_e_ehsize);
    fprintf(f, "%s%-*s = 0x%08lx (%lu) bytes\n",            p, w, "phextrasz",              p_phextrasz, p_phextrasz);
    fprintf(f, "%s%-*s = %lu\n",                            p, w, "e_phnum",                p_e_phnum);
    fprintf(f, "%s%-*s = 0x%08lx (%lu) bytes\n",            p, w, "shextrasz",              p_shextrasz, p_shextrasz);
    fprintf(f, "%s%-*s = %lu\n",                            p, w, "e_shnum",                p_e_shnum);
    fprintf(f, "%s%-*s = %lu\n",                            p, w, "e_shstrndx",             p_e_shstrndx);
    if (p_section_table) {
        fprintf(f, "%s%-*s = [%d] \"%s\"\n",                p, w, "section_table",
                p_section_table->get_id(), p_section_table->get_name()->c_str());
    } else {
        fprintf(f, "%s%-*s = none\n",                       p, w, "section_table");
    }
    if (p_segment_table) {
        fprintf(f, "%s%-*s = [%d] \"%s\"\n",                p, w, "segment_table",
                p_segment_table->get_id(), p_segment_table->get_name()->c_str());
    } else {
        fprintf(f, "%s%-*s = none\n",                       p, w, "segment_table");
    }

    if (variantT() == V_SgAsmElfFileHeader) //unless a base class
        hexdump(f, 0, std::string(p)+"data at ", p_data);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Sections
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/* Constructor for sections that are in neither the ELF Section Table nor the ELF Segment Table yet (but eventually will be) */
void
SgAsmElfSection::ctor()
{
    set_synthesized(false);
    set_purpose(SP_UNSPECIFIED);
}

/** Initializes the section from data parsed from the ELF Section Table. This includes the section name, offset, size, memory
 *  mapping, and alignments. The @p id is the index into the section table. This function complements
 *  SgAsmElfSectionTable::add_section(): this function initializes this section from the section table while add_section()
 *  initializes the section table from the section. */
SgAsmElfSection *
SgAsmElfSection::init_from_section_table(SgAsmElfSectionTableEntry *shdr, SgAsmElfStringSection *strsec, int id)
{
    ROSE_ASSERT(shdr);
    ROSE_ASSERT(strsec);
    ROSE_ASSERT(id>=0);

    /* Purpose */
    switch (shdr->get_sh_type()) {
      case SgAsmElfSectionTableEntry::SHT_PROGBITS:
        set_purpose(SP_PROGRAM);
        break;
      case SgAsmElfSectionTableEntry::SHT_STRTAB:
        set_purpose(SP_HEADER);
        break;
      case SgAsmElfSectionTableEntry::SHT_DYNSYM:
      case SgAsmElfSectionTableEntry::SHT_SYMTAB:
        set_purpose(SP_SYMTAB);
        break;
      default:
        set_purpose(SP_OTHER);
        break;
    }

    /* File mapping */
    set_offset(shdr->get_sh_offset());
    if (SgAsmElfSectionTableEntry::SHT_NULL==shdr->get_sh_type() ||
        SgAsmElfSectionTableEntry::SHT_NOBITS==shdr->get_sh_type()) {
        set_size(0);
    } else {
        set_size(shdr->get_sh_size());
    }
    set_file_alignment(shdr->get_sh_addralign());
    grab_content();

    /* Memory mapping */
    if (shdr->get_sh_addr() > 0) {
        set_mapped_preferred_rva(shdr->get_sh_addr());
        set_mapped_actual_rva(0); /*will be assigned by Loader*/
        set_mapped_size(shdr->get_sh_size());
        set_mapped_rperm(true);
        set_mapped_wperm((shdr->get_sh_flags() & 0x01) == 0x01);
        set_mapped_xperm((shdr->get_sh_flags() & 0x04) == 0x04);
        set_mapped_alignment(shdr->get_sh_addralign());
    } else {
        set_mapped_preferred_rva(0);
        set_mapped_actual_rva(0); /*will be assigned by Loader*/
        set_mapped_size(0);
        set_mapped_rperm(false);
        set_mapped_wperm(false);
        set_mapped_xperm(false);
        set_mapped_alignment(shdr->get_sh_addralign());
    }

    /* Name. This has to be near the end because possibly strsec==this, in which case we have to call set_size() to extend the
     * section to be large enough before we can try to look up the name. */
    set_id(id);
    set_name(new SgAsmStoredString(strsec->get_strtab(), shdr->get_sh_name()));

    /* Add section table entry to section */
    set_section_entry(shdr);
    shdr->set_parent(this);

    return this;
}

/** Initializes the section from data parse from the ELF Segment Table similar to init_from_section_table() */
SgAsmElfSection *
SgAsmElfSection::init_from_segment_table(SgAsmElfSegmentTableEntry *shdr, bool mmap_only)
{
    if (!mmap_only) {
        /* Purpose */
        set_purpose(SP_HEADER);

        /* File mapping */
        set_offset(shdr->get_offset());
        set_size(shdr->get_filesz());
        set_file_alignment(shdr->get_align());
        grab_content();
    
        /* Name */
        char name[128];
        switch (shdr->get_type()) {
          case SgAsmElfSegmentTableEntry::PT_LOAD:         strcpy(name, "ELF Load");          break;
          case SgAsmElfSegmentTableEntry::PT_DYNAMIC:      strcpy(name, "ELF Dynamic");       break;
          case SgAsmElfSegmentTableEntry::PT_INTERP:       strcpy(name, "ELF Interpreter");   break;
          case SgAsmElfSegmentTableEntry::PT_NOTE:         strcpy(name, "ELF Note");          break;
          case SgAsmElfSegmentTableEntry::PT_SHLIB:        strcpy(name, "ELF Shlib");         break;
          case SgAsmElfSegmentTableEntry::PT_PHDR:         strcpy(name, "ELF Segment Table"); break;
          case SgAsmElfSegmentTableEntry::PT_GNU_EH_FRAME: strcpy(name, "GNU EH Frame");      break;
          case SgAsmElfSegmentTableEntry::PT_GNU_STACK:    strcpy(name, "GNU Stack");         break;
          case SgAsmElfSegmentTableEntry::PT_GNU_RELRO:    strcpy(name, "GNU Reloc RO");      break;
          case SgAsmElfSegmentTableEntry::PT_PAX_FLAGS:    strcpy(name, "PAX Flags");         break;
          case SgAsmElfSegmentTableEntry::PT_SUNWBSS:      strcpy(name, "Sun WBSS");          break;
          case SgAsmElfSegmentTableEntry::PT_SUNWSTACK:    strcpy(name, "Sun WStack");        break;
          default:                                         sprintf(name, "ELF type 0x%08x", shdr->get_type()); break;
        }
        sprintf(name+strlen(name), " (segment %zu)", shdr->get_index());
        set_name(new SgAsmBasicString(name));
    }
    
    /* Memory mapping */
    set_mapped_preferred_rva(shdr->get_vaddr());
    set_mapped_actual_rva(0); /*will be assigned by Loader*/
    set_mapped_size(shdr->get_memsz());
    set_mapped_alignment(shdr->get_align());
    set_mapped_rperm(shdr->get_flags() & SgAsmElfSegmentTableEntry::PF_RPERM ? true : false);
    set_mapped_wperm(shdr->get_flags() & SgAsmElfSegmentTableEntry::PF_WPERM ? true : false);
    set_mapped_xperm(shdr->get_flags() & SgAsmElfSegmentTableEntry::PF_XPERM ? true : false);

    /* Add segment table entry to section */
    set_segment_entry(shdr);
    shdr->set_parent(this);

    return this;
}

/* Just a convenience function so we don't need to constantly cast the return value from get_header() */
SgAsmElfFileHeader*
SgAsmElfSection::get_elf_header() const
{
    return dynamic_cast<SgAsmElfFileHeader*>(get_header());
}

/* Returns info about the size of the entries based on information already available. Any or all arguments may be null
 * pointers if the caller is not interested in the value. Return values are:
 *
 *   entsize  - size of each entry, sum of required and optional parts. This comes from the sh_entsize member of this
 *              section's ELF Section Table Entry, adjusted upward to be large enough to hold the required part of each
 *              entry (see "required").
 *
 *   required - size of the required (leading) part of each entry. The size of the required part is based on the ELF word size.
 *
 *   optional - size of the optional (trailing) part of each entry. If the section has been parsed then the optional size will
 *              be calculated from the entry with the largest "extra" (aka, optional) data. Otherwise this is calculated as the
 *              difference between the "entsize" and the "required" sizes.
 *   
 *   entcount - total number of entries in this section. If the section has been parsed then this is the actual number of
 *              parsed entries, otherwise its the section size divided by the "entsize".
 *
 * Return value is the total size needed for the section. In all cases, it is entsize*entcount.
 */
rose_addr_t
SgAsmElfSection::calculate_sizes(size_t r32size, size_t r64size,       /*size of required parts*/
                                 const std::vector<size_t> &optsizes,  /*size of optional parts and number of parts parsed*/
                                 size_t *entsize, size_t *required, size_t *optional, size_t *entcount) const
{
    size_t struct_size = 0;
    size_t extra_size = 0;
    size_t entry_size = 0;
    size_t nentries = 0;
    SgAsmElfFileHeader *fhdr = get_elf_header();

    /* Assume ELF Section Table Entry is correct for now for the size of each entry in the table. */
    ROSE_ASSERT(get_section_entry()!=NULL);
    entry_size = get_section_entry()->get_sh_entsize();

    /* Size of required part of each entry */
    if (0==r32size && 0==r64size) {
        /* Probably called by four-argument SgAsmElfSection::calculate_sizes and we don't know the sizes of the required parts
         * because there isn't a parser for this type of section, or the section doesn't contain a table. In the latter case
         * the ELF Section Table has a zero sh_entsize and we'll treat the section as if it were a table with one huge entry.
         * Otherwise we'll assume that the struct size is the same as the sh_entsize and there's no optional data. */
        struct_size = entry_size>0 ? entry_size : get_size();
    } else if (4==fhdr->get_word_size()) {
        struct_size = r32size;
    } else if (8==fhdr->get_word_size()) {
        struct_size = r64size;
    } else {
        throw FormatError("bad ELF word size");
    }

    /* Entire entry should be at least large enough for the required part. This also takes care of the case when the ELF
     * Section Table Entry has a zero-valued sh_entsize */
    entry_size = std::max(entry_size, struct_size);

    /* Size of optional parts. If we've parsed the table then use the largest optional part, otherwise assume the entry from
     * the ELF Section Table is correct. */
    nentries = optsizes.size();
    if (nentries>0) {
        for (size_t i=0; i<nentries; i++) {
            extra_size = std::max(extra_size, optsizes[i]);
        }
        entry_size = std::min(entry_size, struct_size+extra_size);
    } else {
        extra_size = entry_size - struct_size;
        nentries = entry_size>0 ? get_size() / entry_size : 0;
    }

    /* Return values */
    if (entsize)
        *entsize = entry_size;
    if (required)
        *required = struct_size;
    if (optional)
        *optional = extra_size;
    if (entcount)
        *entcount = nentries;
    return entry_size * nentries;
}

/* Most subclasses will override this virtual function in order to return more useful values. This implementation returns the
 * following values:
 *   entsize  -- size stored in the ELF Section Table's sh_entsize member, or size of entire section if not a table.
 *   required -- same as entsize
 *   optional -- zero
 *   entcount -- number of entries, each of size entsize, that can fit in the section.
 * The return size is entsize*entcount, which, if this section is a table (nonzero sh_entsize), could be smaller than the
 * total size of the section. */
rose_addr_t
SgAsmElfSection::calculate_sizes(size_t *entsize, size_t *required, size_t *optional, size_t *entcount) const
{
    return calculate_sizes(0, 0, std::vector<size_t>(), entsize, required, optional, entcount);
}

/* Called prior to unparse to make things consistent. */
bool
SgAsmElfSection::reallocate()
{
    bool reallocated = false;
    SgAsmElfSectionTableEntry *sechdr = get_section_entry();
    SgAsmElfSegmentTableEntry *seghdr = get_segment_entry();

    /* Change section size if this section was defined in the ELF Section Table */
    if (sechdr!=NULL) {
        addr_t need = calculate_sizes(NULL, NULL, NULL, NULL);
        if (need < get_size()) {
            if (is_mapped()) {
                ROSE_ASSERT(get_mapped_size()==get_size());
                set_mapped_size(need);
            }
            set_size(need);
            reallocated = true;
        } else if (need > get_size()) {
            get_file()->shift_extend(this, 0, need-get_size(), SgAsmGenericFile::ADDRSP_ALL, SgAsmGenericFile::ELASTIC_HOLE);
            reallocated = true;
        }
    }

    /* Update entry in the ELF Section Table and/or ELF Segment Table */
    if (sechdr)
        sechdr->update_from_section(this);
    if (seghdr)
        seghdr->update_from_section(this);
    
    return reallocated;
}

/* Print some debugging info */
void
SgAsmElfSection::dump(FILE *f, const char *prefix, ssize_t idx) const
{
    char p[4096];
    if (idx>=0) {
        sprintf(p, "%sElfSection[%zd].", prefix, idx);
    } else {
        sprintf(p, "%sElfSection.", prefix);
    }
    int w = std::max(1, DUMP_FIELD_WIDTH-(int)strlen(p));
    
    SgAsmGenericSection::dump(f, p, -1);
    
    if (get_section_entry())
        get_section_entry()->dump(f, p, -1);
    if (get_segment_entry())
        get_segment_entry()->dump(f, p, -1);

    if (p_linked_section) {
        fprintf(f, "%s%-*s = [%d] \"%s\"\n", p, w, "linked_to", p_linked_section->get_id(), p_linked_section->get_name()->c_str());
    } else {
        fprintf(f, "%s%-*s = NULL\n",    p, w, "linked_to");
    }

    if (variantT() == V_SgAsmElfSection) //unless a base class
        hexdump(f, 0, std::string(p)+"data at ", p_data);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// String Table Sections
//
//    SgAsmElfStringSection is derived from SgAsmElfSection, which is derived in turn from SgAsmGenericSection. An ELF String
//    Table Section points to the ELF String Table (SgAsmElfStrtab) that is contained in the section.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/* Non-parsing constructor. The ELF String Table is constructed to contain one NUL byte. */
void
SgAsmElfStringSection::ctor()
{
    get_name()->set_string("ELF String Table");
    if (get_size()==0)
        set_size(1);
    p_strtab = new SgAsmElfStrtab(this);
}

/* Parse the file content to initialize the string table */
SgAsmElfStringSection *
SgAsmElfStringSection::parse()
{
    SgAsmElfSection::parse();
    ROSE_ASSERT(p_strtab);
    p_strtab->get_freelist().clear(); /*because set_size() during construction added to the free list*/
    p_strtab->parse();
    return this;
}

/* Reallocate space for the string section if necessary. Note that reallocation is lazy here -- we don't shrink the section,
 * we only enlarge it (if you want the section to shrink then call SgAsmGenericStrtab::reallocate(bool) with a true value
 * rather than calling this function. SgAsmElfStringSection::reallocate is called in response to unparsing a file and gives
 * the string table a chance to extend its container section if it needs to allocate more space for strings. */
bool
SgAsmElfStringSection::reallocate()
{
    bool reallocated = SgAsmElfSection::reallocate();
    if (get_strtab()->reallocate(false))
        reallocated = true;

    /* Update parts of the section and segment tables not updated by superclass */
    SgAsmElfSectionTableEntry *secent = get_section_entry();
    if (secent)
        secent->set_sh_type(SgAsmElfSectionTableEntry::SHT_STRTAB);

    return reallocated;
}

/* Unparse an ElfStringSection by unparsing the ElfStrtab */
void
SgAsmElfStringSection::unparse(std::ostream &f) const
{
    get_strtab()->unparse(f);
    unparse_holes(f);
}

/** Augments superclass to make sure free list and such are adjusted properly. Any time the ELF String Section size is changed
 *  we adjust the free list in the ELF String Table contained in this section. */
void
SgAsmElfStringSection::set_size(addr_t newsize)
{
    addr_t orig_size = get_size();
    SgAsmElfSection::set_size(newsize);
    SgAsmGenericStrtab *strtab = get_strtab();

    if (strtab) {
        if (get_size() > orig_size) {
            /* Add new address space to string table free list */
            addr_t n = get_size() - orig_size;
            strtab->get_freelist().insert(orig_size, n);
        } else if (get_size() < orig_size) {
            /* Remove deleted address space from string table free list */
            addr_t n = orig_size - get_size();
            strtab->get_freelist().erase(get_size(), n);
        }
    }
}

/* Print some debugging info */
void
SgAsmElfStringSection::dump(FILE *f, const char *prefix, ssize_t idx) const
{
    char p[4096];
    if (idx>=0) {
        sprintf(p, "%sElfStringSection[%zd].", prefix, idx);
    } else {
        sprintf(p, "%sElfStringSection.", prefix);
    }
    
    SgAsmElfSection::dump(f, p, -1);

    ROSE_ASSERT(get_strtab()!=NULL);
    get_strtab()->dump(f, p, -1);

    if (variantT() == V_SgAsmElfStringSection) //unless a base class
        hexdump(f, 0, std::string(p)+"data at ", p_data);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// String Tables
//
//    An SgAsmElfStrtab is an ELF String Table, inheriting from SgAsmGenericStrtab. String tables point to the
//    SgAsmGenericSection that contains them. In the case of SgAsmElfStrtab it points to an SgAsmElfStringSection.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/** Non-parsing constructor. The table is created to be at least one byte long and having a NUL character as the first byte. */
void
SgAsmElfStrtab::ctor()
{
    ROSE_ASSERT(get_container());
    if (get_container()->get_size()==0)
        get_container()->set_size(1);
    p_dont_free = create_storage(0, false);
}

/* Parses the string table. All that actually happens at this point is we look to see if the table begins with an empty
 * string. */
SgAsmElfStrtab *
SgAsmElfStrtab::parse()
{
    SgAsmGenericStrtab::parse();
    ROSE_ASSERT(get_container());
    if (get_container()->get_size()>0) {
        unsigned char first_byte;
        get_container()->read_content_local(0, &first_byte, 1);
        if (first_byte=='\0') {
            if (p_dont_free) {
                ROSE_ASSERT(0==p_dont_free->get_offset());
            } else {
                p_dont_free = create_storage(0, false);
            }
        } else if (p_dont_free) {
            p_dont_free = NULL;
        }
    }
    return this;
}

/* Free StringStorage objects associated with this string table. It may not be safe to blow them away yet since other objects
 * may still have SgAsmStoredStrings pointing to these storage objects. So instead, we will mark all this strtab's storage
 * objects as no longer being associated with a string table. This allows the SgAsmStoredString objects to still function
 * properly and their destructors (~SgAsmStoredString) will free their storage. */
SgAsmElfStrtab::~SgAsmElfStrtab()
{
    for (referenced_t::iterator i = p_storage_list.begin(); i != p_storage_list.end(); ++i) {
        SgAsmStringStorage *storage = *i;
        storage->set_strtab(NULL);
        storage->set_offset(SgAsmGenericString::unallocated);
    }
    p_storage_list.clear();
    p_dont_free = NULL; /*FIXME: can't delete for same reason as in SgAsmStoredString destructor. (RPM 2008-09-05) */
}

/* Creates the storage item for the string at the specified offset. If 'shared' is true then attempt to re-use a previous
 * storage object, otherwise always create a new one. Each storage object is considered a separate string, therefore when two
 * strings share the same storage object, changing one string changes the other. */
SgAsmStringStorage *
SgAsmElfStrtab::create_storage(addr_t offset, bool shared)
{
    ROSE_ASSERT(offset!=SgAsmGenericString::unallocated);

    /* Has this string already been created? If so, return previous storage object. However, never share the empty_string at
     * offset zero created when this string table was constructed because the ELF spec says it needs to stay there whether
     * referenced or not. */
    if (shared) {
        for (referenced_t::iterator i=p_storage_list.begin(); i!=p_storage_list.end(); i++) {
            if ((*i)->get_offset()==offset && (*i) != p_dont_free)
                return *i;
        }
    }

    /* Create a new storage object at this offset. */
    SgAsmStringStorage *storage = NULL;
    if (0==offset && 0==get_container()->get_data().size()) {
        ROSE_ASSERT(get_container()->get_size()>=1);
        storage = new SgAsmStringStorage(this, "", 0);
    } else {
        std::string s = get_container()->read_content_local_str(offset);
        storage = new SgAsmStringStorage(this, s, offset);
    }

    /* It's a bad idea to free (e.g., modify) strings before we've identified all the strings in the table. Consider
     * the case where offset 1 is "domain" and offset 3 is "main" (i.e., they overlap). If we modify "main" before knowing
     * about "domain" then we'll end up freeing the last part of "domain" (and possibly replacing it with something else)!
     *
     * The only time we can guarantee this is OK is when the new storage points to the same file location as "dont_free"
     * since the latter is guaranteed to never be freed or shared. This exception is used when creating a new, unallocated
     * string (see SgAsmStoredString(SgAsmGenericStrtab,const std::string&)). */
    if (p_num_freed>0 && (!p_dont_free || offset!=p_dont_free->get_offset())) {
        fprintf(stderr,
                "SgAsmElfStrtab::create_storage(%"PRIu64"): %zu other string%s (of %zu created) in [%d] \"%s\""
                " %s been modified and/or reallocated!\n",
                offset, p_num_freed, 1==p_num_freed?"":"s", p_storage_list.size(),
                get_container()->get_id(), get_container()->get_name()->c_str(),
                1==p_num_freed?"has":"have");
        ROSE_ASSERT(0==p_num_freed);
    }
    
    p_storage_list.push_back(storage);
    set_isModified(true);
    return storage;
}

/* Similar to create_storage() but uses a storage object that's already been allocated. */
void
SgAsmElfStrtab::rebind(SgAsmStringStorage *storage, addr_t offset)
{
    ROSE_ASSERT(p_dont_free && storage!=p_dont_free && storage->get_offset()==p_dont_free->get_offset());
    std::string s = get_container()->read_content_local_str(offset);
    storage->set_offset(offset);
    storage->set_string(s);
}

/* Returns the number of bytes required to store the string in the string table. This is the length of the string plus
 * one for the NUL terminator. */
rose_addr_t
SgAsmElfStrtab::get_storage_size(const SgAsmStringStorage *storage) {
    return storage->get_string().size() + 1;
}

/* Tries to find a suitable offset for a string such that it overlaps with some other string already allocated. If the new
 * string is the same as the end of some other string (new="main", existing="domain") then we just use an offset into that
 * string since the space is already allocated for the existing string. If the new string ends with an existing string
 * (new="domain", existing="main") and there's enough free space before the existing string (two bytes in this case) then
 * we allocate some of that free space and use a suitable offset. In any case, upon return storage->get_offset() will return
 * the allocated offset if successful, or SgAsmGenericString::unallocated if we couldn't find an overlap. */
void
SgAsmElfStrtab::allocate_overlap(SgAsmStringStorage *storage)
{
    ROSE_ASSERT(storage->get_offset()==SgAsmGenericString::unallocated);
    size_t need = storage->get_string().size();
    for (size_t i=0; i<p_storage_list.size(); i++) {
        SgAsmStringStorage *existing = p_storage_list[i];
        if (existing->get_offset()!=SgAsmGenericString::unallocated) {
            size_t have = existing->get_string().size();
            if (need<=have && 0==existing->get_string().compare(have-need, need, storage->get_string())) {
                /* An existing string ends with the new string. */
                storage->set_offset(existing->get_offset() + (have-need));
                return;
            } else if (need>have && existing->get_offset()>=need-have &&
                       0==storage->get_string().compare(need-have, have, existing->get_string())) {
                /* New string ends with an existing string. Check for, and allocate, free space. */
                addr_t offset = existing->get_offset() - (need-have); /* positive diffs checked above */
                if (get_freelist().subtract_from(offset, need-have).size()==0) {
                    get_freelist().allocate_at(offset, need-have);
                    storage->set_offset(offset);
                    return;
                }
            }
        }
    }
}

/* Write string table back to disk. Free space is zeroed out; holes are left as they are. */
void
SgAsmElfStrtab::unparse(std::ostream &f) const
{
    SgAsmGenericSection *container = get_container();
    
    /* Write strings with NUL termination. Shared strings will be written more than once, but that's OK. */
    for (size_t i=0; i<p_storage_list.size(); i++) {
        SgAsmStringStorage *storage = p_storage_list[i];
        ROSE_ASSERT(storage->get_offset()!=SgAsmGenericString::unallocated);
        addr_t at = container->write(f, storage->get_offset(), storage->get_string());
        container->write(f, at, '\0');
    }
    
    /* Fill free areas with zero */
    for (ExtentMap::const_iterator i=get_freelist().begin(); i!=get_freelist().end(); ++i) {
        container->write(f, i->first, std::string(i->second, '\0'));
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Section tables
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/* Converts 32-bit disk representation to host representation */
void
SgAsmElfSectionTableEntry::ctor(ByteOrder sex, const Elf32SectionTableEntry_disk *disk) 
{
    p_sh_name      = disk_to_host(sex, disk->sh_name);
    p_sh_type      = (SectionType)disk_to_host(sex, disk->sh_type);
    p_sh_flags     = disk_to_host(sex, disk->sh_flags);
    p_sh_addr      = disk_to_host(sex, disk->sh_addr);
    p_sh_offset    = disk_to_host(sex, disk->sh_offset);
    p_sh_size      = disk_to_host(sex, disk->sh_size);
    p_sh_link      = disk_to_host(sex, disk->sh_link);
    p_sh_info      = disk_to_host(sex, disk->sh_info);
    p_sh_addralign = disk_to_host(sex, disk->sh_addralign);
    p_sh_entsize   = disk_to_host(sex, disk->sh_entsize);
}
    
/* Converts 64-bit disk representation to host representation */
void
SgAsmElfSectionTableEntry::ctor(ByteOrder sex, const Elf64SectionTableEntry_disk *disk) 
{
    p_sh_name      = disk_to_host(sex, disk->sh_name);
    p_sh_type      = (SectionType)disk_to_host(sex, disk->sh_type);
    p_sh_flags     = disk_to_host(sex, disk->sh_flags);
    p_sh_addr      = disk_to_host(sex, disk->sh_addr);
    p_sh_offset    = disk_to_host(sex, disk->sh_offset);
    p_sh_size      = disk_to_host(sex, disk->sh_size);
    p_sh_link      = disk_to_host(sex, disk->sh_link);
    p_sh_info      = disk_to_host(sex, disk->sh_info);
    p_sh_addralign = disk_to_host(sex, disk->sh_addralign);
    p_sh_entsize   = disk_to_host(sex, disk->sh_entsize);
}

/* Encode a section table entry into the disk structure */
void *
SgAsmElfSectionTableEntry::encode(ByteOrder sex, Elf32SectionTableEntry_disk *disk) const
{
    host_to_disk(sex, p_sh_name,      &(disk->sh_name));
    host_to_disk(sex, p_sh_type,      &(disk->sh_type));
    host_to_disk(sex, p_sh_flags,     &(disk->sh_flags));
    host_to_disk(sex, p_sh_addr,      &(disk->sh_addr));
    host_to_disk(sex, p_sh_offset,    &(disk->sh_offset));
    host_to_disk(sex, p_sh_size,      &(disk->sh_size));
    host_to_disk(sex, p_sh_link,      &(disk->sh_link));
    host_to_disk(sex, p_sh_info,      &(disk->sh_info));
    host_to_disk(sex, p_sh_addralign, &(disk->sh_addralign));
    host_to_disk(sex, p_sh_entsize,   &(disk->sh_entsize));

    return disk;
}
void *
SgAsmElfSectionTableEntry::encode(ByteOrder sex, Elf64SectionTableEntry_disk *disk) const
{
    host_to_disk(sex, p_sh_name,      &(disk->sh_name));
    host_to_disk(sex, p_sh_type,      &(disk->sh_type));
    host_to_disk(sex, p_sh_flags,     &(disk->sh_flags));
    host_to_disk(sex, p_sh_addr,      &(disk->sh_addr));
    host_to_disk(sex, p_sh_offset,    &(disk->sh_offset));
    host_to_disk(sex, p_sh_size,      &(disk->sh_size));
    host_to_disk(sex, p_sh_link,      &(disk->sh_link));
    host_to_disk(sex, p_sh_info,      &(disk->sh_info));
    host_to_disk(sex, p_sh_addralign, &(disk->sh_addralign));
    host_to_disk(sex, p_sh_entsize,   &(disk->sh_entsize));

    return disk;
}

/** Non-parsing constructor for an ELF Section Table */
void
SgAsmElfSectionTable::ctor()
{
    /* There can be only one ELF Section Table */
    SgAsmElfFileHeader *fhdr = dynamic_cast<SgAsmElfFileHeader*>(get_header());
    ROSE_ASSERT(fhdr);
    ROSE_ASSERT(fhdr->get_section_table()==NULL);

    set_synthesized(true);                              /* the section table isn't really a section itself */
    set_name(new SgAsmBasicString("ELF Section Table"));
    set_purpose(SP_HEADER);

    /* Every section table has a first entry that's all zeros. We don't declare that section here (see parse()) but we do set
     * the section count in the header in order to reserve that first slot. */
    if (fhdr->get_e_shnum()<1)
        fhdr->set_e_shnum(1);

    fhdr->set_section_table(this);
}
    
/** Parses an ELF Section Table and constructs and parses all sections reachable from the table. The section is extended as
 *  necessary based on the number of entries and the size of each entry. */
SgAsmElfSectionTable *
SgAsmElfSectionTable::parse()
{
    SgAsmGenericSection::parse();

    SgAsmElfFileHeader *fhdr = dynamic_cast<SgAsmElfFileHeader*>(get_header());
    ROSE_ASSERT(fhdr!=NULL);
    ByteOrder sex = fhdr->get_sex();

    size_t ent_size, struct_size, opt_size, nentries;
    calculate_sizes(&ent_size, &struct_size, &opt_size, &nentries);
    ROSE_ASSERT(opt_size==fhdr->get_shextrasz() && nentries==fhdr->get_e_shnum());

    /* If the current size is very small (0 or 1 byte) then we're coming straight from the constructor and the parsing should
     * also extend this section to hold all the entries. Otherwise the caller must have assigned a specific size for a good
     * reason and we should leave that alone, reading zeros if the entries extend beyond the defined size. */
    if (get_size()<=1 && get_size()<nentries*ent_size)
        extend(nentries*ent_size - get_size());

    /* Read all the section headers. */
    std::vector<SgAsmElfSectionTableEntry*> entries;
    addr_t offset = 0;
    for (size_t i=0; i<nentries; i++, offset+=ent_size) {
        SgAsmElfSectionTableEntry *shdr = NULL;
        if (4 == fhdr->get_word_size()) {
            SgAsmElfSectionTableEntry::Elf32SectionTableEntry_disk disk;
            read_content_local(offset, &disk, struct_size);
            shdr = new SgAsmElfSectionTableEntry(sex, &disk);
        } else {
            SgAsmElfSectionTableEntry::Elf64SectionTableEntry_disk disk;
            read_content_local(offset, &disk, struct_size);
            shdr = new SgAsmElfSectionTableEntry(sex, &disk);
        }
        if (opt_size>0)
            shdr->get_extra() = read_content_local_ucl(offset+struct_size, opt_size);
        entries.push_back(shdr);
    }

    /* This vector keeps track of which sections have already been parsed. We could get the same information by calling
     * fhdr->get_section_by_id() and passing the entry number since entry numbers and IDs are one and the same in ELF. However,
     * this is a bit easier. */
    std::vector<SgAsmElfSection*> is_parsed;
    is_parsed.resize(entries.size(), NULL);

    /* All sections implicitly depend on the section string table for their names. */
    SgAsmElfStringSection *section_name_strings=NULL;
    if (fhdr->get_e_shstrndx() > 0) {
        SgAsmElfSectionTableEntry *entry = entries[fhdr->get_e_shstrndx()];
        section_name_strings = new SgAsmElfStringSection(fhdr);
        section_name_strings->init_from_section_table(entry, section_name_strings, fhdr->get_e_shstrndx());
        section_name_strings->parse();
        is_parsed[fhdr->get_e_shstrndx()] = section_name_strings;
    }

    /* Read all the sections. Some sections depend on other sections, so we read them in such an order that all dependencies
     * are satisfied first. */
    while (1) {
        bool try_again=false;
        for (size_t i=0; i<entries.size(); i++) {
            SgAsmElfSectionTableEntry *entry = entries[i];
            ROSE_ASSERT(entry->get_sh_link()<entries.size());
            SgAsmElfSection *linked = entry->get_sh_link()>0 ? is_parsed[entry->get_sh_link()] : NULL;
            if (is_parsed[i]) {
                /* This section has already been parsed. */
            } else if (entry->get_sh_link()>0 && !linked) {
                /* Don't parse this section yet because it depends on something that's not parsed yet. */
                try_again = true;
            } else {
                switch (entry->get_sh_type()) {
                  case SgAsmElfSectionTableEntry::SHT_NULL:
                    /* Null entry. We still create the section just to hold the section header. */
                    is_parsed[i] = new SgAsmElfSection(fhdr);
                    break;
                  case SgAsmElfSectionTableEntry::SHT_NOBITS:
                    /* These types of sections don't occupy any file space (e.g., BSS) */
                    is_parsed[i] = new SgAsmElfSection(fhdr);
                    break;
                  case SgAsmElfSectionTableEntry::SHT_DYNAMIC: {
                      SgAsmElfStringSection *strsec = dynamic_cast<SgAsmElfStringSection*>(linked);
                      ROSE_ASSERT(strsec);
                      is_parsed[i] = new SgAsmElfDynamicSection(fhdr, strsec);
                      break;
                  }
                  case SgAsmElfSectionTableEntry::SHT_DYNSYM: {
                      SgAsmElfStringSection *strsec = dynamic_cast<SgAsmElfStringSection*>(linked);
                      ROSE_ASSERT(strsec);
                      SgAsmElfSymbolSection *symsec = new SgAsmElfSymbolSection(fhdr, strsec);
                      symsec->set_is_dynamic(true);
                      is_parsed[i] = symsec;
                      break;
                  }
                  case SgAsmElfSectionTableEntry::SHT_SYMTAB: {
                      SgAsmElfStringSection *strsec = dynamic_cast<SgAsmElfStringSection*>(linked);
                      ROSE_ASSERT(strsec);
                      SgAsmElfSymbolSection *symsec = new SgAsmElfSymbolSection(fhdr, strsec);
                      symsec->set_is_dynamic(false);
                      is_parsed[i] = symsec;
                      break;
                  }
                  case SgAsmElfSectionTableEntry::SHT_STRTAB:
                    is_parsed[i] = new SgAsmElfStringSection(fhdr);
                    break;
                  case SgAsmElfSectionTableEntry::SHT_REL: {
                      SgAsmElfSymbolSection *symbols = dynamic_cast<SgAsmElfSymbolSection*>(linked);
                      ROSE_ASSERT(symbols);
                      SgAsmElfRelocSection *relocsec = new SgAsmElfRelocSection(fhdr, symbols);
                      relocsec->set_uses_addend(false);
                      is_parsed[i] = relocsec;
                      break;
                  }
                  case SgAsmElfSectionTableEntry::SHT_RELA: {
                      SgAsmElfSymbolSection *symbols = dynamic_cast<SgAsmElfSymbolSection*>(linked);
                      ROSE_ASSERT(symbols);
                      SgAsmElfRelocSection *relocsec = new SgAsmElfRelocSection(fhdr, symbols);
                      relocsec->set_uses_addend(true);
                      is_parsed[i] = relocsec;
                      break;
                  }
                  case SgAsmElfSectionTableEntry::SHT_PROGBITS: {
                      std::string section_name = section_name_strings->read_content_local_str(entry->get_sh_name());
                      if (section_name == ".eh_frame") {
                          is_parsed[i] = new SgAsmElfEHFrameSection(fhdr);
                      } else {
                          is_parsed[i] = new SgAsmElfSection(fhdr);
                      }
                      break;
                  }
		  case SgAsmElfSectionTableEntry::SHT_GNU_versym: {
		      is_parsed[i] = new SgAsmElfSymverSection(fhdr);
		      break;
		  }
		  case SgAsmElfSectionTableEntry::SHT_GNU_verdef: {
                      SgAsmElfStringSection *strsec = dynamic_cast<SgAsmElfStringSection*>(linked);
                      ROSE_ASSERT(strsec);
		      is_parsed[i] = new SgAsmElfSymverDefinedSection(fhdr,strsec);
		      break;
		  }
		  case SgAsmElfSectionTableEntry::SHT_GNU_verneed: {
                      SgAsmElfStringSection *strsec = dynamic_cast<SgAsmElfStringSection*>(linked);
                      ROSE_ASSERT(strsec);
		      is_parsed[i] = new SgAsmElfSymverNeededSection(fhdr,strsec);
		      break;
		  }
                  default:
                    is_parsed[i] = new SgAsmElfSection(fhdr);
                    break;
                }
                is_parsed[i]->init_from_section_table(entry, section_name_strings, i);
                is_parsed[i]->parse();
            }
        }
        if (!try_again)
            break;
    }

#if 1 /*This will be going away shortly [RPM 2008-12-12]*/
    /* Initialize links between sections */
    for (size_t i = 0; i < entries.size(); i++) {
        SgAsmElfSectionTableEntry *shdr = entries[i];
        if (shdr->get_sh_link() > 0) {
            SgAsmElfSection *source = dynamic_cast<SgAsmElfSection*>(fhdr->get_file()->get_section_by_id(i));
            SgAsmElfSection *target = dynamic_cast<SgAsmElfSection*>(fhdr->get_file()->get_section_by_id(shdr->get_sh_link()));
            source->set_linked_section(target);
        }
    }
#endif

    /* Finish parsing sections now that we have basic info for all the sections. */
    for (size_t i=0; i<is_parsed.size(); i++)
        is_parsed[i]->finish_parsing();

    return this;
}

/** Attaches a previously unattached ELF Section to the section table. If @p section is an  ELF String Section
 *  (SgAsmElfStringSection) that contains an ELF String Table (SgAsmElfStringTable) and the ELF Section Table has no
 *  associated string table then the @p section will be used as the string table to hold the section names.
 *
 *  This method complements SgAsmElfSection::init_from_section_table. This method initializes the section table from the
 *  section while init_from_section_table() initializes the section from the section table. */
void
SgAsmElfSectionTable::add_section(SgAsmElfSection *section)
{
    ROSE_ASSERT(section!=NULL);
    ROSE_ASSERT(section->get_file()==get_file());
    ROSE_ASSERT(section->get_header()==get_header());
    ROSE_ASSERT(section->get_section_entry()==NULL);            /* must not be in the section table yet */
    
    SgAsmElfFileHeader *fhdr = dynamic_cast<SgAsmElfFileHeader*>(get_header());
    ROSE_ASSERT(fhdr!=NULL);

    /* Assign an ID if there isn't one yet */
    if (section->get_id()<0) {
        int id = fhdr->get_e_shnum();
        fhdr->set_e_shnum(id+1);
        section->set_id(id);
    }

    /* If the supplied section is a string table and the ELF Section Table doesn't have a string table associated with it yet,
     * then use the supplied section as the string table to hold the names of the sections. When this happens, all sections
     * that are already defined in the ELF Section Table should have their names moved into the new string table. */
    SgAsmElfStringSection *strsec = NULL;
    if (fhdr->get_e_shstrndx()==0) {
        strsec = dynamic_cast<SgAsmElfStringSection*>(section);
        if (strsec) {
            fhdr->set_e_shstrndx(section->get_id());
            SgAsmGenericSectionList *all = fhdr->get_sections();
            for (size_t i=0; i<all->get_sections().size(); i++) {
                SgAsmElfSection *s = dynamic_cast<SgAsmElfSection*>(all->get_sections()[i]);
                if (s && s->get_id()>=0 && s->get_section_entry()!=NULL) {
                    s->allocate_name_to_storage(strsec);
                }
            }
        }
    } else {
        strsec = dynamic_cast<SgAsmElfStringSection*>(fhdr->get_section_by_id(fhdr->get_e_shstrndx()));
        ROSE_ASSERT(strsec!=NULL);
    }

    /* Make sure the name is in the correct string table */
    if (strsec)
        section->allocate_name_to_storage(strsec);

    /* Create a new section table entry. */
    SgAsmElfSectionTableEntry *shdr = new SgAsmElfSectionTableEntry;
    shdr->update_from_section(section);
    section->set_section_entry(shdr);
}

/** Make this section's name to be stored in the specified string table. */
void
SgAsmElfSection::allocate_name_to_storage(SgAsmElfStringSection *strsec)
{
    if (get_name()) {
        SgAsmStoredString *old_stored = dynamic_cast<SgAsmStoredString*>(get_name());
        if (!old_stored || old_stored->get_strtab()!=strsec->get_strtab()) {
            /* Reallocate string to new string table */
            SgAsmStoredString *new_stored = new SgAsmStoredString(strsec->get_strtab(), 0);
            new_stored->set_string(get_name()->get_string());
            get_name()->set_string(""); /*free old string*/
            set_name(new_stored);
        }
    }
}

/* Returns info about the size of the entries based on information already available. Any or all arguments may be null
 * pointers if the caller is not interested in the value. */
rose_addr_t
SgAsmElfSectionTable::calculate_sizes(size_t *entsize, size_t *required, size_t *optional, size_t *entcount) const
{
    SgAsmElfFileHeader *fhdr = dynamic_cast<SgAsmElfFileHeader*>(get_header());
    ROSE_ASSERT(fhdr!=NULL);

    size_t struct_size = 0;
    size_t extra_size = fhdr->get_shextrasz();
    size_t entry_size = 0;
    size_t nentries = 0;

    /* Size of required part of each entry */
    if (4==fhdr->get_word_size()) {
        struct_size = sizeof(SgAsmElfSectionTableEntry::Elf32SectionTableEntry_disk);
    } else if (8==fhdr->get_word_size()) {
        struct_size = sizeof(SgAsmElfSectionTableEntry::Elf64SectionTableEntry_disk);
    } else {
        throw FormatError("bad ELF word size");
    }

    /* Entire entry should be at least large enough for the required part. */
    entry_size = struct_size;

    /* Size of optional parts. If we've parsed the table then use the largest optional part, otherwise assume the entry from
     * the ELF File Header is correct. */
    SgAsmGenericSectionPtrList sections = fhdr->get_sections()->get_sections();
    for (size_t i=0; i<sections.size(); i++) {
        SgAsmElfSection *elfsec = dynamic_cast<SgAsmElfSection*>(sections[i]);
        if (elfsec && elfsec->get_section_entry()) {
            ROSE_ASSERT(elfsec->get_id()>=0);
            nentries = std::max(nentries, (size_t)elfsec->get_id()+1);
            extra_size = std::max(extra_size, elfsec->get_section_entry()->get_extra().size());
        }
    }

    /* Total number of entries. Either we haven't parsed the section table yet (nor created the sections it defines) or we
     * have. In the former case we use the setting from the ELF File Header. Otherwise the table has to be large enough to
     * store the section with the largest ID (ID also serves as the index into the ELF Section Table). */
    if (0==nentries)
        nentries = fhdr->get_e_shnum();

    /* Return values */
    if (entsize)
        *entsize = entry_size;
    if (required)
        *required = struct_size;
    if (optional)
        *optional = extra_size;
    if (entcount)
        *entcount = nentries;
    return entry_size * nentries;
}

/** Update this section table entry with newer information from the section */
void
SgAsmElfSectionTableEntry::update_from_section(SgAsmElfSection *section)
{
    if (section->get_name()->get_offset()==SgAsmGenericString::unallocated) {
        p_sh_name = 0; /*not a stored string after all*/
    } else {
        p_sh_name = section->get_name()->get_offset();
    }

    set_sh_offset(section->get_offset());
    if (get_sh_type()==SHT_NOBITS && section->is_mapped()) {
        set_sh_size(section->get_mapped_size());
    } else {
        set_sh_size(section->get_size());
    }

    if (section->is_mapped()) {
        set_sh_addr(section->get_mapped_preferred_rva());
        set_sh_addralign(section->get_mapped_alignment());
        if (section->get_mapped_wperm()) {
            p_sh_flags |= 0x01;
        } else {
            p_sh_flags &= ~0x01;
        }
        if (section->get_mapped_xperm()) {
            p_sh_flags |= 0x04;
        } else {
            p_sh_flags &= ~0x04;
        }
    } else {
        set_sh_addr(0);
        p_sh_flags &= ~0x05; /*clear write & execute bits*/
    }
    
    SgAsmElfSection *linked_to = section->get_linked_section();
    if (linked_to) {
        ROSE_ASSERT(linked_to->get_id()>0);
        set_sh_link(linked_to->get_id());
    } else {
        set_sh_link(0);
    }
}

/* Change symbol to string */
const char *
SgAsmElfSectionTableEntry::to_string(SectionType t)
{
    switch (t) {
      case SHT_NULL:     return "SHT_NULL";
      case SHT_PROGBITS: return "SHT_PROGBITS";
      case SHT_SYMTAB:   return "SHT_SYMTAB";
      case SHT_STRTAB:   return "SHT_STRTAB";
      case SHT_RELA:     return "SHT_RELA";
      case SHT_HASH:     return "SHT_HASH";
      case SHT_DYNAMIC:  return "SHT_DYNAMIC";
      case SHT_NOTE:     return "SHT_NOTE";
      case SHT_NOBITS:   return "SHT_NOBITS";
      case SHT_REL:      return "SHT_REL";
      case SHT_SHLIB:    return "SHT_SHLIB";
      case SHT_DYNSYM:   return "SHT_DYNSYM";

	// extensions
      case SHT_GNU_verdef: return "SHT_GNU_verdef";
      case SHT_GNU_verneed: return "SHT_GNU_verneed";
      case SHT_GNU_versym: return "SHT_GNU_versym";
      default:
	if(t>=SHT_LOOS && t <= SHT_HIOS) {
	    return "os-specific";
        } else if (t>=SHT_LOPROC && t<=SHT_HIPROC) {
            return "processor-specific";
        } else if (t>=SHT_LOUSER && t<=SHT_HIUSER) {
            return "application-specific";
        } else {
            return "unknown";
        }
    }
}

/* Print some debugging info */
void
SgAsmElfSectionTableEntry::dump(FILE *f, const char *prefix, ssize_t idx) const
{
    char p[4096];
    if (idx>=0) {
        sprintf(p, "%sElfSectionTableEntry[%zd].", prefix, idx);
    } else {
        sprintf(p, "%sElfSectionTableEntry.", prefix);
    }
    const int w = std::max(1, DUMP_FIELD_WIDTH-(int)strlen(p));
    
    fprintf(f, "%s%-*s = %u bytes into strtab\n",                      p, w, "sh_name",        p_sh_name);
    fprintf(f, "%s%-*s = 0x%x (%d) %s\n",                              p, w, "sh_type", 
            p_sh_type, p_sh_type, to_string(p_sh_type));
    fprintf(f, "%s%-*s = %lu\n",                                       p, w, "sh_link",        p_sh_link);
    fprintf(f, "%s%-*s = %lu\n",                                       p, w, "sh_info",        p_sh_info);
    fprintf(f, "%s%-*s = 0x%08"PRIx64"\n",                             p, w, "sh_flags",       p_sh_flags);
    fprintf(f, "%s%-*s = 0x%08"PRIx64" (%"PRIu64")\n",                 p, w, "sh_addr",        p_sh_addr, p_sh_addr);
    fprintf(f, "%s%-*s = 0x%08"PRIx64" (%"PRIu64") bytes into file\n", p, w, "sh_offset",      p_sh_offset, p_sh_offset);
    fprintf(f, "%s%-*s = 0x%08"PRIx64" (%"PRIu64") bytes\n",           p, w, "sh_size",        p_sh_size, p_sh_size);
    fprintf(f, "%s%-*s = 0x%08"PRIx64" (%"PRIu64") bytes\n",           p, w, "sh_addralign",   p_sh_addralign, p_sh_addralign);
    fprintf(f, "%s%-*s = 0x%08"PRIx64" (%"PRIu64") bytes\n",           p, w, "sh_entsize",     p_sh_entsize, p_sh_entsize);
    if (p_extra.size()>0) {
        fprintf(f, "%s%-*s = %zu bytes\n", p, w, "extra", p_extra.size());
        hexdump(f, 0, std::string(p)+"extra at ", p_extra);
    }
}

/* Pre-unparsing updates */
bool
SgAsmElfSectionTable::reallocate()
{
    bool reallocated = false;

    /* Resize based on word size from ELF File Header */
    size_t opt_size, nentries;
    addr_t need = calculate_sizes(NULL, NULL, &opt_size, &nentries);
    if (need < get_size()) {
        if (is_mapped()) {
            ROSE_ASSERT(get_mapped_size()==get_size());
            set_mapped_size(need);
        }
        set_size(need);
        reallocated = true;
        
    } else if (need > get_size()) {
        get_file()->shift_extend(this, 0, need-get_size(), SgAsmGenericFile::ADDRSP_ALL, SgAsmGenericFile::ELASTIC_HOLE);
        reallocated = true;
    }

    /* Update data members in the ELF File Header. No need to return true for these changes. */
    SgAsmElfFileHeader *fhdr = dynamic_cast<SgAsmElfFileHeader*>(get_header());
    fhdr->set_shextrasz(opt_size);
    fhdr->set_e_shnum(nentries);

    return reallocated;
}

/* Write the section table section back to disk */
void
SgAsmElfSectionTable::unparse(std::ostream &f) const
{
    SgAsmElfFileHeader *fhdr = dynamic_cast<SgAsmElfFileHeader*>(get_header());
    ROSE_ASSERT(fhdr!=NULL);
    ByteOrder sex = fhdr->get_sex();
    SgAsmGenericSectionPtrList sections = fhdr->get_sectab_sections();

    /* Write the sections first */
    for (size_t i=0; i<sections.size(); i++)
        sections[i]->unparse(f);
    unparse_holes(f);

    /* Calculate sizes. The ELF File Header should have been updated in reallocate() prior to unparsing. */
    size_t ent_size, struct_size, opt_size, nentries;
    calculate_sizes(&ent_size, &struct_size, &opt_size, &nentries);
    ROSE_ASSERT(fhdr->get_shextrasz()==opt_size);
    ROSE_ASSERT(fhdr->get_e_shnum()==nentries);
    
    /* Write the section table entries */
    for (size_t i=0; i<sections.size(); ++i) {
        SgAsmElfSection *section = dynamic_cast<SgAsmElfSection*>(sections[i]);
        ROSE_ASSERT(section!=NULL);
        SgAsmElfSectionTableEntry *shdr = section->get_section_entry();
        ROSE_ASSERT(shdr!=NULL);
        ROSE_ASSERT(shdr->get_sh_offset()==section->get_offset()); /*section table entry should have been updated in reallocate()*/

        int id = section->get_id();
        ROSE_ASSERT(id>=0 && (size_t)id<nentries);

        SgAsmElfSectionTableEntry::Elf32SectionTableEntry_disk disk32;
        SgAsmElfSectionTableEntry::Elf64SectionTableEntry_disk disk64;
        void *disk  = NULL;

        if (4==fhdr->get_word_size()) {
            disk = shdr->encode(sex, &disk32);
        } else if (8==fhdr->get_word_size()) {
            disk = shdr->encode(sex, &disk64);
        } else {
            ROSE_ASSERT(!"invalid word size");
        }

        /* The disk struct */
        addr_t spos = write(f, id*ent_size, struct_size, disk);
        if (shdr->get_extra().size() > 0) {
            ROSE_ASSERT(shdr->get_extra().size()<=opt_size);
            write(f, spos, shdr->get_extra());
        }
    }
}

/* Print some debugging info */
void
SgAsmElfSectionTable::dump(FILE *f, const char *prefix, ssize_t idx) const
{
    char p[4096];
    if (idx>=0) {
        sprintf(p, "%sSectionTable[%zd].", prefix, idx);
    } else {
        sprintf(p, "%sSectionTable.", prefix);
    }

    SgAsmGenericSection::dump(f, p, -1);

    if (variantT() == V_SgAsmElfSectionTable) //unless a base class
        hexdump(f, 0, std::string(p)+"data at ", p_data);
}
    

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Segment tables
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/* Converts 32-bit disk representation to host representation */
void
SgAsmElfSegmentTableEntry::ctor(ByteOrder sex, const struct Elf32SegmentTableEntry_disk *disk) 
{
    p_type      = (SegmentType)disk_to_host(sex, disk->p_type);
    p_offset    = disk_to_host(sex, disk->p_offset);
    p_vaddr     = disk_to_host(sex, disk->p_vaddr);
    p_paddr     = disk_to_host(sex, disk->p_paddr);
    p_filesz    = disk_to_host(sex, disk->p_filesz);
    p_memsz     = disk_to_host(sex, disk->p_memsz);
    p_flags     = (SegmentFlags)disk_to_host(sex, disk->p_flags);
    p_align     = disk_to_host(sex, disk->p_align);
}

/* Converts 64-bit disk representation to host representation */
void
SgAsmElfSegmentTableEntry::ctor(ByteOrder sex, const Elf64SegmentTableEntry_disk *disk) 
{
    p_type      = (SegmentType)disk_to_host(sex, disk->p_type);
    p_offset    = disk_to_host(sex, disk->p_offset);
    p_vaddr     = disk_to_host(sex, disk->p_vaddr);
    p_paddr     = disk_to_host(sex, disk->p_paddr);
    p_filesz    = disk_to_host(sex, disk->p_filesz);
    p_memsz     = disk_to_host(sex, disk->p_memsz);
    p_flags     = (SegmentFlags)disk_to_host(sex, disk->p_flags);
    p_align     = disk_to_host(sex, disk->p_align);
}

/* Converts segment table entry back into disk structure */
void *
SgAsmElfSegmentTableEntry::encode(ByteOrder sex, Elf32SegmentTableEntry_disk *disk) const
{
    host_to_disk(sex, p_type, &(disk->p_type));
    host_to_disk(sex, p_offset, &(disk->p_offset));
    host_to_disk(sex, p_vaddr, &(disk->p_vaddr));
    host_to_disk(sex, p_paddr, &(disk->p_paddr));
    host_to_disk(sex, p_filesz, &(disk->p_filesz));
    host_to_disk(sex, p_memsz, &(disk->p_memsz));
    host_to_disk(sex, p_flags, &(disk->p_flags));
    host_to_disk(sex, p_align, &(disk->p_align));
    return disk;
}
void *
SgAsmElfSegmentTableEntry::encode(ByteOrder sex, Elf64SegmentTableEntry_disk *disk) const
{
    host_to_disk(sex, p_type, &(disk->p_type));
    host_to_disk(sex, p_offset, &(disk->p_offset));
    host_to_disk(sex, p_vaddr, &(disk->p_vaddr));
    host_to_disk(sex, p_paddr, &(disk->p_paddr));
    host_to_disk(sex, p_filesz, &(disk->p_filesz));
    host_to_disk(sex, p_memsz, &(disk->p_memsz));
    host_to_disk(sex, p_flags, &(disk->p_flags));
    host_to_disk(sex, p_align, &(disk->p_align));
    return disk;
}

/** Update this segment table entry with newer information from the section */
void
SgAsmElfSegmentTableEntry::update_from_section(SgAsmElfSection *section)
{
    set_offset(section->get_offset());
    set_filesz(section->get_size());

    set_vaddr(section->get_mapped_preferred_va());
    set_memsz(section->get_mapped_size());
    if (section->get_mapped_rperm()) {
        set_flags((SegmentFlags)(p_flags | PF_RPERM));
    } else {
        set_flags((SegmentFlags)(p_flags & ~PF_RPERM));
    }
    if (section->get_mapped_wperm()) {
        set_flags((SegmentFlags)(p_flags | PF_WPERM));
    } else {
        set_flags((SegmentFlags)(p_flags & ~PF_WPERM));
    }
    if (section->get_mapped_xperm()) {
        set_flags((SegmentFlags)(p_flags | PF_XPERM));
    } else {
        set_flags((SegmentFlags)(p_flags & ~PF_XPERM));
    }

    if (isSgAsmElfNoteSection(section)) {
        set_type(PT_NOTE);
    }
}

/* Print some debugging info */
void
SgAsmElfSegmentTableEntry::dump(FILE *f, const char *prefix, ssize_t idx) const
{
    char p[4096];
    if (idx>=0) {
        sprintf(p, "%sElfSegmentTableEntry[%zd].", prefix, idx);
    } else {
        sprintf(p, "%sElfSegmentTableEntry.", prefix);
    }
    const int w = std::max(1, DUMP_FIELD_WIDTH-(int)strlen(p));

    fprintf(f, "%s%-*s = %zu\n",                             p, w, "index",  p_index);
    fprintf(f, "%s%-*s = 0x%08x = %s\n",                     p, w, "type",   p_type,  stringifyType(p_type).c_str());
    fprintf(f, "%s%-*s = 0x%08x ",                           p, w, "flags",  p_flags);
    fputc(p_flags & PF_RPERM ? 'r' : '-', f);
    fputc(p_flags & PF_WPERM ? 'w' : '-', f);
    fputc(p_flags & PF_XPERM ? 'x' : '-', f);
    if (p_flags & PF_PROC_MASK) fputs(" proc", f);
    if (p_flags & PF_RESERVED) fputs(" *", f);
    fputc('\n', f);
    fprintf(f, "%s%-*s = 0x%08"PRIx64" (%"PRIu64") bytes into file\n", p, w, "offset", p_offset, p_offset);
    fprintf(f, "%s%-*s = 0x%08"PRIx64" (%"PRIu64")\n",                 p, w, "vaddr",  p_vaddr, p_vaddr);
    fprintf(f, "%s%-*s = 0x%08"PRIx64" (%"PRIu64")\n",                 p, w, "paddr",  p_paddr, p_paddr);
    fprintf(f, "%s%-*s = 0x%08"PRIx64" (%"PRIu64") bytes\n",           p, w, "filesz", p_filesz, p_filesz);
    fprintf(f, "%s%-*s = 0x%08"PRIx64" (%"PRIu64") bytes\n",           p, w, "memsz",  p_memsz, p_memsz);
    fprintf(f, "%s%-*s = 0x%08"PRIx64" (%"PRIu64") bytes\n",           p, w, "align",  p_align, p_align);
    if (p_extra.size()>0) {
        fprintf(f, "%s%-*s = %zu bytes\n", p, w, "extra", p_extra.size());
        hexdump(f, 0, std::string(p)+"extra at ", p_extra);
    }
}

// DQ (26/2008): Support output of named enum values
std::string
SgAsmElfSegmentTableEntry::stringifyType(SegmentType kind) const
{
    std::string s;

    switch (kind) {
      case SgAsmElfSegmentTableEntry::PT_NULL:    s = "PT_NULL";    break; // 0
      case SgAsmElfSegmentTableEntry::PT_LOAD:    s = "PT_LOAD";    break; // 1
      case SgAsmElfSegmentTableEntry::PT_DYNAMIC: s = "PT_DYNAMIC"; break; // 2
      case SgAsmElfSegmentTableEntry::PT_INTERP:  s = "PT_INTERP";  break; // 3
      case SgAsmElfSegmentTableEntry::PT_NOTE:    s = "PT_NOTE";    break; // 4
      case SgAsmElfSegmentTableEntry::PT_SHLIB:   s = "PT_SHLIB";   break; // 5
      case SgAsmElfSegmentTableEntry::PT_PHDR:    s = "PT_PHDR";    break; // 6

      // DQ (10/31/2008): Added mising enum values to prevent run-time warnings
      /* OS- and Processor-specific ranges */
      case SgAsmElfSegmentTableEntry::PT_LOOS: s = "PT_LOOS";  break; // 0x60000000, Values reserved for OS-specific semantics
      case SgAsmElfSegmentTableEntry::PT_HIOS: s = "PT_HIOS";  break; // 0x6fffffff,

      /* Values reserved for processor-specific semantics */
      case SgAsmElfSegmentTableEntry::PT_LOPROC: s = "PT_LOPROC";  break;
      case SgAsmElfSegmentTableEntry::PT_HIPROC: s = "PT_HIPROC";  break;

      /* OS-specific values for GNU/Linux */
      case SgAsmElfSegmentTableEntry::PT_GNU_EH_FRAME: s = "PT_GNU_EH_FRAME"; break; // 0x6474e550 GCC .eh_frame_hdr segment
      case SgAsmElfSegmentTableEntry::PT_GNU_STACK:    s = "PT_GNU_STACK";    break; // 0x6474e551 Indicates stack executability */
      case SgAsmElfSegmentTableEntry::PT_GNU_RELRO:    s = "PT_GNU_RELRO";    break; // 0x6474e552 Read-only after relocation */
      case SgAsmElfSegmentTableEntry::PT_PAX_FLAGS:    s = "PT_PAX_FLAGS";    break; // 0x65041580 Indicates PaX flag markings */

      /* OS-specific values for Sun */
      case SgAsmElfSegmentTableEntry::PT_SUNWBSS:      s = "PT_SUNWBSS";   break; // 0x6ffffffa Sun Specific segment */
      case SgAsmElfSegmentTableEntry::PT_SUNWSTACK:    s = "PT_SUNWSTACK"; break; // 0x6ffffffb Stack segment */

      default:
      {
          s = "error";

          // DQ (8/29/2008): This case is exercised frequently, I think it warrants only a warning, instead of an error.
          printf ("Warning: default reached for SgAsmElfSegmentTableEntry::stringifyType = 0x%x \n",kind);
      }
    }
    return s;
}

/** Non-parsing constructor for an ELF Segment (Program Header) Table */
void
SgAsmElfSegmentTable::ctor()
{
    /* There can be only one ELF Segment Table */
    SgAsmElfFileHeader *fhdr = dynamic_cast<SgAsmElfFileHeader*>(get_header());
    ROSE_ASSERT(fhdr);
    ROSE_ASSERT(fhdr->get_segment_table()==NULL);
    fhdr->set_segment_table(this);
    
    set_synthesized(true);                              /* the segment table isn't part of any explicit section */
    set_name(new SgAsmBasicString("ELF Segment Table"));
    set_purpose(SP_HEADER);

    fhdr->set_segment_table(this);
}

/** Parses an ELF Segment (Program Header) Table and constructs and parses all segments reachable from the table. The section
 *  is extended as necessary based on the number of entries and teh size of each entry. */
SgAsmElfSegmentTable *
SgAsmElfSegmentTable::parse()
{
    SgAsmGenericSection::parse();

    SgAsmElfFileHeader *fhdr = dynamic_cast<SgAsmElfFileHeader*>(get_header());
    ROSE_ASSERT(fhdr!=NULL);
    ByteOrder sex = fhdr->get_sex();

    size_t ent_size, struct_size, opt_size, nentries;
    calculate_sizes(&ent_size, &struct_size, &opt_size, &nentries);
    ROSE_ASSERT(opt_size==fhdr->get_phextrasz() && nentries==fhdr->get_e_phnum());

    /* If the current size is very small (0 or 1 byte) then we're coming straight from the constructor and the parsing should
     * also extend this section to hold all the entries. Otherwise the caller must have assigned a specific size for a good
     * reason and we should leave that alone, reading zeros if the entries extend beyond the defined size. */
    if (get_size()<=1 && get_size()<nentries*ent_size)
        extend(nentries*ent_size - get_size());
    
    addr_t offset=0;                                /* w.r.t. the beginning of this section */
    for (size_t i=0; i<nentries; i++, offset+=ent_size) {
        /* Read/decode the segment header */
        SgAsmElfSegmentTableEntry *shdr = NULL;
        if (4==fhdr->get_word_size()) {
            SgAsmElfSegmentTableEntry::Elf32SegmentTableEntry_disk disk;
            read_content_local(offset, &disk, struct_size);
            shdr = new SgAsmElfSegmentTableEntry(sex, &disk);
        } else {
            SgAsmElfSegmentTableEntry::Elf64SegmentTableEntry_disk disk;
            read_content_local(offset, &disk, struct_size);
            shdr = new SgAsmElfSegmentTableEntry(sex, &disk);
        }
        shdr->set_index(i);
        if (opt_size>0)
            shdr->get_extra() = read_content_local_ucl(offset+struct_size, opt_size);

        /* Null segments are just unused slots in the table; no real section to create */
        if (SgAsmElfSegmentTableEntry::PT_NULL == shdr->get_type())
            continue;

        /* Create SgAsmElfSection objects for each ELF Segment. However, if the ELF Segment Table describes a segment
         * that's the same offset and size as a section from the Elf Section Table (and the memory mappings are
         * consistent) then use the preexisting section instead of creating a new one. */
        SgAsmElfSection *s = NULL;
        SgAsmGenericSectionPtrList possible = fhdr->get_file()->get_sections_by_offset(shdr->get_offset(), shdr->get_filesz());
        for (size_t j=0; !s && j<possible.size(); j++) {
            if (possible[j]->get_offset()!=shdr->get_offset() || possible[j]->get_size()!=shdr->get_filesz())
                continue; /*different file extent*/
            if (possible[j]->is_mapped()) {
                if (possible[j]->get_mapped_preferred_rva()!=shdr->get_vaddr() ||
                    possible[j]->get_mapped_size()!=shdr->get_memsz())
                    continue; /*different mapped address or size*/
                unsigned section_perms = (possible[j]->get_mapped_rperm() ? 0x01 : 0x00) |
                                         (possible[j]->get_mapped_wperm() ? 0x02 : 0x00) |
                                         (possible[j]->get_mapped_xperm() ? 0x04 : 0x00);
                unsigned segment_perms = (shdr->get_flags() & SgAsmElfSegmentTableEntry::PF_RPERM ? 0x01 : 0x00) |
                                         (shdr->get_flags() & SgAsmElfSegmentTableEntry::PF_WPERM ? 0x02 : 0x00) |
                                         (shdr->get_flags() & SgAsmElfSegmentTableEntry::PF_XPERM ? 0x04 : 0x00);
                if (section_perms != segment_perms)
                    continue; /*different mapped permissions*/
            }

            /* Found a match. Set memory mapping params only. */
            s = dynamic_cast<SgAsmElfSection*>(possible[j]);
            if (!s) continue; /*potential match was not from the ELF Section or Segment table*/
            if (s->get_segment_entry()) continue; /*potential match is assigned to some other segment table entry*/
            s->init_from_segment_table(shdr, true); /*true=>set memory mapping params only*/
        }

        /* Create a new segment if no matching section was found. */
        if (!s) {
            if (SgAsmElfSegmentTableEntry::PT_NOTE == shdr->get_type()) {
                s = new SgAsmElfNoteSection(fhdr);
            } else {
                s = new SgAsmElfSection(fhdr);
            }
            s->init_from_segment_table(shdr);
            s->parse();
        }
    }
    return this;
}

/** Attaches a previously unattached ELF Segment (SgAsmElfSection) to the ELF Segment Table (SgAsmElfSegmentTable). This
 *  method complements SgAsmElfSection::init_from_segment_table. This method initializes the segment table from the segment
 *  while init_from_segment_table() initializes the segment from the segment table.
 *  
 *  ELF Segments are represented by SgAsmElfSection objects since ELF Segments and ELF Sections overlap very much in their
 *  features and thus should share an interface. An SgAsmElfSection can appear in the ELF Section Table and/or the ELF Segment
 *  Table and you can determine where it was located by calling get_section_entry() and get_segment_entry(). */
void
SgAsmElfSegmentTable::add_section(SgAsmElfSection *section)
{
    ROSE_ASSERT(section!=NULL);
    ROSE_ASSERT(section->get_file()==get_file());
    ROSE_ASSERT(section->get_header()==get_header());
    ROSE_ASSERT(section->get_segment_entry()==NULL);            /* must not be in the segment table yet */

    SgAsmElfFileHeader *fhdr = dynamic_cast<SgAsmElfFileHeader*>(get_header());
    ROSE_ASSERT(fhdr);
    
    /* Assign a slot in the segment table */
    int idx = fhdr->get_e_phnum();
    fhdr->set_e_phnum(idx+1);

    /* Create a new segment table entry */
    SgAsmElfSegmentTableEntry *shdr = new SgAsmElfSegmentTableEntry;
    shdr->set_index(idx);
    shdr->update_from_section(section);
    section->set_segment_entry(shdr);
}

/* Returns info about the size of the entries based on information already available. Any or all arguments may be null
 * pointers if the caller is not interested in the value. */
rose_addr_t
SgAsmElfSegmentTable::calculate_sizes(size_t *entsize, size_t *required, size_t *optional, size_t *entcount) const
{
    SgAsmElfFileHeader *fhdr = dynamic_cast<SgAsmElfFileHeader*>(get_header());
    ROSE_ASSERT(fhdr!=NULL);

    size_t struct_size = 0;
    size_t extra_size = fhdr->get_phextrasz();
    size_t entry_size = 0;
    size_t nentries = 0;

    /* Size of required part of each entry */
    if (4==fhdr->get_word_size()) {
        struct_size = sizeof(SgAsmElfSegmentTableEntry::Elf32SegmentTableEntry_disk);
    } else if (8==fhdr->get_word_size()) {
        struct_size = sizeof(SgAsmElfSegmentTableEntry::Elf64SegmentTableEntry_disk);
    } else {
        throw FormatError("bad ELF word size");
    }

    /* Entire entry should be at least large enough for the required part. */
    entry_size = struct_size;

    /* Size of optional parts. If we've parsed the table then use the largest optional part, otherwise assume the entry from
     * the ELF File Header is correct. */
    SgAsmGenericSectionPtrList sections = fhdr->get_sections()->get_sections();
    for (size_t i=0; i<sections.size(); i++) {
        SgAsmElfSection *elfsec = dynamic_cast<SgAsmElfSection*>(sections[i]);
        if (elfsec && elfsec->get_segment_entry()) {
            nentries++;
            extra_size = std::max(extra_size, elfsec->get_segment_entry()->get_extra().size());
        }
    }

    /* Total number of entries. Either we haven't parsed the segment table yet (nor created the segments it defines) or we
     * have. In the former case we use the setting from the ELF File Header, otherwise we just count the number of segments
     * that have associated segment table entry pointers. */
    if (0==nentries)
        nentries = fhdr->get_e_phnum();

    /* Return values */
    if (entsize)
        *entsize = entry_size;
    if (required)
        *required = struct_size;
    if (optional)
        *optional = extra_size;
    if (entcount)
        *entcount = nentries;
    return entry_size * nentries;
}

/* Pre-unparsing updates */
bool
SgAsmElfSegmentTable::reallocate()
{
    bool reallocated = false;

    /* Resize based on word size from ELF File Header */
    size_t opt_size, nentries;
    addr_t need = calculate_sizes(NULL, NULL, &opt_size, &nentries);
    if (need < get_size()) {
        if (is_mapped()) {
            ROSE_ASSERT(get_mapped_size()==get_size());
            set_mapped_size(need);
        }
        set_size(need);
        reallocated = true;
    } else if (need > get_size()) {
        get_file()->shift_extend(this, 0, need-get_size(), SgAsmGenericFile::ADDRSP_ALL, SgAsmGenericFile::ELASTIC_HOLE);
        reallocated = true;
    }

    /* Update data members in the ELF File Header. No need to return true for these changes. */
    SgAsmElfFileHeader *fhdr = dynamic_cast<SgAsmElfFileHeader*>(get_header());
    fhdr->set_phextrasz(opt_size);
    fhdr->set_e_phnum(nentries);

    return reallocated;
}

/* Write the segment table to disk. */
void
SgAsmElfSegmentTable::unparse(std::ostream &f) const
{
    SgAsmElfFileHeader *fhdr = dynamic_cast<SgAsmElfFileHeader*>(get_header());
    ROSE_ASSERT(fhdr!=NULL);
    ByteOrder sex = fhdr->get_sex();
    SgAsmGenericSectionPtrList sections = fhdr->get_segtab_sections();

    /* Write the segments first */
    for (size_t i=0; i<sections.size(); i++)
        sections[i]->unparse(f);
    unparse_holes(f);

    /* Calculate sizes. The ELF File Header should have been updated in reallocate() prior to unparsing. */
    size_t ent_size, struct_size, opt_size, nentries;
    calculate_sizes(&ent_size, &struct_size, &opt_size, &nentries);
    ROSE_ASSERT(fhdr->get_phextrasz()==opt_size);
    ROSE_ASSERT(fhdr->get_e_phnum()==nentries);
    
    /* Write the segment table entries */
    for (size_t i=0; i < sections.size(); ++i) {
        SgAsmElfSection *section = dynamic_cast<SgAsmElfSection*>(sections[i]);
        ROSE_ASSERT(section!=NULL);
        SgAsmElfSegmentTableEntry *shdr = section->get_segment_entry();
        ROSE_ASSERT(shdr!=NULL);
        ROSE_ASSERT(shdr->get_offset()==section->get_offset()); /*segment table entry should have been updated in reallocate()*/

        int id = shdr->get_index();
        ROSE_ASSERT(id>=0 && (size_t)id<nentries);
            
        SgAsmElfSegmentTableEntry::Elf32SegmentTableEntry_disk disk32;
        SgAsmElfSegmentTableEntry::Elf64SegmentTableEntry_disk disk64;
        void *disk = NULL;
        
        if (4==fhdr->get_word_size()) {
            disk = shdr->encode(sex, &disk32);
        } else if (8==fhdr->get_word_size()) {
            disk = shdr->encode(sex, &disk64);
        } else {
            ROSE_ASSERT(!"invalid word size");
        }
        
        /* The disk struct */
        addr_t spos = write(f, id*ent_size, struct_size, disk);
        if (shdr->get_extra().size() > 0)
            write(f, spos, shdr->get_extra());
    }
}

/* Print some debugging info */
void
SgAsmElfSegmentTable::dump(FILE *f, const char *prefix, ssize_t idx) const
{
    char p[4096];
    if (idx>=0) {
        sprintf(p, "%sSegmentTable[%zd].", prefix, idx);
    } else {
        sprintf(p, "%sSegmentTable.", prefix);
    }

    SgAsmGenericSection::dump(f, p, -1);

    if (variantT() == V_SgAsmElfSegmentTable) //unless a base class
        hexdump(f, 0, std::string(p)+"data at ", p_data);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Relocation (Rel and Rela)
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/** Constructor adds the new entry to the relocation table. */
void
SgAsmElfRelocEntry::ctor(SgAsmElfRelocSection *section)
{
    ROSE_ASSERT(section->get_entries()!=NULL);
    section->get_entries()->get_entries().push_back(this);
    ROSE_ASSERT(section->get_entries()->get_entries().size()>0);
    set_parent(section->get_entries());
}

/* Parsers */
void
SgAsmElfRelocEntry::parse(ByteOrder sex, const Elf32RelaEntry_disk *disk)
{
    p_r_offset    = disk_to_host(sex, disk->r_offset);
    p_r_addend    = disk_to_host(sex, disk->r_addend);
    uint64_t info = disk_to_host(sex, disk->r_info);
    p_sym = info >> 8;
    p_type = info & 0xff;
}
void
SgAsmElfRelocEntry::parse(ByteOrder sex, const Elf64RelaEntry_disk *disk)
{
    p_r_offset    = disk_to_host(sex, disk->r_offset);
    p_r_addend    = disk_to_host(sex, disk->r_addend);
    uint64_t info = disk_to_host(sex, disk->r_info);
    p_sym = info >> 32;
    p_type = info & 0xffffffff;
}
void
SgAsmElfRelocEntry::parse(ByteOrder sex, const Elf32RelEntry_disk *disk)
{
    p_r_offset    = disk_to_host(sex, disk->r_offset);
    p_r_addend    = 0;
    uint64_t info = disk_to_host(sex, disk->r_info);
    p_sym = info >> 8;
    p_type = info & 0xff;
}
void
SgAsmElfRelocEntry::parse(ByteOrder sex, const Elf64RelEntry_disk *disk)
{
    p_r_offset    = disk_to_host(sex, disk->r_offset);
    p_r_addend    = 0;
    uint64_t info = disk_to_host(sex, disk->r_info);
    p_sym = info >> 32;
    p_type = info & 0xffffffff;
}

/* Encode a native entry back into disk format */
void *
SgAsmElfRelocEntry::encode(ByteOrder sex, Elf32RelaEntry_disk *disk) const
{
    host_to_disk(sex, p_r_offset, &(disk->r_offset));
    host_to_disk(sex, p_r_addend, &(disk->r_addend));
    uint64_t info = (p_sym<<8) | (p_type & 0xff);
    host_to_disk(sex, info, &(disk->r_info));
    return disk;
}
void *
SgAsmElfRelocEntry::encode(ByteOrder sex, Elf64RelaEntry_disk *disk) const
{
    host_to_disk(sex, p_r_offset, &(disk->r_offset));
    host_to_disk(sex, p_r_addend, &(disk->r_addend));
    uint64_t info = ((uint64_t)p_sym<<32) | (p_type & 0xffffffff);
    host_to_disk(sex, info, &(disk->r_info));
    return disk;
}
void *
SgAsmElfRelocEntry::encode(ByteOrder sex, Elf32RelEntry_disk *disk) const
{
    host_to_disk(sex, p_r_offset, &(disk->r_offset));
    ROSE_ASSERT(0==p_r_addend);
    uint64_t info = (p_sym<<8) | (p_type & 0xff);
    host_to_disk(sex, info, &(disk->r_info));
    return disk;
}
void *
SgAsmElfRelocEntry::encode(ByteOrder sex, Elf64RelEntry_disk *disk) const
{
    host_to_disk(sex, p_r_offset, &(disk->r_offset));
    ROSE_ASSERT(0==p_r_addend);
    uint64_t info = ((uint64_t)p_sym<<32) | (p_type & 0xffffffff);
    host_to_disk(sex, info, &(disk->r_info));
    return disk;
}

/* Print some debugging info */
void
SgAsmElfRelocEntry::dump(FILE *f, const char *prefix, ssize_t idx, SgAsmElfSymbolSection *symtab) const
{
    char p[4096];
    if (idx>=0) {
        sprintf(p, "%sElfRelocEntry[%zd]", prefix, idx);
    } else {
        sprintf(p, "%sElfRelocEntry", prefix);
    }
    const int w = std::max(1, DUMP_FIELD_WIDTH-(int)strlen(p));

    /* compact one-line-per-reloc format */
    if (0==idx)
        fprintf(f, "%s%-*s   %-10s %-4s %-10s %4s %-10s Name + Addend\n", p, w, "", "Offset", "Type", "Addend", "Sym", "Value");
    fprintf(f, "%s%-*s = 0x%08"PRIx64" 0x%02lx 0x%08"PRIx64" %4lu", p, w, "", p_r_offset, p_type, p_r_addend, p_sym);
    if (!symtab) {
        fprintf(f, " 0x%08x <no-symtab>", 0);
    } else if (p_sym>=symtab->get_symbols()->get_symbols().size()) {
        fprintf(f, " 0x%08x <range>", 0);
    } else {
        SgAsmGenericSymbol *sym = symtab->get_symbols()->get_symbols()[p_sym];
        fprintf(f, " 0x%08"PRIx64" %s", sym->get_value(), sym->get_name()->c_str());
    }
    fprintf(f, " + %"PRIu64"\n", p_r_addend);
    if (p_extra.size()>0) {
        fprintf(f, "%s%-*s = %zu bytes\n", p, w, ".extra", p_extra.size());
        hexdump(f, 0, std::string(p)+"extra at ", p_extra);
    }
}

/* Non-parsing constructor */
void
SgAsmElfRelocSection::ctor(SgAsmElfSymbolSection *symbols)
{
    p_entries = new SgAsmElfRelocEntryList;
    p_entries->set_parent(this);
    ROSE_ASSERT(symbols!=NULL);
    p_linked_section = symbols;
}

/* Parse an existing ELF Rela Section */
SgAsmElfRelocSection *
SgAsmElfRelocSection::parse()
{
    SgAsmElfSection::parse();

    SgAsmElfFileHeader *fhdr = get_elf_header();
    ROSE_ASSERT(fhdr);

    size_t entry_size, struct_size, extra_size, nentries;
    calculate_sizes(&entry_size, &struct_size, &extra_size, &nentries);
    ROSE_ASSERT(extra_size==0);
    
    /* Parse each entry */
    for (size_t i=0; i<nentries; i++) {
        SgAsmElfRelocEntry *entry = 0;
        if (4==fhdr->get_word_size()) {
            if (p_uses_addend) {
                SgAsmElfRelocEntry::Elf32RelaEntry_disk disk;
                read_content_local(i*entry_size, &disk, struct_size);
                entry = new SgAsmElfRelocEntry(this);
                entry->parse(fhdr->get_sex(), &disk);
            } else {
                SgAsmElfRelocEntry::Elf32RelEntry_disk disk;
                read_content_local(i*entry_size, &disk, struct_size);
                entry = new SgAsmElfRelocEntry(this);
                entry->parse(fhdr->get_sex(), &disk);
            }
        } else if (8==fhdr->get_word_size()) {
            if (p_uses_addend) {
                SgAsmElfRelocEntry::Elf64RelaEntry_disk disk;
                read_content_local(i*entry_size, &disk, struct_size);
                entry = new SgAsmElfRelocEntry(this);
                entry->parse(fhdr->get_sex(), &disk);
            } else {
                SgAsmElfRelocEntry::Elf64RelEntry_disk disk;
                read_content_local(i*entry_size, &disk, struct_size);
                entry = new SgAsmElfRelocEntry(this);
                entry->parse(fhdr->get_sex(), &disk);
            }
        } else {
            throw FormatError("unsupported ELF word size");
        }
        if (extra_size>0)
            entry->get_extra() = read_content_local_ucl(i*entry_size+struct_size, extra_size);
    }
    return this;
}

/* Return sizes for various parts of the table. See doc for SgAsmElfSection::calculate_sizes. */
rose_addr_t
SgAsmElfRelocSection::calculate_sizes(size_t *entsize, size_t *required, size_t *optional, size_t *entcount) const
{
    rose_addr_t retval=0;
    std::vector<size_t> extra_sizes;
    for (size_t i=0; i<p_entries->get_entries().size(); i++)
        extra_sizes.push_back(p_entries->get_entries()[i]->get_extra().size());
    if (p_uses_addend) {
        retval =  calculate_sizes(sizeof(SgAsmElfRelocEntry::Elf32RelaEntry_disk), sizeof(SgAsmElfRelocEntry::Elf64RelaEntry_disk),
                                  extra_sizes, entsize, required, optional, entcount);
    } else {
        retval =  calculate_sizes(sizeof(SgAsmElfRelocEntry::Elf32RelEntry_disk),  sizeof(SgAsmElfRelocEntry::Elf64RelEntry_disk),
                                  extra_sizes, entsize, required, optional, entcount);
    }
    return retval;
}

/* Pre-unparsing adjustments */
bool
SgAsmElfRelocSection::reallocate()
{
    bool reallocated = SgAsmElfSection::reallocate();
    
    /* Update parts of the section and segment tables not updated by superclass */
    SgAsmElfSectionTableEntry *secent = get_section_entry();
    if (secent)
        secent->set_sh_type(p_uses_addend ?
                            SgAsmElfSectionTableEntry::SHT_RELA :
                            SgAsmElfSectionTableEntry::SHT_REL);

    return reallocated;
}

/* Write section back to disk */
void
SgAsmElfRelocSection::unparse(std::ostream &f) const
{
    SgAsmElfFileHeader *fhdr = get_elf_header();
    ROSE_ASSERT(fhdr);
    ByteOrder sex = fhdr->get_sex();

    size_t entry_size, struct_size, extra_size, nentries;
    calculate_sizes(&entry_size, &struct_size, &extra_size, &nentries);

    /* Adjust the entry size stored in the ELF Section Table */
    get_section_entry()->set_sh_entsize(entry_size);

    /* Write each entry's required part followed by the optional part */
    for (size_t i=0; i<nentries; i++) {
        SgAsmElfRelocEntry::Elf32RelaEntry_disk diska32;
        SgAsmElfRelocEntry::Elf64RelaEntry_disk diska64;
        SgAsmElfRelocEntry::Elf32RelEntry_disk  disk32;
        SgAsmElfRelocEntry::Elf64RelEntry_disk  disk64;
        void *disk  = NULL;

        SgAsmElfRelocEntry *entry = p_entries->get_entries()[i];

        if (4==fhdr->get_word_size()) {
            if (p_uses_addend) {
                disk = entry->encode(sex, &diska32);
            } else {
                disk = entry->encode(sex, &disk32);
            }
        } else if (8==fhdr->get_word_size()) {
            if (p_uses_addend) {
                disk = entry->encode(sex, &diska64);
            } else {
                disk = entry->encode(sex, &disk64);
            }
        } else {
            ROSE_ASSERT(!"unsupported word size");
        }

        addr_t spos = i * entry_size;
        spos = write(f, spos, struct_size, disk);
#if 0 /*FIXME: padding not supported here yet (RPM 2008-10-13)*/
        if (entry->get_extra().size()>0) {
            ROSE_ASSERT(entry->get_extra().size()<=extra_size);
            write(f, spos, entry->get_extra());
        }
#endif
    }

    unparse_holes(f);
}

/* Print some debugging info */
void
SgAsmElfRelocSection::dump(FILE *f, const char *prefix, ssize_t idx) const
{
    char p[4096];
    if (idx>=0) {
        sprintf(p, "%sRelocSection[%zd].", prefix, idx);
    } else {
        sprintf(p, "%sRelocSection.", prefix);
    }
    const int w = std::max(1, DUMP_FIELD_WIDTH-(int)strlen(p));

    SgAsmElfSection::dump(f, p, -1);
    SgAsmElfSymbolSection *symtab = dynamic_cast<SgAsmElfSymbolSection*>(get_linked_section());
    fprintf(f, "%s%-*s = %s\n", p, w, "uses_addend", p_uses_addend ? "yes" : "no");

    for (size_t i=0; i<p_entries->get_entries().size(); i++) {
        SgAsmElfRelocEntry *ent = p_entries->get_entries()[i];
        ent->dump(f, p, i, symtab);
    }

    if (variantT() == V_SgAsmElfRelocSection) //unless a base class
        hexdump(f, 0, std::string(p)+"data at ", p_data);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Dynamic Linking
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/** Adds the newly constructed entry to the dynamic section. */
void
SgAsmElfDynamicEntry::ctor(SgAsmElfDynamicSection *dynsec)
{
    ROSE_ASSERT(dynsec!=NULL);

    set_name(NULL); /*only defined for DT_NEEDED entries; see SgAsmDynamicSection::parse*/

    ROSE_ASSERT(dynsec->get_entries()!=NULL);
    dynsec->get_entries()->get_entries().push_back(this);
    ROSE_ASSERT(dynsec->get_entries()->get_entries().size()>0);
    set_parent(dynsec->get_entries());
}

/** Initialize a dynamic section entry by parsing something stored in the file. */
void
SgAsmElfDynamicEntry::parse(ByteOrder sex, const Elf32DynamicEntry_disk *disk)
{
    p_d_tag = (EntryType)disk_to_host(sex, disk->d_tag);
    p_d_val = disk_to_host(sex, disk->d_val);
}
void
SgAsmElfDynamicEntry::parse(ByteOrder sex, const Elf64DynamicEntry_disk *disk)
{
    p_d_tag = (EntryType)disk_to_host(sex, disk->d_tag);
    p_d_val = disk_to_host(sex, disk->d_val);
}

/* Encode a native entry back into disk format */
void *
SgAsmElfDynamicEntry::encode(ByteOrder sex, Elf32DynamicEntry_disk *disk) const
{
    host_to_disk(sex, p_d_tag, &(disk->d_tag));
    host_to_disk(sex, p_d_val.get_rva(), &(disk->d_val));
    return disk;
}
void *
SgAsmElfDynamicEntry::encode(ByteOrder sex, Elf64DynamicEntry_disk *disk) const
{
    host_to_disk(sex, p_d_tag, &(disk->d_tag));
    host_to_disk(sex, p_d_val.get_rva(), &(disk->d_val));
    return disk;
}

/* Convert Dynamic Entry Tag to a string */
const char *
SgAsmElfDynamicEntry::stringify_tag(EntryType t) const
{
    switch (t) {
      case DT_NULL:             return "DT_NULL";
      case DT_NEEDED:           return "DT_NEEDED";
      case DT_PLTRELSZ:         return "DT_PLTRELSZ";
      case DT_PLTGOT:           return "DT_PLTGOT";
      case DT_HASH:             return "DT_HASH";
      case DT_STRTAB:           return "DT_STRTAB";
      case DT_SYMTAB:           return "DT_SYMTAB";
      case DT_RELA:             return "DT_RELA";
      case DT_RELASZ:           return "DT_RELASZ";
      case DT_RELAENT:          return "DT_RELAENT";
      case DT_STRSZ:            return "DT_STRSZ";
      case DT_SYMENT:           return "DT_SYMENT";
      case DT_INIT:             return "DT_INIT";
      case DT_FINI:             return "DT_FINI";
      case DT_SONAME:           return "DT_SONAME";
      case DT_RPATH:            return "DT_RPATH";
      case DT_SYMBOLIC:         return "DT_SYMBOLIC";
      case DT_REL:              return "DT_REL";
      case DT_RELSZ:            return "DT_RELSZ";
      case DT_RELENT:           return "DT_RELENT";
      case DT_PLTREL:           return "DT_PLTREL";
      case DT_DEBUG:            return "DT_DEBUG";
      case DT_TEXTREL:          return "DT_TEXTREL";
      case DT_JMPREL:           return "DT_JMPREL";
      case DT_BIND_NOW:         return "DT_BIND_NOW";
      case DT_INIT_ARRAY:       return "DT_INIT_ARRAY";
      case DT_FINI_ARRAY:       return "DT_FINI_ARRAY";
      case DT_INIT_ARRAYSZ:     return "DT_INIT_ARRAYSZ";
      case DT_FINI_ARRAYSZ:     return "DT_FINI_ARRAYSZ";
      case DT_RUNPATH:          return "DT_RUNPATH";
      case DT_FLAGS:            return "DT_FLAGS";
      case DT_PREINIT_ARRAY:    return "DT_PREINIT_ARRAY";
      case DT_PREINIT_ARRAYSZ:  return "DT_PREINIT_ARRAYSZ";
      case DT_NUM:              return "DT_NUM";
      case DT_GNU_PRELINKED:    return "DT_GNU_PRELINKED";
      case DT_GNU_CONFLICTSZ:   return "DT_GNU_CONFLICTSZ";
      case DT_GNU_LIBLISTSZ:    return "DT_GNU_LIBLISTSZ";
      case DT_CHECKSUM:         return "DT_CHECKSUM";
      case DT_PLTPADSZ:         return "DT_PLTPADSZ";
      case DT_MOVEENT:          return "DT_MOVEENT";
      case DT_MOVESZ:           return "DT_MOVESZ";
      case DT_FEATURE_1:        return "DT_FEATURE_1";
      case DT_POSFLAG_1:        return "DT_POSFLAG_1";
      case DT_SYMINSZ:          return "DT_SYMINSZ";
      case DT_SYMINENT:         return "DT_SYMINENT";
      case DT_GNU_HASH:         return "DT_GNU_HASH";
      case DT_TLSDESC_PLT:      return "DT_TLSDESC_PLT";
      case DT_TLSDESC_GOT:      return "DT_TLSDESC_GOT";
      case DT_GNU_CONFLICT:     return "DT_GNU_CONFLICT";
      case DT_GNU_LIBLIST:      return "DT_GNU_LIBLIST";
      case DT_CONFIG:           return "DT_CONFIG";
      case DT_DEPAUDIT:         return "DT_DEPAUDIT";
      case DT_AUDIT:            return "DT_AUDIT";
      case DT_PLTPAD:           return "DT_PLTPAD";
      case DT_MOVETAB:          return "DT_MOVETAB";
      case DT_SYMINFO:          return "DT_SYMINFO";
      case DT_VERSYM:           return "DT_VERSYM";
      case DT_RELACOUNT:        return "DT_RELACOUNT";
      case DT_RELCOUNT:         return "DT_RELCOUNT";
      case DT_FLAGS_1:          return "DT_FLAGS_1";
      case DT_VERDEF:           return "DT_VERDEF";
      case DT_VERDEFNUM:        return "DT_VERDEFNUM";
      case DT_VERNEED:          return "DT_VERNEED";
      case DT_VERNEEDNUM:       return "DT_VERNEEDNUM";
      case DT_AUXILIARY:        return "DT_AUXILIARY";
      case DT_FILTER:           return "DT_FILTER";

      default:
        static char s[64];
        sprintf(s, "0x%08lx", (unsigned long)t);
        return s;
    }
}

/* Set name and adjust parent */
void
SgAsmElfDynamicEntry::set_name(SgAsmGenericString *name)
{
    if (p_name)
        p_name->set_parent(NULL);
    p_name = name;
    if (p_name)
        p_name->set_parent(this);
}

/* Print some debugging info */
void
SgAsmElfDynamicEntry::dump(FILE *f, const char *prefix, ssize_t idx) const
{
    char p[4096];
    if (idx>=0) {
        sprintf(p, "%sElfDynamicEntry[%zd].", prefix, idx);
    } else {
        sprintf(p, "%sElfDynamicEntry.", prefix);
    }
    const int w = std::max(1, DUMP_FIELD_WIDTH-(int)strlen(p));

    char label[256];
    strcpy(label, stringify_tag(p_d_tag));
    for (char *s=label; *s; s++) *s = tolower(*s);

    fprintf(f, "%s%-*s = %s", p, w, label, p_d_val.to_string().c_str());
    if (p_name)
        fprintf(f, " \"%s\"", p_name->c_str());
    fputc('\n', f);

    if (p_extra.size()>0) {
        fprintf(f, "%s%-*s = %zu bytes\n", p, w, "extra", p_extra.size());
        hexdump(f, 0, std::string(p)+"extra at ", p_extra);
    }
}

/* Non-parsing constructor */
void
SgAsmElfDynamicSection::ctor(SgAsmElfStringSection *strings)
{
    p_entries = new SgAsmElfDynamicEntryList;
    p_entries->set_parent(this);
    ROSE_ASSERT(strings!=NULL);
    p_linked_section = strings;
}

/** Parse an existing section of a file in order to initialize this ELF Dynamic Section. */
SgAsmElfDynamicSection *
SgAsmElfDynamicSection::parse()
{
    SgAsmElfSection::parse();

    SgAsmElfFileHeader *fhdr = get_elf_header();
    ROSE_ASSERT(fhdr);
    SgAsmElfSectionTableEntry *shdr = get_section_entry();
    ROSE_ASSERT(shdr);
    SgAsmElfStringSection *strsec = dynamic_cast<SgAsmElfStringSection*>(get_linked_section());
    ROSE_ASSERT(strsec!=NULL);

    size_t entry_size, struct_size, extra_size, nentries;
    calculate_sizes(&entry_size, &struct_size, &extra_size, &nentries);
    ROSE_ASSERT(entry_size==shdr->get_sh_entsize());

    /* Parse each entry */
    for (size_t i=0; i<nentries; i++) {
        SgAsmElfDynamicEntry *entry=0;
        if (4==fhdr->get_word_size()) {
            entry = new SgAsmElfDynamicEntry(this);
            SgAsmElfDynamicEntry::Elf32DynamicEntry_disk disk;
            read_content_local(i*entry_size, &disk, struct_size);
            entry->parse(fhdr->get_sex(), &disk);
        } else if (8==fhdr->get_word_size()) {
            entry = new SgAsmElfDynamicEntry(this);
            SgAsmElfDynamicEntry::Elf64DynamicEntry_disk disk;
            read_content_local(i*entry_size, &disk, struct_size);
            entry->parse(fhdr->get_sex(), &disk);
        } else {
            throw FormatError("unsupported ELF word size");
        }
        if (extra_size>0)
            entry->get_extra() = read_content_local_ucl(i*entry_size+struct_size, extra_size);

        /* Set name */
        if (entry->get_d_tag()==SgAsmElfDynamicEntry::DT_NEEDED) {
            ROSE_ASSERT(entry->get_name()==NULL);
            SgAsmStoredString *name = new SgAsmStoredString(strsec->get_strtab(), entry->get_d_val().get_rva());
            entry->set_name(name);
#if 1       /* FIXME: Do we really want this stuff duplicated in the AST? [RPM 2008-12-12] */
            SgAsmStoredString *name2 = new SgAsmStoredString(strsec->get_strtab(), entry->get_d_val().get_rva());
            fhdr->add_dll(new SgAsmGenericDLL(name2));
#endif
        }
    }
    return this;
}

/* Return sizes for various parts of the table. See doc for SgAsmElfSection::calculate_sizes. */
rose_addr_t
SgAsmElfDynamicSection::calculate_sizes(size_t *entsize, size_t *required, size_t *optional, size_t *entcount) const
{
    std::vector<size_t> extra_sizes;
    for (size_t i=0; i<p_entries->get_entries().size(); i++)
        extra_sizes.push_back(p_entries->get_entries()[i]->get_extra().size());
    return calculate_sizes(sizeof(SgAsmElfDynamicEntry::Elf32DynamicEntry_disk),
                           sizeof(SgAsmElfDynamicEntry::Elf64DynamicEntry_disk),
                           extra_sizes,
                           entsize, required, optional, entcount);
}
    
/* Finish initializing the section entries. */
void
SgAsmElfDynamicSection::finish_parsing() 
{
    SgAsmElfFileHeader *fhdr = get_elf_header();
    ROSE_ASSERT(fhdr!=NULL);

    for (size_t i=0; i<p_entries->get_entries().size(); i++) {
        SgAsmElfDynamicEntry *entry = p_entries->get_entries()[i];
        switch (entry->get_d_tag()) {
          case SgAsmElfDynamicEntry::DT_NEEDED:
            break;
          case SgAsmElfDynamicEntry::DT_PLTGOT:
          case SgAsmElfDynamicEntry::DT_HASH:
          case SgAsmElfDynamicEntry::DT_STRTAB:
          case SgAsmElfDynamicEntry::DT_SYMTAB:
          case SgAsmElfDynamicEntry::DT_RELA:
          case SgAsmElfDynamicEntry::DT_INIT:
          case SgAsmElfDynamicEntry::DT_FINI:
          case SgAsmElfDynamicEntry::DT_REL:
          case SgAsmElfDynamicEntry::DT_DEBUG:
          case SgAsmElfDynamicEntry::DT_JMPREL:
          case SgAsmElfDynamicEntry::DT_INIT_ARRAY:
          case SgAsmElfDynamicEntry::DT_FINI_ARRAY:
          case SgAsmElfDynamicEntry::DT_PREINIT_ARRAY:
          case SgAsmElfDynamicEntry::DT_GNU_HASH:
          case SgAsmElfDynamicEntry::DT_TLSDESC_PLT:
          case SgAsmElfDynamicEntry::DT_TLSDESC_GOT:
          case SgAsmElfDynamicEntry::DT_GNU_CONFLICT:
          case SgAsmElfDynamicEntry::DT_GNU_LIBLIST:
          case SgAsmElfDynamicEntry::DT_CONFIG:
          case SgAsmElfDynamicEntry::DT_DEPAUDIT:
          case SgAsmElfDynamicEntry::DT_AUDIT:
          case SgAsmElfDynamicEntry::DT_PLTPAD:
          case SgAsmElfDynamicEntry::DT_MOVETAB:
          case SgAsmElfDynamicEntry::DT_SYMINFO:
          case SgAsmElfDynamicEntry::DT_VERSYM:
          case SgAsmElfDynamicEntry::DT_VERDEF:
          case SgAsmElfDynamicEntry::DT_VERNEED:
          case SgAsmElfDynamicEntry::DT_AUXILIARY:
          case SgAsmElfDynamicEntry::DT_FILTER: {
              /* d_val is relative to a section. We know that all ELF Sections (but perhaps not the ELF Segments) have been
               * created by this time. */
              ROSE_ASSERT(entry->get_d_val().get_section()==NULL);
              SgAsmGenericSectionPtrList containers = fhdr->get_sections_by_rva(entry->get_d_val().get_rva());
              SgAsmGenericSection *best = NULL;
              for (SgAsmGenericSectionPtrList::iterator i=containers.begin(); i!=containers.end(); ++i) {
                  if ((*i)->is_mapped()) {
                      if ((*i)->get_mapped_preferred_rva()==entry->get_d_val().get_rva()) {
                          best = *i;
                          break;
                      } else if (!best) {
                          best = *i;
                      } else if ((*i)->get_mapped_size() < best->get_mapped_size()) {
                          best = *i;
                      }
                  }
              }
              if (best)
                  entry->set_d_val(rose_rva_t(entry->get_d_val().get_rva(), best));
              break;
          }
          default:
            break;
        }
    }
}

/* Called prior to unparse to make things consistent. */
bool
SgAsmElfDynamicSection::reallocate()
{
    bool reallocated = SgAsmElfSection::reallocate();

    /* Update parts of the section and segment tables not updated by superclass */
    SgAsmElfSectionTableEntry *secent = get_section_entry();
    if (secent)
        secent->set_sh_type(SgAsmElfSectionTableEntry::SHT_DYNAMIC);
    SgAsmElfSegmentTableEntry *segent = get_segment_entry();
    if (segent)
        segent->set_type(SgAsmElfSegmentTableEntry::PT_DYNAMIC);

    /* Update entries with name offsets. The name should point to the string table to which the dynamic section links. */
    for (size_t i=0; i<p_entries->get_entries().size(); i++) {
        SgAsmElfDynamicEntry *entry = p_entries->get_entries()[i];
        if (entry->get_name()) {
            SgAsmElfStringSection *strsec = dynamic_cast<SgAsmElfStringSection*>(get_linked_section());
            ROSE_ASSERT(strsec);
            SgAsmStoredString *stored_string = dynamic_cast<SgAsmStoredString*>(entry->get_name());
            if (!stored_string || stored_string->get_strtab()!=strsec->get_strtab()) {
                /* Not a stored string, or stored in the wrong string table. */
                stored_string = new SgAsmStoredString(strsec->get_strtab(), entry->get_name()->get_string());
                entry->get_name()->set_string(""); /*free old storage*/
                entry->set_name(stored_string);
            }
            entry->set_d_val(entry->get_name()->get_offset());
        }
    }
    
    return reallocated;
}

/* Write the dynamic section back to disk */
void
SgAsmElfDynamicSection::unparse(std::ostream &f) const
{
    SgAsmElfFileHeader *fhdr = get_elf_header();
    ROSE_ASSERT(fhdr);
    ByteOrder sex = fhdr->get_sex();

    size_t entry_size, struct_size, extra_size, nentries;
    calculate_sizes(&entry_size, &struct_size, &extra_size, &nentries);

    /* Adjust the entry size stored in the ELF Section Table */
    get_section_entry()->set_sh_entsize(entry_size);

    /* Write each entry's required part followed by the optional part */
    for (size_t i=0; i<nentries; i++) {
        SgAsmElfDynamicEntry::Elf32DynamicEntry_disk disk32;
        SgAsmElfDynamicEntry::Elf64DynamicEntry_disk disk64;
        void *disk  = NULL;

        SgAsmElfDynamicEntry *entry = p_entries->get_entries()[i];

        if (4==fhdr->get_word_size()) {
            disk = entry->encode(sex, &disk32);
        } else if (8==fhdr->get_word_size()) {
            disk = entry->encode(sex, &disk64);
        } else {
            ROSE_ASSERT(!"unsupported word size");
        }

        addr_t spos = i * entry_size;
        spos = write(f, spos, struct_size, disk);
        if (entry->get_extra().size()>0) {
            ROSE_ASSERT(entry->get_extra().size()<=extra_size);
            write(f, spos, entry->get_extra());
        }
    }

    unparse_holes(f);
}

/* Print some debugging info */
void
SgAsmElfDynamicSection::dump(FILE *f, const char *prefix, ssize_t idx) const
{
    char p[4096];
    if (idx>=0) {
        sprintf(p, "%sDynamicSection[%zd].", prefix, idx);
    } else {
        sprintf(p, "%sDynamicSection.", prefix);
    }

    SgAsmElfSection::dump(f, p, -1);

    for (size_t i=0; i<p_entries->get_entries().size(); i++) {
        SgAsmElfDynamicEntry *ent = p_entries->get_entries()[i];
        ent->dump(f, p, i);
        dump_containing_sections(f, std::string(p)+"...", ent->get_d_val(), get_header()->get_sections()->get_sections());
    }

    if (variantT() == V_SgAsmElfDynamicSection) //unless a base class
        hexdump(f, 0, std::string(p)+"data at ", p_data);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Symbol Tables
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/** Adds the newly constructed symbol to the specified ELF Symbol Table. */
void
SgAsmElfSymbol::ctor(SgAsmElfSymbolSection *symtab)
{
    ROSE_ASSERT(symtab!=NULL);
    SgAsmElfStringSection *strsec = dynamic_cast<SgAsmElfStringSection*>(symtab->get_linked_section());
    ROSE_ASSERT(strsec!=NULL);
    
    set_name(new SgAsmStoredString(strsec->get_strtab(), 0));

    ROSE_ASSERT(symtab->get_symbols()!=NULL);
    symtab->get_symbols()->get_symbols().push_back(this);
    ROSE_ASSERT(symtab->get_symbols()->get_symbols().size()>0);
    set_parent(symtab->get_symbols());

    set_st_info(0);
    set_st_res1(0);
    set_st_shndx(0);
    set_st_size(0);
}

/** Initialize symbol by parsing a symbol table entry. An ELF String Section must be supplied in order to get the symbol name. */
void
SgAsmElfSymbol::parse(ByteOrder sex, const Elf32SymbolEntry_disk *disk)
{
    p_st_info  = disk_to_host(sex, disk->st_info);
    p_st_res1  = disk_to_host(sex, disk->st_res1);
    p_st_shndx = disk_to_host(sex, disk->st_shndx);
    p_st_size  = disk_to_host(sex, disk->st_size);

    p_value    = disk_to_host(sex, disk->st_value);
    p_size     = p_st_size;

    addr_t name_offset  = disk_to_host(sex, disk->st_name);
    get_name()->set_string(name_offset);

    parse_common();
}

/** Initialize symbol by parsing a symbol table entry. An ELF String Section must be supplied in order to get the symbol name. */
void
SgAsmElfSymbol::parse(ByteOrder sex, const Elf64SymbolEntry_disk *disk)
{
    p_st_info  = disk_to_host(sex, disk->st_info);
    p_st_res1  = disk_to_host(sex, disk->st_res1);
    p_st_shndx = disk_to_host(sex, disk->st_shndx);
    p_st_size  = disk_to_host(sex, disk->st_size);

    p_value    = disk_to_host(sex, disk->st_value);
    p_size     = p_st_size;

    addr_t name_offset  = disk_to_host(sex, disk->st_name);
    get_name()->set_string(name_offset);

    parse_common();
}

void
SgAsmElfSymbol::parse_common()
{
    /* Binding */
    switch (get_elf_binding()) {
      case STB_LOCAL:   p_binding = SYM_LOCAL;  break;
      case STB_GLOBAL:  p_binding = SYM_GLOBAL; break;
      case STB_WEAK:    p_binding = SYM_WEAK;   break;
      default:
        fprintf(stderr, "unknown elf symbol binding: %u\n", get_elf_binding());
        ROSE_ASSERT(0);
        break;
    }

    /* Type */
    switch (get_elf_type()) {
      case STT_NOTYPE:  p_type = SYM_NO_TYPE; break;
      case STT_OBJECT:  p_type = SYM_DATA;    break;
      case STT_FUNC:    p_type = SYM_FUNC;    break;
      case STT_SECTION: p_type = SYM_SECTION; break;
      case STT_FILE:    p_type = SYM_FILE;    break;
      case STT_COMMON:  p_type = SYM_COMMON;  break;
      case STT_TLS:     p_type = SYM_TLS;     break;
      default:
        fprintf(stderr, "unknown elf symbol type: %u\n", get_elf_type());
        ROSE_ASSERT(0);
        break;
    }

    /* Definition state */
    if (p_value || p_size) {
        p_def_state = SYM_DEFINED;
    } else if (p_name->get_string().size() > 0 || get_elf_type()) {
        p_def_state = SYM_TENTATIVE;
    } else {
        p_def_state = SYM_UNDEFINED;
    }
}

void
SgAsmElfSymbol::dump(FILE *f, const char *prefix, ssize_t idx) const
{
    dump(f, prefix, idx, NULL);
}

SgAsmElfSymbol::ElfSymBinding
SgAsmElfSymbol::get_elf_binding() const
{
    return (ElfSymBinding)(p_st_info >> 4);
}

SgAsmElfSymbol::ElfSymType
SgAsmElfSymbol::get_elf_type() const
{
    return (ElfSymType)(p_st_info & 0xf);
}

/* Encode a symbol into disk format */
void *
SgAsmElfSymbol::encode(ByteOrder sex, Elf32SymbolEntry_disk *disk) const
{
    addr_t st_name = p_name->get_offset();
    ROSE_ASSERT(st_name!=SgAsmGenericString::unallocated);
    host_to_disk(sex, st_name,     &(disk->st_name));
    host_to_disk(sex, p_st_info,   &(disk->st_info));
    host_to_disk(sex, p_st_res1,   &(disk->st_res1));
    host_to_disk(sex, p_st_shndx,  &(disk->st_shndx));
    host_to_disk(sex, p_st_size,   &(disk->st_size));
    host_to_disk(sex, get_value(), &(disk->st_value));
    return disk;
}
void *
SgAsmElfSymbol::encode(ByteOrder sex, Elf64SymbolEntry_disk *disk) const
{
    addr_t st_name = p_name->get_offset();
    ROSE_ASSERT(st_name!=SgAsmGenericString::unallocated);
    host_to_disk(sex, st_name,     &(disk->st_name));
    host_to_disk(sex, p_st_info,   &(disk->st_info));
    host_to_disk(sex, p_st_res1,   &(disk->st_res1));
    host_to_disk(sex, p_st_shndx,  &(disk->st_shndx));
    host_to_disk(sex, p_st_size,   &(disk->st_size));
    host_to_disk(sex, get_value(), &(disk->st_value));
    return disk;
}

/* Print some debugging info. The 'section' is an optional section pointer for the st_shndx member. */
void
SgAsmElfSymbol::dump(FILE *f, const char *prefix, ssize_t idx, SgAsmGenericSection *section) const
{
    char p[4096];
    if (idx>=0) {
        sprintf(p, "%sElfSymbol[%zd].", prefix, idx);
    } else {
        sprintf(p, "%sElfSymbol.", prefix);
    }
    const int w = std::max(1, DUMP_FIELD_WIDTH-(int)strlen(p));
    const char *s;
    char sbuf[256];

    SgAsmGenericSymbol::dump(f, p, -1);

    fprintf(f, "%s%-*s = %u (",          p, w, "st_info",  p_st_info);
    switch (get_elf_binding()) {
      case STB_LOCAL:  s = "local";  break;
      case STB_GLOBAL: s = "global"; break;
      case STB_WEAK:   s = "weak";   break;
      default:
        sprintf(sbuf, "binding-%d", get_elf_binding());
        s = sbuf;
        break;
    }
    fputs(s, f);
    switch (get_elf_type()) {
      case STT_NOTYPE:  s = " no-type";   break;
      case STT_OBJECT:  s = " object";    break;
      case STT_FUNC:    s = " function";  break;
      case STT_SECTION: s = " section";   break;
      case STT_FILE:    s = " file";      break;
      default:
        sprintf(sbuf, " type-%d", get_elf_type());
        s = sbuf;
        break;
    }
    fputs(s, f);
    fputs(")\n", f);

    fprintf(f, "%s%-*s = %u\n",         p, w, "st_res1", p_st_res1);
    fprintf(f, "%s%-*s = %"PRIu64"\n",  p, w, "st_size", p_st_size);

    if (section && section->get_id() == (int)p_st_shndx) {
        fprintf(f, "%s%-*s = [%d] \"%s\"\n", p, w, "st_shndx", section->get_id(), section->get_name()->c_str());
    } else {
        fprintf(f, "%s%-*s = %u\n",         p, w, "st_shndx", p_st_shndx);        
    }

    if (p_extra.size()>0) {
        fprintf(f, "%s%-*s = %zu bytes\n", p, w, "extra", p_extra.size());
        hexdump(f, 0, std::string(p)+"extra at ", p_extra);
    }
}

/* Non-parsing constructor */
void
SgAsmElfSymbolSection::ctor(SgAsmElfStringSection *strings)
{
    p_symbols = new SgAsmElfSymbolList;
    p_symbols->set_parent(this);
    ROSE_ASSERT(strings!=NULL);
    p_linked_section = strings;
}

/** Initializes this ELF Symbol Section by parsing a file. */
SgAsmElfSymbolSection *
SgAsmElfSymbolSection::parse()
{
    SgAsmElfSection::parse();

    SgAsmElfFileHeader *fhdr = get_elf_header();
    ROSE_ASSERT(fhdr!=NULL);
    SgAsmElfSectionTableEntry *shdr = get_section_entry();
    ROSE_ASSERT(shdr!=NULL);
    SgAsmElfStringSection *strsec = dynamic_cast<SgAsmElfStringSection*>(get_linked_section());
    ROSE_ASSERT(strsec!=NULL);

    size_t entry_size, struct_size, extra_size, nentries;
    calculate_sizes(&entry_size, &struct_size, &extra_size, &nentries);
    ROSE_ASSERT(entry_size==shdr->get_sh_entsize());

    /* Parse each entry */
    for (size_t i=0; i<nentries; i++) {
        SgAsmElfSymbol *entry=0;
        if (4==fhdr->get_word_size()) {
            entry = new SgAsmElfSymbol(this); /*adds symbol to this symbol table*/
            SgAsmElfSymbol::Elf32SymbolEntry_disk disk;
            read_content_local(i*entry_size, &disk, struct_size);
            entry->parse(fhdr->get_sex(), &disk);
        } else if (8==fhdr->get_word_size()) {
            entry = new SgAsmElfSymbol(this); /*adds symbol to this symbol table*/
            SgAsmElfSymbol::Elf64SymbolEntry_disk disk;
            read_content_local(i*entry_size, &disk, struct_size);
            entry->parse(fhdr->get_sex(), &disk);
        } else {
            throw FormatError("unsupported ELF word size");
        }
        if (extra_size>0)
            entry->get_extra() = read_content_local_ucl(i*entry_size+struct_size, extra_size);
    }
    return this;
}

/* Return sizes for various parts of the table. See doc for SgAsmElfSection::calculate_sizes. */
rose_addr_t
SgAsmElfSymbolSection::calculate_sizes(size_t *entsize, size_t *required, size_t *optional, size_t *entcount) const
{
    std::vector<size_t> extra_sizes;
    for (size_t i=0; i<p_symbols->get_symbols().size(); i++)
        extra_sizes.push_back(p_symbols->get_symbols()[i]->get_extra().size());
    return calculate_sizes(sizeof(SgAsmElfSymbol::Elf32SymbolEntry_disk),
                           sizeof(SgAsmElfSymbol::Elf64SymbolEntry_disk),
                           extra_sizes,
                           entsize, required, optional, entcount);
}

/* Update section pointers for locally-bound symbols since we know that the section table has been read and all
 * non-synthesized sections have been created.
 * 
 * The st_shndx is the index (ID) of the section to which the symbol is bound. Special values are:
 *   0x0000        no section (section table entry zero should be all zeros anyway)
 *   0xff00-0xffff reserved values, not an index
 *   0xff00-0xff1f processor specific values
 *   0xfff1        symbol has absolute value not affected by relocation
 *   0xfff2        symbol is fortran common or unallocated C extern */
void
SgAsmElfSymbolSection::finish_parsing()
{
    for (size_t i=0; i < p_symbols->get_symbols().size(); i++) {
        SgAsmElfSymbol *symbol = p_symbols->get_symbols()[i];

        /* Get bound section ptr */
        if (symbol->get_st_shndx() > 0 && symbol->get_st_shndx() < 0xff00) {
            SgAsmGenericSection *bound = get_file()->get_section_by_id(symbol->get_st_shndx());
            ROSE_ASSERT(bound != NULL);
            symbol->set_bound(bound);
        }
    }
}

/* Given a symbol, return its index in this symbol table. */
size_t
SgAsmElfSymbolSection::index_of(SgAsmElfSymbol *symbol)
{
    for (size_t i=0; i<p_symbols->get_symbols().size(); i++) {
        if (p_symbols->get_symbols()[i]==symbol)
            return i;
    }
    throw FormatError("symbol is not in symbol table");
}

/* Called prior to unparsing. Updates symbol entries with name offsets */
bool
SgAsmElfSymbolSection::reallocate()
{
    bool reallocated = SgAsmElfSection::reallocate();

    /* Update parts of the section and segment tables not updated by superclass */
    SgAsmElfSectionTableEntry *secent = get_section_entry();
    if (secent)
        secent->set_sh_type(p_is_dynamic ?
                            SgAsmElfSectionTableEntry::SHT_DYNSYM :
                            SgAsmElfSectionTableEntry::SHT_SYMTAB);
    return reallocated;
}

/* Write symbol table sections back to disk */
void
SgAsmElfSymbolSection::unparse(std::ostream &f) const
{
    SgAsmElfFileHeader *fhdr = get_elf_header();
    ROSE_ASSERT(fhdr);
    ByteOrder sex = fhdr->get_sex();

    size_t entry_size, struct_size, extra_size, nentries;
    calculate_sizes(&entry_size, &struct_size, &extra_size, &nentries);
    
    /* Adjust the entry size stored in the ELF Section Table */
    get_section_entry()->set_sh_entsize(entry_size);

    /* Write each entry's required part followed by the optional part */
    for (size_t i=0; i<nentries; i++) {
        SgAsmElfSymbol::Elf32SymbolEntry_disk disk32;
        SgAsmElfSymbol::Elf64SymbolEntry_disk disk64;
        void *disk=NULL;

        SgAsmElfSymbol *entry = p_symbols->get_symbols()[i];
        
        if (4==fhdr->get_word_size()) {
            disk = entry->encode(sex, &disk32);
        } else if (8==fhdr->get_word_size()) {
            disk = entry->encode(sex, &disk64);
        } else {
            ROSE_ASSERT(!"unsupported word size");
        }

        addr_t spos = i * entry_size;
        spos = write(f, spos, struct_size, disk);
        if (entry->get_extra().size()>0) {
            ROSE_ASSERT(entry->get_extra().size()<=extra_size);
            write(f, spos, entry->get_extra());
        }
    }

    unparse_holes(f);
}

/* Print some debugging info */
void
SgAsmElfSymbolSection::dump(FILE *f, const char *prefix, ssize_t idx) const
{
    char p[4096];
    if (idx>=0) {
        sprintf(p, "%sElfSymbolSection[%zd].", prefix, idx);
    } else {
        sprintf(p, "%sElfSymbolSection.", prefix);
    }
    const int w = std::max(1, DUMP_FIELD_WIDTH-(int)strlen(p));

    SgAsmElfSection::dump(f, p, -1);
    fprintf(f, "%s%-*s = %s\n", p, w, "is_dynamic", p_is_dynamic ? "yes" : "no");
    fprintf(f, "%s%-*s = %zu symbols\n", p, w, "ElfSymbol.size", p_symbols->get_symbols().size());
    for (size_t i = 0; i < p_symbols->get_symbols().size(); i++) {
        SgAsmGenericSection *section = get_file()->get_section_by_id(p_symbols->get_symbols()[i]->get_st_shndx());
        p_symbols->get_symbols()[i]->dump(f, p, i, section);
    }

    if (variantT() == V_SgAsmElfSymbolSection) //unless a base class
        hexdump(f, 0, std::string(p)+"data at ", p_data);
}

/********************************************************************************************************************************
 * Error Handling Frame (.eh_frame) Section
 * See http://refspecs.freestandards.org/LSB_3.1.0/LSB-Core-generic/LSB-Core-generic/ehframechpt.html
 * Additional information can be found in the DWARF 3 documentation under "Other Debugging Information: Call Frame Information".
 ********************************************************************************************************************************/

/* Non-parsing constructor */
void
SgAsmElfEHFrameEntryCI::ctor(SgAsmElfEHFrameSection *ehframe)
{
    ROSE_ASSERT(ehframe->get_ci_entries()!=NULL);
    ehframe->get_ci_entries()->get_entries().push_back(this);
    ROSE_ASSERT(ehframe->get_ci_entries()->get_entries().size()>0);
    set_parent(ehframe->get_ci_entries());

    p_fd_entries = new SgAsmElfEHFrameEntryFDList;
    p_fd_entries->set_parent(this);
}

/* Unparse one Common Information Entry (CIE) without unparsing the Frame Description Entries (FDE) to which it points. The
 * initial length fields are not included in the result string. */
std::string
SgAsmElfEHFrameEntryCI::unparse(const SgAsmElfEHFrameSection *ehframe) const 
{
    SgAsmElfFileHeader *fhdr = ehframe->get_elf_header();
    ROSE_ASSERT(fhdr!=NULL);

    /* Allocate worst-case size for results */
    size_t worst_size = (4+
                         1+
                         get_augmentation_string().size()+1+
                         10+
                         10+
                         10+
                         get_augmentation_data_length()+
                         get_instructions().size()+
                         fhdr->get_word_size());
    unsigned char *buf = new unsigned char[worst_size];

    addr_t at = 0;
    uint32_t u32_disk;
    unsigned char u8_disk;

    /* CIE back offset (always zero) */
    u32_disk=0;
    memcpy(buf+at, &u32_disk, 4); at+=4;

    /* Version */
    u8_disk = get_version();
    memcpy(buf+at, &u8_disk, 1); at+=1;

    /* NUL-terminated Augmentation String */
    size_t sz = get_augmentation_string().size()+1;
    memcpy(buf+at, get_augmentation_string().c_str(), sz); at+=sz;

    /* Alignment factors */
    at = ehframe->write_uleb128(buf, at, get_code_alignment_factor());
    at = ehframe->write_sleb128(buf, at, get_data_alignment_factor());

    /* Augmentation data */
    at = ehframe->write_uleb128(buf, at, get_augmentation_data_length());
    std::string astr = get_augmentation_string();
    if (astr[0]=='z') {
        for (size_t i=1; i<astr.size(); i++) {
            if ('L'==astr[i]) {
                u8_disk = get_lsda_encoding();
                buf[at++] = u8_disk;
            } else if ('P'==astr[i]) {
                u8_disk = get_prh_encoding();
                buf[at++] = u8_disk;
                switch (get_prh_encoding()) {
                  case 0x05:
                  case 0x06:
                  case 0x07:
                    buf[at++] = get_prh_arg();
                    host_to_le(get_prh_addr(), &u32_disk);
                    memcpy(buf+at, &u32_disk, 4); at+=4;
                    break;
                  case 0x09:
                    break;
                  default:
                    /* See parser */
                    fprintf(stderr, "%s:%u: unknown PRH encoding (0x%02x)\n", __FILE__, __LINE__, get_prh_encoding());
                    abort();
                }
            } else if ('R'==astr[i]) {
                u8_disk = get_addr_encoding();
                buf[at++] = u8_disk;
            } else if ('S'==astr[i]) {
                /* Signal frame; no auxilliary data */
            } else {
                ROSE_ASSERT(!"invalid .eh_frame augmentation string");
                abort();
            }
        }
    }

    /* Initial instructions */
    sz = get_instructions().size();
    if (sz>0) {
        memcpy(buf+at, &(get_instructions()[0]), sz);
        at += sz;
    }

    std::string retval((char*)buf, at);
    delete[] buf;
    return retval;
}

/* Print some debugging info */
void
SgAsmElfEHFrameEntryCI::dump(FILE *f, const char *prefix, ssize_t idx) const
{
    char p[4096];
    if (idx>=0) {
        sprintf(p, "%sCIE[%zd].", prefix, idx);
    } else {
        sprintf(p, "%sCIE.", prefix);
    }
    const int w = std::max(1, DUMP_FIELD_WIDTH-(int)strlen(p));

    fprintf(f, "%s%-*s = %d\n", p, w, "version", get_version());
    fprintf(f, "%s%-*s = \"%s\"\n", p, w, "augStr", get_augmentation_string().c_str());
    fprintf(f, "%s%-*s = %s\n", p, w, "sig_frame", get_sig_frame()?"yes":"no");
    fprintf(f, "%s%-*s = 0x%08"PRIx64" (%"PRIu64")\n", p, w, "code_align",
            get_code_alignment_factor(), get_code_alignment_factor());
    fprintf(f, "%s%-*s = 0x%08"PRIx64" (%"PRId64")\n", p, w, "data_align",
            get_data_alignment_factor(), get_data_alignment_factor());
    fprintf(f, "%s%-*s = 0x%08"PRIx64" (%"PRIu64")\n", p, w, "aug_length",
            get_augmentation_data_length(), get_augmentation_data_length());
    fprintf(f, "%s%-*s = %d\n", p, w, "lsda_encoding", get_lsda_encoding());
    fprintf(f, "%s%-*s = %d\n", p, w, "prh_encoding", get_prh_encoding());
    if (get_prh_encoding()>=0) {
        fprintf(f, "%s%-*s = 0x%02x (%u)\n", p, w, "prh_arg", get_prh_arg(), get_prh_arg());
        fprintf(f, "%s%-*s = 0x%08"PRIx64" (%"PRIu64")\n", p, w, "prh_addr", get_prh_addr(), get_prh_addr());
    }
    fprintf(f, "%s%-*s = %d\n", p, w, "addr_encoding", get_addr_encoding());
    if (get_instructions().size()>0) {
        fprintf(f, "%s%-*s = 0x%08zx (%zu) bytes\n", p, w, "instructions",
                get_instructions().size(), get_instructions().size());
        hexdump(f, 0, std::string(p)+"insns at ", get_instructions());
    }
    for (size_t i=0; i<get_fd_entries()->get_entries().size(); i++) {
        SgAsmElfEHFrameEntryFD *fde = get_fd_entries()->get_entries()[i];
        fde->dump(f, p, i);
    }
}

/* Non-parsing constructor */
void
SgAsmElfEHFrameEntryFD::ctor(SgAsmElfEHFrameEntryCI *cie)
{
    ROSE_ASSERT(cie->get_fd_entries()!=NULL);
    cie->get_fd_entries()->get_entries().push_back(this);
    ROSE_ASSERT(cie->get_fd_entries()->get_entries().size()>0);
    set_parent(cie->get_fd_entries());
}

/* Unparse the Frame Description Entry (FDE) into a string but do not include the leading length field(s) or the CIE back pointer.
 */
std::string
SgAsmElfEHFrameEntryFD::unparse(const SgAsmElfEHFrameSection *ehframe, SgAsmElfEHFrameEntryCI *cie) const
{
    SgAsmElfFileHeader *fhdr = ehframe->get_elf_header();
    ROSE_ASSERT(fhdr!=NULL);

    /* Allocate worst-case size for results */
    size_t worst_size = 8 + get_augmentation_data().size() + get_instructions().size() + fhdr->get_word_size();
    unsigned char *buf = new unsigned char[worst_size];

    size_t sz;
    addr_t at = 0;
    uint32_t u32_disk;

    /* PC Begin (begin_rva) and size */
    switch (cie->get_addr_encoding()) {
      case -1:          /* No address encoding specified */
      case 0x01:
      case 0x03:
      case 0x1b:
      {
          host_to_le(get_begin_rva().get_rva(), &u32_disk);
          memcpy(buf+at, &u32_disk, 4); at+=4;
          host_to_le(get_size(), &u32_disk);
          memcpy(buf+at, &u32_disk, 4); at+=4;
          break;
      }
      default:
        /* See parser */
        fprintf(stderr, "%s:%u: unknown FDE address encoding (0x%02x)\n", __FILE__, __LINE__, cie->get_addr_encoding());
        abort();
    }

    /* Augmentation Data */
    std::string astr = cie->get_augmentation_string();
    if (astr.size()>0 && astr[0]=='z') {
        at = ehframe->write_uleb128(buf, at, get_augmentation_data().size());
        sz = get_augmentation_data().size();
        if (sz>0) {
            memcpy(buf+at, &(get_augmentation_data()[0]), sz);
            at += sz;
        }
    }

    /* Call frame instructions */
    sz = get_instructions().size();
    if (sz>0) {
        memcpy(buf+at, &(get_instructions()[0]), sz);
        at += sz;
    }

    std::string retval((char*)buf, at);
    delete[] buf;
    return retval;
}


/* Print some debugging info */
void
SgAsmElfEHFrameEntryFD::dump(FILE *f, const char *prefix, ssize_t idx) const
{
    char p[4096];
    if (idx>=0) {
        sprintf(p, "%sFDE[%zd].", prefix, idx);
    } else {
        sprintf(p, "%sFDE.", prefix);
    }
    const int w = std::max(1, DUMP_FIELD_WIDTH-(int)strlen(p));

    fprintf(f, "%s%-*s = %s\n", p, w, "begin_rva", get_begin_rva().to_string().c_str());
    fprintf(f, "%s%-*s = 0x%08"PRIx64" (%"PRIu64") bytes\n", p, w, "size", get_size(), get_size());
    fprintf(f, "%s%-*s = 0x%08zx (%zu) bytes\n", p, w, "aug_data",
            get_augmentation_data().size(), get_augmentation_data().size());
    hexdump(f, 0, std::string(p)+"data at ", get_augmentation_data());
    fprintf(f, "%s%-*s = 0x%08zx (%zu) bytes\n", p, w, "instructions",
            get_instructions().size(), get_instructions().size());
    hexdump(f, 0, std::string(p)+"insns at ", get_instructions());
}

/* Non-parsing constructor */
void
SgAsmElfEHFrameSection::ctor()
{
    p_ci_entries = new SgAsmElfEHFrameEntryCIList;
    p_ci_entries->set_parent(this);
}

/* Initialize by parsing a file. */
SgAsmElfEHFrameSection *
SgAsmElfEHFrameSection::parse()
{
    SgAsmElfSection::parse();
    SgAsmElfFileHeader *fhdr = get_elf_header();
    ROSE_ASSERT(fhdr!=NULL);

    addr_t record_offset=0;
    std::map<addr_t, SgAsmElfEHFrameEntryCI*> cies;

    while (record_offset<get_size()) {
        addr_t at = record_offset;
        unsigned char u8_disk;
        uint32_t u32_disk;
        uint64_t u64_disk;

        /* Length or extended length */
        addr_t length_field_size = 4; /*number of bytes not counted in length*/
        read_content_local(at, &u32_disk, 4); at += 4;
        addr_t record_size = disk_to_host(fhdr->get_sex(), u32_disk);
        if (record_size==0xffffffff) {
            read_content_local(at, &u64_disk, 8); at += 8;
            record_size = disk_to_host(fhdr->get_sex(), u64_disk);
            length_field_size += 8; /*FIXME: it's not entirely clear whether ExtendedLength includes this field*/
        }
        if (0==record_size)
            break;

        /* Backward offset to CIE record, or zero if this is a CIE record. */
        read_content_local(at, &u32_disk, 4); at += 4;
        addr_t cie_back_offset = disk_to_host(fhdr->get_sex(), u32_disk);
        if (0==cie_back_offset) {
            /* This is a CIE record */
            SgAsmElfEHFrameEntryCI *cie = new SgAsmElfEHFrameEntryCI(this);
            cies[record_offset] = cie;

            /* Version */
            uint8_t cie_version;
            read_content_local(at++, &cie_version, 1);
            cie->set_version(cie_version);

            /* Augmentation String */
            std::string astr = read_content_local_str(at);
            at += astr.size() + 1;
            cie->set_augmentation_string(astr);

            /* Alignment factors */
            cie->set_code_alignment_factor(read_content_local_uleb128(&at));
            cie->set_data_alignment_factor(read_content_local_sleb128(&at));

            /* Augmentation data length. This is apparently the length of the data described by the Augmentation String plus
             * the Initial Instructions plus any padding. [RPM 2009-01-15] */
            cie->set_augmentation_data_length(read_content_local_uleb128(&at));

            /* Augmentation data. The format of the augmentation data in the CIE record is determined by reading the
             * characters of the augmentation string. */ 
            if (astr[0]=='z') {
                for (size_t i=1; i<astr.size(); i++) {
                    if ('L'==astr[i]) {
                        read_content_local(at++, &u8_disk, 1);
                        cie->set_lsda_encoding(u8_disk);
                    } else if ('P'==astr[i]) {
                        /* The first byte is an encoding method which describes the following bytes, which are the address of
                         * a Personality Routine Handler. There appears to be very little documentation about these fields. */
                        read_content_local(at++, &u8_disk, 1);
                        cie->set_prh_encoding(u8_disk);
                        switch (cie->get_prh_encoding()) {
                            case 0x05:          /* See Ubuntu 32bit /usr/bin/aptitude */
                            case 0x06:          /* See second CIE record for Gentoo-Amd64 /usr/bin/addftinfo */
                            case 0x07:          /* See first CIE record for Gentoo-Amd64 /usr/bin/addftinfo */
                                read_content_local(at++, &u8_disk, 1); /* not sure what this is; arg for __gxx_personality_v0? */
                                cie->set_prh_arg(u8_disk);
                                read_content_local(at, &u32_disk, 4); at+=4; /* address of <__gxx_personality_v0@plt> */
                                cie->set_prh_addr(le_to_host(u32_disk));
                                break;
                            case 0x09:          /* *.o file generated by gcc-4.0.x */
                                /* FIXME: Cannot find any info about this entry. Fix SgAsmElfEHFrameSection::parse() if we
                                 *        ever figure this out. [RPM 2009-09-29] */
                                break;
                            default:
                                fprintf(stderr, "%s:%u: ELF CIE 0x%08"PRIx64": unknown PRH encoding: 0x%02x\n", 
                                        __FILE__, __LINE__, get_offset()+record_offset, cie->get_prh_encoding());
                                abort();
                        }
                    } else if ('R'==astr[i]) {
                        read_content_local(at++, &u8_disk, 1);
                        cie->set_addr_encoding(u8_disk);
                    } else if ('S'==astr[i]) {
                        /* See http://lkml.indiana.edu/hypermail/linux/kernel/0602.3/1144.html and GCC PR #26208*/
                        cie->set_sig_frame(true);
                    } else {
                        fprintf(stderr, "%s:%u: ELF CIE 0x%08"PRIx64": invalid augmentation string: \"%s\"\n", 
                                __FILE__, __LINE__, get_offset()+record_offset, astr.c_str());
                        abort();
                    }
                }
            }

            /* Initial instructions. These are apparently included in the augmentation_data_length. The final instructions can
             * be zero padding (no-op instructions) to bring the record up to a multiple of the word size. */
            addr_t init_insn_size = (length_field_size + record_size) - (at - record_offset);
            cie->get_instructions() = read_content_local_ucl(at, init_insn_size);
            ROSE_ASSERT(cie->get_instructions().size()==init_insn_size);

        } else {
            /* This is a FDE record */
            addr_t cie_offset = record_offset + length_field_size - cie_back_offset;
            assert(cies.find(cie_offset)!=cies.end());
            SgAsmElfEHFrameEntryCI *cie = cies[cie_offset];
            SgAsmElfEHFrameEntryFD *fde = new SgAsmElfEHFrameEntryFD(cie);

            /* PC Begin (begin_rva) and size */
            switch (cie->get_addr_encoding()) {
              case -1:          /* No address encoding specified */
              case 0x01:
              case 0x03:
              case 0x1b:        /* Address doesn't look valid (e.g., 0xfffd74e8) but still four bytes [RPM 2008-01-16]*/
              {
                  read_content_local(at, &u32_disk, 4); at+=4;
                  fde->set_begin_rva(le_to_host(u32_disk));
                  read_content_local(at, &u32_disk, 4); at+=4;
                  fde->set_size(le_to_host(u32_disk));
                  break;
              }
              default:
                fprintf(stderr, "%s:%u: ELF CIE 0x%08"PRIx64", FDE 0x%08"PRIx64": unknown address encoding: 0x%02x\n", 
                        __FILE__, __LINE__, get_offset()+cie_offset, get_offset()+record_offset, cie->get_addr_encoding());
                abort();
            }

            /* Augmentation Data */
            std::string astring = cie->get_augmentation_string();
            if (astring.size()>0 && astring[0]=='z') {
                addr_t aug_length = read_content_local_uleb128(&at);
                fde->get_augmentation_data() = read_content_local_ucl(at, aug_length);
                at += aug_length;
                ROSE_ASSERT(fde->get_augmentation_data().size()==aug_length);
            }

            /* Call frame instructions */
            addr_t cf_insn_size = (length_field_size + record_size) - (at - record_offset);
            fde->get_instructions() = read_content_local_ucl(at, cf_insn_size);
            ROSE_ASSERT(fde->get_instructions().size()==cf_insn_size);
        }

        record_offset += length_field_size + record_size;
    }
    return this;
}

/** Return sizes for various parts of the table. See doc for SgAsmElfSection::calculate_sizes. Since EH Frame Sections are
 *  run-length encoded, we need to actually unparse the section in order to determine its size. */
rose_addr_t
SgAsmElfEHFrameSection::calculate_sizes(size_t *entsize, size_t *required, size_t *optional, size_t *entcount) const
{
    addr_t whole = unparse(NULL);
    if (entsize)
        *entsize = 0;
    if (required)
        *required = 0;
    if (optional)
        *optional = 0;
    if (entcount)
        *entcount = 0;
    return whole;
}

/* Write data to .eh_frame section */
void
SgAsmElfEHFrameSection::unparse(std::ostream &f) const
{
    unparse(&f);
}

/* Unparses the section into the optional output stream and returns the number of bytes written. If there is no output stream
 * we still go through the actions but don't write anything. This is the only way to determine the amount of memory required
 * to store the section since the section is run-length encoded. */
rose_addr_t
SgAsmElfEHFrameSection::unparse(std::ostream *fp) const
{
    SgAsmElfFileHeader *fhdr = get_elf_header();
    ROSE_ASSERT(fhdr!=NULL);

    addr_t at=0;
    uint32_t u32_disk;
    uint64_t u64_disk;

    for (size_t i=0; i<get_ci_entries()->get_entries().size(); i++) {
        addr_t last_cie_offset = at;
        SgAsmElfEHFrameEntryCI *cie = get_ci_entries()->get_entries()[i];
        std::string s = cie->unparse(this);
        if (s.size()<0xffffffff) {
            host_to_disk(fhdr->get_sex(), s.size(), &u32_disk);
            if (fp)
                write(*fp, at, 4, &u32_disk);
            at += 4;
        } else {
            u32_disk = 0xffffffff;
            if (fp)
                write(*fp, at, 4, &u32_disk);
            at += 4;
            host_to_disk(fhdr->get_sex(), s.size(), &u64_disk);
            if (fp)
                write(*fp, at, 8, &u64_disk);
            at += 8;
        }
        if (fp)
            write(*fp, at, s);
        at += s.size();

        for (size_t j=0; j<cie->get_fd_entries()->get_entries().size(); j++) {
            SgAsmElfEHFrameEntryFD *fde = cie->get_fd_entries()->get_entries()[j];
            std::string s = fde->unparse(this, cie);

            /* Record size, not counting run-length coded size field, but counting CIE back offset. */
            addr_t record_size = 4 + s.size();
            if (record_size<0xffffffff) {
                host_to_disk(fhdr->get_sex(), record_size, &u32_disk);
                if (fp)
                    write(*fp, at, 4, &u32_disk);
                at += 4;
            } else {
                u32_disk = 0xffffffff;
                if (fp)
                    write(*fp, at, 4, &u32_disk);
                at += 4;
                host_to_disk(fhdr->get_sex(), record_size, &u64_disk);
                if (fp)
                    write(*fp, at, 8, &u64_disk);
                at += 8;
            }

            /* CIE back offset. Number of bytes from the beginning of the current CIE record (including the Size fields) to
             * the beginning of the FDE record (excluding the Size fields but including the CIE back offset). */
            addr_t cie_back_offset = at - last_cie_offset;
            host_to_disk(fhdr->get_sex(), cie_back_offset, &u32_disk);
            if (fp)
                write(*fp, at, 4, &u32_disk);
            at += 4;

            /* The FDE record itself */
            if (fp)
                write(*fp, at, s);
            at += s.size();
        }
    }

    /* Write a zero length to indicate the end of the CIE list */
    u32_disk = 0;
    if (fp)
        write(*fp, at, 4, &u32_disk);
    at += 4;

    return at;
}

/* Print some debugging info */
void
SgAsmElfEHFrameSection::dump(FILE *f, const char *prefix, ssize_t idx) const
{
    char p[4096];
    if (idx>=0) {
        sprintf(p, "%sElfEHFrameSection[%zd].", prefix, idx);
    } else {
        sprintf(p, "%sElfEHFrameSection.", prefix);
    }

    SgAsmElfSection::dump(f, p, -1);
    for (size_t i=0; i<get_ci_entries()->get_entries().size(); i++) {
        SgAsmElfEHFrameEntryCI *cie = get_ci_entries()->get_entries()[i];
        cie->dump(f, p, i);
    }
}




///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Symver Symbol Versioning (gnu extension) defines .gnu.version, .gnu.version_d, .gnu.version_r
// For more information see
// Sun: http://docs.sun.com/app/docs/doc/819-0690/chapter6-54676?a=view
// LSB: http://refspecs.freestandards.org/LSB_3.1.0/LSB-Core-generic/LSB-Core-generic/symversion.html
// Redhat: http://people.redhat.com/drepper/symbol-versioning
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/** Adds the newly constructed symver Entry to the specified ELF Symver Section. */
void
SgAsmElfSymverEntry::ctor(SgAsmElfSymverSection *symver)
{
  ROSE_ASSERT(NULL != symver);
    
  ROSE_ASSERT(symver->get_entries()!=NULL);
  symver->get_entries()->get_entries().push_back(this);
  ROSE_ASSERT(symver->get_entries()->get_entries().size()>0);
  set_parent(symver->get_entries());

  set_value(0);
}

/* Print some debugging info. */
void
SgAsmElfSymverEntry::dump(FILE *f, const char *prefix, ssize_t idx) const
{
  char p[4096];
  if (idx>=0) {
    sprintf(p, "%sElfSymverEntry[%zd].", prefix, idx);
  } else {
    sprintf(p, "%sElfSymver.", prefix);
  }
  const int w = std::max(1, DUMP_FIELD_WIDTH-(int)strlen(p));
  
  /* compact one-line-per-entry format */
  if (0==idx)
    fprintf(f, "%s%-*s   %-10s\n", p, w, "", "Value");

  fprintf(f, "%s%-*s = 0x%08"PRIx64"\n", p, w, "", p_value);
}

/* Non-parsing constructor */
void
SgAsmElfSymverSection::ctor()
{
  p_entries = new SgAsmElfSymverEntryList;
  p_entries->set_parent(this);
}

/** Initializes this ELF Symver Section by parsing a file. */
SgAsmElfSymverSection *
SgAsmElfSymverSection::parse()
{
  SgAsmElfSection::parse();
  
  SgAsmElfFileHeader *fhdr = get_elf_header();
  ROSE_ASSERT(fhdr!=NULL);
  SgAsmElfSectionTableEntry *shdr = get_section_entry();
  ROSE_ASSERT(shdr!=NULL);
  
  size_t entry_size, struct_size, extra_size, nentries;
  calculate_sizes(&entry_size, &struct_size, &extra_size, &nentries);
  ROSE_ASSERT(entry_size==shdr->get_sh_entsize());
  
  /* Parse each entry */
  for (size_t i=0; i<nentries; ++i) {
    SgAsmElfSymverEntry *entry=0;
    entry = new SgAsmElfSymverEntry(this); /*adds symver to this symver table*/
    uint16_t value;
    read_content_local(i*entry_size, &value, struct_size);
    entry->set_value(disk_to_host(fhdr->get_sex(), value));
  }
  return this;
}

/* Return sizes for various parts of the table. See doc for SgAsmElfSection::calculate_sizes. */
rose_addr_t
SgAsmElfSymverSection::calculate_sizes(size_t *entsize, size_t *required, size_t *optional, size_t *entcount) const
{
  std::vector<size_t> extra_sizes;
  return calculate_sizes(sizeof(uint16_t),
			 sizeof(uint16_t),
			 extra_sizes,
			 entsize, required, optional, entcount);
}


/* Write symver table sections back to disk */
void
SgAsmElfSymverSection::unparse(std::ostream &f) const
{
  SgAsmElfFileHeader *fhdr = get_elf_header();
  ROSE_ASSERT(fhdr);
  ByteOrder sex = fhdr->get_sex();
  
  size_t entry_size, struct_size, extra_size, nentries;
  calculate_sizes(&entry_size, &struct_size, &extra_size, &nentries);

  /* Adjust the entry size stored in the ELF Section Table */
  get_section_entry()->set_sh_entsize(entry_size);
  
  /* Write each entry's required part followed by the optional part */
  for (size_t i=0; i<nentries; i++) {
    uint16_t val;
    void *disk=NULL;
    
    SgAsmElfSymverEntry *entry = p_entries->get_entries()[i];
    host_to_disk(sex,entry->get_value(),&val);

    addr_t spos = i * entry_size;
    spos = write(f, spos, struct_size, &val);
  }
    unparse_holes(f);
}

/* Print some debugging info */
void
SgAsmElfSymverSection::dump(FILE *f, const char *prefix, ssize_t idx) const
{
  char p[4096];
  if (idx>=0) {
    sprintf(p, "%sElfSymverSection[%zd].", prefix, idx);
  } else {
    sprintf(p, "%sElfSymverSection.", prefix);
  }
  const int w = std::max(1, DUMP_FIELD_WIDTH-(int)strlen(p));
  
  SgAsmElfSection::dump(f, p, -1);
  fprintf(f, "%s%-*s = %zu entries\n", p, w, "entries.size", p_entries->get_entries().size());
  for (size_t i = 0; i < p_entries->get_entries().size(); i++) {
    p_entries->get_entries()[i]->dump(f, p, i);
  }
  
  if (variantT() == V_SgAsmElfSymverSection) //unless a base class
    hexdump(f, 0, std::string(p)+"data at ", p_data);
}




void SgAsmElfSymverDefinedAux::ctor(SgAsmElfSymverDefinedEntry* entry, SgAsmElfSymverDefinedSection* symver)
{
  SgAsmElfStringSection *strsec = isSgAsmElfStringSection(symver->get_linked_section());
  ROSE_ASSERT(strsec!=NULL);
  
  set_name(new SgAsmStoredString(strsec->get_strtab(), 0));
  
  ROSE_ASSERT(NULL != entry);
  ROSE_ASSERT(NULL != entry->get_entries());
  entry->get_entries()->get_entries().push_back(this);

  set_parent(entry);
}

void SgAsmElfSymverDefinedAux::dump(FILE *f, const char *prefix, ssize_t idx) const
{
  char p[4096];
  if (idx>=0) {
    sprintf(p, "%sElfSymverDefinedAux[%zd].", prefix, idx);
  } else {
    sprintf(p, "%sElfSymverDefinedAux.", prefix);
  }
  const int w = std::max(1, DUMP_FIELD_WIDTH-(int)strlen(p));
  
  fprintf(f, "%s%-*s = %s \n", p, w, "name", get_name()->c_str());
}

/**  */
void SgAsmElfSymverDefinedAux::parse(ByteOrder sex, const ElfSymverDefinedAux_disk* disk)
{

  rose_addr_t name_offset  = disk_to_host(sex, disk->vda_name);
  get_name()->set_string(name_offset);
}

void *SgAsmElfSymverDefinedAux::encode(ByteOrder sex, ElfSymverDefinedAux_disk* disk) const
{
  addr_t name_offset = p_name->get_offset();
  ROSE_ASSERT(name_offset!=SgAsmGenericString::unallocated);
  host_to_disk(sex, name_offset, &(disk->vda_name));
  return disk;
}


/** Adds the newly constructed symver defined entry to the specified symver. */
void
SgAsmElfSymverDefinedEntry::ctor(SgAsmElfSymverDefinedSection *section)
{
  ROSE_ASSERT(NULL != section);
  
  ROSE_ASSERT(NULL != section->get_entries());
  section->get_entries()->get_entries().push_back(this);

  ROSE_ASSERT(section->get_entries()->get_entries().size()>0);
  set_parent(section->get_entries());

  p_entries = new SgAsmElfSymverDefinedAuxList;
  p_version  = 0;
  p_flags  = 0;
  p_index = 0;
  p_hash  = 0;
}

/** Initialize symbol by parsing an Entry table entry.*/
void
SgAsmElfSymverDefinedEntry::parse(ByteOrder sex, const ElfSymverDefinedEntry_disk *disk)
{
  p_version  = disk_to_host(sex, disk->vd_version);
  p_flags  = disk_to_host(sex, disk->vd_flags);
  p_index = disk_to_host(sex, disk->vd_ndx);
  p_hash  = disk_to_host(sex, disk->vd_hash);  
}

/* Encode an Entry into disk format */
void *
SgAsmElfSymverDefinedEntry::encode(ByteOrder sex, ElfSymverDefinedEntry_disk *disk) const
{
  host_to_disk(sex, p_version, &(disk->vd_version));
  host_to_disk(sex, p_flags, &(disk->vd_flags));
  host_to_disk(sex, p_index, &(disk->vd_ndx));
  host_to_disk(sex, p_hash, &(disk->vd_hash));  
  return disk;
}

/* Print some debugging info. */
void
SgAsmElfSymverDefinedEntry::dump(FILE *f, const char *prefix, ssize_t idx) const
{
  char p[4096];
  if (idx>=0) {
    sprintf(p, "%sElfSymverDefinedEntry[%zd].", prefix, idx);
  } else {
    sprintf(p, "%sElfSymverDefinedEntry.", prefix);
  }
  const int w = std::max(1, DUMP_FIELD_WIDTH-(int)strlen(p));

  /* compact one-line-per-entry format */
  if (0==idx)
    fprintf(f, "%s%-*s   %-8s %6s %10s %6s %-6s \n", p, w, "", "Version", "Index", "Hash", "Flags", "Names");
  fprintf(f,   "%s%-*s =  0x%04x  0x%04x 0x%08x 0x%04x ", p, w, "", p_version, p_index, p_hash, p_flags);

  const SgAsmElfSymverDefinedAuxPtrList &entries=get_entries()->get_entries();
  if(entries.empty()){
    fprintf(f, "<zero entries>");
  }
  for(size_t i=0; i < entries.size(); ++i){
    fprintf(f, "%s ", entries[i]->get_name()->c_str());
  }
  fprintf(f, "\n");
}

/* Non-parsing constructor */
void
SgAsmElfSymverDefinedSection::ctor(SgAsmElfStringSection *strings)
{
  p_entries = new SgAsmElfSymverDefinedEntryList;
  p_entries->set_parent(this);
  
  ROSE_ASSERT(NULL != strings);
  p_linked_section = strings;
}

/** Initializes this ELF SymverDefined Section by parsing a file. 
    The structure is nominally the following (where n is from DT_VERDEFNUM - 1 in .dynamic)
 [0]ElfSymverDefinedEntry_disk
      vd_next------------------------------------+
      vd_aux ---------------------------------+  |
      vd_cnt                                  |  |
    [0]       ElfSymverDefinedAux_disk <------+  |
                vda_next -----------------+      |
    [1]       ElfSymverDefinedAux_disk <--+      |
       ...                                       | 
    [vd_cnt-1]ElfSymverDefinedAux_disk           |
                vda_next = 0 <== null term       |
 [1]ElfSymverDefinedEntry_disk <-----------------+
    ...
 [n]ElfSymverDefinedEntry_disk
      vd_next = 0
      vd_aux
      vd_cnt
    [0]       ElfSymverDefinedAux_disk
    [1]       ElfSymverDefinedAux_disk
       ...
    [vd_cnt-1]ElfSymverDefinedAux_disk


  However, the spec doesn't specify any actual relationship to the layout of
  anything...so it could just as easily be:
  [0]ElfSymverDefinedEntry_disk ---+---+
  [1]ElfSymverDefinedEntry_disk <--+   |
  ...                                  |
  [n]ElfSymverDefinedEntry_disk -------|---+ 
                                       |   |
  [0]ElfSymverDefinedAux_disk   <------+   |
  ...                                      |
  [x]ElfSymverDefinedAux_disk   <----------+
  [.]ElfSymverDefinedAux_disk

  There is also nothing in particular that says Aux entries need to be next to each other.
  So, the code handles the most rigidly compliant case, which is to use only the offsets
  and make no assumptions about layouts.
				
  Also note the number of entries is specified in two ways - via null termination on the
   "linked list", as well as the number from the .dynamic section [DT_VERDEFNUM].
  For now, we'll support the NULL terminator, restricted by ensuring we don't exceed
  the size of the section (to keep from running away on a bad file).

  We have a similar problem w/ the number of Aux's per Entry (vd_cnt versus vda_aux=0)
  However, in this case, we respect the min of the two (i.e. we assume cnt is right, but
  if vda_aux is zero earlier than expected, we stop).

  All offsets are relative to the start of the struct they were specified in.
  i.e. 
  Entry* entry=(0x0100);
  Aux* firstAux=(0x100 + entry->vd_aux)
  Aux* secondAux=(0x100 + entry->vd_aux + firstAux->vda_next)

  Entry* secondEntry=(0x0100 + entry->vd_next);


  Because of this rather complex structure, the section itself (SgAsmElfSymverDefinedSection)
  manages all of the data related to structure (vd_next,vd_aux,vd_cnt, vda_next) - the
  subclasses can simply ignore all of that.  The section also takes care of creating
  both *Entries and *Auxes and tying them together correctly.
*/
SgAsmElfSymverDefinedSection *
SgAsmElfSymverDefinedSection::parse()
{
  SgAsmElfSection::parse();
  
  SgAsmElfFileHeader *fhdr = get_elf_header();
  ROSE_ASSERT(NULL!=fhdr);
  SgAsmElfSectionTableEntry *shdr = get_section_entry();
  ROSE_ASSERT(NULL!=shdr);
  SgAsmElfStringSection *strsec = dynamic_cast<SgAsmElfStringSection*>(get_linked_section());
  ROSE_ASSERT(NULL!=strsec);
  
  size_t struct_size=sizeof(SgAsmElfSymverDefinedEntry::ElfSymverDefinedEntry_disk);
  
  rose_addr_t entry_addr=0;

  ByteOrder sex=fhdr->get_sex();
  /* Parse each entry*/
  while (entry_addr < this->get_size()) {

    SgAsmElfSymverDefinedEntry *entry=new SgAsmElfSymverDefinedEntry(this); /*adds SymverDefinedEntry to this*/
    SgAsmElfSymverDefinedEntry::ElfSymverDefinedEntry_disk entryDisk;
    read_content_local(entry_addr, &entryDisk, sizeof(entryDisk));
    entry->parse(sex, &entryDisk);

    /* These are relative to the start of this entry - i.e. entry_addr */
    size_t num_aux = disk_to_host(sex,entryDisk.vd_cnt);
    size_t first_aux = disk_to_host(sex,entryDisk.vd_aux);
    size_t next_entry = disk_to_host(sex,entryDisk.vd_next);  
    
    rose_addr_t aux_addr=entry_addr+first_aux;
    for(size_t i=0; i < num_aux; ++i){
      SgAsmElfSymverDefinedAux *aux=new SgAsmElfSymverDefinedAux(entry,this); /*adds SymverDefinedAux to this entry*/
      SgAsmElfSymverDefinedAux::ElfSymverDefinedAux_disk auxDisk;
      read_content_local(aux_addr, &auxDisk, sizeof(auxDisk));
      aux->parse(fhdr->get_sex(), &auxDisk);
      
      size_t next_aux = disk_to_host(sex,auxDisk.vda_next);      
      if(next_aux == 0)
	break;
      aux_addr+=next_aux;
    }

    if(next_entry == 0)
      break;
    entry_addr += next_entry;
  }

  return this;
}

/* Return sizes for various parts of the table. See doc for SgAsmElfSection::calculate_sizes. */
rose_addr_t
SgAsmElfSymverDefinedSection::calculate_sizes(size_t *entsize, size_t *required, size_t *optional, size_t *entcount) const
{
  size_t struct_size = sizeof(SgAsmElfSymverDefinedEntry::ElfSymverDefinedEntry_disk);
  size_t aux_size = sizeof(SgAsmElfSymverDefinedAux::ElfSymverDefinedAux_disk);

  size_t extra_size = 0;
  size_t entry_size = 0;
  size_t nentries = get_entries()->get_entries().size();

  size_t total_size=0;
  /* Entire entry should be at least large enough for the required part. */
  entry_size = struct_size;
  
  /* Each entry has a list of 'aux' structures
   */
  const SgAsmElfSymverDefinedEntryPtrList &entries = get_entries()->get_entries();
  for (size_t i=0; i<nentries; ++i) {
    size_t numAux = entries[i]->get_entries()->get_entries().size();
    extra_size = std::max(extra_size, numAux * aux_size);
    total_size += (struct_size + (numAux* aux_size));
  }
  // Note - we could try to reach into the dynamic section for nentries
  
  /* Return values */
  if (entsize)
    *entsize = entry_size;
  if (required)
    *required = struct_size;
  if (optional)
    *optional = extra_size;
  if (entcount)
    *entcount = nentries;
  return total_size;
}


/* Write SymverDefined section back to disk 
   for more information about encoding, see SgAsmElfSymverDefinedSection::parse
*/
void
SgAsmElfSymverDefinedSection::unparse(std::ostream &f) const
{
  SgAsmElfFileHeader *fhdr = get_elf_header();
  ROSE_ASSERT(NULL != fhdr);
  ByteOrder sex = fhdr->get_sex();
  size_t nentries;
  calculate_sizes(NULL,NULL,NULL,&nentries);

  /* Adjust the entry size stored in the ELF Section Table */
  get_section_entry()->set_sh_entsize(0);// This doesn't have consistently sized entries, zero it
  
  /* Write each entry's required part followed by the optional part */
  rose_addr_t entry_addr=0;// as offset from section

  for(size_t ent=0; ent < nentries; ++ent){
    SgAsmElfSymverDefinedEntry *entry=get_entries()->get_entries()[ent];
    SgAsmElfSymverDefinedEntry::ElfSymverDefinedEntry_disk entryDisk;
    entry->encode(sex, &entryDisk);
    const size_t entry_size=sizeof(SgAsmElfSymverDefinedEntry::ElfSymverDefinedEntry_disk);
    const size_t aux_size=sizeof(SgAsmElfSymverDefinedAux::ElfSymverDefinedAux_disk);
    
    const SgAsmElfSymverDefinedAuxPtrList& auxes = entry->get_entries()->get_entries();
    size_t num_aux = auxes.size();
    size_t first_aux = entry_size;// we always stick Aux's just after Entry
    size_t next_entry = first_aux + ( num_aux * sizeof(aux_size) );
    if(nentries -1 == ent){
      next_entry=0; // final entry: next is null (0)
    }

    host_to_disk(sex,    num_aux, &entryDisk.vd_cnt);
    host_to_disk(sex,  first_aux, &entryDisk.vd_aux);
    host_to_disk(sex, next_entry, &entryDisk.vd_next);

    write(f, entry_addr, entry_size,&entryDisk);

    rose_addr_t aux_addr=entry_addr+first_aux;
    for(size_t i=0; i < num_aux; ++i){
      SgAsmElfSymverDefinedAux *aux=auxes[i];

      SgAsmElfSymverDefinedAux::ElfSymverDefinedAux_disk auxDisk;
      aux->encode(sex, &auxDisk);
      
      size_t next_aux = aux_size;// all auxes are contigious, so the next one is always just 8
      if(num_aux-1 == i){
	next_aux=0;// ... unless it is the final aux, then the next is null (0)
      }
      host_to_disk(sex,next_aux, &auxDisk.vda_next);

      write(f,aux_addr,aux_size, &auxDisk);
      aux_addr+=next_aux;
    }

    entry_addr += next_entry;
  }

  unparse_holes(f);
}

/* Print some debugging info */
void
SgAsmElfSymverDefinedSection::dump(FILE *f, const char *prefix, ssize_t idx) const
{
  char p[4096];
  if (idx>=0) {
    sprintf(p, "%sElfSymverDefinedSection[%zd].", prefix, idx);
  } else {
    sprintf(p, "%sElfSymverDefinedSection.", prefix);
  }
  const int w = std::max(1, DUMP_FIELD_WIDTH-(int)strlen(p));
  
  SgAsmElfSection::dump(f, p, -1);
  fprintf(f, "%s%-*s = %zu entries\n", p, w, "ElfSymverDefined.size", p_entries->get_entries().size());
  for (size_t i = 0; i < p_entries->get_entries().size(); i++) {
    p_entries->get_entries()[i]->dump(f, p, i);
  }
  
  if (variantT() == V_SgAsmElfSymverDefinedSection) //unless a base class
    hexdump(f, 0, std::string(p)+"data at ", p_data);
}

/** .gnu.version_r */
void SgAsmElfSymverNeededAux::ctor(SgAsmElfSymverNeededEntry* entry, SgAsmElfSymverNeededSection* symver)
{
  SgAsmElfStringSection *strsec = isSgAsmElfStringSection(symver->get_linked_section());
  ROSE_ASSERT(NULL != strsec);
  
  set_name(new SgAsmStoredString(strsec->get_strtab(), 0));
  
  ROSE_ASSERT(NULL != entry);
  ROSE_ASSERT(NULL != entry->get_entries());
  entry->get_entries()->get_entries().push_back(this);

  set_parent(entry);
  p_flags  = 0;
  p_other = 0;
  p_hash  = 0;
}

void SgAsmElfSymverNeededAux::dump(FILE *f, const char *prefix, ssize_t idx) const
{
  char p[4096];
  if (idx>=0) {
    sprintf(p, "%sElfSymverNeededAux[%zd].", prefix, idx);
  } else {
    sprintf(p, "%sElfSymverNeededAux.", prefix);
  }
  const int w = std::max(1, DUMP_FIELD_WIDTH-(int)strlen(p));
  
  fprintf(f, "%s%-*s = %s \n", p, w, "name", get_name()->c_str());
}

/**  */
void SgAsmElfSymverNeededAux::parse(ByteOrder sex, const ElfSymverNeededAux_disk* disk)
{
  p_hash = disk_to_host(sex,disk->vna_hash);
  p_flags= disk_to_host(sex,disk->vna_flags);
  p_other= disk_to_host(sex,disk->vna_other);

  rose_addr_t name_offset  = disk_to_host(sex, disk->vna_name);
  get_name()->set_string(name_offset);
}

void *SgAsmElfSymverNeededAux::encode(ByteOrder sex, ElfSymverNeededAux_disk* disk) const
{
  host_to_disk(sex,p_hash,&disk->vna_hash);
  host_to_disk(sex,p_flags,&disk->vna_flags);
  host_to_disk(sex,p_other,&disk->vna_other);

  addr_t name_offset = p_name->get_offset();
  ROSE_ASSERT(name_offset!=SgAsmGenericString::unallocated);
  host_to_disk(sex, name_offset, &(disk->vna_name));
  return disk;
}


/** Adds the newly constructed symver needed entry to the specified symver. */
void
SgAsmElfSymverNeededEntry::ctor(SgAsmElfSymverNeededSection *section)
{
  ROSE_ASSERT(NULL != section);  
  ROSE_ASSERT(NULL != section->get_entries());
  section->get_entries()->get_entries().push_back(this);

  ROSE_ASSERT(section->get_entries()->get_entries().size()>0);
  set_parent(section->get_entries());

  SgAsmElfStringSection *strsec = isSgAsmElfStringSection(section->get_linked_section());
  ROSE_ASSERT(NULL != strsec);
  
  set_file_name(new SgAsmStoredString(strsec->get_strtab(), 0));

  p_entries = new SgAsmElfSymverNeededAuxList;
  p_version  = 0;
}

/** */
void
SgAsmElfSymverNeededEntry::parse(ByteOrder sex, const ElfSymverNeededEntry_disk *disk)
{
  p_version  = disk_to_host(sex, disk->vn_version);

  rose_addr_t file_offset  = disk_to_host(sex, disk->vn_file);
  get_file_name()->set_string(file_offset);

}

/* Encode an Entry into disk format */
void *
SgAsmElfSymverNeededEntry::encode(ByteOrder sex, ElfSymverNeededEntry_disk *disk) const
{
  host_to_disk(sex, p_version, &(disk->vn_version));

  addr_t file_offset = p_file_name->get_offset();
  ROSE_ASSERT(file_offset!=SgAsmGenericString::unallocated);
  host_to_disk(sex, file_offset, &(disk->vn_file));

  return disk;
}

/* Print some debugging info. */
void
SgAsmElfSymverNeededEntry::dump(FILE *f, const char *prefix, ssize_t idx) const
{
  char p[4096];
  if (idx>=0) {
    sprintf(p, "%sElfSymverNeededEntry[%zd].", prefix, idx);
  } else {
    sprintf(p, "%sElfSymverNeededEntry.", prefix);
  }
  const int w = std::max(1, DUMP_FIELD_WIDTH-(int)strlen(p));

  /* compact one-line-per-entry format */
  if (0==idx)
    fprintf(f, "%s%-*s   %-8s %-22s %6s %10s %6s %s\n", p, w, "", "Version", "File", "Other", "Hash", "Flags", "Name");
  fprintf(f,   "%s%-*s =   0x%04x %s", p, w, "", p_version, get_file_name()->c_str());
  

  const SgAsmElfSymverNeededAuxPtrList &entries=get_entries()->get_entries();
  if(entries.empty()){
    fprintf(f, "<zero entries>\n");
  }
  else{
    fprintf(f, "\n");
  }

  for(size_t i=0; i < entries.size(); ++i){
    SgAsmElfSymverNeededAux* aux = entries[i];
    fprintf(f,   "%s%-*s =                                 0x%04x 0x%08x 0x%04x %s\n", p, w, "", 
	    aux->get_other(), aux->get_hash(), aux->get_flags(), aux->get_name()->c_str());
  }
  fprintf(f, "\n");
}

/* Non-parsing constructor */
void
SgAsmElfSymverNeededSection::ctor(SgAsmElfStringSection *strings)
{
  p_entries = new SgAsmElfSymverNeededEntryList;
  p_entries->set_parent(this);
  
  ROSE_ASSERT(NULL != strings);
  p_linked_section = strings;
}

/** 
    See SgAsmElfSymverDefinedSection::parse for information about the layout of this structure
                      -------
    They use different objects, but they basic structure is the same
*/
SgAsmElfSymverNeededSection *
SgAsmElfSymverNeededSection::parse()
{
  SgAsmElfSection::parse();
  
  SgAsmElfFileHeader *fhdr = get_elf_header();
  ROSE_ASSERT(NULL!=fhdr);
  SgAsmElfSectionTableEntry *shdr = get_section_entry();
  ROSE_ASSERT(NULL!=shdr);
  
  size_t struct_size=sizeof(SgAsmElfSymverNeededEntry::ElfSymverNeededEntry_disk);
  
  rose_addr_t entry_addr=0;

  ByteOrder sex=fhdr->get_sex();
  /* Parse each entry*/
  while (entry_addr < this->get_size()) {

    SgAsmElfSymverNeededEntry *entry=new SgAsmElfSymverNeededEntry(this); /*adds SymverNeededEntry to this*/
    SgAsmElfSymverNeededEntry::ElfSymverNeededEntry_disk entryDisk;
    read_content_local(entry_addr, &entryDisk, sizeof(entryDisk));
    entry->parse(sex, &entryDisk);

    /* These are relative to the start of this entry - i.e. entry_addr */
    size_t num_aux = disk_to_host(sex,entryDisk.vn_cnt);
    size_t first_aux = disk_to_host(sex,entryDisk.vn_aux);
    size_t next_entry = disk_to_host(sex,entryDisk.vn_next);  
    
    rose_addr_t aux_addr=entry_addr+first_aux;
    for(size_t i=0; i < num_aux; ++i){
      SgAsmElfSymverNeededAux *aux=new SgAsmElfSymverNeededAux(entry,this); /*adds SymverNeededAux to this entry*/
      SgAsmElfSymverNeededAux::ElfSymverNeededAux_disk auxDisk;
      read_content_local(aux_addr, &auxDisk, sizeof(auxDisk));
      aux->parse(sex, &auxDisk);
      
      size_t next_aux = disk_to_host(sex,auxDisk.vna_next);      
      if(next_aux == 0)
	break;
      aux_addr+=next_aux;
    }

    if(next_entry == 0)
      break;
    entry_addr += next_entry;
  }

  return this;
}

/* Return sizes for various parts of the table. See doc for SgAsmElfSection::calculate_sizes. */
rose_addr_t
SgAsmElfSymverNeededSection::calculate_sizes(size_t *entsize, size_t *required, size_t *optional, size_t *entcount) const
{
  size_t struct_size = sizeof(SgAsmElfSymverNeededEntry::ElfSymverNeededEntry_disk);
  size_t aux_size = sizeof(SgAsmElfSymverNeededAux::ElfSymverNeededAux_disk);

  size_t extra_size = 0;
  size_t entry_size = 0;
  size_t nentries = get_entries()->get_entries().size();

  size_t total_size=0;
  /* Entire entry should be at least large enough for the required part. */
  entry_size = struct_size;
  
  /* Each entry has a list of 'aux' structures
   */
  const SgAsmElfSymverNeededEntryPtrList &entries = get_entries()->get_entries();
  for (size_t i=0; i<nentries; ++i) {
    size_t numAux = entries[i]->get_entries()->get_entries().size();
    extra_size = std::max(extra_size, numAux * aux_size);
    total_size += (struct_size + (numAux* aux_size));
  }
  // Note - we could try to reach into the dynamic section for nentries
  
  /* Return values */
  if (entsize)
    *entsize = entry_size;
  if (required)
    *required = struct_size;
  if (optional)
    *optional = extra_size;
  if (entcount)
    *entcount = nentries;
  return total_size;
}


/* Write SymverNeeded section back to disk 
   for more information about encoding, see SgAsmElfSymverNeededSection::parse
*/
void
SgAsmElfSymverNeededSection::unparse(std::ostream &f) const
{
  SgAsmElfFileHeader *fhdr = get_elf_header();
  ROSE_ASSERT(NULL != fhdr);
  ByteOrder sex = fhdr->get_sex();
  size_t nentries;
  calculate_sizes(NULL,NULL,NULL,&nentries);

  /* Adjust the entry size stored in the ELF Section Table */
  get_section_entry()->set_sh_entsize(0);// This doesn't have consistently sized entries, zero it
  
  /* Write each entry's required part followed by the optional part */
  /* Parse each entry*/
  rose_addr_t entry_addr=0;// as offset from section

  for(size_t ent=0; ent < nentries; ++ent){
    SgAsmElfSymverNeededEntry *entry=get_entries()->get_entries()[ent];
    SgAsmElfSymverNeededEntry::ElfSymverNeededEntry_disk entryDisk;
    entry->encode(sex, &entryDisk);
    const size_t entry_size=sizeof(SgAsmElfSymverNeededEntry::ElfSymverNeededEntry_disk);
    const size_t aux_size=sizeof(SgAsmElfSymverNeededAux::ElfSymverNeededAux_disk);
    
    const SgAsmElfSymverNeededAuxPtrList& auxes = entry->get_entries()->get_entries();
    size_t num_aux = auxes.size();
    size_t first_aux = entry_size;// we always stick Aux's just after Entry
    size_t next_entry = first_aux + ( num_aux * sizeof(aux_size) );
    if(nentries -1 == ent){
      next_entry=0; // final entry: next is null (0)
    }

    host_to_disk(sex,    num_aux, &entryDisk.vn_cnt);
    host_to_disk(sex,  first_aux, &entryDisk.vn_aux);
    host_to_disk(sex, next_entry, &entryDisk.vn_next);

    write(f, entry_addr, entry_size,&entryDisk);

    rose_addr_t aux_addr=entry_addr+first_aux;
    for(size_t i=0; i < num_aux; ++i){
      SgAsmElfSymverNeededAux *aux=auxes[i];

      SgAsmElfSymverNeededAux::ElfSymverNeededAux_disk auxDisk;
      aux->encode(sex, &auxDisk);
      
      size_t next_aux = aux_size;// all auxes are contigious, so the next one is always just 8
      if(num_aux-1 == i){
	next_aux=0;// ... unless it is the final aux, then the next is null (0)
      }
      host_to_disk(sex,next_aux, &auxDisk.vna_next);

      write(f,aux_addr,aux_size, &auxDisk);
      aux_addr+=next_aux;
    }

    entry_addr += next_entry;
  }

  unparse_holes(f);
}

/* Print some debugging info */
void
SgAsmElfSymverNeededSection::dump(FILE *f, const char *prefix, ssize_t idx) const
{
  char p[4096];
  if (idx>=0) {
    sprintf(p, "%sElfSymverNeededSection[%zd].", prefix, idx);
  } else {
    sprintf(p, "%sElfSymverNeededSection.", prefix);
  }
  const int w = std::max(1, DUMP_FIELD_WIDTH-(int)strlen(p));
  
  SgAsmElfSection::dump(f, p, -1);
  fprintf(f, "%s%-*s = %zu entries\n", p, w, "ElfSymverNeeded.size", p_entries->get_entries().size());
  for (size_t i = 0; i < p_entries->get_entries().size(); i++) {
    p_entries->get_entries()[i]->dump(f, p, i);
  }
  
  if (variantT() == V_SgAsmElfSymverNeededSection) //unless a base class
    hexdump(f, 0, std::string(p)+"data at ", p_data);
}


/********************************************************************************************************************************
 * Note sections (PT_NOTE)
 ********************************************************************************************************************************
 */

/** Constructor adds the new note to the list of notes for the note section. */
void
SgAsmElfNoteEntry::ctor(SgAsmElfNoteSection *section)
{
    ROSE_ASSERT(section->get_entries()!=NULL);
    section->get_entries()->get_entries().push_back(this);
    ROSE_ASSERT(section->get_entries()->get_entries().size()>0);
    set_parent(section->get_entries());
}

/* Set name and adjust parent */
void
SgAsmElfNoteEntry::set_name(SgAsmGenericString *name)
{
    if (p_name)
        p_name->set_parent(NULL);
    p_name = name;
    if (p_name)
        p_name->set_parent(this);
}

/* Initialize a note by parsing it from the specified location in the note section. Return value is the offset to the
 * beginning of the next note. */
rose_addr_t
SgAsmElfNoteEntry::parse(rose_addr_t at)
{
    /* Find the section holding this note */
    SgAsmElfNoteSection *notes = NULL;
    for (SgNode *node=this->get_parent(); node && !notes; node=node->get_parent()) {
        notes = dynamic_cast<SgAsmElfNoteSection*>(node);
    }
    ROSE_ASSERT(notes!=NULL);
    ROSE_ASSERT(at < notes->get_size());
    SgAsmElfFileHeader *fhdr = dynamic_cast<SgAsmElfFileHeader*>(notes->get_header());
    ROSE_ASSERT(fhdr!=NULL);
    
    /* Length of note entry name, including NUL termination */
    uint32_t u32;
    notes->read_content_local(at, &u32, 4);
    size_t name_size = disk_to_host(fhdr->get_sex(), u32);
    at += 4;

    /* Length of note entry description (i.e., the payload) */
    notes->read_content_local(at, &u32, 4);
    size_t payload_size = disk_to_host(fhdr->get_sex(), u32);
    at += 4;

    /* Type of note */
    notes->read_content_local(at, &u32, 4);
    unsigned type = disk_to_host(fhdr->get_sex(), u32);
    at += 4;

    /* NUL-terminated name */
    std::string note_name = notes->read_content_local_str(at);
    ROSE_ASSERT(note_name.size()+1 == name_size);
    at += name_size;
    at = (at+3) & ~0x3; /* payload is aligned on a four-byte offset */

    /* Set properties */
    set_name(new SgAsmBasicString(note_name));
    set_type(type);
    p_payload = notes->read_content_local_ucl(at, payload_size);

    return at + payload_size;
}

/* Write a note at the specified offset to the section containing the note. Returns the offset for the first byte past the end
 * of the note. */
rose_addr_t
SgAsmElfNoteEntry::unparse(std::ostream &f, rose_addr_t at)
{
    /* Find the section holding this note */
    SgAsmElfNoteSection *notes = NULL;
    for (SgNode *node=this->get_parent(); node && !notes; node=node->get_parent()) {
        notes = dynamic_cast<SgAsmElfNoteSection*>(node);
    }
    ROSE_ASSERT(notes!=NULL);
    ROSE_ASSERT(at < notes->get_size());
    SgAsmElfFileHeader *fhdr = dynamic_cast<SgAsmElfFileHeader*>(notes->get_header());
    ROSE_ASSERT(fhdr!=NULL);

    /* Name size, including NUL termination */
    uint32_t u32;
    host_to_disk(fhdr->get_sex(), p_name->get_string().size()+1, &u32);
    notes->write(f, at, 4, &u32);
    at += 4;

    /* Payload size */
    host_to_disk(fhdr->get_sex(), p_payload.size(), &u32);
    notes->write(f, at, 4, &u32);
    at += 4;
    
    /* Type */
    host_to_disk(fhdr->get_sex(), p_type, &u32);
    notes->write(f, at, 4, &u32);
    at += 4;
    
    /* Name with NUL termination and padded to a multiple of four bytes */
    std::string name = p_name->get_string();
    while ((name.size()+1) % 4)
        name += '\0';
    notes->write(f, at, name.size()+1, name.c_str());
    at += name.size()+1;
    
    /* Payload */
    notes->write(f, at, p_payload);
    at += p_payload.size();
    
    return at;
}

/* Returns the number of bytes needed to store this note. */
rose_addr_t
SgAsmElfNoteEntry::calculate_size() const {
    addr_t need = 12;                           /*namesize, payloadsize, type*/
    need += p_name->get_string().size() + 1;    /*name plus NUL terminator*/
    need = (need+3) & ~0x3;                     /*pad to align payload on a four-byte offset */
    need += p_payload.size();
    return need;
}

/* Print some debugging information */
void
SgAsmElfNoteEntry::dump(FILE *f, const char *prefix, ssize_t idx) const
{
    char p[4096];
    if (idx>=0) {
        sprintf(p, "%sElfNoteEntry[%zd]", prefix, idx);
    } else {
        sprintf(p, "%sElfNoteEntry", prefix);
    }
    const int w = std::max(1, DUMP_FIELD_WIDTH-(int)strlen(p));

    fprintf(f, "%s%-*s \"%s\"\n", p, w, "name", p_name->c_str());
    fprintf(f, "%s%-*s %u\n", p, w, "type", p_type);
    if (p_payload.size()>0) {
        fprintf(f, "%s%-*s = %zu bytes\n", p, w, "extra", p_payload.size());
        hexdump(f, 0, std::string(p)+"extra at ", p_payload);
    }
}

/* Non-parsing constructor */
void
SgAsmElfNoteSection::ctor()
{
    p_entries = new SgAsmElfNoteEntryList;
    p_entries->set_parent(this);
}

/* Parse existing notes */
SgAsmElfNoteSection *
SgAsmElfNoteSection::parse()
{
    SgAsmElfSection::parse();

    rose_addr_t at=0;
    while (at < get_size()) {
        SgAsmElfNoteEntry *note = new SgAsmElfNoteEntry(this);
        at = note->parse(at);
    }
    return this;
}

/* Pre-unparsing adjustments */
bool
SgAsmElfNoteSection::reallocate()
{
    bool reallocated = SgAsmElfSection::reallocate();
    
    /* How much space is needed by the notes? */
    addr_t need = 0;
    for (size_t i=0; i<p_entries->get_entries().size(); i++) {
        SgAsmElfNoteEntry *ent = p_entries->get_entries()[i];
        need += ent->calculate_size();
    }

    /* Adjust the section/segment size */
    if (need < get_size()) {
        if (is_mapped()) {
            ROSE_ASSERT(get_mapped_size()==get_size());
            set_mapped_size(need);
        }
        set_size(need);
        reallocated = true;
    } else if (need > get_size()) {
        get_file()->shift_extend(this, 0, need-get_size(), SgAsmGenericFile::ADDRSP_ALL, SgAsmGenericFile::ELASTIC_HOLE);
        reallocated = true;
    }
    
    return reallocated;
}

/* Write data to note section */
void
SgAsmElfNoteSection::unparse(std::ostream &f) const
{
    SgAsmElfFileHeader *fhdr = get_elf_header();
    ROSE_ASSERT(fhdr);

    addr_t at = 0;
    for (size_t i=0; i<p_entries->get_entries().size(); i++) {
        SgAsmElfNoteEntry *ent = p_entries->get_entries()[i];
        at = ent->unparse(f, at);
    }
}


/* Print some debugging information */
void
SgAsmElfNoteSection::dump(FILE *f, const char *prefix, ssize_t idx) const
{
    char p[4096];
    if (idx>=0) {
        sprintf(p, "%sElfNoteSection[%zd].", prefix, idx);
    } else {
        sprintf(p, "%sElfNoteSection.", prefix);
    }

    SgAsmElfSection::dump(f, p, -1);

    for (size_t i=0; i<p_entries->get_entries().size(); i++) {
        SgAsmElfNoteEntry *ent = p_entries->get_entries()[i];
        ent->dump(f, p, i);
    }
}

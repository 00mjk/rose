// #include <merge.h>
#include "rose.h"

#ifdef _MSC_VER
#include "buildMangledNameMap.h"
#endif

using namespace std;

MangledNameMapTraversal::MangledNameMapTraversal ( MangledNameMapType & m, SetOfNodesType & deleteSet )
   : mangledNameMap(m), setOfNodesToDelete(deleteSet) 
   {
     numberOfNodes                         = 0;
     numberOfNodesSharable                 = 0;
     numberOfNodesEvaluated                = 0;
     numberOfNodesAddedToManagledNameMap   = 0;
     numberOfNodesAlreadyInManagledNameMap = 0;
   }

bool
MangledNameMapTraversal::shareableIRnode ( const SgNode* node )
   {
  // At least for now we will likely share all possible IR nodes (except a few)
  // In the visit function we get more specific (we are mostly interested in declarations).
     bool returnValue = true;

  // These are not sharable IR nodes (could all these dynamic casts might be a performance issue?)
     const SgProject* project                         = isSgProject(node);
     const SgFile* file                               = isSgFile(node);
     const SgSymbolTable* symbolTable                 = isSgSymbolTable(node);
     const SgCtorInitializerList* ctorInitializerList = isSgCtorInitializerList(node);
     const SgBasicBlock* block                        = isSgBasicBlock(node);

  // DQ (2/9/2007): Adding this IR node decreased the number of tested IR nodes by 30%.
     const Sg_File_Info* fileInfo                     = isSg_File_Info(node);

  // DQ (2/9/2007): Added this case, but it makes less than a 1% difference (e.g. 14 out of 8412)
     const SgExpression* expression                   = isSgExpression(node);

     if ( project != NULL || file != NULL || symbolTable != NULL || ctorInitializerList != NULL || block != NULL || fileInfo != NULL || expression != NULL )
        {
          returnValue = false;
        }
#if 0
     const SgTypedefDeclaration* typedefDeclaration   = isSgTypedefDeclaration(node);

  // Added to test use of sharing only for global scope declarations!
     if ( typedefDeclaration != NULL )
        {
          returnValue = false;
        }
#endif

#if 0
  // I can't make this work, and I think it is because there are nested IR nodes that
  // can have a representation in global scope or a namespace scope such that all are required.
  // Further limit sharable IR nodes to declarations appearing in global scope!
     if ( returnValue == true )
        {
          const SgDeclarationStatement* declaration = isSgDeclarationStatement(node);
          if (declaration != NULL)
             {
            // Ignore IR nodes that not in either a SgGlobal or SgNamespaceDefinitionStatement
            // if (declaration->get_scope()->variantT() != V_SgGlobal && declaration->get_scope()->variantT() != V_SgNamespaceDefinitionStatement ) 
               if (declaration->get_scope()->variantT() == V_SgClassDefinition )
                  {
                    returnValue = false;
                  }
             }
        }
#endif

     return returnValue;
   }

void
MangledNameMapTraversal::displayMagledNameMap ( MangledNameMapTraversal::MangledNameMapType & m )
   {
     printf ("In MangledNameMapTraversal::displayMagledNameMap(): size() = %zu \n",m.size());
     MangledNameMapType::iterator i = m.begin();
     while (i != m.end())
        {
          string  s    = i->first;
          SgNode* node = i->second;
          ROSE_ASSERT(node != NULL);
          printf ("node = %p = %s  generated unique name = %s \n",node,node->class_name().c_str(),s.c_str());

          i++;
        }
   }


set<SgNode*>
MangledNameMapTraversal::buildSetFromMangleNameMap ( MangledNameMapTraversal::MangledNameMapType & m )
   {
  // This function support the set_defference to remove any nodes used as reference point in the 
  // mangled name map from the delete list that is generated.  IR nodes in the mangled name map
  // will be the IR nodes used to share IR nodes in the merged AST.  This is an issue for un-named
  // types which appear multiple times and need to be handled precisely.

  // printf ("In MangledNameMapTraversal::buildSetFromMangleNameMap(): size() = %ld \n",m.size());
      set<SgNode*> returnSet;
     MangledNameMapType::iterator i = m.begin();
     while (i != m.end())
        {
          ROSE_ASSERT(i->second != NULL);
          returnSet.insert(i->second);
          i++;
        }

     return returnSet;
   }


// Forward function declaration
// void buildDeleteList ( set<SgNode*> & listToDelete );
// void addAssociatedNodes ( SgNode* node, set<SgNode*> & setOfNodesToDelete, SgNode* matchingNodeInMergedAST );

void
MangledNameMapTraversal::addToMap ( string key, SgNode* node)
   {
     ROSE_ASSERT(node != NULL);

  // Note that "foo(); foo();" (repeated forward declarations of a global function is legal C and this
  // would cause the first entry in the mangledNameMap to be over written.  We have to handle this as 
  // a special case.
  // Difficult issues will be:
  //    1) extern declarations
  //    2) repeated global function declarations
  // if (mangledNameMap.find(key) == mangledNameMap.end())

     MangledNameMapType::iterator key_iterator = mangledNameMap.find(key);
  // bool matchingMangledNameIsNew = matchingMangledNameIsNew = (key_iterator == mangledNameMap.end());
     bool matchingMangledNameIsNew = key_iterator == mangledNameMap.end();

#define IMPLEMENT_MERGE 1
#if IMPLEMENT_MERGE
     if (matchingMangledNameIsNew == true)
        {
       // Build a new entry in the map!
#if 0
          printf ("Adding unique key to map for node = %p = %s (key = %s) \n",node,node->class_name().c_str(),key.c_str());
#endif

       // Need the more uniform syntax when using hash_map
       // mangledNameMap[key] = node;
          mangledNameMap.insert(pair<string,SgNode*>(key,node));

       // Keep track of the number of IR nodes that were evaluated for mangled name matching
          numberOfNodesAddedToManagledNameMap++;
        }
       else
        {
       // This key already exists in the mangledNameMap (so we can delete any remaining occurances to it.

       // Keep track of the number of IR nodes that were evaluated for mangled name matching
          numberOfNodesAlreadyInManagledNameMap++;

#if 0
          printf ("Note: This node = %p has a key = %s that already exists in the mangledNameMap, adding to the deleteList! node = %p = %s \n",node,key.c_str(),node,node->class_name().c_str());
#endif
       // Make sure this is never this IR node
          ROSE_ASSERT(isSgTypedefSeq(node) == NULL);

          setOfNodesToDelete.insert(node);

       // Use the matchingNodeInMergedAST so that we can reset the entries in the symbol tables where required
          SgNode* matchingNodeInMergedAST = key_iterator->second;
          ROSE_ASSERT(matchingNodeInMergedAST != NULL);
          addAssociatedNodes(node,setOfNodesToDelete,false,matchingNodeInMergedAST);
        }
#else
     printf ("Skipping implementation of AST merge \n");
#endif

  // printf ("In MangledNameMapTraversal::addToMap(): setOfNodesToDelete.size() = %ld \n",setOfNodesToDelete.size());
   }

void
MangledNameMapTraversal::visit ( SgNode* node)
   {
     ROSE_ASSERT(node != NULL);
  // printf ("MangledNameMapTraversal::visit: node = %s \n",node->class_name().c_str());

  // Keep track of the number of IR nodes visited
     numberOfNodes++;

     bool sharable = shareableIRnode(node);
     if (sharable == true)
        {
       // Initially we will only merge things in global scope!  Then
       // we will operate on namespaces! Then I think we are done!
       // Basically we can simplify the problem by skipping merging of things in 
       // function definitions since if the function definitions are the same they 
       // will be merged directly.

       // Keep track of the number of IR nodes that were considered sharable
          numberOfNodesSharable++;

       // Here is where we get much more specific about what is sharable!
          switch (node->variantT())
             {
            // Since we abstract out the generation of the key we can simplify this code!
               case V_SgFunctionDeclaration:
               case V_SgVariableDeclaration:
               case V_SgClassDeclaration:

            // DQ (2/10/2007): These need to be shared (but I still see "xxxxx____Lnnnn" based names)
               case V_SgTemplateInstantiationDecl:

            // DQ (2/10/2007): These should be shared
               case V_SgPragmaDeclaration:
               case V_SgTemplateInstantiationDirectiveStatement:

            // DQ (2/3/2007): Added additional declarations that we should share
               case V_SgMemberFunctionDeclaration:
               case V_SgTemplateInstantiationFunctionDecl:
               case V_SgTemplateInstantiationMemberFunctionDecl:

               case V_SgTypedefDeclaration:
               case V_SgEnumDeclaration:
               case V_SgTemplateDeclaration:
               case V_SgUsingDeclarationStatement:
               case V_SgUsingDirectiveStatement:

               case V_SgClassDefinition:
               case V_SgTemplateInstantiationDefn:
               case V_SgFunctionDefinition:
               case V_SgVariableDefinition:

            // DQ (2/20/2007): Added to list so that it could be process to build the delete list
            // statement fo the SgBasicBlock have to be considerd for the delete list. However,
            // it is still not meaningful since we don't generate a unique name for the SgBasicBlock
            // so it will never be shared.
            // case V_SgBasicBlock:

            // DQ (5/29/2006): Added support for types
               case V_SgFunctionType:
               case V_SgMemberFunctionType:
               case V_SgModifierType:
               case V_SgPointerType:

            // DQ (5/29/2006): Added support for types
               case V_SgClassType:
               case V_SgEnumType:
               case V_SgTypedefType:

            // DQ (2/3/2007): Added support for symbols
               case V_SgClassSymbol:
               case V_SgEnumFieldSymbol:
               case V_SgEnumSymbol:
               case V_SgFunctionSymbol:
               case V_SgMemberFunctionSymbol:
               case V_SgLabelSymbol:
               case V_SgNamespaceSymbol:

            // DQ (2/10/2007): This case has been a problem previously
               case V_SgTemplateSymbol:

               case V_SgTypedefSymbol:
               case V_SgVariableSymbol:

            // DQ (2/10/2007): Add this case
               case V_SgTemplateArgument:

            // DQ (3/17/2007): These should be shared, I think!
               case V_SgPragma:

            // DQ (5/20/2006): Initialized names are held in SgVariableDeclaration IR
            // nodes or other sharable structures so we don't have to share these.
            // But we have to permit them all to be shared because all pointers to 
            // them need to be reset they all need to be reset.
               case V_SgInitializedName:
                  {
                 // Make the use of false in generateUniqueName() more clear.  We need to 
                 // distinguish between defining and non-defining declarations in the generation 
                 // of unique names for the AST merge.
                 // string key = generateUniqueName(node,false);
                    bool ignoreDifferenceBetweenDefiningAndNondefiningDeclarations = false;
                    string key = SageInterface::generateUniqueName(node,ignoreDifferenceBetweenDefiningAndNondefiningDeclarations);
                    ROSE_ASSERT(key.empty() == false);
#if 1
                    SgDeclarationStatement* declaration = isSgDeclarationStatement(node);
                    if (declaration != NULL)
                       {
                      // ROSE_ASSERT(declaration->get_symbol_from_symbol_table() != NULL);

                      // DQ (7/4/2007): Some SgDeclarationStatement IR nodes don't have a representation 
                      // in the symbol table (the list of SgInitializedName object have them instead).
                         if (isSgVariableDeclaration(declaration) == NULL && 
                             isSgVariableDefinition(declaration) == NULL && 
                             isSgUsingDeclarationStatement(declaration) == NULL && 
                             isSgUsingDirectiveStatement(declaration) == NULL && 
                             isSgTemplateInstantiationDirectiveStatement(declaration) == NULL && 
                             isSgPragmaDeclaration(declaration) == NULL)
                            {
                              SgSymbol* symbol = declaration->search_for_symbol_from_symbol_table();
                              if (symbol == NULL)
                                 {
                                // Output more information to support debugging!
                                   printf ("declaration = %p = %s = %s \n",declaration,declaration->class_name().c_str(),SageInterface::get_name(declaration).c_str());
                                   SgScopeStatement* scope = declaration->get_scope();
                                   ROSE_ASSERT(scope != NULL);
                                   printf ("     scope = %p = %s = %s \n",scope,scope->class_name().c_str(),SageInterface::get_name(scope).c_str());
                                   declaration->get_startOfConstruct()->display("declaration->search_for_symbol_from_symbol_table() == NULL");
                                 }
                              ROSE_ASSERT(symbol != NULL);
                            }
                       }
#endif

                    addToMap(key,node);

                 // Keep track of the number of IR nodes that were evaluated for mangled name matching
                    numberOfNodesEvaluated++;
                    break;
                  }

               default:
                  {
                 // Nothing to do here
                  }
             }
        }
   }

// MangledNameMapTraversal::MangledNameMapType getMangledNameMap()
void
generateMangledNameMap (MangledNameMapTraversal::MangledNameMapType & mangledMap, MangledNameMapTraversal::SetOfNodesType & setOfIRnodesToDelete )
   {
  // DQ (2/2/2007): Introduce tracking of performance of within AST merge
     TimingPerformance timer ("Build the STL map of mangled names:");

     MangledNameMapTraversal traversal(mangledMap,setOfIRnodesToDelete);
     traversal.traverseMemoryPool();
#if 0
     printf ("Check what the intersetion is between the merged list and the delete list before doing set_difference \n");
     displaySet(computeSetIntersection(MangledNameMapTraversal::buildSetFromMangleNameMap(mangledMap),setOfIRnodesToDelete),"intersectionSet of merged map IR nodes and delete list IR nodes");
#endif
  // Remove any elements in intermediateDeleteSet that are used in the mangledMap
  // These are the reference IR nodes that will be shared and they should not be deleted
  // this is required for processing "struct { int x; } a;" since in two files the merge of
  // the SgClassType IR nodes (there will be 4) will be built and the one is used as a 
  // reference and three are added to the delete list.
     set<SgNode*> mangledNameReferenceSet = MangledNameMapTraversal::buildSetFromMangleNameMap(mangledMap);
     setOfIRnodesToDelete = computeSetDifference(setOfIRnodesToDelete,mangledNameReferenceSet);

     if (SgProject::get_verbose() > 0)
        {
          printf ("numberOfNodes                         = %d \n",traversal.numberOfNodes);
          printf ("numberOfNodesSharable                 = %d \n",traversal.numberOfNodesSharable);
          printf ("numberOfNodesEvaluated                = %d \n",traversal.numberOfNodesEvaluated);
          printf ("numberOfNodesAddedToManagledNameMap   = %d \n",traversal.numberOfNodesAddedToManagledNameMap);
          printf ("numberOfNodesAlreadyInManagledNameMap = %d \n",traversal.numberOfNodesAlreadyInManagledNameMap);
        }
   }


// Put non-generated Aterm support code here.

// #include "rosePublicConfig.h"

// #include "aterm1.h"
// #include "aterm2.h"

namespace AtermSupport 
   {
  // DQ (10/5/2014): This is the part of the latest version of ATerm support (now generated by ROSETTA).

     std::string aterm_type_name( ATerm term );

     std::string uniqueId(SgNode* n);

  // This supports generation of strings from addresses (mostly so that the SgAsm support will compile).
  // I don't think that Aterms have a data type for unsigned 64-bit integers.
     std::string uniqueId(uint64_t n);

  // This supports generation of strings from rose_rva_t (so that the SgAsm support will compile).
  // I don't think it is clear how to implement this function (but we can worry about the binary analysis 
  // use of Aterms later).
     std::string uniqueId(const rose_rva_t & n);

     ATerm convertFileInfoToAterm(Sg_File_Info* fi);

     ATerm convertVectorToAterm(const std::vector<ATerm>& v, int start, int len);

     template <typename Iter>
     ATerm convertRangeToAterm(Iter b, Iter e);

     template <typename Iter>
     ATerm convertSgNodeRangeToAterm(Iter b, Iter e);

     std::string getShortVariantName(VariantT var);

     ATerm getTraversalChildrenAsAterm(SgNode* n);

     ATerm convertNodeToAterm(SgNode* n);

     ATerm getAtermAnnotation(ATerm term, char* annotation_name );

  // Function for reading aterms and converting them to ROSE AST IR nodes.
     SgNode* generate_AST(ATerm & term);

  // Generate a list of aterms from the input aterm.
     std::vector<ATerm> getAtermList(ATerm ls);

     std::string getAtermStringAttribute(ATerm term, const std::string & annotationName );
     int getAtermIntegerAttribute(ATerm term, const std::string & annotationName );

  // DQ (10/8/2014): I don't think we need these (Aterm type system is not rich enough to justify these).
  // int getAtermEnumAttribute(ATerm term, const std::string & annotationName );
  // std::string getAtermNodeNameAttribute(ATerm term, const std::string & annotationName );

  // This function is special in that it accesses (internal) maps to lookup the SgNode 
  // using a sting that is saved as an annotation in the aterm and then as a key into the map.
  // Note that this should work where we see declarations before they are referenced, but 
  // will likely have to be fixed up after the translation where this rule is relaxed in C++
  // classes (which may refer to constructs before they are declared (and is always an issue)).
     SgNode* getAtermNodeAttribute(ATerm term, const std::string & annotationName );

   }


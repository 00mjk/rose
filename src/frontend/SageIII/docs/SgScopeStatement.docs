/* GENERATED FILE - DO NOT MODIFY */
//////////////////////////////////////////////////////////////////////////
// Documentation for class SgScopeStatement
//////////////////////////////////////////////////////////////////////////
/*!
\class SgScopeStatement
\brief This class represents the concept of a scope in C++ (e.g. global scope, fuction scope, etc.).
    Scopes are an important aspect of language design. They allow
declarations to have a local context and so promote good programming style.
Scope statments in C++ include a number of different kinds of statements;
the SgScopeStatement is a base class for these. Each scope statement contains
a symbol table and the SgScopeStatements role is mostly to provide this
symbol table and an interface to accessing it.
\internal This is a base class for scope statements.
\todo Where current derived IR nodes from SgScopeStatement contain SgBasicBlock objects,
    we should consider having them contain SgStatement objects instead of SgBasicBlock.
    This would avoid current normalizations which are cute, but perhaps unwelcome.  We 
    need to discuss and rule on this detail. 
    An alternative would be to let there be a SgBasicBlock and mark it as
    compiler-generated if it does not appear in the original source code.  then the
    unparser (code generator) could be made to avoid output of the SgBasicblock (and
    enforce that the number of statements in the block is not greater than one).
    Effected IR nodes include:
     - SgCatchOptionStmt (should contain SgStatement)
     - SgDoWhileStmt (should contain SgStatement)
     - SgForStatement (should contain SgStatement)
     - SgIfStmt (should contain true and false SgStatement)
     - SgSwitchStatement (should contain SgStatement)
     - SgWhileStmt (should contain SgStatement) \n
   these are currently correct:
     - SgFunctionDefinition (should contain a SgBasicBlock)
     - SgGlobal (constains a list of declarations (SgDeclarationStatement objects))
     - SgNamespaceDefinitionStatement (constains a list of declarations (SgDeclarationStatement objects))
     - SgClassDefinition (constains a list of declarations (SgDeclarationStatement objects))
\note Note about "conditions" used in loop constructs. "Conditionals" are either:
         - an expression, or
         - a declaration with initializer \n
      Note also that a SgConditional is different (a ternary operator (<test expr>) ? <true part> : <false part>;)
      There are a few errors in ROSE, locations in the IR where statements are used instead of expressions and
      expression used instead of statements. (reference Appendix A.6)
\note The following should have the "conditional" concept:
        - (SgIfStmt) if ( condition ) statement     // Currently correct
        - (SgSwitchStatement) switch ( condition ) statement // Currently uses SgExpression (wrong)
        - (SgWhileStmt) while ( condition ) statement  // Currently correct
        - (SgForStatement) for ( for-init-statment; condition; expression ) statement  // Currently uses SgExpression (wrong)
\note The following should have an expression:
        - (SgDoWhileStmt) do statement while ( expression );  // currently uses SgStatement instead of SgExpression
*/
/*
\sa
\ref SgScopeStatement_usage  "Example of using a SgScopeStatement object"
*/
//////////////////////////////////////////////////////////////////////////
// Documentation for class SgScopeStatement data members
/////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
// Documentation for class SgScopeStatement member functions (methods)
/////////////////////////////////////////////////////////////////////////
/*
\sa 
\ref SgScopeStatement_create "Example:create an SgScopeStatement object"
*/
/*!
\fn SgScopeStatement::~SgScopeStatement()
\brief This is the destructor.
   There are a lot of things to delete, but nothing is deleted in this destructor.
*/
/*!
\fn SgScopeStatement::isSgScopeStatement (SgNode *s)
\brief Cast function (from derived class to SgScopeStatement pointer).
   This functions returns a SgScopeStatement pointer for any input of a 
pointer to an object derived from a SgScopeStatement.
\return Returns valid pointer to SgScopeStatement if input is derived from a SgLocatedNode.
*/
/*!
\fn SgScopeStatement::isSgScopeStatement (const SgNode *s)
\brief Cast function (from derived class to SgScopeStatement pointer).
   This functions returns a SgScopeStatement pointer for any input of a 
pointer to an object derived from a SgScopeStatement.
\return Returns valid pointer to SgScopeStatement if input is derived from a SgLocatedNode.
*/
/*! \name Class Members*/
//@{
/*! \var SgSymbolTable *SgScopeStatement::p_symbol_table
\brief This pointer is always valid and stores the symbl table.
\internal The symbol table implementation was changed in fall of 2004, by Alin. 
It is not simple and leverages STL and provides more features.
*/
/*!\var std::set< SgSymbol * , std::less< SgSymbol * >  , std::allocator< SgSymbol * >  > SgScopeStatement::p_hidden_type_list
*/
/*!\var std::set< SgSymbol * , std::less< SgSymbol * >  , std::allocator< SgSymbol * >  > SgScopeStatement::p_type_elaboration_list
*/
/*!\var std::set< SgSymbol * , std::less< SgSymbol * >  , std::allocator< SgSymbol * >  > SgScopeStatement::p_hidden_declaration_list
*/
//@}
/*! \name User Interface*/
//@{
/*!\fn SgClassSymbol *SgScopeStatement::first_class_symbol() const
*/
/*!\fn SgClassSymbol *SgScopeStatement::lookup_class_symbol(const SgName &n) const
*/
/*!\fn SgClassSymbol *SgScopeStatement::next_class_symbol() const
*/
/*!
\fn SgDeclarationStatementPtrList &SgScopeStatement::getDeclarationList()
\brief Gets reference to internal STL list of pointers to SgDeclarationStatement objects
    (only defined for scopes containing declarations, see bool containsOnlyDeclarations()).
   This function is useful for SgScopeStatement objects that contain declarations, and is
not defined (returns an error) if called on a SgClassDefinition,
SgTemplateInstantiationDefn, SgGlobal, SgNamespaceDefinitionStatement.
To test if a scope contains only declarations use "bool containsOnlyDeclarations()".
Because this function returns a reference to the list (instead of a list of pointers
to the declarations or statements) any modification of the list is a modification of
the AST.
\return STL list of pointers to SgDeclarationStatement objects.
*/
/*!\fn SgEnumFieldSymbol *SgScopeStatement::first_enum_field_symbol() const
*/
/*!\fn SgEnumFieldSymbol *SgScopeStatement::lookup_enum_field_symbol(const SgName &n) const
*/
/*!\fn SgEnumFieldSymbol *SgScopeStatement::next_enum_field_symbol() const
*/
/*!\fn SgEnumSymbol *SgScopeStatement::first_enum_symbol() const
*/
/*!\fn SgEnumSymbol *SgScopeStatement::lookup_enum_symbol(const SgName &n) const
*/
/*!\fn SgEnumSymbol *SgScopeStatement::next_enum_symbol() const
*/
/*!\fn SgFunctionSymbol *SgScopeStatement::first_function_symbol() const
*/
/*!\fn SgFunctionSymbol *SgScopeStatement::lookup_function_symbol(const SgName &n) const
*/
/*!\fn SgFunctionSymbol *SgScopeStatement::lookup_function_symbol(const SgName &n,const SgType *t) const
*/
/*!\fn SgFunctionSymbol *SgScopeStatement::next_function_symbol() const
*/
/*!\fn SgLabelSymbol *SgScopeStatement::first_label_symbol() const
*/
/*!\fn SgLabelSymbol *SgScopeStatement::lookup_label_symbol(const SgName &n) const
*/
/*!\fn SgLabelSymbol *SgScopeStatement::next_label_symbol() const
*/
/*!\fn SgNamespaceSymbol *SgScopeStatement::first_namespace_symbol() const
*/
/*!\fn SgNamespaceSymbol *SgScopeStatement::lookup_namespace_symbol(const SgName &n) const
*/
/*!\fn SgNamespaceSymbol *SgScopeStatement::next_namespace_symbol() const
*/
/*!
\fn SgScopeStatement::SgScopeStatement(Sg_File_Info *file_info=(0))
\brief This is the constructor.
   This constructor builds the SgScopeStatement base class.
\param startOfConstruct represents the position in the source code
*/
/*!\fn SgScopeStatement::SgScopeStatement(const SgScopeStatementStorageClass &source)
*/
/*!
\fn SgStatementPtrList &SgScopeStatement::getStatementList()
\brief Gets reference to internal STL list of pointers to SgStatement objects
    (only defined for scopes containing declarations, see bool containsOnlyDeclarations()).
   This function is useful for SgScopeStatement objects that contain non-declarations
(lists of SgStatement instead of lists of SgDeclarationStatement IR nodes).
Because this function returns a reference to the list (instead of a list of pointers
to the declarations or statements) any modification of the list is a modification of
the AST.
\return STL list of pointers to SgStatement objects.
*/
/*!
\fn SgSymbol *SgScopeStatement::lookup_symbol(const SgName &n) const
\brief returns boolean value if symbol exists.
\return Returns SgSymbol pointer.
*/
/*!\fn SgTemplateSymbol *SgScopeStatement::first_template_symbol() const
*/
/*!\fn SgTemplateSymbol *SgScopeStatement::lookup_template_symbol(const SgName &n) const
*/
/*!\fn SgTemplateSymbol *SgScopeStatement::next_template_symbol() const
*/
/*!\fn SgTypedefSymbol *SgScopeStatement::first_typedef_symbol() const
*/
/*!\fn SgTypedefSymbol *SgScopeStatement::lookup_typedef_symbol(const SgName &n) const
*/
/*!\fn SgTypedefSymbol *SgScopeStatement::next_typedef_symbol() const
*/
/*!\fn SgVariableSymbol *SgScopeStatement::first_variable_symbol() const
*/
/*!\fn SgVariableSymbol *SgScopeStatement::lookup_var_symbol(const SgName &n) const
*/
/*!\fn SgVariableSymbol *SgScopeStatement::lookup_variable_symbol(const SgName &n) const
*/
/*!\fn SgVariableSymbol *SgScopeStatement::next_variable_symbol() const
*/
/*!
\fn bool SgScopeStatement::containsOnlyDeclarations() const
\brief boolean member function to distinquish if getStatementList() or getDeclarationList() is
    appropriate for the SgScopeStatment IR node.
\return bool.
*/
/*!\fn bool SgScopeStatement::symbol_exists(const SgName &,SgSymbol *sp) const
*/
/*!\fn bool SgScopeStatement::symbol_exists(const SgName &name) const
*/
/*!\fn bool SgScopeStatement::symbol_exists(const SgSymbol *sp) const
*/
/*!\fn const SgDeclarationStatementPtrList &SgScopeStatement::getDeclarationList() const
*/
/*!\fn const SgStatementPtrList &SgScopeStatement::getStatementList() const
*/
/*!
\fn const SgStatementPtrList SgScopeStatement::generateStatementList() const
\brief Builds list of pointers to SgStatement objects (useful for all SgScopeStatement objects,
    independent of whether they contain lists of SgDeclarationStatements or lists of SgStatements).
   This function is useful for any SgScopeStatement object, but since it returns
by value any modification of the list is not reflected in the AST.
\todo This runtion should return a const value so that it would be more clear that
it could not be modified (since such modifications would not be reflected in the AST).
\return STL list of pointers to SgStatement objects (returns by value).
*/
/*!\fn inline static void SgScopeStatement::operator delete(void *pointer)
*/
/*!
\fn int SgScopeStatement::lookup_symbol(const SgName &n,SgSymbol *s) const
\brief returns boolean value if symbol exists.
\return Returns bool.
\internal Not clear if this is used!
*/
/*!\fn static SgScopeStatement *SgScopeStatement::getPointerFromGlobalIndex(AstSpecificDataManagingClass *astInPool,unsigned long globalIndex)
*/
/*!\fn static unsigned long SgScopeStatement::getNumberOfLastValidPointer()
*/
/*!\fn static unsigned long SgScopeStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer(unsigned long )
*/
/*!\fn static unsigned long SgScopeStatement::initializeStorageClassArray(SgScopeStatementStorageClass *storageArray)
*/
/*!\fn static void SgScopeStatement::clearMemoryPool()
*/
/*!\fn static void SgScopeStatement::extendMemoryPoolForFileIO()
*/
/*!\fn static void SgScopeStatement::resetValidFreepointers()
*/
/*!\fn virtual RTIReturnType SgScopeStatement::roseRTI()
*/
/*!
\fn virtual SgNode *SgScopeStatement::copy(SgCopyHelp &help) const
\brief Makes a copy (deap of shallow depending on SgCopyHelp).
\return Returns pointer to copy of SgScopeStatement.
*/
/*!\fn virtual void SgScopeStatement::fixupCopy_references(SgNode *copy,SgCopyHelp &help) const
*/
/*!\fn virtual void SgScopeStatement::fixupCopy_scopes(SgNode *copy,SgCopyHelp &help) const
*/
/*!\fn virtual void SgScopeStatement::fixupCopy_symbols(SgNode *copy,SgCopyHelp &help) const
*/
/*!\fn virtual void SgScopeStatement::post_construction_initialization()
*/
/*!\fn void SgScopeStatement::insertStatementInScope(SgStatement *newTransformationStatement,bool atTop)
*/
/*!
\fn void SgScopeStatement::insert_symbol(const SgName &n,SgSymbol *s)
\brief Puts a SgSymbol object into the local symbol table.
\return Returns void.
*/
/*!\fn void SgScopeStatement::prepend_statement(SgStatement *stmt)
*/
/*!\fn void SgScopeStatement::print_symboltable(const std::string &str,std::ostream &os=std::cout)
*/
/*!\fn void SgScopeStatement::remove_symbol(SgSymbol *s)
*/
/*!\fn void SgScopeStatement::set_hidden_declaration_list(const std::set< SgSymbol * , std::less< SgSymbol * >  , std::allocator< SgSymbol * >  > &hidden_declaration_list)
\brief \brief See  &hidden_declaration_list)
hidden_declaration_list for documentation */
/*!\fn void SgScopeStatement::set_hidden_type_list(const std::set< SgSymbol * , std::less< SgSymbol * >  , std::allocator< SgSymbol * >  > &hidden_type_list)
\brief \brief See  &hidden_type_list)
hidden_type_list for documentation */
/*!
\fn void SgScopeStatement::set_symbol_table(SgSymbolTable *symbol_table)
\brief Sets the pointer to the locally strored SgSymbolTable.See  *symbol_table)
symbol_table for documentation 
\return Returns void.
*/
/*!\fn void SgScopeStatement::set_type_elaboration_list(const std::set< SgSymbol * , std::less< SgSymbol * >  , std::allocator< SgSymbol * >  > &type_elaboration_list)
\brief \brief See  &type_elaboration_list)
type_elaboration_list for documentation */
/*!
\fn SgSymbolTable *SgScopeStatement::get_symbol_table() const
\brief Returns a pointer to the locally strored SgSymbolTable.See  const
symbol_table for documentation 
\return Returns a pointer.
*/
/*!\fn virtual SgName SgScopeStatement::get_mangled_name() const
\brief \brief See  const
mangled_name for documentation */
/*!
\fn virtual SgName SgScopeStatement::get_qualified_name() const
\brief Returns SgName (a string) representing the name of the current scope.See  const
qualified_name for documentation 
   See discussion of mangled names in the documentation.
\return Returns SgName (a string).
*/
/*!\fn virtual SgNode *SgScopeStatement::get_traversalSuccessorByIndex(size_t idx)
\brief \brief See  idx)
traversalSuccessorByIndex for documentation */
/*!\fn virtual size_t SgScopeStatement::get_childIndex(SgNode *child)
\brief \brief See  *child)
childIndex for documentation */
/*!\fn virtual size_t SgScopeStatement::get_numberOfTraversalSuccessors()
\brief \brief See  SgScopeStatement::numberOfTraversalSuccessors for documentation */
/*!\fn virtual std::vector< SgNode * , std::allocator< SgNode * >  > SgScopeStatement::get_traversalSuccessorContainer()
\brief \brief See  SgScopeStatement::traversalSuccessorContainer for documentation */
/*!\fn virtual std::vector< std::string  , std::allocator< std::string  >  > SgScopeStatement::get_traversalSuccessorNamesContainer()
\brief \brief See  SgScopeStatement::traversalSuccessorNamesContainer for documentation */
/*!\fn virtual SgScopeStatement::~SgScopeStatement()
*/
//@}
int SAGE_Doxygen_Dummy_30916245543869;

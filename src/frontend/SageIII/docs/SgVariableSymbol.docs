/* GENERATED FILE - DO NOT MODIFY */
//////////////////////////////////////////////////////////////////////////
// Documentation for class SgVariableSymbol
//////////////////////////////////////////////////////////////////////////
/*!
\class SgVariableSymbol
\brief This class represents the concept of a variable name within the compiler (a
    shared container for the declaration of a variable (SgInitializedName)).
   Symbols are a simpler way for the compiler to quickly associate types,
declarations and names.  This symbol is specific to holding a variable name.
\internal  Symbols are placed into scopes (more precisely into symbol tables held in 
    each SgScopeStatement).  Most symbols are only in a single symbol table, but the
    SgVariableSymbol can exist in two scopes if it is a static data member declared both
    in its class (SgClassDefinition) and outside of the class (in global scope or a
    namespace scope (SgGlobal or SgNamespaceDefinitionStatement)).
\todo Need to figure out if it is such a great idea of a single symbol to be in two scopes
    or if it would be better to use two different symbols (since there are two different
    SgInitializedName object built (the last one referencing the previous one through
    the p_prev_decl_item pointer)).
\todo The get_type() function can return NULL when the get_definition() is NULL.  I think
    we should have assertiosn to make sure that get_definition is a valid pointer and that
    get_type() should not return NULL.
\sa \ref SgInitializedName
\sa
\ref SgVariableSymbol_usage  "Example of using a SgVariableSymbol object"
*/
//////////////////////////////////////////////////////////////////////////
// Documentation for class SgVariableSymbol data members
/////////////////////////////////////////////////////////////////////////
/*
\var SgVariableSymbol::p_declaration
\brief This pointer is always valid and stores the first non-defining declaration 
where the class was defined.  
    It is important to note that this is the first non-defining declaration as 
opposed to the defining declaration.  Thus is it the first forward declaration for the
named class or a non-defining version of the declaration if the named class is
defined at the locations where it was declared.
\internal The value held is sharable across many references where as the defining
          declaration (not held by this variable) should have one unique reference
          within the Sage III AST, except where reference though the declarations
          definingDeclaration data member pointer.  See declarations for details
          (SgDeclarationStatements).
*/
//////////////////////////////////////////////////////////////////////////
// Documentation for class SgVariableSymbol member functions (methods)
/////////////////////////////////////////////////////////////////////////
/*
      NOT IMPELEMENTED IN C++ SOURCE CODE
\fn SgVariableSymbol::SgVariableSymbol (const SgVariableSymbol &X)
\brief Copy constructor (made private to prevent being called by accident).
*/
/*!
\fn SgVariableSymbol::~SgVariableSymbol()
\brief This is the destructor.
*/
/*!
\fn SgVariableSymbol::isSgVariableSymbol (SgNode *s)
\brief Cast function (from derived class to SgVariableSymbol pointer).
   This functions returns a SgVariableSymbol pointer for any input of a 
pointer to an object derived from a SgVariableSymbol.
\return Returns valid pointer to SgVariableSymbol if input is derived from a SgVariableSymbol.
*/
/*!
\fn SgVariableSymbol::isSgVariableSymbol (const SgNode *s)
\brief Cast function (from derived class to SgVariableSymbol pointer).
   This functions returns a SgVariableSymbol pointer for any input of a 
pointer to an object derived from a SgVariableSymbol.
\return Returns valid pointer to SgVariableSymbol if input is derived from a SgVariableSymbol.
*/
/*! \name Class Members*/
//@{
/*!\var SgInitializedName *SgVariableSymbol::p_declaration
*/
//@}
/*! \name User Interface*/
//@{
/*!\fn SgVariableSymbol::SgVariableSymbol(const SgVariableSymbolStorageClass &source)
*/
/*!\fn inline static void SgVariableSymbol::operator delete(void *pointer)
*/
/*!\fn static SgVariableSymbol *SgVariableSymbol::getPointerFromGlobalIndex(AstSpecificDataManagingClass *astInPool,unsigned long globalIndex)
*/
/*!\fn static unsigned long SgVariableSymbol::getNumberOfLastValidPointer()
*/
/*!\fn static unsigned long SgVariableSymbol::getNumberOfValidNodesAndSetGlobalIndexInFreepointer(unsigned long )
*/
/*!\fn static unsigned long SgVariableSymbol::initializeStorageClassArray(SgVariableSymbolStorageClass *storageArray)
*/
/*!\fn static void SgVariableSymbol::clearMemoryPool()
*/
/*!\fn static void SgVariableSymbol::extendMemoryPoolForFileIO()
*/
/*!\fn static void SgVariableSymbol::resetValidFreepointers()
*/
/*!\fn virtual RTIReturnType SgVariableSymbol::roseRTI()
*/
/*!\fn virtual SgNode *SgVariableSymbol::copy(SgCopyHelp &help) const
*/
/*!\fn virtual SgVariableSymbol::~SgVariableSymbol()
*/
/*!\fn void SgVariableSymbol::set_declaration(SgInitializedName *declaration)
\brief \brief See  *declaration)
declaration for documentation */
/*!\fn SgInitializedName *SgVariableSymbol::get_declaration() const
\brief \brief See  const
declaration for documentation */
/*!
\fn virtual SgName SgVariableSymbol::get_name() const
\brief Access function for getting name from declarations or types internally.See  const
name for documentation 
\internal This is a virtual function.
\return Returns SgName.
*/
/*!\fn virtual SgNode *SgVariableSymbol::get_symbol_basis() const
\brief \brief See  const
symbol_basis for documentation */
/*!\fn virtual SgNode *SgVariableSymbol::get_traversalSuccessorByIndex(size_t idx)
\brief \brief See  idx)
traversalSuccessorByIndex for documentation */
/*!
\fn virtual SgType *SgVariableSymbol::get_type() const
\brief This function returns the type associated with the named entity.See  const
type for documentation 
\internal This is a virtual function.
\return Returns SgType*.
*/
/*!\fn virtual size_t SgVariableSymbol::get_childIndex(SgNode *child)
\brief \brief See  *child)
childIndex for documentation */
/*!\fn virtual size_t SgVariableSymbol::get_numberOfTraversalSuccessors()
\brief \brief See  SgVariableSymbol::numberOfTraversalSuccessors for documentation */
/*!\fn virtual std::vector< SgNode * , std::allocator< SgNode * >  > SgVariableSymbol::get_traversalSuccessorContainer()
\brief \brief See  SgVariableSymbol::traversalSuccessorContainer for documentation */
/*!\fn virtual std::vector< std::string  , std::allocator< std::string  >  > SgVariableSymbol::get_traversalSuccessorNamesContainer()
\brief \brief See  SgVariableSymbol::traversalSuccessorNamesContainer for documentation */
/*!
\fn SgVariableSymbol::SgVariableSymbol(SgInitializedName *declaration=(0))
\brief This is the only constructor.
   This constructor builds the SgVariableSymbol base class.
\sa 
\ref SgVariableSymbol_create "Example:create an SgVariableSymbol object"
*/
//@}
int SAGE_Doxygen_Dummy_40261305810582;

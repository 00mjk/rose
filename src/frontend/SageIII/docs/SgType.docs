/* GENERATED FILE - DO NOT MODIFY */
//////////////////////////////////////////////////////////////////////////
// Documentation for class SgType
//////////////////////////////////////////////////////////////////////////
/*!
\class SgType
\brief This class represents the base class for all types.
    There are no uses of this IR node anywhere.  All SgType based IR nodes
are derived from this SgType class.
Discussion of get_base_type() and findBaseType():
    -# fileBaseType() will recursively strip away all typedefs, reference, pointers, arrays,
       and modifiers
    -# get_base_type() is a member function on some IR nodes derived from SgType and
       returns the non-recursively striped (immediate) type under the typedefs, reference,
       pointers, arrays, modifiers, etc.
Note that the typedefs for which the current SgType is the base type are stored in a list.
There is a special IR node (SgTypedefSeq) to maintain this list (which is internally an
STL list).  We could also store pointers to other SgType IR nodes where pointers and 
references have been taken to the current IR node, but currently only typedefs are
stored explicitly.  As a result of storing the typedefs, the builtin types store the
list for most SgType IR nodes (since ther is only a single SgType IR node for most
SgType derived classes).  We could imagine storing the SgTypedefSeq as static data members
of the derived SgType classes, but this would not work since then all SgNamedType IR nodes
would share the same list of typedefs.  So this is the correct location for this list.
\internal This is a base class for all SgType objects.
\todo Several classes derived from SgType are not used and can be removed:
   -# SgTypeUnknown (Used by SageInterface to specify reference to undeclared variables)
   -# SgUnknownMemberFunctionType
\todo The signed types (except for signed char) are not used in SAGE III and do not exist
      in C or C++.  These IR nodes should be removed, specifically SgTypeSignedShort,
      SgTypeSignedInt, SgTypeSignedLong.
\todo For Fortran support we need to add the kind, length data member to specify the width.
      To support handling of kind, length parameters we should use the information about
      the target backend compiler and map kind information to bit widths (not a high
      priority).
\todo Labels appear to be used as types in "foo(*,*)", see example from 
      Chris (LANL, 4/19/2007).
\sa
\ref SgType_usage  "Example of using a SgType object"
*/
//////////////////////////////////////////////////////////////////////////
// Documentation for class SgType data members
/////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
// Documentation for class SgType member functions (methods)
/////////////////////////////////////////////////////////////////////////
/*!
\fn SgType::~SgType()
\brief This is the destructor.
   There is nothing to delete in this object.
*/
/*!
\fn SgType::isSgType (SgNode *s)
\brief Cast function (from derived class to SgType pointer).
   This functions returns a SgType pointer for any input of a 
pointer to an object derived from a SgType.
\return Returns valid pointer to SgType if input is derived from a SgLocatedNode.
*/
/*!
\fn SgType::isSgType (const SgNode *s)
\brief Cast function (from derived class to SgType pointer).
   This functions returns a SgType pointer for any input of a 
pointer to an object derived from a SgType.
\return Returns valid pointer to SgType if input is derived from a SgType node.
*/
/*! \name Class Members*/
//@{
/*!
\var SgModifierNodes *SgType::p_modifiers
\brief This points to any SgModifierNodes if this type contains type modifiers.
*/
/*!
\var SgPointerType *SgType::p_ptr_to
\brief This holds the pointer to a SgPointerType if this type is a pointer to another type.
*/
/*!
\var SgReferenceType *SgType::p_ref_to
\brief This holds the pointer to a SgReferenceType if this type is a reference to another type.
*/
/*!
\var SgTypedefSeq *SgType::p_typedefs
\brief This points to IR node which holds a list of typedefs where the base_type if this SgType.
\sa SgTypedefSeq
*/
/*!
\var int SgType::p_substitutedForTemplateParam
\brief This boolean variable marks if the current type was originally a template
    parameter.
\internal This mechanism is not fully implemented and might be modified when it is.
          Also, this variables type should have been bool.
*/
/*!\var static const unsigned char SgType::STRIP_ARRAY_TYPE
*/
/*!\var static const unsigned char SgType::STRIP_POINTER_TYPE
*/
/*!\var static const unsigned char SgType::STRIP_REFERENCE_TYPE
*/
/*!\var static const unsigned char SgType::STRIP_TYPEDEF_TYPE
*/
/*!\var AstAttributeMechanism *SgType::p_attributeMechanism
*/
//@}
/*! \name User Interface*/
//@{
/*!\fn SgType *SgType::stripTypedefsAndModifiers() const
*/
/*!
\fn SgType::SgType()
\brief This is the constructor.
   This constructor builds the SgType base class.
\sa 
\ref SgType_create "Example:create an SgType object"
*/
/*!\fn SgType::SgType(const SgTypeStorageClass &source)
*/
/*!\fn inline static void SgType::operator delete(void *pointer)
*/
/*!\fn static SgType *SgType::getPointerFromGlobalIndex(AstSpecificDataManagingClass *astInPool,unsigned long globalIndex)
*/
/*!\fn static unsigned long SgType::getNumberOfLastValidPointer()
*/
/*!\fn static unsigned long SgType::getNumberOfValidNodesAndSetGlobalIndexInFreepointer(unsigned long )
*/
/*!\fn static unsigned long SgType::initializeStorageClassArray(SgTypeStorageClass *storageArray)
*/
/*!\fn static void SgType::clearMemoryPool()
*/
/*!\fn static void SgType::extendMemoryPoolForFileIO()
*/
/*!\fn static void SgType::resetValidFreepointers()
*/
/*!\fn virtual RTIReturnType SgType::roseRTI()
*/
/*!\fn virtual SgNode *SgType::copy(SgCopyHelp &help) const
*/
/*!\fn virtual void SgType::set_attributeMechanism(AstAttributeMechanism *attributeMechanism)
\brief \brief See  *attributeMechanism)
attributeMechanism for documentation */
/*!\fn void SgType::set_modifiers(SgModifierNodes *modifiers)
\brief \brief See  *modifiers)
modifiers for documentation */
/*!\fn void SgType::set_ptr_to(SgPointerType *ptr_to)
\brief \brief See  *ptr_to)
ptr_to for documentation */
/*!\fn void SgType::set_ref_to(SgReferenceType *ref_to)
\brief \brief See  *ref_to)
ref_to for documentation */
/*!\fn void SgType::set_substitutedForTemplateParam(int substitutedForTemplateParam)
\brief \brief See  substitutedForTemplateParam)
substitutedForTemplateParam for documentation */
/*!\fn void SgType::set_typedefs(SgTypedefSeq *typedefs)
\brief \brief See  *typedefs)
typedefs for documentation */
/*!\fn SgModifierNodes *SgType::get_modifiers() const
\brief \brief See  const
modifiers for documentation */
/*!\fn SgPointerType *SgType::get_ptr_to() const
\brief \brief See  const
ptr_to for documentation */
/*!\fn SgReferenceType *SgType::get_ref_to() const
\brief \brief See  const
ref_to for documentation */
/*!\fn SgTypedefSeq *SgType::get_typedefs() const
\brief \brief See  const
typedefs for documentation */
/*!\fn int SgType::get_substitutedForTemplateParam() const
\brief \brief See  const
substitutedForTemplateParam for documentation */
/*!\fn virtual AstAttributeMechanism *SgType::get_attributeMechanism() const
\brief \brief See  const
attributeMechanism for documentation */
/*!\fn virtual SgNode *SgType::get_traversalSuccessorByIndex(size_t idx)
\brief \brief See  idx)
traversalSuccessorByIndex for documentation */
/*!\fn virtual size_t SgType::get_childIndex(SgNode *child)
\brief \brief See  *child)
childIndex for documentation */
/*!\fn virtual size_t SgType::get_numberOfTraversalSuccessors()
\brief \brief See  SgType::numberOfTraversalSuccessors for documentation */
/*!\fn virtual std::vector< SgNode * , std::allocator< SgNode * >  > SgType::get_traversalSuccessorContainer()
\brief \brief See  SgType::traversalSuccessorContainer for documentation */
/*!\fn virtual std::vector< std::string  , std::allocator< std::string  >  > SgType::get_traversalSuccessorNamesContainer()
\brief \brief See  SgType::traversalSuccessorNamesContainer for documentation */
/*!\fn virtual SgType::~SgType()
*/
//@}
int SAGE_Doxygen_Dummy_143626492250;

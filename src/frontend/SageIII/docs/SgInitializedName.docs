/* GENERATED FILE - DO NOT MODIFY */
//////////////////////////////////////////////////////////////////////////
// Documentation for class SgInitializedName
/////////////////////////////////////////////////////////////////////////
/*!
\class SgInitializedName
\brief This class represents the notion of a declared variable.  
 
Each variable in the program has a SgInitializedName object which
represents its definition. A SgVariableDeclaration for example might
contain several SgInitializedName objects, while the
SgInitializedName contains the declaration for \em one
variable. Each variable use (VarRefExp for example) must have a link
to the SgInitializedName object where that specific variable was
defined.
\b What \b really \b happens
Currently, each SgVariableDeclaration contains \b only \b one SgInitializedName
In order to have a valid SgInitializedName object, this information must be provided :
- the variable name which represents the variable that is being declared in this class.
- the variable type
- the declaration object which contains the SgInitializedName ( this might be a SgVariableDeclaration, SgFunctionParameterList, SgClassDeclaration,etc)
 
\sa 
\ref SgInitializedName_create "Example of creating an SgInitializedName object"
\ref SgInitializedName_usage  "Example of using an SgInitializedName object"
*/
//////////////////////////////////////////////////////////////////////////
// Documentation for class SgInitializedName data members
/////////////////////////////////////////////////////////////////////////
/*!
\var SgInitializedName::p_fileInfo
\brief This pointer is always valid and stores the source position of the start a name.
This is an Sg_File_Info object which represents the source position of the starting of
the name represented by the SgInitializedName object (variable name, function name, etc.).
*/
/*!
\var SgInitializedName::p_itemptr
\brief Pointer to the next SgInitializedName in the declaration.
\b Alin's \b intuitive \b explanation
This is a pointer to the next SgInitializedName in a declaration
statement. For example, if there is a declaration statement of this
form "int x=5,y=3", and the current SgInitializedName represents
variable "x", the next SgInitializedName in the current declaration
is for the variable "y".
\b What \b really \b happens
This is the pointer that points to a nested SgInitializedName object
that has the same variable name, variable type, but it has a
different declaration statement and a different SgStorageModifier
(this one makes sens). For the nested SgInitalizedName::p_itemptr
object, this data member is set to 0 and the SgInitializedName::p_prev_itemptr data
member is set to the parent SgInitializedName.
*/
/*!
\var SgInitializedName::p_prev_itemptr
\brief  Pointer to the previous SgInitializedName in the declaration.
 \b Alin's \b intuitive \b explanation
This is a pointer to the previous SgInitializedName in a declaration
statement. For example, if there is a declaration statement of this
form "int x=5,y=3", and the current SgInitializedName represents
variable "y", the next SgInitializedName in the current declaration
is for the variable "x".
\b What \b really \b happens
For the first level SgInitializedName, this data member is set to 0. For the nested one, this is set to the parent SgInitializedName.
*/
/*!
\var SgInitializedName::p_register_name_name
\brief String representing the register name, used when associated GNU code can't be translated.
This is a string value representing the name specified (untranslated to the GNU standard
register codes). The string is used when the name specified by theused was
untranslatable to a more compact GNU code.  This forces the IR to hold an rarely
used string object in a frequently used IR node, but I don't think we have any
simple way around this detail since we have to support the more general use of 
the asm options in C and C++.
\internal This is less architecture dependent than the GNU standard register codes, but
    takes more storage (though it is not used often).
*/
//////////////////////////////////////////////////////////////////////////
// Documentation for class SgInitializedName member functions (methods)
/////////////////////////////////////////////////////////////////////////
/*
\fn SgInitializedName::error
\brief 
*/
/*!
\fn SgInitializedName & SgInitializedName::operator= (const SgInitializedName &ptr)
\brief assignment operator. It copies \b everything (including pointers) from the rhs object to the lhs object
It copies all the data members of the rhs SgInitializedName object
to the lhs (this) object. The copying is done by value, so all the
data member pointers are copied by \b value. After the assignment
operator is executed, both operands \b share the same data
members. Actually there is a note in the source code (Cxx_Grammar.h)
that says that this needs to be executed recursively ( allocating
new data members for the newly assigned object).  
*/
/*!
\fn bool SgInitializedName::operator== (const SgInitializedName &) const
\brief  Equal operator : it checks if all the data members are the same or point to the same objects
\b What \b really \b happens
It returns false all the time. 
*/
/*!
\fn SgInitializedName::p_name
\brief variable x
detailed variable x
*/
/*! \name Deprecated*/
//@{
/*!
\fn SgInitializedName::SgInitializedName(const SgName &name,SgType *typeptr,SgInitializer *iptr=(0),SgDeclarationStatement *declptr=(0),SgInitializedName *prev_decl_item=(0))
\brief This is the constructor
\deprecated This is an older constructor which does not include the Sg_File_Info or the
    SgScopeStatement in its parameter list.  These must be set explicitly using the data
    member's access functions when using this constructor.
\param name the variable name
\param typeptr a pointer to the variable's type object
\param iptr pointer to the initializer of the variable ( if any)
\param declptr pointer to the declaration statement to which this SgInitializedName belongs to
\param itemptr the next SgInitializedName object in the parent declaration statement
\param prev_itemptr the previous SgInitializedName object in the parent declaration statement
\sa 
\ref SgInitializedName_create "Example:create an SgInitializedName object"
*/
//@}
/*! \name Class Members*/
//@{
/*!\var AstAttributeMechanism *SgInitializedName::p_attributeMechanism
*/
/*!
\var SgDeclarationStatement *SgInitializedName::p_declptr
\brief Pointer to the declaration object where this SgInitializedName object belongs to.
\b Alin's \b intuitive \b explanation
Each SgInitializedName object contains the declaration of \em one
variable. In the case where the code has more declarations in a
single statement, for example "int x=5,y=3;", that declaration is
composed of two SgInitializedName objects, one for each variable
declared in that statment. So, this SgInitializedName::p_declptr points to the
statement (actually the declaration - SgDeclaration) that contains it.
\b What \b really \b happens
For the first SgInitializedName, this points to the the
SgDeclarationStatement that contains this SgInitializedName. For the
second one, it is set to an unknown SgDeclarationStatement that does
not show up in the pdf or the dot files (not traversed).
\b Dan's \b explaination
   This points to the SgVariableDefinition and is the same as get_definition().
*/
/*!
\var SgInitializedName *SgInitializedName::p_prev_decl_item
\brief Pointer to the initial uses of this variable previous to its redeclaration declaration.
\b Dan's \b intuitive \b explanation
This pointer references any initialized name previously built to define a SgVarRefExp,
which requires a pointer to a variable declaration (but points to a SgInitializedName
since a SgVariableDeclaration could stand for many variables (not just one, e.g. 
"int x,y,z;"), since uniqueness is required.  Although non-intuative, C++ code defined 
within a class definition can
reference variables before they are defined (e.g. "class X { int foo() { return x; } int x; };"), 
see test2005_67.C (non-static data member) and test2005_68.C (static data member).  
It is also used by a SgInitializedName in a static declaration outside the class to
refer to the preliminary declaration inside the class.
(e.g. "class X { static int a;}; int X::a = 0; };")
*/
/*!
\var SgInitializer *SgInitializedName::p_initptr
\brief Pointer to an initializer for the variable.
In the case that the declaration contains an initializer for the variable, for example "int x=5" or "int x=y" (in these cases the intializers for the declared variable are "5" and "y"), that initializer has to be stored in SgInitializedName::p_initptr as a pointer that points to the SgInitializer object that the SgInitializedName::p_name variable is initialized with. 
*/
/*!
\var SgName SgInitializedName::p_name
\brief The variable that is declared in this declaration
This is a SgName object which represents the variable that is being declared in this SgInitializedName object.
For example, if there is a "int x" declaration in the code, "x" is the variable that will be stored in SgInitializedName::p_name as a SgName object.
*/
/*!
\var SgScopeStatement *SgInitializedName::p_scope
\brief This pointer is always valid and stores the current scope of the variable.
This is the current scope of the variable (required because variables can be defined
separately from their declaration).  See test2004_133.C (approx).
*/
/*!
\var SgStorageModifier *SgInitializedName::p_storageModifier
\brief This is the storage modifier (static, auto, register, mutable, asm, etc.).
This is the storage modifier (static, auto, register, mutable, asm, etc.), see complete
list in source code for more details.  This is an implementation of the modifier system
as outlined in appendix A of Bjarne's book.
\internal Note that isStatic() in the SgInitializedName is always false, is is set in the
SgStorageModifier stored in the SgVariableDeclaration (where it is filed of the SgDeclarationModifier).
*/
/*!
\var SgType *SgInitializedName::p_typeptr
\brief Pointer to a type object that has been associated with SgInitializedName::p_name
This is a pointer that points to an SgType object that represents
the type the variable SgInitializedName::p_name declared in this SgInitializedName
class (in this declaration). For example, if the variable is of type
"int" (as in "int x"), then a SgTypeInt object has to be allocated , and a pointer
to this SgTypeInt object has to be stored in SgInitializedName::p_typeptr to represent
the type of SgInitializedName::p_name.
*/
/*!\var Sg_File_Info *SgInitializedName::p_startOfConstruct
*/
/*!
\var bool SgInitializedName::p_is_initializer
\brief flag to determine whether the declaration has an initializer.
If the declaration has an initializer, for example "int x=5", then
this flag is set to true. The flag is set to false otherwise.
*/
/*!\var bool SgInitializedName::p_requiresGlobalNameQualificationOnType
*/
/*!\var bool SgInitializedName::p_shapeDeferred
*/
/*!
\var enum SgInitializedName::asm_register_name_enum SgInitializedName::p_register_name_code
\brief Code (following GNU standard) for register name.
This value is set based on an enum value of GNU standard codes mappings to register names.
\internal This is a very architecture dependent aspect of the Sage III IR.  We only
    currently represent code for the Intel X86 processor.
*/
/*!
\var enum SgInitializedName::preinitialization_enum SgInitializedName::p_preinitialization
\brief This data member stores an enum value.
This value is set based on an enum value to indicate the type of use of the initialized
name (valid values are: virtual base class, non-virtual base, data member).
\internal I think that the preinitalization information might be redundant with the
SgStorageModifier information.
*/
/*!\var std::string SgInitializedName::p_register_name_string
*/
/*!\var bool SgInitializedName::p_initializationDeferred
*/
//@}
/*! \name User Interface*/
//@{
/*!\fn SgInitializedName &SgInitializedName::operator=(const SgInitializedName &ptr)
*/
/*!
\fn SgInitializedName::SgInitializedName(Sg_File_Info *fileInfo,const SgName &name,SgType *typeptr,SgInitializer *iptr,SgDeclarationStatement *declptr,SgScopeStatement *scope,SgInitializedName *prev_itemptr)
\brief This is the constructor
\param fileInfo pointer to source position (also used to mark compiler generated or transformed code)
\param name the variable name
\param typeptr a pointer to the variable's type object
\param iptr pointer to the initializer of the variable ( if any)
\param declptr pointer to the declaration statement to which this SgInitializedName belongs to
\param scope pointer to SgScopeStatement to explicitly represent the scope of the variable (required for ROSE, but mostly useful in C++)
\param itemptr the next SgInitializedName object in the parent declaration statement
\param prev_itemptr the previous SgInitializedName object in the parent declaration statement
\sa 
\ref SgInitializedName_create "Example:create an SgInitializedName object"
*/
/*!
\fn SgInitializedName::SgInitializedName(const SgInitializedName &ptr)
\brief This is the copy constructor
*/
/*!\fn SgInitializedName::SgInitializedName(const SgInitializedNameStorageClass &source)
*/
/*!\fn bool SgInitializedName::operator<(const SgInitializedName &) const
*/
/*!\fn bool SgInitializedName::operator==(const SgInitializedName &) const
*/
/*!\fn inline static void SgInitializedName::operator delete(void *pointer)
*/
/*!\fn static SgInitializedName *SgInitializedName::getPointerFromGlobalIndex(AstSpecificDataManagingClass *astInPool,unsigned long globalIndex)
*/
/*!\fn static unsigned long SgInitializedName::getNumberOfLastValidPointer()
*/
/*!\fn static unsigned long SgInitializedName::getNumberOfValidNodesAndSetGlobalIndexInFreepointer(unsigned long )
*/
/*!\fn static unsigned long SgInitializedName::initializeStorageClassArray(SgInitializedNameStorageClass *storageArray)
*/
/*!\fn static void SgInitializedName::clearMemoryPool()
*/
/*!\fn static void SgInitializedName::extendMemoryPoolForFileIO()
*/
/*!\fn static void SgInitializedName::resetValidFreepointers()
*/
/*!\fn virtual RTIReturnType SgInitializedName::roseRTI()
*/
/*!\fn virtual SgInitializedName::~SgInitializedName()
*/
/*!
\fn virtual SgNode *SgInitializedName::copy(SgCopyHelp &help) const
\brief It clones the current SgInitializedName object recursively or not, depending on the argument
\param help - If this argument is of type SgTreeCopy, then the
SgInitializedName is cloned recursively. If it's of type SgShallowCopy
only the first level of SgInitializedName is copied, everything else
pointing to the the original SgInitializedName object's data members.
\return a pointer to the new clone.
*/
/*!\fn virtual bool SgInitializedName::cfgIsIndexInteresting(unsigned int index) const
*/
/*!\fn virtual std::vector< VirtualCFG::CFGEdge  , std::allocator< VirtualCFG::CFGEdge  >  > SgInitializedName::cfgInEdges(unsigned int index)
*/
/*!\fn virtual std::vector< VirtualCFG::CFGEdge  , std::allocator< VirtualCFG::CFGEdge  >  > SgInitializedName::cfgOutEdges(unsigned int index)
*/
/*!\fn virtual unsigned int SgInitializedName::cfgFindChildIndex(SgNode *n)
*/
/*!\fn virtual unsigned int SgInitializedName::cfgFindNextChildIndex(SgNode *n)
*/
/*!\fn virtual unsigned int SgInitializedName::cfgIndexForEnd() const
*/
/*!\fn virtual void SgInitializedName::fixupCopy_references(SgNode *copy,SgCopyHelp &help) const
*/
/*!\fn virtual void SgInitializedName::fixupCopy_scopes(SgNode *copy,SgCopyHelp &help) const
*/
/*!\fn virtual void SgInitializedName::fixupCopy_symbols(SgNode *copy,SgCopyHelp &help) const
*/
/*!
\fn virtual void SgInitializedName::post_construction_initialization()
\brief Allocates a new storage modifier and sets the storage modifier to default values
*/
/*!\fn virtual void SgInitializedName::set_attributeMechanism(AstAttributeMechanism *attributeMechanism)
\brief \brief See  *attributeMechanism)
attributeMechanism for documentation */
/*!\fn virtual void SgInitializedName::set_file_info(Sg_File_Info *X)
\brief \brief See  *X)
file_info for documentation */
/*!\fn void SgInitializedName::set_declptr(SgDeclarationStatement *declptr)
\brief \brief See  *declptr)
declptr for documentation */
/*!\fn void SgInitializedName::set_definition(SgDeclarationStatement *def)
\brief \brief See  *def)
definition for documentation */
/*!\fn void SgInitializedName::set_initializationDeferred(bool initializationDeferred)
\brief \brief See  initializationDeferred)
initializationDeferred for documentation */
/*!\fn void SgInitializedName::set_initializer(SgInitializer *i)
\brief \brief See  *i)
initializer for documentation */
/*!\fn void SgInitializedName::set_initptr(SgInitializer *initptr)
\brief \brief See  *initptr)
initptr for documentation */
/*!\fn void SgInitializedName::set_name(SgName name)
\brief \brief See  name)
name for documentation */
/*!\fn void SgInitializedName::set_preinitialization(enum SgInitializedName::preinitialization_enum preinitialization)
\brief \brief See  preinitialization)
preinitialization for documentation */
/*!\fn void SgInitializedName::set_prev_decl_item(SgInitializedName *prev_decl_item)
\brief \brief See  *prev_decl_item)
prev_decl_item for documentation */
/*!\fn void SgInitializedName::set_register_name_code(enum SgInitializedName::asm_register_name_enum register_name_code)
\brief \brief See  register_name_code)
register_name_code for documentation */
/*!\fn void SgInitializedName::set_register_name_string(std::string register_name_string)
\brief \brief See  register_name_string)
register_name_string for documentation */
/*!\fn void SgInitializedName::set_requiresGlobalNameQualificationOnType(bool requiresGlobalNameQualificationOnType)
\brief \brief See  requiresGlobalNameQualificationOnType)
requiresGlobalNameQualificationOnType for documentation */
/*!\fn void SgInitializedName::set_scope(SgScopeStatement *scope)
\brief \brief See  *scope)
scope for documentation */
/*!\fn void SgInitializedName::set_shapeDeferred(bool shapeDeferred)
\brief \brief See  shapeDeferred)
shapeDeferred for documentation */
/*!\fn void SgInitializedName::set_startOfConstruct(Sg_File_Info *startOfConstruct)
\brief \brief See  *startOfConstruct)
startOfConstruct for documentation */
/*!\fn void SgInitializedName::set_type(SgType *t)
\brief \brief See  *t)
type for documentation */
/*!\fn void SgInitializedName::set_typeptr(SgType *typeptr)
\brief \brief See  *typeptr)
typeptr for documentation */
/*!
\fn SgDeclarationStatement *SgInitializedName::get_declaration() const
\brief Equal operator : it checks if all the data members are the same or point to the same objectsSee  const
declaration for documentation 
\returns Pointer to SgDeclarationStatement
*/
/*!\fn SgDeclarationStatement *SgInitializedName::get_declptr() const
\brief \brief See  const
declptr for documentation */
/*!\fn SgDeclarationStatement *SgInitializedName::get_definition() const
\brief \brief See  const
definition for documentation */
/*!\fn SgInitializedName *SgInitializedName::get_prev_decl_item() const
\brief \brief See  const
prev_decl_item for documentation */
/*!\fn SgInitializer *SgInitializedName::get_initializer() const
\brief \brief See  const
initializer for documentation */
/*!\fn SgInitializer *SgInitializedName::get_initptr() const
\brief \brief See  const
initptr for documentation */
/*!\fn SgName SgInitializedName::get_name() const
\brief \brief See  const
name for documentation */
/*!\fn SgScopeStatement *SgInitializedName::get_scope() const
\brief \brief See  const
scope for documentation */
/*!
\fn SgStorageModifier &SgInitializedName::get_storageModifier()
\brief returns a reference to the storage modifierSee  &SgInitializedName::storageModifier for documentation 
*/
/*!\fn SgType *SgInitializedName::get_type() const
\brief \brief See  const
type for documentation */
/*!\fn SgType *SgInitializedName::get_typeptr() const
\brief \brief See  const
typeptr for documentation */
/*!\fn bool SgInitializedName::get_initializationDeferred() const
\brief \brief See  const
initializationDeferred for documentation */
/*!\fn bool SgInitializedName::get_requiresGlobalNameQualificationOnType() const
\brief \brief See  const
requiresGlobalNameQualificationOnType for documentation */
/*!\fn bool SgInitializedName::get_shapeDeferred() const
\brief \brief See  const
shapeDeferred for documentation */
/*!\fn enum SgInitializedName::asm_register_name_enum SgInitializedName::get_register_name_code() const
\brief \brief See  const
register_name_code for documentation */
/*!\fn enum SgInitializedName::preinitialization_enum SgInitializedName::get_preinitialization() const
\brief \brief See  const
preinitialization for documentation */
/*!\fn std::string SgInitializedName::get_register_name_string() const
\brief \brief See  const
register_name_string for documentation */
/*!\fn virtual AstAttributeMechanism *SgInitializedName::get_attributeMechanism() const
\brief \brief See  const
attributeMechanism for documentation */
/*!\fn virtual SgName SgInitializedName::get_mangled_name() const
\brief \brief See  const
mangled_name for documentation */
/*!\fn virtual SgNode *SgInitializedName::get_traversalSuccessorByIndex(size_t idx)
\brief \brief See  idx)
traversalSuccessorByIndex for documentation */
/*!\fn virtual Sg_File_Info *SgInitializedName::get_file_info() const
\brief \brief See  const
file_info for documentation */
/*!\fn virtual Sg_File_Info *SgInitializedName::get_startOfConstruct() const
\brief \brief See  const
startOfConstruct for documentation */
/*!\fn virtual size_t SgInitializedName::get_childIndex(SgNode *child)
\brief \brief See  *child)
childIndex for documentation */
/*!\fn virtual size_t SgInitializedName::get_numberOfTraversalSuccessors()
\brief \brief See  SgInitializedName::numberOfTraversalSuccessors for documentation */
/*!\fn virtual std::vector< SgNode * , std::allocator< SgNode * >  > SgInitializedName::get_traversalSuccessorContainer()
\brief \brief See  SgInitializedName::traversalSuccessorContainer for documentation */
/*!\fn virtual std::vector< std::string  , std::allocator< std::string  >  > SgInitializedName::get_traversalSuccessorNamesContainer()
\brief \brief See  SgInitializedName::traversalSuccessorNamesContainer for documentation */
/*!\fn SgInitializedName::SgInitializedName()
*/
//@}
int SAGE_Doxygen_Dummy_194862206317986;

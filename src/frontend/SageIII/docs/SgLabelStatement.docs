/* GENERATED FILE - DO NOT MODIFY */
//////////////////////////////////////////////////////////////////////////
// Documentation for class SgLabelStatement
//////////////////////////////////////////////////////////////////////////
/*!
\class SgLabelStatement
\brief This class represents the concept of a C or C++ label statement.
    The label statment is used for labels asociated with goto statements.
    A label construct in C++ has a statement associated with it,
this concept is not represented in ROSE, but is one of the ways 
that IPR differs from ROSE.  It seems that EDG accepts the representation of
a label without a statement as an extension (ref Peter).  An empty
statement is an alternative representation:
    label:;
instead of
    label:
To handle the case where a label is used without an associated statement
ROSE will unparse: "LABEL:;"
to avoid generating cases without an associated statement.  The "empty
statement" represented by ";" is ignored and so will not cause an error
or change the semantics.
\internal  Since the label statment does not define a scope, it is not clear that
we want to attach a sequence of statements to the label which would only be
traversed through the label statement.  We could alternatively fixup
label statements to internally reference their next statement if it
exists, or an empty statement (e.g. ";") if it did not exist.  The problem
with a internal reference is that it serves on particular purpose, and represent
a muptiple refeence to it's associated statement (which could cause bugs
within transformations), so the current design might be best.
\todo Review if we want to have the label statement reference it's 
associated statement (it would be a redundent reference, since the next
statement is already in the list of statements for the scope).
\sa
\ref SgLabelStatement_usage  "Example of using a SgLabelStatement object"
*/
//////////////////////////////////////////////////////////////////////////
// Documentation for class SgLabelStatement data members
/////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
// Documentation for class SgLabelStatement member functions (methods)
/////////////////////////////////////////////////////////////////////////
/*
\sa 
\ref SgLabelStatement_create "Example:create an SgLabelStatement object"
*/
/*!
\fn SgLabelStatement::~SgLabelStatement()
\brief This is the destructor.
   There are a lot of things to delete, but nothing is deleted in this destructor.
*/
/*!
\fn SgLabelStatement::isSgLabelStatement (SgNode *s)
\brief Cast function (from derived class to SgLabelStatement pointer).
   This functions returns a SgLabelStatement pointer for any input of a 
pointer to an object derived from a SgLabelStatement.
\return Returns valid pointer to SgLabelStatement if input is derived from a SgLocatedNode.
*/
/*!
\fn SgLabelStatement::isSgLabelStatement (const SgNode *s)
\brief Cast function (from derived class to SgLabelStatement pointer).
   This functions returns a SgLabelStatement pointer for any input of a 
pointer to an object derived from a SgLabelStatement.
\return Returns valid pointer to SgLabelStatement if input is derived from a SgLocatedNode.
*/
/*! \name Class Members*/
//@{
/*! \var SgName SgLabelStatement::p_label
\brief This a SgName object which stores the name of the label.
*/
/*!\var SgScopeStatement *SgLabelStatement::p_scope
*/
/*!\var SgStatement *SgLabelStatement::p_statement
*/
/*!\var bool SgLabelStatement::p_gnu_extension_unused
*/
//@}
/*! \name User Interface*/
//@{
/*!\fn SgLabelStatement::SgLabelStatement(Sg_File_Info *startOfConstruct,SgName label=(""),SgStatement *statement=(0))
*/
/*!\fn SgLabelStatement::SgLabelStatement(const SgLabelStatementStorageClass &source)
*/
/*!\fn inline static void SgLabelStatement::operator delete(void *pointer)
*/
/*!\fn static SgLabelStatement *SgLabelStatement::getPointerFromGlobalIndex(AstSpecificDataManagingClass *astInPool,unsigned long globalIndex)
*/
/*!\fn static unsigned long SgLabelStatement::getNumberOfLastValidPointer()
*/
/*!\fn static unsigned long SgLabelStatement::getNumberOfValidNodesAndSetGlobalIndexInFreepointer(unsigned long )
*/
/*!\fn static unsigned long SgLabelStatement::initializeStorageClassArray(SgLabelStatementStorageClass *storageArray)
*/
/*!\fn static void SgLabelStatement::clearMemoryPool()
*/
/*!\fn static void SgLabelStatement::extendMemoryPoolForFileIO()
*/
/*!\fn static void SgLabelStatement::resetValidFreepointers()
*/
/*!\fn virtual RTIReturnType SgLabelStatement::roseRTI()
*/
/*!\fn virtual SgLabelStatement::~SgLabelStatement()
*/
/*!\fn virtual SgNode *SgLabelStatement::copy(SgCopyHelp &help) const
*/
/*!\fn virtual std::vector< VirtualCFG::CFGEdge  , std::allocator< VirtualCFG::CFGEdge  >  > SgLabelStatement::cfgInEdges(unsigned int index)
*/
/*!\fn virtual std::vector< VirtualCFG::CFGEdge  , std::allocator< VirtualCFG::CFGEdge  >  > SgLabelStatement::cfgOutEdges(unsigned int index)
*/
/*!\fn virtual unsigned int SgLabelStatement::cfgIndexForEnd() const
*/
/*!\fn virtual void SgLabelStatement::fixupCopy_references(SgNode *copy,SgCopyHelp &help) const
*/
/*!\fn virtual void SgLabelStatement::fixupCopy_scopes(SgNode *copy,SgCopyHelp &help) const
*/
/*!\fn virtual void SgLabelStatement::fixupCopy_symbols(SgNode *copy,SgCopyHelp &help) const
*/
/*!\fn virtual void SgLabelStatement::post_construction_initialization()
*/
/*!\fn virtual void SgLabelStatement::set_scope(SgScopeStatement *scope)
\brief \brief See  *scope)
scope for documentation */
/*!\fn void SgLabelStatement::set_gnu_extension_unused(bool gnu_extension_unused)
\brief \brief See  gnu_extension_unused)
gnu_extension_unused for documentation */
/*!
\fn void SgLabelStatement::set_label(SgName label)
\brief Access function for p_label.See  label)
label for documentation 
\return Returns void.
*/
/*!\fn void SgLabelStatement::set_statement(SgStatement *statement)
\brief \brief See  *statement)
statement for documentation */
/*!
\fn SgName SgLabelStatement::get_label() const
\brief Returns SgName by value.See  const
label for documentation 
\return Returns SgName.
*/
/*!\fn SgName SgLabelStatement::get_name() const
\brief \brief See  const
name for documentation */
/*!\fn SgStatement *SgLabelStatement::get_statement() const
\brief \brief See  const
statement for documentation */
/*!\fn bool SgLabelStatement::get_gnu_extension_unused() const
\brief \brief See  const
gnu_extension_unused for documentation */
/*!\fn virtual SgNode *SgLabelStatement::get_traversalSuccessorByIndex(size_t idx)
\brief \brief See  idx)
traversalSuccessorByIndex for documentation */
/*!\fn virtual SgScopeStatement *SgLabelStatement::get_scope() const
\brief \brief See  const
scope for documentation */
/*!\fn virtual SgSymbol *SgLabelStatement::get_symbol_from_symbol_table() const
\brief \brief See  const
symbol_from_symbol_table for documentation */
/*!\fn virtual size_t SgLabelStatement::get_childIndex(SgNode *child)
\brief \brief See  *child)
childIndex for documentation */
/*!\fn virtual size_t SgLabelStatement::get_numberOfTraversalSuccessors()
\brief \brief See  SgLabelStatement::numberOfTraversalSuccessors for documentation */
/*!\fn virtual std::vector< SgNode * , std::allocator< SgNode * >  > SgLabelStatement::get_traversalSuccessorContainer()
\brief \brief See  SgLabelStatement::traversalSuccessorContainer for documentation */
/*!\fn virtual std::vector< std::string  , std::allocator< std::string  >  > SgLabelStatement::get_traversalSuccessorNamesContainer()
\brief \brief See  SgLabelStatement::traversalSuccessorNamesContainer for documentation */
/*!
\fn SgLabelStatement::SgLabelStatement(SgName label,SgStatement *statement)
\brief This is the constructor.
   This constructor builds the SgLabelStatement base class.
\param startOfConstruct represents the position in the source code
*/
//@}
int SAGE_Doxygen_Dummy_13115139304113;

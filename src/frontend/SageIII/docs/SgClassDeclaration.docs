/* GENERATED FILE - DO NOT MODIFY */
//////////////////////////////////////////////////////////////////////////
// Documentation for class SgDeclarationStatement
//////////////////////////////////////////////////////////////////////////
/*!
\class SgClassDeclaration
\brief This class represents the concept of a class declaration statement. It includes the
concept of an instantiated class template as well.
    Declaration statements are where variables and types are
defined and become available for use within a program.  Declarations
are strored in symbols (\ref SgSymbol) and used to associate
the symbol with a location within a scope within the application 
source code.  There are many different types of declarations, within Sage III
the SgDeclaration forms a base class for numerous IR nodes such as:
class declarations (including structs and unions), enum declarations,
function declarations, namespace declarations, pragma declarations,
template declarations, typedef declarations, using declarations,
using directives, variable declarations, etc.
   An important concept for a few types fo declarations is that
of defining vs. non-defining.  Defining declarations are associated with
definitions, for example a class definition or function definition.
A class declaration where a class is defined (instead of a forward 
declaration) is a defining declaration.  A forward declaration is
a non-defining declaration.  Some declarations are not explicitly 
forward declarations, they are non-defining declarations.  Only 
declarations where there is a definition are defining declarations. 
Because definitions can at most appear once within a translation unit 
(a source file and it included header files), there is at most one
defining declaration.  The defining declaration is never shared,
however the non-defining declaration can be shared and is required 
to be shared if there is more than one location in the AST where 
a non-defining declaration is required.  There is at most one
defining and one non-defining declaration (at some point they will
also share their name, but this is not implemented yet).  If a variable
is defined to be extern or only defined through a refererence or pointer, 
then there would be no defining declaration (only a non-defining declaration).
   The following code contains no defining declaration for the 
type "foobar": \n
     typedef struct foobar *((FunctionPointer)(void);\n
     foobar* foobar_pointer = NULL; \n
and yet is vailid code (even though there is no explicit forward declaration
of "foobar" as a class (or struct).  In this case foobar is represented
using a non-defining declaration internally and that declaration is 
reference multiple types (once within each statement).  Note that
the code abouve is valid C++, and not valid C code (to make it valid C code 
we would have to add "struct" the pointer declaration, for example:
     struct foobar* foobar_pointer = NULL; \n
So C++ is not always a super set of C :-).
Different types of declarations explained: \n
    C and C++ declarations can come in several forms, for example: \n
typedef struct { int A; } A; // unnamed class declaration (which gets a name from the typedef) \n
struct A { int i; };         // autonomous declaration \n
struct B { int i; } b;       // non autonomous declaration \n
In these cases "struct" and "class" can be used interchangablily. Internally 
"struct" and "class" are he same (but with a different enum to classify them,
see SgNameType and SgClassType).  Clearly most C++ code uses autonomous 
declarations.
    There are no uses of this IR node anywhere.  All statements
are derived from this SgClassDeclaration class.
\internal This is a base class for all statements.
\sa
\ref SgClassDeclaration_usage  "Example of using a SgClassDeclaration object"
*/
//////////////////////////////////////////////////////////////////////////
// Documentation for class SgClassDeclaration data members
/////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
// Documentation for class SgClassDeclaration member functions (methods)
/////////////////////////////////////////////////////////////////////////
/*!
\fn SgClassDeclaration::~SgClassDeclaration()
\brief This is the destructor.
   There are a lot of things to delete, but nothing is deleted in this destructor.
*/
/*!
\fn SgClassDeclaration::isSgClassDeclaration (SgNode *s)
\brief Cast function (from derived class to SgClassDeclaration pointer).
   This functions returns a SgClassDeclaration pointer for any input of a 
pointer to an object derived from a SgClassDeclaration.
\return Returns valid pointer to SgClassDeclaration if input is derived from a SgLocatedNode.
*/
/*!
\fn SgClassDeclaration::isSgClassDeclaration (const SgNode *s)
\brief Cast function (from derived class to SgClassDeclaration pointer).
   This functions returns a SgClassDeclaration pointer for any input of a 
pointer to an object derived from a SgClassDeclaration.
\return Returns valid pointer to SgClassDeclaration if input is derived from a SgLocatedNode.
*/
/*! \name Class Members*/
//@{
/*!
\var SgClassDefinition *SgClassDeclaration::p_definition
\brief This is the class definition (alway a valid pointer, except for explicitly marked
    forward declarations).
   When this is a defining or nondefining declartion the p_definition pointer is
always valid.  However, as a separate rule, all forward declarations are both
makred explicit as forward declarations AND have a NULL value for their p_definition 
pointer.
\internal The declaration associated with the definition is the defining declaration and
    may not be the same as that pointed to by the "this" pointer.
*/
/*!
\var SgClassType *SgClassDeclaration::p_type
\brief This is the type used in the declaration (SgClassType).
*/
/*!
\var SgName SgClassDeclaration::p_name
\brief This is the name of the class or instantiated class template
\internal The value held is not shared within the Sage III AST.
*/
/*!\var SgScopeStatement *SgClassDeclaration::p_scope
*/
/*!\var bool SgClassDeclaration::p_fixupScope
*/
/*!
\var bool SgClassDeclaration::p_from_template
\brief This records if the class declaration is associated with a template.
   This boolean value is set to true if this is a non-template class nested 
in a templated class.  We have an explicit IR node for template classes, but
this is only flag to indicate that several template specific rules apply to
the declaration of this class if the value is true.  For example, the class
will not be output unless it is transformed, then the required specialization 
is required for the parent templated class.
\internal It is set internally and there is no need for it to be set by the user!
*/
/*!
\var enum SgClassDeclaration::class_types SgClassDeclaration::p_class_type
\brief Enum value classifying this as a class,struct,or union.
\internal The enum type is also defined in this class.
*/
/*!\var enum SgDeclarationStatement::template_specialization_enum SgClassDeclaration::p_specialization
*/
/*!\var bool SgClassDeclaration::p_isUnNamed
*/
//@}
/*! \name User Interface*/
//@{
/*!\fn SgClassDeclaration::SgClassDeclaration(Sg_File_Info *startOfConstruct,SgName name=(""),enum SgClassDeclaration::class_types class_type=SgClassDeclaration::e_class,SgClassType *type=(0),SgClassDefinition *definition=(0))
*/
/*!\fn SgClassDeclaration::SgClassDeclaration(const SgClassDeclarationStorageClass &source)
*/
/*!\fn SgClassDefinition *SgClassDeclaration::compute_classDefinition() const
*/
/*!\fn bool SgClassDeclaration::isPartialSpecialization() const
*/
/*!\fn bool SgClassDeclaration::isSpecialization() const
*/
/*!\fn inline static void SgClassDeclaration::operator delete(void *pointer)
*/
/*!\fn static SgClassDeclaration *SgClassDeclaration::getPointerFromGlobalIndex(AstSpecificDataManagingClass *astInPool,unsigned long globalIndex)
*/
/*!\fn static unsigned long SgClassDeclaration::getNumberOfLastValidPointer()
*/
/*!\fn static unsigned long SgClassDeclaration::getNumberOfValidNodesAndSetGlobalIndexInFreepointer(unsigned long )
*/
/*!\fn static unsigned long SgClassDeclaration::initializeStorageClassArray(SgClassDeclarationStorageClass *storageArray)
*/
/*!\fn static void SgClassDeclaration::clearMemoryPool()
*/
/*!\fn static void SgClassDeclaration::extendMemoryPoolForFileIO()
*/
/*!\fn static void SgClassDeclaration::resetValidFreepointers()
*/
/*!\fn virtual RTIReturnType SgClassDeclaration::roseRTI()
*/
/*!\fn virtual SgClassDeclaration::~SgClassDeclaration()
*/
/*!\fn virtual SgNode *SgClassDeclaration::copy(SgCopyHelp &help) const
*/
/*!\fn virtual bool SgClassDeclaration::replace_child(SgStatement *,SgStatement *,bool extractListFromBasicBlock=false)
*/
/*!\fn virtual std::vector< VirtualCFG::CFGEdge  , std::allocator< VirtualCFG::CFGEdge  >  > SgClassDeclaration::cfgInEdges(unsigned int index)
*/
/*!\fn virtual std::vector< VirtualCFG::CFGEdge  , std::allocator< VirtualCFG::CFGEdge  >  > SgClassDeclaration::cfgOutEdges(unsigned int index)
*/
/*!\fn virtual unsigned int SgClassDeclaration::cfgIndexForEnd() const
*/
/*!\fn virtual void SgClassDeclaration::fixupCopy_references(SgNode *copy,SgCopyHelp &help) const
*/
/*!\fn virtual void SgClassDeclaration::fixupCopy_scopes(SgNode *copy,SgCopyHelp &help) const
*/
/*!\fn virtual void SgClassDeclaration::fixupCopy_symbols(SgNode *copy,SgCopyHelp &help) const
*/
/*!\fn virtual void SgClassDeclaration::post_construction_initialization()
*/
/*!\fn virtual void SgClassDeclaration::set_scope(SgScopeStatement *scope)
\description See  *scope)
scope for documentation */
/*!\fn void SgClassDeclaration::set_class_type(enum SgClassDeclaration::class_types class_type)
\description See  class_type)
class_type for documentation */
/*!\fn void SgClassDeclaration::set_definition(SgClassDefinition *definition)
\description See  *definition)
definition for documentation */
/*!\fn void SgClassDeclaration::set_fixupScope(bool fixupScope)
\description See  fixupScope)
fixupScope for documentation */
/*!\fn void SgClassDeclaration::set_from_template(bool from_template)
\description See  from_template)
from_template for documentation */
/*!\fn void SgClassDeclaration::set_isUnNamed(bool isUnNamed)
\description See  isUnNamed)
isUnNamed for documentation */
/*!\fn void SgClassDeclaration::set_name(SgName name)
\description See  name)
name for documentation */
/*!\fn void SgClassDeclaration::set_specialization(enum SgDeclarationStatement::template_specialization_enum specialization)
\description See  specialization)
specialization for documentation */
/*!\fn void SgClassDeclaration::set_type(SgClassType *type)
\description See  *type)
type for documentation */
/*!\fn SgClassDefinition *SgClassDeclaration::get_definition() const
\description See  const
definition for documentation */
/*!\fn SgClassType *SgClassDeclaration::get_type() const
\description See  const
type for documentation */
/*!\fn SgName SgClassDeclaration::get_name() const
\description See  const
name for documentation */
/*!\fn bool SgClassDeclaration::get_fixupScope() const
\description See  const
fixupScope for documentation */
/*!\fn bool SgClassDeclaration::get_from_template() const
\description See  const
from_template for documentation */
/*!\fn bool SgClassDeclaration::get_isUnNamed() const
\description See  const
isUnNamed for documentation */
/*!\fn enum SgClassDeclaration::class_types SgClassDeclaration::get_class_type() const
\description See  const
class_type for documentation */
/*!\fn enum SgDeclarationStatement::template_specialization_enum SgClassDeclaration::get_specialization() const
\description See  const
specialization for documentation */
/*!\fn virtual SgName SgClassDeclaration::get_mangled_name() const
\description See  const
mangled_name for documentation */
/*!\fn virtual SgName SgClassDeclaration::get_qualified_name() const
\description See  const
qualified_name for documentation */
/*!\fn virtual SgNode *SgClassDeclaration::get_traversalSuccessorByIndex(size_t idx)
\description See  idx)
traversalSuccessorByIndex for documentation */
/*!\fn virtual SgScopeStatement *SgClassDeclaration::get_scope() const
\description See  const
scope for documentation */
/*!\fn virtual SgSymbol *SgClassDeclaration::get_symbol_from_symbol_table() const
\description See  const
symbol_from_symbol_table for documentation */
/*!\fn virtual size_t SgClassDeclaration::get_childIndex(SgNode *child)
\description See  *child)
childIndex for documentation */
/*!\fn virtual size_t SgClassDeclaration::get_numberOfTraversalSuccessors()
\description See  SgClassDeclaration::numberOfTraversalSuccessors for documentation */
/*!\fn virtual std::vector< SgNode * , std::allocator< SgNode * >  > SgClassDeclaration::get_traversalSuccessorContainer()
\description See  SgClassDeclaration::traversalSuccessorContainer for documentation */
/*!\fn virtual std::vector< std::string  , std::allocator< std::string  >  > SgClassDeclaration::get_traversalSuccessorNamesContainer()
\description See  SgClassDeclaration::traversalSuccessorNamesContainer for documentation */
/*!
\fn SgClassDeclaration::SgClassDeclaration(SgName name,enum SgClassDeclaration::class_types class_type,SgClassType *type,SgClassDefinition *definition)
\brief This is the only constructor.
   This constructor builds the SgClassDeclaration base class. but has some specific
side-effects (some of which have been removed in the latest work).  It is however
still that case that if the definition is provided then it's declaration will be changed
to the declaration being constructed (a warning message it output if this happens and
this side-effect will be removed soon).
\param startOfConstruct represents the position in the source code
\sa 
\ref SgClassDeclaration_create "Example:create an SgClassDeclaration object"
*/
//@}
int SAGE_Doxygen_Dummy_14247175216642;

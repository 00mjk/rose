/* GENERATED FILE - DO NOT MODIFY */
//////////////////////////////////////////////////////////////////////////
// Documentation for class SgTypedefDeclaration
//////////////////////////////////////////////////////////////////////////
/*!
\class SgTypedefDeclaration
\brief This class represents the notion of a typedef declaration.
   Typedefs define new types for use in variable declarations, function parameter 
lists, etc.  Typically the base type is complex and the typedef name allows the 
more complex types use to be made easier to read.
\todo There are a few data members in this field that don't appear to be used (should be
    removed if not required):
     - p_declaration: have not seen it be used anywhere (I think it is used when a
       declartion is explicit in the typedef, check this out, might be part of older
       mechanism before defining and nondefining declarations were developed to provide a
       uniform mechanism for all declarations)
     - p_parent_scope: this is a SgSymbol, but I don't know why it is stored explicitly.
\sa
\ref SgTypedefDeclaration_usage  "Example of using a SgTypedefDeclaration object"
*/
//////////////////////////////////////////////////////////////////////////
// Documentation for class SgTypedefDeclaration data members
/////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
// Documentation for class SgTypedefDeclaration member functions (methods)
/////////////////////////////////////////////////////////////////////////
/*!
\fn SgTypedefDeclaration::~SgTypedefDeclaration()
\brief This is the destructor.
   There is nothing to delete in this object.
*/
/*!
\fn SgTypedefDeclaration::isSgTypedefDeclaration (SgNode *s)
\brief Cast function (from derived class to SgTypedefDeclaration pointer).
   This functions returns a SgTypedefDeclaration pointer for any input of a 
pointer to an object derived from a SgTypedefDeclaration.
\return Returns valid pointer to SgTypedefDeclaration if input is derived from a SgLocatedNode.
*/
/*!
\fn SgTypedefDeclaration::isSgTypedefDeclaration (const SgNode *s)
\brief Cast function (from derived class to SgTypedefDeclaration pointer).
   This functions returns a SgTypedefDeclaration pointer for any input of a 
pointer to an object derived from a SgTypedefDeclaration.
\return Returns valid pointer to SgTypedefDeclaration if input is derived from a SgLocatedNode.
*/
/*! \name Deprecated*/
//@{
/*!
\var SgSymbol *SgTypedefDeclaration::p_parent_scope
\brief This is the type symbol of the class when it is a member type (redundent with the
    the explicitly stored scope).
    This pointer almost always NULL, however test2005_188.C demonstrates a non-NULL value.
\internal This is redundant with the explicitly stored scope.
\todo We can remove this.
\deprecated This should be removed, but and get_scope used instead.
*/
//@}
/*! \name Class Members*/
//@{
/*!
\var SgDeclarationStatement *SgTypedefDeclaration::p_declaration
\brief pointer to the declaration (typically a SgClassDeclaration).
   A typedef such as "typedef struct {int __pos; int __state;} _G_fpos64_t;"
defines a class as part of its declaration.  p_declaration pointes to the
declaration in these cases.
\internal This is the class declaration in a typedef that defines a class.
*/
/*!
\var SgName SgTypedefDeclaration::p_name
\brief This is the name of the newly defined type.
\internal This name carries no qualification.
*/
/*!
\var SgScopeStatement *SgTypedefDeclaration::p_scope
\brief This is the scope of the typedef declaration.
\internal Comment on why we need to store the scope explicitly (resolves name
    qualification issues).
*/
/*!
\var SgType *SgTypedefDeclaration::p_base_type
\brief This is the type being given a new name by the typedef declaration.
\internal This name can be private so using the base type directly can cause access
    violations within generated code.
*/
/*!
\var SgTypedefType *SgTypedefDeclaration::p_type
\brief This is the resulting type defined by the typedef declaration.
    This type can be used where any type can be use, declaration of variables, etc.
\internal Because of access privileges on the typedef declaration the resulting type can
    have access restrictions.
*/
/*!
\var bool SgTypedefDeclaration::p_typedefBaseTypeContainsDefiningDeclaration
\brief This flag indicates that the typedef defines a structure
\example typedefExample.C
    This example show the definition of a struct within the typedef.
\internal I would like to give this a better name.
*/
/*!\var bool SgTypedefDeclaration::p_requiresGlobalNameQualificationOnType
*/
//@}
/*! \name User Interface*/
//@{
/*!\fn SgTypedefDeclaration::SgTypedefDeclaration(Sg_File_Info *startOfConstruct,SgName name=(""),SgType *base_type=(0),SgTypedefType *type=(0),SgDeclarationStatement *declaration=(0),SgSymbol *parent_scope=(0))
*/
/*!
\fn SgTypedefDeclaration::SgTypedefDeclaration(const SgTypedefDeclarationStorageClass &source)
\brief This is the constructor.
   This constructor builds the SgTypedefDeclaration base class.
\param startOfConstruct represents the position in the source code
\sa 
\ref SgTypedefDeclaration_create "Example:create an SgTypedefDeclaration object"
*/
/*!\fn inline static void SgTypedefDeclaration::operator delete(void *pointer)
*/
/*!\fn static SgTypedefDeclaration *SgTypedefDeclaration::getPointerFromGlobalIndex(AstSpecificDataManagingClass *astInPool,unsigned long globalIndex)
*/
/*!\fn static unsigned long SgTypedefDeclaration::getNumberOfLastValidPointer()
*/
/*!\fn static unsigned long SgTypedefDeclaration::getNumberOfValidNodesAndSetGlobalIndexInFreepointer(unsigned long )
*/
/*!\fn static unsigned long SgTypedefDeclaration::initializeStorageClassArray(SgTypedefDeclarationStorageClass *storageArray)
*/
/*!\fn static void SgTypedefDeclaration::clearMemoryPool()
*/
/*!\fn static void SgTypedefDeclaration::extendMemoryPoolForFileIO()
*/
/*!\fn static void SgTypedefDeclaration::resetValidFreepointers()
*/
/*!\fn virtual RTIReturnType SgTypedefDeclaration::roseRTI()
*/
/*!\fn virtual SgNode *SgTypedefDeclaration::copy(SgCopyHelp &help) const
*/
/*!\fn virtual SgTypedefDeclaration::~SgTypedefDeclaration()
*/
/*!\fn virtual bool SgTypedefDeclaration::replace_child(SgStatement *,SgStatement *,bool extractListFromBasicBlock=false)
*/
/*!\fn virtual std::vector< VirtualCFG::CFGEdge  , std::allocator< VirtualCFG::CFGEdge  >  > SgTypedefDeclaration::cfgInEdges(unsigned int index)
*/
/*!\fn virtual std::vector< VirtualCFG::CFGEdge  , std::allocator< VirtualCFG::CFGEdge  >  > SgTypedefDeclaration::cfgOutEdges(unsigned int index)
*/
/*!\fn virtual unsigned int SgTypedefDeclaration::cfgIndexForEnd() const
*/
/*!\fn virtual void SgTypedefDeclaration::fixupCopy_references(SgNode *copy,SgCopyHelp &help) const
*/
/*!\fn virtual void SgTypedefDeclaration::fixupCopy_scopes(SgNode *copy,SgCopyHelp &help) const
*/
/*!\fn virtual void SgTypedefDeclaration::fixupCopy_symbols(SgNode *copy,SgCopyHelp &help) const
*/
/*!\fn virtual void SgTypedefDeclaration::post_construction_initialization()
*/
/*!\fn virtual void SgTypedefDeclaration::set_scope(SgScopeStatement *scope)
\description See  *scope)
scope for documentation */
/*!\fn void SgTypedefDeclaration::set_base_type(SgType *base_type)
\description See  *base_type)
base_type for documentation */
/*!\fn void SgTypedefDeclaration::set_declaration(SgDeclarationStatement *declaration)
\description See  *declaration)
declaration for documentation */
/*!\fn void SgTypedefDeclaration::set_name(SgName name)
\description See  name)
name for documentation */
/*!\fn void SgTypedefDeclaration::set_parent_scope(SgSymbol *parent_scope)
\description See  *parent_scope)
parent_scope for documentation */
/*!\fn void SgTypedefDeclaration::set_requiresGlobalNameQualificationOnType(bool requiresGlobalNameQualificationOnType)
\description See  requiresGlobalNameQualificationOnType)
requiresGlobalNameQualificationOnType for documentation */
/*!\fn void SgTypedefDeclaration::set_type(SgTypedefType *type)
\description See  *type)
type for documentation */
/*!\fn void SgTypedefDeclaration::set_typedefBaseTypeContainsDefiningDeclaration(bool typedefBaseTypeContainsDefiningDeclaration)
\description See  typedefBaseTypeContainsDefiningDeclaration)
typedefBaseTypeContainsDefiningDeclaration for documentation */
/*!\fn SgDeclarationStatement *SgTypedefDeclaration::get_declaration() const
\description See  const
declaration for documentation */
/*!\fn SgName SgTypedefDeclaration::get_name() const
\description See  const
name for documentation */
/*!\fn SgSymbol *SgTypedefDeclaration::get_parent_scope() const
\description See  const
parent_scope for documentation */
/*!\fn SgType *SgTypedefDeclaration::get_base_type() const
\description See  const
base_type for documentation */
/*!\fn SgTypedefType *SgTypedefDeclaration::get_type() const
\description See  const
type for documentation */
/*!\fn bool SgTypedefDeclaration::get_requiresGlobalNameQualificationOnType() const
\description See  const
requiresGlobalNameQualificationOnType for documentation */
/*!\fn bool SgTypedefDeclaration::get_typedefBaseTypeContainsDefiningDeclaration() const
\description See  const
typedefBaseTypeContainsDefiningDeclaration for documentation */
/*!\fn virtual SgName SgTypedefDeclaration::get_mangled_name() const
\description See  const
mangled_name for documentation */
/*!\fn virtual SgName SgTypedefDeclaration::get_qualified_name() const
\description See  const
qualified_name for documentation */
/*!\fn virtual SgNode *SgTypedefDeclaration::get_traversalSuccessorByIndex(size_t idx)
\description See  idx)
traversalSuccessorByIndex for documentation */
/*!
\fn virtual SgScopeStatement *SgTypedefDeclaration::get_scope() const
\brief Returns scope of current statement.
   This functions returns a pointer to the inner most SgScopeStatement where the current 
statement is located.
This is a function called after the parents have been set.  It is not called by the
EDG/SAGE interface and is only called after the SAGE AST has been built and the parent
pointers set within a separate phase.
Improtant exception: The SgFunctionParameterList should have as it's scope the
SgFunctionDefinition, but it is a sibling of the SgFunctionDefinition (both the
SgFunctionParameterList and the SgFunctionDefinition have the SgFunctionDeclaration
as a parent.  Thus the scope of the SgFunctionParameterList is computed to be the 
SgGlobal (global scope) most often; which is an error).  So we handle this case 
explicitly.
See  const
scope for documentation \return Returns valid pointer to SgScopeStatement.
*/
/*!\fn virtual SgSymbol *SgTypedefDeclaration::get_symbol_from_symbol_table() const
\description See  const
symbol_from_symbol_table for documentation */
/*!\fn virtual size_t SgTypedefDeclaration::get_childIndex(SgNode *child)
\description See  *child)
childIndex for documentation */
/*!\fn virtual size_t SgTypedefDeclaration::get_numberOfTraversalSuccessors()
\description See  SgTypedefDeclaration::numberOfTraversalSuccessors for documentation */
/*!\fn virtual std::vector< SgNode * , std::allocator< SgNode * >  > SgTypedefDeclaration::get_traversalSuccessorContainer()
\description See  SgTypedefDeclaration::traversalSuccessorContainer for documentation */
/*!\fn virtual std::vector< std::string  , std::allocator< std::string  >  > SgTypedefDeclaration::get_traversalSuccessorNamesContainer()
\description See  SgTypedefDeclaration::traversalSuccessorNamesContainer for documentation */
/*!\fn SgTypedefDeclaration::SgTypedefDeclaration(SgName name,SgType *base_type,SgTypedefType *type,SgDeclarationStatement *declaration,SgSymbol *parent_scope)
*/
//@}
int SAGE_Doxygen_Dummy_11134217614321;

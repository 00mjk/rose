
#include "KLT/Sequential/generator.hpp"
#include "KLT/Sequential/kernel.hpp"

#include "sage3basic.h"

#include <sstream>

#include <cassert>

namespace KLT {

namespace Sequential {

template <typename Symbol, typename Defn>
std::pair<Symbol *, Defn *> buildDeclAndDefn(
  const std::string & name,
  SgScopeStatement * decl_scope,
  SgScopeStatement * defn_scope,
  SgType * type = NULL
);

template <>
std::pair<SgClassSymbol *, SgClassDefinition *> buildDeclAndDefn<SgClassSymbol, SgClassDefinition>(
  const std::string & name,
  SgScopeStatement * decl_scope,
  SgScopeStatement * defn_scope,
  SgType * type
) {
  assert(type == NULL);
  assert(decl_scope != NULL && defn_scope != NULL);

  std::pair<SgClassSymbol *, SgClassDefinition *> result(NULL, NULL);

  SgClassDeclaration * class_decl = SageBuilder::buildNondefiningClassDeclaration(name, decl_scope);
  SageInterface::appendStatement(class_decl, decl_scope);

  assert(class_decl->get_definition() == NULL);

  // result.first = SageInterface::lookupClassSymbolInParentScopes(name, decl_scope);
  result.first = decl_scope->lookup_class_symbol(name);
  assert(result.first != NULL);
 
  SgClassDeclaration * class_defn = SageBuilder::buildDefiningClassDeclaration(name, defn_scope);
  SageInterface::appendStatement(class_defn, defn_scope);
 
  result.second = class_defn->get_definition();
  assert(result.second != NULL);
 
  class_decl->set_definingDeclaration(class_defn);
  class_decl->set_firstNondefiningDeclaration(class_decl);
 
  class_defn->set_definingDeclaration(class_defn);
  class_defn->set_firstNondefiningDeclaration(class_decl);

  return result;
}

template <>
std::pair<SgFunctionSymbol *, SgFunctionDefinition *> buildDeclAndDefn<SgFunctionSymbol , SgFunctionDefinition>(
  const std::string & name,
  SgScopeStatement * decl_scope,
  SgScopeStatement * defn_scope,
  SgType * type
) {
  assert(type != NULL);
  assert(decl_scope != NULL && defn_scope != NULL);
 
  std::pair<SgFunctionSymbol *, SgFunctionDefinition *> result(NULL, NULL);
 
  SgFunctionDeclaration * func_decl = SageBuilder::buildNondefiningFunctionDeclaration(name, decl_scope);
  SageInterface::appendStatement(func_decl, decl_scope);
 
  assert(func_decl->get_definition() == NULL);
 
  // result.first = SageInterface::lookupClassSymbolInParentScopes(name, decl_scope);
  result.first = decl_scope->lookup_class_symbol(name);
  assert(result.first != NULL);
 
  SgFunctionDeclaration * func_defn = SageBuilder::buildDefiningFunctionDeclaration(name, defn_scope);
  SageInterface::appendStatement(func_defn, defn_scope);
 
  result.second = func_defn->get_definition();
  assert(result.second != NULL);
 
  func_decl->set_definingDeclaration(func_defn);
  func_decl->set_firstNondefiningDeclaration(func_decl);
 
  func_defn->set_definingDeclaration(func_defn);
  func_defn->set_firstNondefiningDeclaration(func_decl);
 
  return result;
}

Kernel * Generator::makeKernel() const {
  return new Kernel();
}

void Generator::doCodeGeneration(Core::Kernel * kernel_, const Core::CG_Config & cg_config) {
  Kernel * kernel = dynamic_cast<Kernel *>(kernel_);
  assert(kernel != NULL);

  assert(kernel->isDataflowDone());
  assert(kernel->isArgumentDone());
  assert(kernel->isContentDone());

  SgScopeStatement * decl_scope = p_decl_file->get_globalScope();
  SgScopeStatement * defn_scope = p_defn_file->get_globalScope();

  std::ostringstream arguments_packer_name;
  arguments_packer_name << "arguments_packer_" << kernel->id << "_" << kernel;

  std::pair<SgClassSymbol *, SgClassDefinition *> arguments_packer =
    buildDeclAndDefn<SgClassSymbol, SgClassDefinition>(arguments_packer_name.str(), decl_scope, defn_scope);

  // TODO fill arguments_packer.second

  kernel->setArgumentPacker(arguments_packer.first);

  std::ostringstream kernel_function_name;
  kernel_function_name << "kernel_function_" << kernel->id << "_" << kernel;

  std::pair<SgFunctionSymbol *, SgFunctionDefinition *> kernel_function =
    buildDeclAndDefn<SgFunctionSymbol , SgFunctionDefinition>(kernel_function_name.str(), decl_scope, defn_scope);

  // TODO fill kernel_function.second

  kernel->setKernelSymbol(kernel_symbol.first);
}

Generator::Generator(SgProject * project, std::string filename_) :
  Core::Generator(project),
  p_decl_file(NULL),
  p_defn_file(NULL)
{
  if (!CommandlineProcessing::isCppFileNameSuffix("hpp"))
    CommandlineProcessing::extraCppSourceFileSuffixes.push_back("hpp");

  std::string filename;

  filename = filename_ + ".hpp";
  p_decl_file = isSgSourceFile(SageBuilder::buildFile(filename, filename, p_project));
  SageInterface::attachComment(p_decl_file, "/* File generated by KLT::Sequential::Generator */");

  filename = filename_ + ".cpp";
  p_defn_file = isSgSourceFile(SageBuilder::buildFile(filename, filename, p_project));
  SageInterface::attachComment(p_defn_file, "/* File generated by KLT::Sequential::Generator */");
  SageInterface::insertHeader(p_defn_file, filename_ + ".hpp");
}

Generator::~Generator() {}

void Generator::unparse() {
  assert(p_decl_file != NULL && p_defn_file != NULL);

  p_decl_file->unparse();
  p_defn_file->unparse();
}

}

}


// #########################################################
// #########################################################
//                      HEADER CODE
// #########################################################
// #########################################################



HEADER_BINARY_X86_INSTRUCTION_PREDECLARATION_START
#include "x86InstructionEnum.h"
HEADER_BINARY_X86_INSTRUCTION_PREDECLARATION_END

HEADER_BINARY_ARM_INSTRUCTION_PREDECLARATION_START
#include "armInstructionEnum.h"
HEADER_BINARY_ARM_INSTRUCTION_PREDECLARATION_END

HEADER_BINARY_START

 /*  This class forms a base class for all of the types represented in the Asm Instruction grammar.
     All Asm Instructions are derived from this class and thus contain the following functionality.
  */

  public:

HEADER_BINARY_END


HEADER_BINARY_INSTRUCTION_START
  public:
   SgAsmInstruction* cfgBinFlowOutEdge(const VirtualBinCFG::AuxiliaryInformation* info);
   std::vector<VirtualBinCFG::CFGEdge> cfgBinOutEdges(const VirtualBinCFG::AuxiliaryInformation* info);
   std::vector<VirtualBinCFG::CFGEdge> cfgBinInEdges(const VirtualBinCFG::AuxiliaryInformation* info);
   void append_sources( SgAsmInstruction* instruction );	
HEADER_BINARY_INSTRUCTION_END


HEADER_BINARY_FILE_START

#if 0
       // enums for ELF header information

#error "DEAD CODE!"

       // unsigned char	e_ident[EI_NIDENT]
       // typedef unsigned char magic_number_vector_type[EI_NIDENT];

       // Executable and Linking Format class kind
          enum elf_class_kind_enum
             {
               e_class_error   = 0,
               e_class_unknown = 1,
               e_class_none    = 2, // value maps to ELFCLASSNONE
               e_class_32      = 3, // value maps to ELFCLASS32
               e_class_64      = 4, // value maps to ELFCLASS64
               e_class_last
             };

#error "DEAD CODE!"

          enum elf_data_encoding_enum
             {
               e_data_encoding_error                  = 0,
               e_data_encoding_unknown                = 1,
               e_data_encoding_none                   = 2, // value maps to ELFDATANONE
               e_data_encoding_least_significant_byte = 3, // value maps to ELFDATA2LSB
               e_data_encoding_most_significant_byte  = 4, // value maps to ELFDATA2MSB
               e_data_encoding_last
             };

          enum elf_version_enum
             {
               e_version_error   = 0,
               e_version_unknown = 1,
               e_version_none    = 2, // value maps to EV_NONE
               e_version_current = 3, // value maps to EV_CURRENT
               e_version_last
             };


#error "DEAD CODE!"

          enum elf_OS_ABI_identification_enum
             {
               e_OS_ABI_error      = 0,
               e_OS_ABI_unknown    = 1,
               e_OS_ABI_none       = 2,
               e_OS_ABI_SYSV       = 3, // Note that ELFOSABI_SYSV == ELFOSABI_NONE (the two are alised)
               e_OS_ABI_HPUX       = 4,
               e_OS_ABI_NETBSD     = 5,
               e_OS_ABI_LINUX      = 6,
               e_OS_ABI_SOLARIS    = 7,
               e_OS_ABI_AIX        = 8,
               e_OS_ABI_IRIX       = 9,
               e_OS_ABI_FREEBSD    = 10,
               e_OS_ABI_TRU64      = 11,
               e_OS_ABI_MODESTO    = 12,
               e_OS_ABI_OPENBSD    = 13,
               e_OS_ABI_ARM        = 14,
               e_OS_ABI_STANDALONE = 15,
               e_OS_ABI_last
             };

#error "DEAD CODE!"

          enum elf_object_file_type_enum
             {
               e_file_type_error       = 0,
               e_file_type_unknown     = 1,
               e_file_type_none        = 2,
               e_file_type_relocatable = 3,
               e_file_type_executable  = 4,
               e_file_type_shared      = 5,
               e_file_type_core        = 6,
               e_file_type_last
             };


#error "DEAD CODE!"

       // DQ (1/8/2008): For a collection of interesting binaries go to: http://www.distributed.net/source/
          enum elf_machine_architecture_enum
             {
               e_machine_architecture_error                    = 0,
               e_machine_architecture_unknown                  = 1,
               e_machine_architecture_none                     = 2, // Maps to EM_NONE
               e_machine_architecture_ATT_WE_32100             = 3,
               e_machine_architecture_Sun_Sparc                = 4,
               e_machine_architecture_Intel_80386              = 5,
               e_machine_architecture_Motorola_m68k_family     = 6,
               e_machine_architecture_Motorola_m88k_family     = 7,
               e_machine_architecture_Intel_80860              = 8,
               e_machine_architecture_MIPS_R3000_big_endian    = 9,
               e_machine_architecture_IBM_System_370           = 10,
               e_machine_architecture_MIPS_R3000_little_endian = 11,
               e_machine_architecture_HPPA                     = 12,
               e_machine_architecture_Fujitsu_VPP500           = 13,
               e_machine_architecture_Sun_v8plus               = 14,
               e_machine_architecture_Intel_80960              = 15,
               e_machine_architecture_PowerPC                  = 16,
               e_machine_architecture_PowerPC_64bit            = 17,
               e_machine_architecture_IBM_S390                 = 18,
               e_machine_architecture_NEC_V800_series          = 19,
               e_machine_architecture_Fujitsu_FR20             = 20,
               e_machine_architecture_TRW_RH_32                = 21,
               e_machine_architecture_Motorola_RCE             = 22,
               e_machine_architecture_ARM                      = 23,
               e_machine_architecture_Digital_Alpha_fake       = 24,
               e_machine_architecture_Hitachi_SH               = 25,
               e_machine_architecture_SPARC_v9_64bit           = 26,
               e_machine_architecture_Siemens_Tricore          = 27,
               e_machine_architecture_Argonaut_RISC_Core       = 28,
               e_machine_architecture_Hitachi_H8_300           = 29,
               e_machine_architecture_Hitachi_H8_300H          = 30,
               e_machine_architecture_Hitachi_H8S              = 31,
               e_machine_architecture_Hitachi_H8_500           = 32,
               e_machine_architecture_Intel_Merced             = 33,
               e_machine_architecture_Stanford_MIPS_X          = 34,
               e_machine_architecture_Motorola_Coldfire        = 35,
               e_machine_architecture_Motorola_M68HC12         = 36,
               e_machine_architecture_Fujitsu_MMA_Multimedia_Accelerator                  = 37,
               e_machine_architecture_Siemens_PCP                                         = 38,
               e_machine_architecture_Sony_nCPU_embeeded_RISC                             = 39,
               e_machine_architecture_Denso_NDR1_microprocessor                           = 40,
               e_machine_architecture_Motorola_Start_Core_processor                       = 41,
               e_machine_architecture_Toyota_ME16_processor                               = 42,
               e_machine_architecture_STMicroelectronic_ST100_processor                   = 43,
               e_machine_architecture_Advanced_Logic_Corp_Tinyj_emb_family                = 44,
               e_machine_architecture_AMD_x86_64_architecture                             = 45,
               e_machine_architecture_Sony_DSP_Processor                                  = 46,
               e_machine_architecture_Siemens_FX66_microcontroller                        = 47,
               e_machine_architecture_STMicroelectronics_ST9_plus_8_16_microcontroller    = 48,
               e_machine_architecture_STMicroelectronics_ST7_8bit_microcontroller         = 49,
               e_machine_architecture_Motorola_MC68HC16_microcontroller                   = 50,
               e_machine_architecture_Motorola_MC68HC11_microcontroller                   = 51,
               e_machine_architecture_Motorola_MC68HC08_microcontroller                   = 52,
               e_machine_architecture_Motorola_MC68HC05_microcontroller                   = 53,
               e_machine_architecture_Silicon_Graphics_SVx                                = 54,
               e_machine_architecture_STMicroelectronics_ST19_8bit_microcontroller        = 55,
               e_machine_architecture_Digital_VAX                                         = 56,
               e_machine_architecture_Axis_Communications_32bit_embedded_processor        = 57,
               e_machine_architecture_Infineon_Technologies_32bit_embedded_processor      = 58,
               e_machine_architecture_Element_14_64bit_DSP_Processor                      = 59,
               e_machine_architecture_LSI_Logic_16bit_DSP_Processor                       = 60,
               e_machine_architecture_Donald_Knuths_educational_64bit_processor           = 61,
               e_machine_architecture_Harvard_University_machine_independent_object_files = 62,
               e_machine_architecture_SiTera_Prism                                        = 63,
               e_machine_architecture_Atmel_AVR_8bit_microcontroller                      = 64,
               e_machine_architecture_Fujitsu_FR30                                        = 65,
               e_machine_architecture_Mitsubishi_D10V                                     = 66,
               e_machine_architecture_Mitsubishi_D30V                                     = 67,
               e_machine_architecture_NEC_v850                                            = 68,
               e_machine_architecture_Mitsubishi_M32R                                     = 69,
               e_machine_architecture_Matsushita_MN10300                                  = 70,
               e_machine_architecture_Matsushita_MN10200                                  = 71,
               e_machine_architecture_picoJava                                            = 72,
               e_machine_architecture_OpenRISC_32bit_embedded_processor                   = 73,
               e_machine_architecture_ARC_Cores_Tangent_A5                                = 74,
               e_machine_architecture_Tensilica_Xtensa_Architecture                       = 75,
               e_machine_architecture_Digital_Alpha                                       = 76,
               e_machine_architecture_last
             };

#error "DEAD CODE!"

       // DQ (2/11/2008): Added support for Windows binaries
          enum pe_processor_architecture_enum
             {
               e_processor_architecture_error   = 0,
               e_processor_architecture_unknown = 1,
               e_processor_architecture_none    = 2,
               e_processor_architecture_INTEL   = 3,
               e_processor_architecture_MIPS    = 4,
               e_processor_architecture_ALPHA   = 5,
               e_processor_architecture_PPC     = 6,
               e_processor_architecture_SHX     = 7,
               e_processor_architecture_ARM     = 8,
               e_processor_architecture_IA64    = 9,
               e_processor_architecture_ALPHA64 = 10,
               e_processor_architecture_MSIL    = 11,
               e_processor_architecture_AMD64   = 12,
               e_processor_architecture_UNKNOWN = 13,
               e_processor_architecture_last
             };

#error "DEAD CODE!"

       // DQ (2/11/2008): Added support for Windows binaries
          enum pe_processor_type_enum
             {
               e_processor_type_error         = 0,
               e_processor_type_unknown       = 1,
               e_processor_type_none          = 2,
               e_processor_type_INTEL_386     = 3,
               e_processor_type_INTEL_486     = 4,
               e_processor_type_INTEL_PENTIUM = 5,
               e_processor_type_INTEL_860     = 6,
               e_processor_type_INTEL_IA64    = 7,
               e_processor_type_AMD_X8664     = 8,
               e_processor_type_MIPS_R2000    = 9,
               e_processor_type_MIPS_R3000    = 10,
               e_processor_type_MIPS_R4000    = 11,
               e_processor_type_ALPHA_21064   = 12,
               e_processor_type_PPC_601       = 13,
               e_processor_type_PPC_603       = 14,
               e_processor_type_PPC_604       = 15,
               e_processor_type_PPC_620       = 16,
               e_processor_type_HITACHI_SH3   = 17,
               e_processor_type_HITACHI_SH3E  = 18,
               e_processor_type_HITACHI_SH4   = 19,
               e_processor_type_MOTOROLA_821  = 20,
               e_processor_type_SHx_SH3       = 21,
               e_processor_type_SHx_SH4       = 22,
               e_processor_type_STRONGARM     = 23,
               e_processor_type_ARM720        = 24,
               e_processor_type_ARM820        = 25,
               e_processor_type_ARM920        = 26,
               e_processor_type_ARM_7TDMI     = 27,
               e_processor_type_last
             };

       // DQ (6/15/2008): Adding interface to simplify migration to newer executable formate IR nodes.
       // JJW (6/18/2008): Commenting out because this function doesn't have a definition
       // SgAsmGenericSectionPtrList & get_sectionList();
#endif

          void post_construction_initialization();

HEADER_BINARY_FILE_END


HEADER_BINARY_FILE_SECTION_HEADER_START

#if 0
          enum elf_version_enum
             {
               e_version_error   = 0,
               e_version_unknown = 1,
               e_version_none    = 2, // value maps to EV_NONE
               e_version_current = 3, // value maps to EV_CURRENT
               e_version_last
             };
#endif

HEADER_BINARY_FILE_SECTION_HEADER_END


HEADER_BINARY_FILE_PROGRAM_HEADER_START

#if 0
          enum elf_type_enum
             {
               e_type_error                = 0,
               e_type_unknown              = 1,
               e_type_null                 = 2,
               e_type_loadable_segment     = 3,
               e_type_dynamic_linking_info = 4,
               e_type_interpreter          = 5,
               e_type_note                 = 6,
               e_type_shlib_reserved       = 7,
               e_type_program_header_table = 8,
               e_type_processor_specific   = 9,
               e_type_last
             };
#endif

HEADER_BINARY_FILE_PROGRAM_HEADER_END


HEADER_BINARY_FILE_SECTION_HEADER_LIST_START
       // const SgAsmSectionHeaderPtrList & get_section_headers() const;
       // SgAsmSectionHeaderPtrList & get_section_headers();

HEADER_BINARY_FILE_SECTION_HEADER_LIST_END


HEADER_BINARY_FILE_PROGRAM_HEADER_LIST_START
       // const SgAsmProgramHeaderPtrList & get_program_headers() const;
       // SgAsmProgramHeaderPtrList & get_program_headers();

HEADER_BINARY_FILE_PROGRAM_HEADER_LIST_END

HEADER_BINARY_BYTE_VALUE_EXPRESSION_START

          virtual SgAsmType* get_type();

HEADER_BINARY_BYTE_VALUE_EXPRESSION_END

HEADER_BINARY_DOUBLE_FLOAT_VALUE_EXPRESSION_START

          virtual SgAsmType* get_type();

HEADER_BINARY_DOUBLE_FLOAT_VALUE_EXPRESSION_END

HEADER_BINARY_DOUBLE_WORD_VALUE_EXPRESSION_START

          virtual SgAsmType* get_type();

HEADER_BINARY_DOUBLE_WORD_VALUE_EXPRESSION_END

HEADER_BINARY_QUAD_WORD_VALUE_EXPRESSION_START

          virtual SgAsmType* get_type();

HEADER_BINARY_QUAD_WORD_VALUE_EXPRESSION_END

HEADER_BINARY_SINGLE_FLOAT_VALUE_EXPRESSION_START

          virtual SgAsmType* get_type();

HEADER_BINARY_SINGLE_FLOAT_VALUE_EXPRESSION_END

HEADER_BINARY_VECTOR_VALUE_EXPRESSION_START

          virtual SgAsmType* get_type();

HEADER_BINARY_VECTOR_VALUE_EXPRESSION_END

HEADER_BINARY_WORD_VALUE_EXPRESSION_START

          virtual SgAsmType* get_type();

HEADER_BINARY_WORD_VALUE_EXPRESSION_END



// ************************************
// NEW IR NODES FOR BINARY FILE FORMATS
// ************************************

HEADER_EXECUTABLE_FILE_FORMAT_START

     public:
       // DQ (8/21/2008): We need something to be in global scope (or not nested here) so that a few references in Node.code can be made.
       // typedef uint64_t addr_t;    // address and size (file and memory)
          typedef rose_addr_t addr_t; // address and size (file and memory)

       // DQ (8/21/2008): Moved this from Node.code to make it local since we can't reference the nested addr_t directly from glogal scope.
       // typedef Rose_STL_Container<addr_t> SgAddressList;
       // typedef SgAddressList*             SgAddressListPtr;

       /* Thrown when an attempt is made to read past the end of a file, section, header, segment, etc. */
          class ShortRead {
               public:
                    ShortRead(class SgAsmGenericSection *section, size_t offset, size_t size)
                       : section(section), offset(offset), size(size) {}
                    ShortRead(class SgAsmGenericSection *section, size_t offset, size_t size, const std::string &mesg)
                       : section(section), offset(offset), size(size), mesg(mesg) {}
                    ShortRead(class SgAsmGenericSection *section, size_t offset, size_t size, const char *mesg)
                       : section(section), offset(offset), size(size), mesg(mesg) {}
                    SgAsmGenericSection *section;   /* Section from which read occurred; null implies file-level write */
                    addr_t         offset;    /* Byte offset into section (or file) */
                    addr_t         size;      /* Number of bytes of attempted read */
                    std::string          mesg;      /* Optional message */
             };

       /* Thrown when an attempt is made to write past the end of a file, section, header, segment, etc. */
          class ShortWrite {
               public:
                    ShortWrite(class SgAsmGenericSection *section, size_t offset, size_t size)
                       : section(section), offset(offset), size(size) {}
                    ShortWrite(class SgAsmGenericSection *section, size_t offset, size_t size, const std::string &mesg)
                       : section(section), offset(offset), size(size), mesg(mesg) {}
                    ShortWrite(class SgAsmGenericSection *section, size_t offset, size_t size, const char *mesg)
                       : section(section), offset(offset), size(size), mesg(mesg) {}
                    SgAsmGenericSection *section;  /* Section to which write occurred; null implies file-level write */
                    addr_t         offset;   /* Byte offset into section (or file) */
                    addr_t         size;     /* Number of bytes of attempted write */
                    std::string          mesg;     /* Optional message */
             };

       /* Thrown when the file contains an error that prevents us from parsing it. */
          class FormatError {
               public:
                    FormatError(const std::string &mesg) {this->mesg=mesg;}
                    FormatError(const char *mesg) {this->mesg=mesg;}
                    std::string mesg;
             };


          typedef struct stat fileDetails;

          enum ByteOrder {
              ORDER_UNSPECIFIED,
              ORDER_LSB,                                          /* little-endian; least significant byte first */
              ORDER_MSB,                                          /* big-endian; most significant byte first */
             };
    
          enum ExecFamily {
              FAMILY_UNSPECIFIED,
              FAMILY_DOS,                                         /* Microsoft DOS format */
              FAMILY_ELF,                                         /* Unix Executable and Linking Format */
              FAMILY_LE,                                          /* Microsft Linear Executable format */
              FAMILY_LX,                                          /* OS/2 LX (Windows 9x VxD device drivers, extension of LE) */
              FAMILY_NE,                                          /* Microsoft New Executable Format */
              FAMILY_PE                                           /* Microsoft Portable Executable Format */
             };

          enum ExecABI {
              ABI_UNSPECIFIED,                                    /* Not specified in file and could not be inferred */
              ABI_OTHER,                                          /* Anything other than values below */
              ABI_86OPEN,                                         /* 86Open Common IA32 */
              ABI_AIX,                                            /* AIX */
              ABI_ARM,                                            /* ARM architecture */
              ABI_FREEBSD,                                        /* FreeBSD */
              ABI_HPUX,                                           /* HP/UX */
              ABI_IRIX,                                           /* IRIX */
              ABI_HURD,                                           /* GNU/Hurd */
              ABI_LINUX,                                          /* GNU/Linux */
              ABI_MODESTO,                                        /* Novell Modesto */
              ABI_MONTEREY,                                       /* Monterey project */
              ABI_MSDOS,                                          /* Microsoft DOS */
              ABI_NT,                                             /* Windows NT */
              ABI_NETBSD,                                         /* NetBSD */
              ABI_OS2,                                            /* OS/2 */
              ABI_SOLARIS,                                        /* Sun Solaris */
              ABI_SYSV,                                           /* SysV R4 */
              ABI_TRU64,                                          /* Compaq TRU64 UNIX */
              ABI_WIN386                                          /* Microsoft Windows */
             };

          /* Instruction sets organized by families */
          enum InsSetArchitecture {
              ISA_UNSPECIFIED             = 0x0000,               /* File does not specify an architecture */
              ISA_OTHER                   = 0xffff,               /* Architecture is something other than below */
              ISA_FAMILY_MASK             = 0xff00,               /* Mask to get family part of ISA */

              ISA_IA32_Family             = 0x0100,               /* x86 IA-32 family of architectures; Intel, AMD, VIA, ... */
              ISA_IA32_286                = 0x0101,               /* 80286 */
              ISA_IA32_386                = 0x0102,               /* MMU with paging */
              ISA_IA32_486                = 0x0103,               /* risc-like pipelining, integrated FPU, on-chip cache */
              ISA_IA32_Pentium            = 0x0104,               /* superscalar, 64-bit databus, MMX */
              ISA_IA32_Cyrix6x86          = 0x0105,               /* register renaming, speculative execution */
              ISA_IA32_AMDK5              = 0x0106,               /* micro-op translation */
              ISA_IA32_PentiumPro         = 0x0107,               /* PAE, integrated L2 cache */
              ISA_IA32_PentiumII          = 0x0108,               /* L3-cache, 3D Now, SSE */
              ISA_IA32_Athlon             = 0x0109,               /* superscalar FPU, wide design */
              ISA_IA32_Pentium4           = 0x010a,               /* deeply pipelined, high frequency, SSE2, hyper-threading */
              ISA_IA32_PentiumM           = 0x010b,               /* low power */

              ISA_X8664_Family            = 0x0200,               /* x86-64 family of architectures: Intel, AMD, VIA, ... */
              ISA_X8664_Athlon64          = 0x0201,               /* on-die memory controller, 40-bit phys address space */
              ISA_X8664_Prescott          = 0x0202,               /* deeply pipelined, high frequency, SSE3 */
              ISA_X8664_IntelCore         = 0x0203,               /* low power, multi-core, lower clock frequency */
              ISA_X8664_AMDPhenom         = 0x0204,               /* quad core, 128-bit FPUs, SSE4a, native mem ctrl, on-die L3 cache */

              ISA_SPARC_Family            = 0x0300,               /* SPARC family of architectures; Sun Microsystems */
              ISA_SPARC_V7                = 0x0301,
              ISA_SPARC_V8                = 0x0302,
              ISA_SPARC_V8E               = 0x0303,
              ISA_SPARC_V9                = 0x0304,
              ISA_SPARC_V9JPS1            = 0x0305,
              ISA_SPARC_V9UA              = 0x0306,
              ISA_SPARC_V9JPS2            = 0x0307,

              ISA_M68K_Family             = 0x0400,               /* Motorala m68k family */
              ISA_M68K_68000              = 0x0401,               /* generation one: 16/32 internal; 8-, 16-, 32-bit interface */
              ISA_M68K_68EC000            = 0x0402,
              ISA_M68K_68HC000            = 0x0403,
              ISA_M68K_68008              = 0x0404,
              ISA_M68K_68010              = 0x0405,
              ISA_M68K_68012              = 0x0406,
              ISA_M68K_68020              = 0x0407,               /* generation two: fully 32-bit */
              ISA_M68K_68EC020            = 0x0408,
              ISA_M68K_68030              = 0x0409,
              ISA_M68K_68EC030            = 0x040a,
              ISA_M68K_68040              = 0x040b,               /* generation three: pipelined */
              ISA_M68K_68EC040            = 0x040c,
              ISA_M68K_68LC040            = 0x040d,
              ISA_M68K_68060              = 0x040e,               /* generation four: superscalar */
              ISA_M68K_ColdFire           = 0x040f,               /* other */
              ISA_M68K_DragonBall         = 0x0410,               /* other */

              ISA_M88K_Family             = 0x0500,               /* Motorola m88k family (not very popular) */
              ISA_M88K_88100              = 0x0501,               /* 32-bit, integrated FPU mated with 88200 MMU and cache controller */
              ISA_M88K_88110              = 0x0502,               /* single package of 88100+88200 */
              ISA_M88K_88110MP            = 0x0503,               /* on-chip comm for use in multi-processor systems */
              ISA_M88K_88120              = 0x0504,               /* superscalar (never actually released) */

              ISA_MIPS_Family             = 0x0600,               /* 32/64-bit RISC; MIPS Technologies, Inc. */
              ISA_MIPS_MarkI              = 0x0601,               /* R2000, R3000 */
              ISA_MIPS_MarkII             = 0x0602,               /* R6000 */
              ISA_MIPS_MarkIII            = 0x0603,               /* R4000 */
              ISA_MIPS_R2000              = 0x0604,               /* 32-bit, Big or little endian */
              ISA_MIPS_R3000              = 0x0605,               /* virtual identical: Pacempi's R3400, IDT's R3500, Toshiba R3900 */
              ISA_MIPS_R4000              = 0x0606,               /* 64-bit; others in the series had larger caches and bug fixes */
              ISA_MIPS_R4200              = 0x0607,               /* low-cost version of R4000 */
              ISA_MIPS_R4300              = 0x0608,               /* low-cost version of R4000 with 32-bit external bus */
              ISA_MIPS_R4600              = 0x0609,               /* "Orion" by Qauntum Effect Devices (QED); larger caches */
              ISA_MIPS_R4650              = 0x060a,               /* by QED */
              ISA_MIPS_R4700              = 0x060b,               /* "Orion" by QED */
              ISA_MIPS_R5000              = 0x060c,               /* by QED */
              ISA_MIPS_RM7000             = 0x060d,               /* by PMC-Sierra; 256kB L2 and optional L3 */
              ISA_MIPS_R8000              = 0x060e,               /* superscalar, fairly rare */
              ISA_MIPS_R10000             = 0x060f,               /* R8000 on a single chip; 32kB caches; out-of-order */
              ISA_MIPS_R12000             = 0x0610,               /* R10000 + higher clock rates */
              ISA_MIPS_R14000             = 0x0611,               /* R12000 + support for DDR SRAM; 200MHz front side bus */
              ISA_MIPS_R16000             = 0x0612,               /* R14000 + increased freq, more L1, smaller die */
              ISA_MIPS_R16000A            = 0x0613,
              ISA_MIPS_16                 = 0x0614,               /* Unknown. Windows PE architecture 0x266 "MIPS16" */
              ISA_MIPS_FPU                = 0x0615,               /* Unknown. Windows PE architecture 0x366 "MIPS with FPU" */
              ISA_MIPS_16FPU              = 0x0616,               /* Unknown. Windows PE architecture 0x466 "MIPS16 with FPU" */

              ISA_I860_Family             = 0x0700,               /* Intel i860 family; 1989-mid 90's; RISC VLIW */
              ISA_I860_860XR              = 0x0701,               /* (code named N10) 25-40MHz */
              ISA_I860_860XP              = 0x0702,               /* (code named N11) larger caches; 40-50MHz; same IS as XR */

              ISA_IA64_Family             = 0x0800,               /* Intel 64-bit architecture */
              ISA_IA64_Itanium            = 0x0801,               /* First generation */
              ISA_IA64_Itanium2           = 0x0802,               /* Second generation starting Nov 2007 */

              /* See http://en.wikipedia.org/wiki/ARM_architecture */
              ISA_ARM_Family              = 0x0900,               /* Acorn RISC Machine, Advanced RISC Machines, ARM Limited */
              ISA_ARM_ARM1                = 0x0901,               /* ARM evaluation system */
              ISA_ARM_ARM2                = 0x0902,               /* ARM2, ARM250 cores */
              ISA_ARM_ARM3                = 0x0903,               /* ARM2a core */
              ISA_ARM_ARM6                = 0x0904,               /* ARM60, ARM600, ARM610 cores */
              ISA_ARM_ARM7                = 0x0905,               /* ARM{700,710,710a,7100,7500,7500FE} cores */
              ISA_ARM_ARM7TDMI            = 0x0906,               /* ARM{7TDMI,7TDMI-S,710T,720T,740T,7EJ-S} cores */
              ISA_ARM_StrongARM           = 0x0907,               /* SA-110, SA-1110 cores */
              ISA_ARM_ARM8                = 0x0908,               /* ARM810 core */
              ISA_ARM_ARM9TDMI            = 0x0909,               /* ARM{9TDMI,920T,922T,940T} cores */
              ISA_ARM_ARM9E               = 0x090a,               /* ARM{946E-S,966E-S,968E-S,926EJ-S,966HS} cores */
              ISA_ARM_ARM10E              = 0x090b,               /* ARM{1020E,1022E,1026EJ-S} cores */
              ISA_ARM_XScale              = 0x090c,               /* 80200, IOP310, IOP315, 80219, IOP321, IOP33x, IOP34x, PXA210,
                                                         * PXA250, PXA255, PXA26x, PXA27x, PXA800(E)F, Monahans, PXA900,
                                                         * IXC1100, IXP2400, IXP2800, IXP2850, IXP2325, IXP2350, IXP42x,
                                                         * IXP460, IXP465 cores */
              ISA_ARM_ARM11               = 0x090d,               /* ARMv{6,6T2,6KZ,6K} cores */
              ISA_ARM_Cortex              = 0x090e,               /* Cortex-{A8,A9,A9 MPCore,R4(F),M3,M1} cores */
          
              /* Others, not yet incorporated into this enum */
              ISA_OTHER_Family            = 0xf000,

              ISA_ATT_WE_32100            = 0xf001,               /* sometimes simply "M32" */
              ISA_IBM_System_370          = 0xf002,
              ISA_HPPA                    = 0xf003,
              ISA_Fujitsu_VPP500          = 0xf004,
              ISA_Sun_v8plus              = 0xf005,
              ISA_PowerPC                 = 0xf006,
              ISA_PowerPC_64bit           = 0xf007,
              ISA_IBM_S390                = 0xf008,
              ISA_NEC_V800_series         = 0xf009,
              ISA_Fujitsu_FR20            = 0xf00a,
              ISA_TRW_RH_32               = 0xf00b,
              ISA_Motorola_RCE            = 0xf00c,
              ISA_Digital_Alpha_fake      = 0xf00e,
              ISA_Hitachi_SH              = 0xf00f,
              ISA_Siemens_Tricore         = 0xf010,
              ISA_Argonaut_RISC_Core      = 0xf011,
              ISA_Hitachi_H8_300          = 0xf012,
              ISA_Hitachi_H8_300H         = 0xf013,
              ISA_Hitachi_H8S             = 0xf014,
              ISA_Hitachi_H8_500          = 0xf015,
              ISA_Stanford_MIPS_X         = 0xf016,
              ISA_Motorola_M68HC12        = 0xf017,
              ISA_Fujitsu_MMA_Multimedia_Accelerator=0xf018,
              ISA_Siemens_PCP             = 0xf019,
              ISA_Sony_nCPU_embeeded_RISC = 0xf01a,
              ISA_Denso_NDR1_microprocessor=0xf01b,
              ISA_Motorola_Start_Core_processor=0xf01c,
              ISA_Toyota_ME16_processor   = 0xf01d,
              ISA_STMicroelectronic_ST100_processor=0xf01e,
              ISA_Advanced_Logic_Corp_Tinyj_emb_family=0xf01f,
              ISA_AMD_x86_64_architecture = 0xf020,
              ISA_Sony_DSP_Processor      = 0xf021,
              ISA_Siemens_FX66_microcontroller=0xf022,
              ISA_STMicroelectronics_ST9_plus_8_16_microcontroller=0xf023,
              ISA_STMicroelectronics_ST7_8bit_microcontroller=0xf024,
              ISA_Motorola_MC68HC16_microcontroller=0xf025,
              ISA_Motorola_MC68HC11_microcontroller=0xf026,
              ISA_Motorola_MC68HC08_microcontroller=0xf027,
              ISA_Motorola_MC68HC05_microcontroller=0xf028,
              ISA_Silicon_Graphics_SVx    = 0xf029,
              ISA_STMicroelectronics_ST19_8bit_microcontroller=0xf02a,
              ISA_Digital_VAX             = 0xf02b,
              ISA_Axis_Communications_32bit_embedded_processor=0xf02c,
              ISA_Infineon_Technologies_32bit_embedded_processor=0xf02d,
              ISA_Element_14_64bit_DSP_Processor=0xf02e,
              ISA_LSI_Logic_16bit_DSP_Processor=0xf02f,
              ISA_Donald_Knuths_educational_64bit_processor=0xf030,
              ISA_Harvard_University_machine_independent_object_files=0xf031,
              ISA_SiTera_Prism            = 0xf032,
              ISA_Atmel_AVR_8bit_microcontroller=0xf033,
              ISA_Fujitsu_FR30            = 0xf034,
              ISA_Mitsubishi_D10V         = 0xf035,
              ISA_Mitsubishi_D30V         = 0xf036,
              ISA_NEC_v850                = 0xf037,
              ISA_Mitsubishi_M32R         = 0xf038,
              ISA_Matsushita_MN10300      = 0xf039,
              ISA_Matsushita_MN10200      = 0xf03a,
              ISA_picoJava                = 0xf03b,
              ISA_OpenRISC_32bit_embedded_processor=0xf03c,
              ISA_ARC_Cores_Tangent_A5    = 0xf03d,
              ISA_Tensilica_Xtensa_Architecture=0xf03e,
              ISA_Digital_Alpha		= 0xf03f,
              ISA_Matsushita_AM33         = 0xf040,
              ISA_EFI_ByteCode            = 0xf041
             };

       /* General purpose of a binary executable file */
          enum ExecPurpose {
              PURPOSE_UNSPECIFIED,                                /* Purpose is not specified and could not be inferred */
              PURPOSE_OTHER,                                      /* A purpose other than any defined below */
              PURPOSE_EXECUTABLE,                                 /* Executable program */
              PURPOSE_LIBRARY,                                    /* Library (shared or relocatable) */
              PURPOSE_CORE_DUMP,                                  /* Post mortem image */
              PURPOSE_OS_SPECIFIC,                                /* Some operating system specific purpose */
              PURPOSE_PROC_SPECIFIC                               /* Some processor specific purpose */
          };


       // DQ (12/8/2008): Hook into the construction of the binary file format support.
          static void parseBinaryFormat(const std::string & name, SgAsmFile* asmFile);
          static void unparseBinaryFormat(const std::string &name, SgAsmFile *asmFile);

       // DQ (11/8/2008): used in the PE support.
       // Looking for function: hexdump(_IO_FILE*&, long unsigned int, const char[5], SgCharList&, size_t&)
          static void hexdump(FILE *f, addr_t base_addr, const char *prefix, const unsigned char *data, size_t n);
       // static void hexdump(FILE *f, addr_t base_addr, const std::string &prefix, const SgCharList &data);
          static void hexdump(FILE *f, addr_t base_addr, const std::string &prefix, const SgUnsignedCharList &data);
          static void hexdump(FILE *f, addr_t base_addr, const std::string &prefix, const SgFileContentList &data);

       /* Return byte order of caller */
          static SgAsmExecutableFileFormat::ByteOrder host_order();

       // DQ (8/21/2008): Interface used by the disassembler
          static SgAsmGenericFile * parse(const char *name);

       /* Swap (reverse) bytes taking care of sign extension */
          static uint8_t swap_bytes(uint8_t n);
          static uint16_t swap_bytes(uint16_t n);
          static uint32_t swap_bytes(uint32_t n);
          static uint64_t swap_bytes(uint64_t n);
          static int8_t swap_bytes(int8_t n);
          static int16_t swap_bytes(int16_t n);
          static int32_t swap_bytes(int32_t n);
          static int64_t swap_bytes(int64_t n);


       /* Little-endian byte order conversions */
          static uint8_t le_to_host(uint8_t n);
          static uint16_t le_to_host(uint16_t n);
          static uint32_t le_to_host(uint32_t n);
          static uint64_t le_to_host(uint64_t n);
          static int8_t le_to_host(int8_t n);
          static int16_t le_to_host(int16_t n);
          static int32_t le_to_host(int32_t n);
          static int64_t le_to_host(int64_t n);

          static void host_to_le(unsigned h, uint8_t *n);
          static void host_to_le(unsigned h, uint16_t *n);
          static void host_to_le(unsigned h, uint32_t *n);
          static void host_to_le(addr_t h, uint64_t *n);
          static void host_to_le(int h, int8_t *n);
          static void host_to_le(int h, int16_t *n);
          static void host_to_le(int h, int32_t *n);
          static void host_to_le(int64_t h, int64_t *n);

       /* Big-endian byte order conversions */
          static uint8_t be_to_host(uint8_t n);
          static uint16_t be_to_host(uint16_t n);
          static uint32_t be_to_host(uint32_t n);
          static uint64_t be_to_host(uint64_t n);
          static int8_t be_to_host(int8_t n);
          static int16_t be_to_host(int16_t n);
          static int32_t be_to_host(int32_t n);
          static int64_t be_to_host(int64_t n);

          static void host_to_be(unsigned h, uint8_t *n);
          static void host_to_be(unsigned h, uint16_t *n);
          static void host_to_be(unsigned h, uint32_t *n);
          static void host_to_be(addr_t h, uint64_t *n);
          static void host_to_be(int h, int8_t *n);
          static void host_to_be(int h, int16_t *n);
          static void host_to_be(int h, int32_t *n);
          static void host_to_be(int64_t h, int64_t *n);

       /* Caller-specified byte order conversions */
          static uint8_t disk_to_host(SgAsmExecutableFileFormat::ByteOrder sex, uint8_t n);
          static uint16_t disk_to_host(SgAsmExecutableFileFormat::ByteOrder sex, uint16_t n);
          static uint32_t disk_to_host(SgAsmExecutableFileFormat::ByteOrder sex, uint32_t n);
          static uint64_t disk_to_host(SgAsmExecutableFileFormat::ByteOrder sex, uint64_t n);
          static int8_t disk_to_host(SgAsmExecutableFileFormat::ByteOrder sex, int8_t n);
          static int16_t disk_to_host(SgAsmExecutableFileFormat::ByteOrder sex, int16_t n);
          static int32_t disk_to_host(SgAsmExecutableFileFormat::ByteOrder sex, int32_t n);
          static int64_t disk_to_host(SgAsmExecutableFileFormat::ByteOrder sex, int64_t n);

       // static void host_to_disk(SgAsmExecutableFileFormat::ByteOrder, unsigned char h, unsigned char *np);
          static void host_to_disk(SgAsmExecutableFileFormat::ByteOrder sex, unsigned h, uint8_t *np);
          static void host_to_disk(SgAsmExecutableFileFormat::ByteOrder sex, unsigned h, uint16_t *np);
          static void host_to_disk(SgAsmExecutableFileFormat::ByteOrder sex, unsigned h, uint32_t *np);
          static void host_to_disk(SgAsmExecutableFileFormat::ByteOrder sex, addr_t h, uint64_t *np);
          static void host_to_disk(SgAsmExecutableFileFormat::ByteOrder sex, int h, int8_t *np);
          static void host_to_disk(SgAsmExecutableFileFormat::ByteOrder sex, int h, int16_t *np);
          static void host_to_disk(SgAsmExecutableFileFormat::ByteOrder sex, int h, int32_t *np);
          static void host_to_disk(SgAsmExecutableFileFormat::ByteOrder sex, int64_t h, int64_t *np);

HEADER_EXECUTABLE_FILE_FORMAT_END


HEADER_GENERIC_SECTION_START
       // RPM (8/27/2008): Is this right? get_offset() returns file offset; get_mapped_rva() returns memory addr*/
       // This can be mapped to the offset data member
          unsigned long get_starting_memory_address() { return get_offset(); }

       // DQ (8/7/2008): These are a few data member access functions that were required 
       // to compile when first adding the new IR nodes (these should be removed).
          unsigned long get_starting_file_offset() { return 0; }
          unsigned long get_flags() { return 0; }
          unsigned long get_type() { return 0; }

     public:

       /* Reason for section's existence. This is a union of all the section purposes from the various supported file formats.
        * However, at this time we're only interested in a few kinds of sections and therefore most will fall into the SP_OTHER
        * category. */
          enum SectionPurpose {
              SP_UNSPECIFIED,                                     /* File format did not specify a reason and none could be determined */
              SP_PROGRAM,                                         /* Program-supplied data, code, etc. */
              SP_HEADER,                                          /* Section contains a header for the executable file format */
              SP_SYMTAB,                                          /* Symbol table */
              SP_OTHER                                            /* File-specified purpose other than any given in this enum */
             };

	  typedef std::pair<addr_t,addr_t> ExtentPair; 		  /* Describes a part of a file (offset, size) */
          typedef std::map<addr_t,addr_t> ExtentMap;              /* Multiple non-overlapping, parts of a file */

          SgAsmGenericSection(SgAsmGenericFile*, SgAsmGenericHeader*, addr_t offset, addr_t size);

       // This destructor modifies the SgAsmGenericFile data to remove its section from the section list!
          virtual ~SgAsmGenericSection();

          virtual void        dump(FILE*, const char *prefix, ssize_t idx);
          virtual void        unparse(FILE*);
          void                unparse(FILE*, const ExtentMap&);
          SgAsmGenericHeader *is_file_header();              /* true if section represents a top level file header */

       /* Functions for section extent within the file */
          addr_t        get_size() const;
	  virtual void  set_size(addr_t);		/* Resize a section w/o regard to other sections or mapping */
	  addr_t        get_offset() const;
	  virtual void  set_offset(addr_t);             /* Move a section w/o regard to other sections or mapping */
          addr_t        get_end_offset(); /* file offset for end of section */
          void          extend(addr_t nbytes);         /* make section larger by extending the end */
          void          extend_up_to(addr_t nbytes);      /* like extend() but more relaxed at EOF */
          addr_t        write(FILE *f, addr_t offset, size_t bufsize, const void *buf);
          addr_t        write(FILE *f, addr_t offset, const std::string &str);
          addr_t        write(FILE *f, addr_t offset, char c);
	  addr_t        write(FILE *f, addr_t offset, const SgFileContentList &buf);
	  addr_t	write(FILE *f, addr_t offset, const SgUnsignedCharList &buf);

       /* Functions for accessing content */
          const unsigned char *content(addr_t offset, addr_t size);/*returns ptr to SIZE bytes starting at OFFSET */
          const SgUnsignedCharList content_ucl(addr_t offset, addr_t size);/*returns ptr to SIZE bytes starting at OFFSET */
          void                 content(addr_t offset, addr_t size, void *buf); /* copies content into BUF */
          const char          *content_str(addr_t offset);    /* returns ptr to NUL-terminated string starting at OFFSET */
          const ExtentMap&    congeal();                      /* congeal referenced areas into holes */
          const ExtentMap&    uncongeal();                    /* uncongeal holes back into references */

       /* Functions related to mapping of sections into executable memory */
          bool   	      is_mapped();                    /* True iff non-zero mapped address and size */
          void   	      clear_mapped();                 /* Set mapped address and size to zero (unmapped)*/
	  addr_t              get_mapped_size() const;
          virtual void        set_mapped_size(addr_t);	      /* Set mapped size w/o regard to other section mappings */
	  addr_t	      get_mapped_rva() const;
	  virtual void        set_mapped_rva(addr_t);         /* Move a section w/o regard to other section mappings */
	  addr_t 	      get_base_va() const;            /* Convenience to get header's base VA */
	  addr_t 	      get_mapped_va();		      /* Like get_mapped_rva() except returns VA */
          addr_t              get_va_offset(addr_t va);       /* Return file offset for specified virtual address */
	  addr_t	      get_rva_offset(addr_t rva);     /* Return file offset for specified relative virtual address */

       // DQ (8/15/2008): This is now automatically generated (and is a const function)!
       // SgAsmGenericHeader *get_header();

       /* Accessors for private members */
          SgAsmGenericString *get_name() const;		      /* Same as standard ROSETTA accessor */
	  void set_name(SgAsmGenericString *s);		      /* Like std accessor but sets parent of 's' */

       // Use the automatically generated access functions
       // Exec::SectionPurpose      get_purpose() {return purpose;}
       // void                set_purpose(SectionPurpose p) {purpose=p;}
       // void                set_synthesized(bool b) {synthesized=b;}
       // bool                get_synthesized() {return synthesized;}

       /* Static functions for manipulating extent maps */
          static ExtentMap subtract_extents(const ExtentMap &map, const ExtentPair &extent)
            {return subtract_extents(map, extent.first, extent.second);}
          static ExtentMap subtract_extents(const ExtentMap &map, addr_t offset, addr_t size);
          static void insert_extent(ExtentMap &map, const ExtentPair &extent)
            {insert_extent(map, extent.first, extent.second);}
          static void insert_extent(ExtentMap &map, addr_t offset, addr_t size);
          static ExtentMap overlap_extents(const ExtentMap &map, const ExtentPair &extent)
            {return overlap_extents(map, extent.first, extent.second);}
          static ExtentMap overlap_extents(const ExtentMap &map, addr_t offset, addr_t size);
          static void erase_extent(ExtentMap &map, const ExtentPair &extent)
            {erase_extent(map, extent.first, extent.second);}
          static void erase_extent(ExtentMap &map, addr_t offset, addr_t size);
          static ExtentMap::iterator best_fit_extent(ExtentMap &map, addr_t size);
          static ExtentPair allocate_best_extent(ExtentMap &map, addr_t size);
          static ExtentPair allocate_first_extent(ExtentMap &map, addr_t size);
          static void dump_extents(const ExtentMap&, FILE*, const char *prefix, const char *label);

     protected:
          void ctor(SgAsmGenericFile*, SgAsmGenericHeader*, addr_t offset, addr_t size);
          void unparse_holes(FILE*);

HEADER_GENERIC_SECTION_END

HEADER_GENERIC_HEADER_START

     public:
          SgAsmGenericHeader(SgAsmGenericFile *ef, addr_t offset, addr_t size);

          virtual ~SgAsmGenericHeader();
	  virtual void unparse(FILE*);
          virtual void dump(FILE*, const char *prefix, ssize_t idx);

       // DQ (8/8/2008): We can't make this pure virtual since then we can't allocate this class.
       // virtual const char *format_name() = 0;
          virtual const char *format_name();
    
       /* Functions for dynamically linked libraries (DLLs) */
          void add_dll(SgAsmGenericDLL *dll);                         /* Add new DLL to list of DLLs for this file */
       // std::vector<SgAsmGenericDLL*>& get_dlls() {return p_dlls;}    /* all necessary dynamically loaded libraries */
          std::vector<SgAsmGenericDLL*>& get_dlls() { ROSE_ASSERT(p_dlls != NULL); return p_dlls->get_dlls(); }    /* all necessary dynamically loaded libraries */

       /* Functions for symbols */
          void add_symbol(SgAsmGenericSymbol*);                       /* add a new symbol to the symbol table. Duplicates are allowed. */
       // std::vector<SgAsmGenericSymbol*>& get_symbol() { ROSE_ASSERT(p_symbols != NULL); return p_symbols->get_symbols(); }
          SgAsmGenericSymbolPtrList & get_symbol_list();

       /* Accessors for protected/private members */
       // SgAsmGenericFormat & get_exec_format() {return p_exec_format;}
          std::vector<unsigned char>& get_magic() {return p_magic;}
       // addr_t get_base_va() const {return p_base_va;}
          addr_t get_entry_rva() const {return p_entry_rvas[0];}
       // const std::vector<addr_t>& get_entry_rvas() const {return p_entry_rvas;}
          void add_entry_rva(addr_t rva) { p_entry_rvas.push_back(rva);}

       /* Convenience functions */
       // SgAsmGenericFormat::ByteOrder get_sex() const { return p_exec_format.p_sex; }
          SgAsmExecutableFileFormat::ByteOrder get_sex() const;
       // size_t get_word_size() const {return p_exec_format.p_word_size;}
          size_t get_word_size() const;

       /* Functions for sections */
          void add_section(SgAsmGenericSection*);             /* Add new section to the file; called implicitly by section ctor */
          void remove_section(SgAsmGenericSection*); 	      /* Remove section from the file */

       /* Section lookup functions (plural) */
	  SgAsmGenericSectionPtrList get_sections_by_id(int id);
	  SgAsmGenericSectionPtrList get_sections_by_name(std::string, char sep=0);
	  SgAsmGenericSectionPtrList get_sections_by_offset(addr_t offset, addr_t size);
	  SgAsmGenericSectionPtrList get_sections_by_rva(addr_t rva);
	  SgAsmGenericSectionPtrList get_sections_by_va(addr_t va);

       /* Section lookup functions (singular) */
	  SgAsmGenericSection *get_section_by_id(int id, size_t *nfound=0);
	  SgAsmGenericSection *get_section_by_name(const std::string&, char sep=0, size_t *nfound=0);
	  SgAsmGenericSection *get_section_by_offset(addr_t offset, addr_t size, size_t *nfound=0);
          SgAsmGenericSection *get_section_by_rva(addr_t rva, size_t *nfound=0);
	  SgAsmGenericSection *get_section_by_va(addr_t va, size_t *nfound=0);
	  SgAsmGenericSection *get_best_section_by_va(addr_t va, size_t *nfound=0);


  // protected:
       // ExecFormat          exec_format;                    /* General info about the executable format */
       // std::vector<unsigned char> magic;                   /* Optional magic number in file byte order */
       // InsSetArchitecture  target;                         /* Machine for which this header and its sections, etc. was compiled */
       // addr_t              base_va;                        /* Base virtual address used by all "relative virtual addresses" (RVA) */
       // std::vector<addr_t> entry_rvas;                     /* Code entry points wrt base_va */
       // std::vector<ExecDLL*> dlls;                         /* List of dynamic libraries needed by this executable */
       // std::vector<ExecSymbol*> symbols;                   /* All symbols defined for this header */

     private:
          void ctor(SgAsmGenericFile *f, addr_t offset, addr_t size);

HEADER_GENERIC_HEADER_END

HEADER_GENERIC_FILE_START
     public:
          SgAsmGenericFile(std::string file_name);

          virtual ~SgAsmGenericFile();                                /* Destructor deletes children and munmaps and closes file */
          void unparse(const std::string &filename);		/* Unparse the file -- mirror image of parsing */
          void dump(FILE*);                                   /* Print some debugging info */

       /* File contents */
          addr_t get_size() const;       				/* Size of file in bytes as of time it was opened */
          const SgFileContentList& content() { return p_data; }     	/* Entire file contents */
          SgFileContentList content(addr_t offset, addr_t size);	/* Partial file contents */

       /* Section lookup functions (plural) */
	  SgAsmGenericSectionPtrList get_sections();
	  SgAsmGenericSectionPtrList get_sections_by_id(int id);
	  SgAsmGenericSectionPtrList get_sections_by_name(std::string, char sep='\0');
	  SgAsmGenericSectionPtrList get_sections_by_offset(addr_t offset, addr_t size);
	  SgAsmGenericSectionPtrList get_sections_by_rva(addr_t rva);
	  SgAsmGenericSectionPtrList get_sections_by_va(addr_t va);

       /* Section lookup functions (singular) */
	  SgAsmGenericSection *get_section_by_id(int id, size_t *nfound=0);
	  SgAsmGenericSection *get_section_by_name(const std::string&, char sep=0, size_t *nfound=0);
	  SgAsmGenericSection *get_section_by_offset(addr_t offset, addr_t size, size_t *nfound=0);
          SgAsmGenericSection *get_section_by_rva(addr_t rva, size_t *nfound=0);
	  SgAsmGenericSection *get_section_by_va(addr_t va, size_t *nfound=0);
	  SgAsmGenericSection *get_best_section_by_va(addr_t va, size_t *nfound=0);
	  static SgAsmGenericSection *best_section_by_va(const SgAsmGenericSectionPtrList &sections, addr_t va);

	/* Section modification functions */
	  void resize(SgAsmGenericSection*, addr_t newsize);  /* Change size of an existing section, adjusting others as needed */
	  void mapped_resize(SgAsmGenericSection*,addr_t);    /* Change mapped size of existing sect., adjusting others */

       /* Holes (unreferenced regions in the file) */	
	  void congeal();                                     /* Identify and freeze all unreferenced regions after parsing */
          addr_t get_next_section_offset(addr_t offset);      /* Find file offset for next section */
	  void add_hole(SgAsmGenericSection*);		      /* Add section to list of holes */
	  void remove_hole(SgAsmGenericSection*);             /* Remove section from list of holes */
          void fill_holes();                                  /* Find holes in file and create sections to fill them */
          void unfill_holes();                                /* Undoes what fill_holes() did, returning hole sections to unused pool */

       /* Functions for file headers (a kind of section) */
          void add_header(SgAsmGenericHeader*);               /* Add a new file header to the list of headers for this file */
          void remove_header(SgAsmGenericHeader*);            /* Remove file header from the file */

          SgAsmGenericHeader *get_header(SgAsmGenericFormat::ExecFamily);                 /* Returns the specified header (exception if more than one) */
          const char *format_name();                          /* Return a string describing the file format */

          const SgAsmGenericFormat::fileDetails & get_sb() { return p_sb; }
          void set_sb ( const SgAsmGenericFormat::fileDetails & sb ) { printf ("set_sb() not implemented! \n"); ROSE_ASSERT(false); }

       // DQ (8/26/2008): Added support for alternative section selection for use in disassembler.
          SgAsmGenericSection* get_best_possible_section_by_va(addr_t va);

     private:
          void ctor(std::string file_name);

HEADER_GENERIC_FILE_END

HEADER_GENERIC_FORMAT_START
     public:

// typedef uint64_t addr_t;                                /* address and size (file and memory) */


#if 0
       // This is automatically generated.
          SgAsmGenericFormat() :
               family(FAMILY_UNSPECIFIED),
               purpose(PURPOSE_UNSPECIFIED),
               sex(ORDER_UNSPECIFIED),
               version(0),
               is_current_version(false),
               abi(ABI_UNSPECIFIED),
               abi_version(0),
               word_size(4)
             {}
#endif

    void dump(FILE*, const char *prefix, ssize_t idx);

HEADER_GENERIC_FORMAT_END

HEADER_GENERIC_DLL_START
     public:
          SgAsmGenericDLL(SgAsmGenericString *s);

       // Use the ones automatically generated by ROSETTA.
       // virtual ~SgAsmGenericDLL() {}

          virtual void dump(FILE*, const char *prefix, ssize_t idx);

          void add_function(std::string fname) { p_funcs.push_back(fname); } /* Add a needed function to the import list for this DLL */

       /* Accessors for protected/private data members */
          SgAsmGenericString *get_name() const;
          void set_name(SgAsmGenericString *s);

HEADER_GENERIC_DLL_END

HEADER_GENERIC_DLL_LIST_START
HEADER_GENERIC_DLL_LIST_END

HEADER_GENERIC_SYMBOL_START

     public:
          enum SymbolDefState {
              SYM_UNDEFINED,                                      /* Symbol has not been defined yet */
              SYM_TENTATIVE,                                      /* Does not have size/value yet (uninitialized C or Fortran common blks) */
              SYM_DEFINED                                         /* Created and assigned storage */
          };

          enum SymbolType {
              SYM_NO_TYPE,                                        /* No type or type is unknown */
              SYM_DATA,                                           /* Normal variable definitions */
              SYM_FUNC,                                           /* Function */
              SYM_SECTION,                                        /* Section of a file */
              SYM_FILE,                                           /* Name of a file */
              SYM_ARRAY,                                          /* Array of some other type */
              SYM_TLS,                                            /* Thread-local storage */
              SYM_REGISTER                                        /* CPU register value (see Sparc) */
          };

          enum SymbolBinding {
              SYM_NO_BINDING,                                     /* Unknown binding */
              SYM_LOCAL,
              SYM_GLOBAL,
              SYM_WEAK
          };

	  // Rosetta-generated version doesn't set the name
          //SgAsmGenericSymbol()
	  //    : p_def_state(SYM_UNDEFINED), p_binding(SYM_NO_BINDING), p_type(SYM_NO_TYPE), p_value(0), p_size(0),
          //      p_bound(NULL), p_name(NULL)
	  //    {set_name(new SgAsmBasicString(""));}
          SgAsmGenericSymbol(SgAsmGenericString *name)
	      : p_def_state(SYM_UNDEFINED), p_binding(SYM_NO_BINDING), p_type(SYM_NO_TYPE), p_value(0), p_size(0),
	        p_bound(NULL), p_name(NULL)
	        {set_name(name);}
          //virtual ~SgAsmGenericSymbol() {}

          virtual void dump(FILE*, const char *prefix, ssize_t idx);

          std::string stringifyDefState() const;
          std::string stringifyType() const;
          std::string stringifyBinding() const;

       // Accessors
          SgAsmGenericString *get_name() const; // same as ROSETTA-generated version
          void set_name(SgAsmGenericString *s); // also sets s.parent

HEADER_GENERIC_SYMBOL_END

HEADER_GENERIC_SYMBOL_LIST_START
HEADER_GENERIC_SYMBOL_LIST_END


HEADER_BASIC_STRING_START
     public:
       // SgAsmBasicString() {}
          explicit SgAsmBasicString(const std::string &s)
	      : p_string(s) {}
	  explicit SgAsmBasicString(const char *s)
	      : p_string(s) {}
       // virtual ~SgAsmBasicString() {}
          virtual void dump(FILE*, const char *prefix, ssize_t idx);

HEADER_BASIC_STRING_END

HEADER_GENERIC_STRING_START
     public:
       // virtual ~SgAsmGenericString() {};

       // These aren't the ROSETTA-generated versions because they hook into string table allocation functions
          virtual std::string get_string() const;
          virtual void set_string(const std::string &s);
          const char *c_str() const;

          virtual void dump(FILE*, const char *prefix, ssize_t idx);

HEADER_GENERIC_STRING_END

HEADER_ELF_STRING_STORAGE_START
     public:
          SgAsmElfStringStorage(SgAsmElfStrtab *strtab, const std::string &string, rose_addr_t offset)
             : p_strtab(strtab), p_string(string), p_offset(offset) {}
          void dump(FILE *s, const char *prefix, ssize_t idx);

       /* Accessors. The set_* accessors are private because we don't want anyone messing with them. These data members are used
        * to control string allocation in ELF string tables and must only be modified by allocators in closely related classes.
        * For instance, to change the value of the string one should call SgAsmGenericString::set_string() instead. */

#if 0
       // Let the access function generated by ROSETTA be used.
	  SgAsmElfStrtab* get_strtab() const {
	       return p_strtab;
	     }
	  const std::string& get_string() const {             /*read-only; set string with SgAsmGenericString::set_string()*/
	       return p_string;
	     }
	  const rose_addr_t get_offset() const {              /*read-only; set only by the string table allocator*/
	       return p_offset;                                /*does not trigger reallocation; cf. SgAsmElfString::get_offset()*/
	     }
#endif

     private:
          friend class SgAsmElfString;                        /*allowed to set private data members*/
          friend class SgAsmElfStrtab;                        /*allowed to set private data members*/
#if 0
       // Let the access function generated by ROSETTA be used.
          void set_string(const std::string &s) {
               p_string = s;
             }
          void set_strtab(SgAsmElfStrtab *strtab) {
               p_strtab = strtab;
             }
          void set_offset(rose_addr_t offset) {
               p_offset = offset;
             }
          SgAsmElfStringStorage() {abort();}                  /*no default constructor; cf. SgAsmElfString::create_storage()*/
#endif

HEADER_ELF_STRING_STORAGE_END



// ***********************************************
//          ELF Binary File Format Support
// ***********************************************

HEADER_ELF_HEADER_START

     public:
       /* File format of an ELF header. Byte order of members depends on e_ident value. This code comes directly from "System V
        * Application Binary Interface, Edition 4.1" and the FreeBSD elf(5) man page, and the "Executable and Linkable Format (ELF)
        * Portable Formats Specifications, Version 1.2" and not from any header file. */
          struct Elf32FileHeader_disk {
               unsigned char       e_ident_magic[4];       /* 0x7f, 'E', 'L', 'F' */
               unsigned char       e_ident_file_class;     /* 1=>32-bit; 2=>64-bit; other is error */
               unsigned char       e_ident_data_encoding;  /* 1=>LSB; 2=>MSB; other is error */
               unsigned char       e_ident_file_version;   /* Format version number (same as 'version' member); must be one. */
               unsigned char       e_ident_padding[9];     /* padding to align next member at byte offset 16; must be zero */
               uint16_t            e_type;                 /* object file type: relocatable, executable, shared object, core, etc. */
               uint16_t            e_machine;              /* required architecture for an individual file */
               uint32_t            e_version;              /* object file version, currently zero or one */
               uint32_t            e_entry;                /* entry virtual address or zero if none */
               uint32_t            e_phoff;                /* file offset of program header (segment) table or zero if none */
               uint32_t            e_shoff;                /* file offset of section header table or zero if none */
               uint32_t            e_flags;                /* processor-specific flags (EF_* constants in documentation) */
               uint16_t            e_ehsize;               /* size of ELF header in bytes */
               uint16_t            e_phentsize;            /* size in bytes of each entry in the program header table */
               uint16_t            e_phnum;                /* number of entries in the program header (segment) table, or PN_XNUM, or zero */
               uint16_t            e_shentsize;            /* size in bytes of each entry in the section header table */
               uint16_t            e_shnum;                /* number of entries in the section header table, or zero for extended entries */
               uint16_t            e_shstrndx;             /* index of section containing section name strings, or SHN_UNDEF, or SHN_XINDEX */
             } __attribute__((packed));

          struct Elf64FileHeader_disk {
               unsigned char       e_ident_magic[4];
               unsigned char       e_ident_file_class;
               unsigned char       e_ident_data_encoding;
               unsigned char       e_ident_file_version;
               unsigned char       e_ident_padding[9];
               uint16_t            e_type;
               uint16_t            e_machine;
               uint32_t            e_version;
               uint64_t            e_entry;
               uint64_t            e_phoff;
               uint64_t            e_shoff;
               uint32_t            e_flags;
               uint16_t            e_ehsize;
               uint16_t            e_phentsize;
               uint16_t            e_phnum;
               uint16_t            e_shentsize;
               uint16_t            e_shnum;
               uint16_t            e_shstrndx;
             } __attribute__((packed));

#if USING_OLD_EXECUTABLE_FORMAT_SUPPORT
       // DQ (8/10/2008): This constructor is implemented in sageSupport.C and will be removed later once the new IR nodes are integrated into use.
       // SgAsmElfFileHeader ( Exec::ELF::ElfFileHeader* elf_file_header );
#endif

          SgAsmElfFileHeader(SgAsmGenericFile *f, addr_t offset)   /* assume 32-bit for now and fix inside ctor() if necessary */
             : SgAsmGenericHeader(f, offset, 0)
             { ctor(f, offset); }
       // virtual ~SgAsmElfFileHeader() {}

          uint64_t max_page_size();
          virtual void unparse(FILE*);

          void *encode(SgAsmExecutableFileFormat::ByteOrder, SgAsmElfFileHeader::Elf32FileHeader_disk*);
          void *encode(SgAsmExecutableFileFormat::ByteOrder, SgAsmElfFileHeader::Elf64FileHeader_disk*);

          virtual void dump(FILE*, const char *prefix, ssize_t idx);

     private:
          void ctor(SgAsmGenericFile *f, addr_t offset);

     public:
       // Forward reference
       // class Exec::ELF::ElfFileHeader;
       //   AsmElfHeader
       // SgAsmElfFileHeader ( Exec::ELF::ElfFileHeader* elf_file_header );

       // Overloaded base class virtual function
          const char *format_name();

          static bool is_ELF(SgAsmGenericFile*);
          static SgAsmElfFileHeader *parse(SgAsmGenericFile*);

HEADER_ELF_HEADER_END

HEADER_ELF_SECTION_TABLE_START
     public:
          SgAsmElfSectionTable(SgAsmElfFileHeader *fhdr);
       // virtual ~SgAsmElfSectionTable() {}

	  virtual void set_offset(addr_t newaddr);
          virtual void unparse(FILE*);
          virtual void dump(FILE*, const char *prefix, ssize_t idx);

     private:
          void ctor();    

HEADER_ELF_SECTION_TABLE_END

HEADER_ELF_SECTION_TABLE_ENTRY_START

     public:
       /* Section types (host order). All other values are reserved. */
          enum SectionType {
              SHT_NULL            = 0,                    /* Section header is inactive */
              SHT_PROGBITS        = 1,                    /* Information defined by the program; format and meaning determined by prog */
              SHT_SYMTAB          = 2,                    /* Complete symbol table */
              SHT_STRTAB          = 3,                    /* String table */
              SHT_RELA            = 4,                    /* Relocation entries with explicit addends (e.g., Elf32_Rela types) */
              SHT_HASH            = 5,                    /* Symbol hash table (used by dynamic linking) */
              SHT_DYNAMIC         = 6,                    /* Information for dynamic linking */
              SHT_NOTE            = 7,                    /* Information that marks the file in some way */
              SHT_NOBITS          = 8,                    /* Like SHT_PROGBITS but occupies no file space */
              SHT_REL             = 9,                    /* Relocation entries without explicit addends (e.g., Elf32_Rel types) */
              SHT_SHLIB           = 10,                   /* Reserved, unspecified semantics; Present only in non-conforming files */
              SHT_DYNSYM          = 11,                   /* Minimal set of dynamic linking symbols */
              SHT_LOPROC          = 0x70000000,           /* Processor specific semantics */
              SHT_HIPROC          = 0x7fffffff,
              SHT_LOUSER          = 0x80000000,           /* Application specific semantics */
              SHT_HIUSER          = 0xffffffff
          };

       /* File format of an ELF Section header. Byte order of members depends on e_ident value in file header. This code comes
        * directly from "Executable and Linkable Format (ELF)", Portable Formats Specification, Version 1.1, Tool Interface
        * Standards (TIS) and not from any header file. The 64-bit structure is gleaned from the Linux elf(5) man page. */
          struct Elf32SectionTableEntry_disk {
              uint32_t            sh_name;                /* 0x00 Section name; index into section header string table */
              uint32_t            sh_type;                /* 0x04 Section contents and semantics (see SectionType enum) */
              uint32_t            sh_flags;               /* 0x08 Bit flags */
              uint32_t            sh_addr;                /* 0x0c Desired mapped address */
              uint32_t            sh_offset;              /* 0x10 Section location in file unless sh_type==SHT_NOBITS */
              uint32_t            sh_size;                /* 0x14 Section size in bytes */
              uint32_t            sh_link;                /* 0x18 Section ID of another section; meaning depends on section type */
              uint32_t            sh_info;                /* 0x1c Extra info depending on section type */
              uint32_t            sh_addralign;           /* 0x20 Mapped alignment (0 and 1=>byte aligned); sh_addr must be aligned */
              uint32_t            sh_entsize;             /* 0x24 If non-zero, size in bytes of each array member in the section */
          } __attribute__((packed));                      /* 0x28 */

          struct Elf64SectionTableEntry_disk {
              uint32_t            sh_name;		  /* 0x00 see Elf32SectionTableEntry_disk */
              uint32_t            sh_type;		  /* 0x04 */
              uint64_t            sh_flags;		  /* 0x08 */
              uint64_t            sh_addr;		  /* 0x10 */
              uint64_t            sh_offset;		  /* 0x18 */
              uint64_t            sh_size;		  /* 0x20 */
              uint32_t            sh_link;		  /* 0x28 */
              uint32_t            sh_info;		  /* 0x2c */
              uint64_t            sh_addralign;		  /* 0x30 */
              uint64_t            sh_entsize;		  /* 0x38 */
          } __attribute__((packed));			  /* 0x40 */


          SgAsmElfSectionTableEntry(SgAsmExecutableFileFormat::ByteOrder sex, const SgAsmElfSectionTableEntry::Elf32SectionTableEntry_disk *disk);
          SgAsmElfSectionTableEntry(SgAsmExecutableFileFormat::ByteOrder sex, const SgAsmElfSectionTableEntry::Elf64SectionTableEntry_disk *disk);

       // virtual ~SgAsmElfSectionTableEntry() {};

          void *encode(SgAsmExecutableFileFormat::ByteOrder sex, SgAsmElfSectionTableEntry::Elf32SectionTableEntry_disk *disk);
          void *encode(SgAsmExecutableFileFormat::ByteOrder sex, SgAsmElfSectionTableEntry::Elf64SectionTableEntry_disk *disk);

	  void update_from_section(SgAsmElfSection*);
          virtual void dump(FILE*, const char *prefix, ssize_t idx);

     private:
          void ctor(SgAsmExecutableFileFormat::ByteOrder sex, const SgAsmElfSectionTableEntry::Elf32SectionTableEntry_disk *disk);
          void ctor(SgAsmExecutableFileFormat::ByteOrder sex, const SgAsmElfSectionTableEntry::Elf64SectionTableEntry_disk *disk);


HEADER_ELF_SECTION_TABLE_ENTRY_END

HEADER_ELF_SECTION_START
     public:
       /* Constructor for size based on section table entry (normal sections) */
          SgAsmElfSection(SgAsmElfFileHeader *fhdr, SgAsmElfSectionTableEntry *shdr);
	  SgAsmElfSection(SgAsmElfFileHeader *fhdr, SgAsmElfSegmentTableEntry *shdr);

       /* Constructor for explicit size (e.g., BSS sections where file size is always zero) */
          SgAsmElfSection(SgAsmElfFileHeader *fhdr, SgAsmElfSectionTableEntry *shdr, addr_t file_size);

       // virtual ~ElfSection() {}

          virtual void dump(FILE*, const char *prefix, ssize_t idx);
	  virtual void set_mapped_rva(addr_t);

       /* Convenience functions */
          SgAsmElfFileHeader *get_elf_header();

       // DQ (8/22/2008): These are not automatically generated since one of them must be virtual.
          SgAsmElfSection* get_linked_section () const;
          virtual void set_linked_section(SgAsmElfSection*);

     private:
          void ctor(SgAsmElfSectionTableEntry*);
	  void ctor(SgAsmElfSegmentTableEntry*);

HEADER_ELF_SECTION_END

HEADER_ELF_STRING_START
    SgAsmElfString(class SgAsmElfStrtab *strtab, rose_addr_t offset)    /*string in string table*/
        {ctor(strtab, offset, false);}
    SgAsmElfString(class SgAsmElfStrtab *strtab, const std::string &s)  /*new string in string table*/
        {ctor(strtab, s);}
    explicit SgAsmElfString(class SgAsmElfStringStorage *storage)       /*string shares other storage*/
        {ctor(storage);}
    explicit SgAsmElfString(const char *s)                              /*non-storage constructor*/
        {ctor(std::string(s));}
    explicit SgAsmElfString(const std::string &s)                       /*non-storage constructor*/
        {ctor(s);}
 // virtual ~SgAsmElfString();
    virtual void dump(FILE*, const char *prefix, ssize_t idx);

    static const rose_addr_t unallocated = ~(rose_addr_t)0;

 // This is not an access function
    virtual std::string get_string() const;
    virtual void set_string(const std::string&);
    rose_addr_t get_offset() const;                                     /*offset is read-only--no set_offset(); triggers realloc*/

    /* Accessors */
 // virtual const std::string& get_string() const;                      /*no non-const version; use only set_string() to modify!*/
 // virtual void set_string(const std::string&);                        /*assignment calls this*/
 // rose_addr_t get_offset() const;                                     /*offset is read-only--no set_offset(); triggers realloc*/
 // class SgAsmElfStringStorage* get_storage() const {                  /*read only; managed by constructor/destructor*/
 //     return p_storage;
 // }

  private:

 // Maybe we need to supressed ROSETTA generated constructor!
 // SgAsmElfString() {abort();}
    void ctor(class SgAsmElfStrtab*, rose_addr_t offset, bool shared);
    void ctor(class SgAsmElfStrtab*, const std::string&);
    void ctor(class SgAsmElfStringStorage*);
    void ctor(const std::string &s);

HEADER_ELF_STRING_END


HEADER_ELF_STRING_TABLE_START
     public:
          SgAsmElfStrtab(SgAsmElfFileHeader *fhdr, SgAsmElfSectionTableEntry *shdr)
             : SgAsmElfSection(fhdr, shdr), p_num_freed(0), p_empty_string(0)
             {ctor(fhdr, shdr);}

       // Supressed ROSETTA generated destructor.
          virtual ~SgAsmElfStrtab();

          virtual void unparse(FILE*);
          virtual void dump(FILE*, const char *prefix, ssize_t idx);
          class SgAsmElfStringStorage *create_storage(addr_t offset, bool shared);
          SgAsmElfString *create_string(addr_t offset, bool shared);
          void free(class SgAsmElfStringStorage*);
          void free_all_strings(bool blow_away_holes=false);
          void reallocate(); /*allocate storage for all unallocated strings*/
          virtual void set_size(addr_t newsize);

     private:
          void ctor(SgAsmElfFileHeader*, SgAsmElfSectionTableEntry*);
          void free(addr_t offset, addr_t size); /*mark part of table as free*/
          rose_addr_t best_fit(addr_t need); /*allocate from free list*/

          typedef std::vector<class SgAsmElfStringStorage*> referenced_t;
          typedef std::map<addr_t, addr_t> freelist_t; /*key is offset; value is size*/

HEADER_ELF_STRING_TABLE_END

HEADER_ELF_DYNAMIC_SECTION_START
     public:
          SgAsmElfDynamicSection(SgAsmElfFileHeader *fhdr, SgAsmElfSectionTableEntry *shdr)
             : SgAsmElfSection(fhdr, shdr), p_dt_pltrelsz(0), p_dt_pltgot(0), p_dt_hash(0), p_dt_strtab(0), p_dt_symtab(0), 
               p_dt_rela(0), p_dt_relasz(0), p_dt_relaent(0), p_dt_strsz(0), p_dt_symentsz(0), p_dt_init(0), p_dt_fini(0), 
               p_dt_pltrel(0), p_dt_jmprel(0), p_dt_verneednum(0), p_dt_verneed(0), p_dt_versym(0)
             {ctor(fhdr, shdr);}
       // virtual ~SgAsmElfDynamicSection() {}

          virtual void set_linked_section(SgAsmElfSection*);   /* Parsing happens here rather than in constructor */
          virtual void unparse(FILE*);
          virtual void dump(FILE*, const char *prefix, ssize_t idx);

       // Moved from global scope
          static void dump_section_rva(FILE *f, const char *p, int w, const char *name, addr_t addr, SgAsmGenericFile *ef);

     private:
	  void ctor(SgAsmElfFileHeader*, SgAsmElfSectionTableEntry*);

HEADER_ELF_DYNAMIC_SECTION_END

HEADER_ELF_DYNAMIC_ENTRY_START
     public:
          struct Elf32DynamicEntry_disk {
               uint32_t            d_tag;  /* Entry type, one of the DT_* constants */
               uint32_t            d_val;  /* Tag's value */
             } __attribute__((packed));

          struct Elf64DynamicEntry_disk {
               uint64_t            d_tag;  /* Entry type, one of the DT_* constants */
               uint64_t            d_val;  /* Tag's value */
             } __attribute__((packed));

          SgAsmElfDynamicEntry(SgAsmExecutableFileFormat::ByteOrder sex, const SgAsmElfDynamicEntry::Elf32DynamicEntry_disk *disk) {ctor(sex, disk);}
          SgAsmElfDynamicEntry(SgAsmExecutableFileFormat::ByteOrder sex, const SgAsmElfDynamicEntry::Elf64DynamicEntry_disk *disk) {ctor(sex, disk);}
       // virtual ~SgAsmElfDynamicEntry() {}

          virtual void dump(FILE*, const char *prefix, ssize_t idx);
          void *encode(SgAsmExecutableFileFormat::ByteOrder, SgAsmElfDynamicEntry::Elf32DynamicEntry_disk*);
          void *encode(SgAsmExecutableFileFormat::ByteOrder, SgAsmElfDynamicEntry::Elf64DynamicEntry_disk*);

     private:
          void ctor(SgAsmExecutableFileFormat::ByteOrder sex, const SgAsmElfDynamicEntry::Elf32DynamicEntry_disk *disk);
          void ctor(SgAsmExecutableFileFormat::ByteOrder sex, const SgAsmElfDynamicEntry::Elf64DynamicEntry_disk *disk);

HEADER_ELF_DYNAMIC_ENTRY_END

HEADER_ELF_SEGMENT_TABLE_START
     public:
          SgAsmElfSegmentTable(SgAsmElfFileHeader *fhdr);
       // virtual ~ElfSegmentTable() {}

          virtual void unparse(FILE*);
          virtual void dump(FILE*, const char *prefix, ssize_t idx);

     private:
          void ctor();

HEADER_ELF_SEGMENT_TABLE_END

HEADER_ELF_SEGMENT_TABLE_ENTRY_START
     public:

       /* Segment types (host order). All other values are reserved. */
          enum SegmentType {
              PT_NULL             = 0,                    /* entry is ignored; other values of entry are undefined */
              PT_LOAD             = 1,                    /* loadable by mapping file contents into memory (see "mapping" note below) */
              PT_DYNAMIC          = 2,                    /* dynamic linking information */
              PT_INTERP           = 3,                    /* segment contains NUL-terminated path name of interpreter */
              PT_NOTE             = 4,                    /* auxiliary information */
              PT_SHLIB            = 5,                    /* Reserved w/unspecified semantics; presence causes file to be nonconforming */
              PT_PHDR             = 6,                    /* Segment contains the segment table itself (program header array) */

	      /* OS- and Processor-specific ranges */
	      PT_LOOS		  = 0x60000000,		  /* Values reserved for OS-specific semantics */
	      PT_HIOS             = 0x6fffffff,
              PT_LOPROC           = 0x70000000,           /* Values reserved for processor-specific semantics */
              PT_HIPROC           = 0x7fffffff,

	      /* OS-specific values for GNU/Linux */
              PT_GNU_EH_FRAME     = 0x6474e550,           /* GCC .eh_frame_hdr segment */
              PT_GNU_STACK        = 0x6474e551,           /* Indicates stack executability */
              PT_GNU_RELRO        = 0x6474e552,           /* Read-only after relocation */
              PT_PAX_FLAGS        = 0x65041580,           /* Indicates PaX flag markings */

	      /* OS-specific values for Sun */
              PT_SUNWBSS          = 0x6ffffffa,           /* Sun Specific segment */
              PT_SUNWSTACK        = 0x6ffffffb            /* Stack segment */
          };

       /* Segment bit flags */
          enum SegmentFlags {
              PF_RESERVED         = 0x0ffffff8,           /* Reserved bits */
              PF_XPERM            = 0x00000001,           /* Execute permission */
              PF_WPERM            = 0x00000002,           /* Write permission */
              PF_RPERM            = 0x00000004,           /* Read permission */
              PF_PROC_MASK        = 0xf0000000            /* Processor-specific bits */
          };

       /* File format of an ELF Segment header. Byte order of members depends on e_ident value in file header. This code
        * comes directly from "Executable and Linkable Format (ELF)", Portable Formats Specification, Version 1.1, Tool Interface
        * Standards (TIS) and not from any header file. The 64-bit structure is gleaned from the Linux elf(5) man page. Segment
        * table entries (a.k.a., ELF program headers) either describe process segments or give supplementary info which does not
        * contribute to the process image.
        *
        * Mapping segments:
        * */
          struct Elf32SegmentTableEntry_disk {
               uint32_t            p_type;                 /* kind of segment */
               uint32_t            p_offset;               /* file offset */
               uint32_t            p_vaddr;                /* desired mapped address of segment */
               uint32_t            p_paddr;                /* physical address where supported (unused by System V) */
               uint32_t            p_filesz;               /* number of bytes in the file (may be zero or other value smaller than p_memsz) */
               uint32_t            p_memsz;                /* number of bytes when mapped (may be zero) */
               uint32_t            p_flags;
               uint32_t            p_align;                /* alignment for file and memory (0,1=>none); must be a power of two */
             } __attribute__((packed));

          struct Elf64SegmentTableEntry_disk {
               uint32_t            p_type;
               uint32_t            p_flags;
               uint64_t            p_offset;
               uint64_t            p_vaddr;
               uint64_t            p_paddr;
               uint64_t            p_filesz;
               uint64_t            p_memsz;
               uint64_t            p_align;
             } __attribute__((packed));


          SgAsmElfSegmentTableEntry(SgAsmExecutableFileFormat::ByteOrder sex, const SgAsmElfSegmentTableEntry::Elf32SegmentTableEntry_disk *disk);
          SgAsmElfSegmentTableEntry(SgAsmExecutableFileFormat::ByteOrder sex, const SgAsmElfSegmentTableEntry::Elf64SegmentTableEntry_disk *disk);
       // virtual ~ElfSegmentTableEntry() {};

          void *encode(SgAsmExecutableFileFormat::ByteOrder, SgAsmElfSegmentTableEntry::Elf32SegmentTableEntry_disk*);
          void *encode(SgAsmExecutableFileFormat::ByteOrder, SgAsmElfSegmentTableEntry::Elf64SegmentTableEntry_disk*);
	  void update_from_section(SgAsmElfSection*);
          virtual void dump(FILE*, const char *prefix, ssize_t idx);

       // DQ (8/26/2008): Added support for clearer output in dump function
          std::string stringifyType  ( SgAsmElfSegmentTableEntry::SegmentType  kind ) const;
       // std::string stringifyFlags ( SgAsmElfSegmentTableEntry::SegmentFlags kind ) const;

     private:
          void ctor(SgAsmExecutableFileFormat::ByteOrder sex, const SgAsmElfSegmentTableEntry::Elf32SegmentTableEntry_disk *disk);
          void ctor(SgAsmExecutableFileFormat::ByteOrder sex, const SgAsmElfSegmentTableEntry::Elf64SegmentTableEntry_disk *disk);

HEADER_ELF_SEGMENT_TABLE_ENTRY_END

HEADER_ELF_SEGMENT_TABLE_ENTRY_LIST_START
HEADER_ELF_SEGMENT_TABLE_ENTRY_LIST_END

HEADER_ELF_SYMBOL_SECTION_START
     public:
          SgAsmElfSymbolSection(SgAsmElfFileHeader *fhdr, SgAsmElfSectionTableEntry *shdr);
       // virtual ~SgAsmElfSymbolSection() {}

          virtual void set_linked_section(SgAsmElfSection*);
          virtual void unparse(FILE*);
          virtual void dump(FILE*, const char *prefix, ssize_t idx);

       /* Accessors for protected/private data members */
       // std::vector<ElfSymbol*>& get_symbols() {return symbols;}
    
     private:
          void ctor(SgAsmElfSectionTableEntry*);

HEADER_ELF_SYMBOL_SECTION_END

HEADER_ELF_SYMBOL_LIST_START
HEADER_ELF_SYMBOL_LIST_END

HEADER_ELF_SYMBOL_START

     public:
          enum ElfSymBinding {
               STB_LOCAL=0,
               STB_GLOBAL=1,
               STB_WEAK=2
             };

          enum ElfSymType {
               STT_NOTYPE  = 0,
               STT_OBJECT  = 1,
               STT_FUNC    = 2,
               STT_SECTION = 3,
               STT_FILE    = 4
             };

          struct Elf32SymbolEntry_disk {
               uint32_t            st_name;   /* Name offset into string table */
               uint32_t            st_value;  /* Value: absolute value, address, etc. depending on sym type */
               uint32_t            st_size;   /* Symbol size in bytes */
               unsigned char       st_info;   /* Type and binding attributes */
               unsigned char       st_res1;   /* Reserved; always zero */
               uint16_t            st_shndx;  /* Section index or special meaning */
             } __attribute__((packed));

          struct Elf64SymbolEntry_disk {
               uint32_t            st_name;
               unsigned char       st_info;
               unsigned char       st_res1;
               uint16_t            st_shndx;
               uint64_t            st_value;
               uint64_t            st_size;
             } __attribute__((packed));

          SgAsmElfSymbol(SgAsmExecutableFileFormat::ByteOrder sex, const SgAsmElfSymbol::Elf32SymbolEntry_disk *disk);
          SgAsmElfSymbol(SgAsmExecutableFileFormat::ByteOrder sex, const SgAsmElfSymbol::Elf64SymbolEntry_disk *disk);
       // virtual ~SgAsmElfSymbol() {};

          void *encode(SgAsmExecutableFileFormat::ByteOrder, SgAsmElfSymbol::Elf32SymbolEntry_disk*);
          void *encode(SgAsmExecutableFileFormat::ByteOrder, SgAsmElfSymbol::Elf64SymbolEntry_disk*);
          virtual void dump(FILE *f, const char *prefix, ssize_t idx);
          void dump(FILE*, const char *prefix, ssize_t idx, SgAsmGenericSection*);
          SgAsmElfSymbol::ElfSymBinding get_elf_binding();
          SgAsmElfSymbol::ElfSymType get_elf_type();

     private:
          void ctor(SgAsmExecutableFileFormat::ByteOrder, const SgAsmElfSymbol::Elf32SymbolEntry_disk*);
          void ctor(SgAsmExecutableFileFormat::ByteOrder, const SgAsmElfSymbol::Elf64SymbolEntry_disk*);

       /* Initialization common to all constructors */
          void ctor_common();

HEADER_ELF_SYMBOL_END





// ***********************************************
//          PE Binary File Format Support
// ***********************************************

HEADER_PE_RVA_SIZE_PAIR_START
     public:
       /* File format for an RVA/Size pair. Such pairs are considered to be part of the PE file header. All fields are little endian. */
          struct RVASizePair_disk
             {
               uint32_t    e_rva;
               uint32_t    e_size;
             } __attribute__((packed));

          SgAsmPERVASizePair(const SgAsmPERVASizePair::RVASizePair_disk *disk);
          void *encode(SgAsmPERVASizePair::RVASizePair_disk *disk);

       // addr_t e_rva;
       // addr_t e_size;

HEADER_PE_RVA_SIZE_PAIR_END


HEADER_PE_RVA_SIZE_PAIR_LIST_START
HEADER_PE_RVA_SIZE_PAIR_LIST_END


HEADER_PE_FILE_HEADER_START

     public:
       // Overloaded base class virtual function
          const char *format_name();

          static bool is_PE (SgAsmGenericFile*);
          static SgAsmPEFileHeader *parse(SgAsmGenericFile*);

       /* File format of a PE File Header. All fields are little endian. */
          struct PEFileHeader_disk {
               unsigned char e_magic[4];           /* magic number "PE\0\0" */
               uint16_t    e_cpu_type;             /* e.g., 0x014c = Intel 386 */
               uint16_t    e_nsections;            /* number of sections defined in the Section Table */
               uint32_t    e_time;                 /* time and date file was created or modified by the linker */
               uint32_t    e_coff_symtab;          /* offset to COFF symbol table */
               uint32_t    e_coff_nsyms;           /* number of symbols in COFF symbol table */
               uint16_t    e_nt_hdr_size;          /* number of remaining bytes in the header following the 'flags' field */
               uint16_t    e_flags;                /* Bit flags: executable file, program/library image, fixed address, etc. */
             } __attribute__((packed));

          struct PE32OptHeader_disk {
               uint16_t    e_opt_magic;            /* magic number */
               uint16_t    e_lmajor;               /* linker version */
               uint16_t    e_lminor;
               uint16_t    e_code_size;            /* Size of .text or sum of all code sections */
               uint32_t    e_data_size;            /* Sum size of initialized data */
               uint32_t    e_bss_size;             /* Sum size of uninitialized data */
               uint32_t    e_entrypoint_rva;       /* RVA="relative virtual address"; relative to 'image_base', below */
               uint32_t    e_code_rva;             /* Address relative to image base for code section when memory mapped */
               uint32_t    e_data_rva;             /* Address relative to image base for data section */
               uint32_t    e_image_base;           /* Virtual base of the image (first byte of file, DOS header). Multiple of 64k. */
               uint32_t    e_section_align;        /* Alignment of sections in memory. Power of two 512<=x<=256M */
               uint32_t    e_file_align;           /* Alignment factor (in bytes) for image pages */
               uint16_t    e_os_major;             /* OS version number required to run this image */
               uint16_t    e_os_minor;
               uint16_t    e_user_major;           /* User-specified at link time. Useful for differentiating between image revisions */
               uint16_t    e_user_minor;
               uint16_t    e_subsys_major;         /* Subsystem version number */
               uint16_t    e_subsys_minor;
               uint32_t    e_reserved9;
               uint32_t    e_image_size;           /* Virtual size (bytes) of the image inc. all headers; multiple of 'section_align' */
               uint32_t    e_header_size;          /* Total header size (DOS Header + PE Header + Section table */
               uint32_t    e_file_checksum;        /* Checksum for entire file; Set to zero by the linker */
               uint16_t    e_subsystem;            /* Unknown, Native, WindowsGUI, WindowsCharacter, OS/2 Character, POSIX Character */
               uint16_t    e_dll_flags;            /* Bit flags for library init/terminate per process or thread */
               uint32_t    e_stack_reserve_size;   /* Virtual memory reserved for stack; non-committed pages are guards */
               uint32_t    e_stack_commit_size;    /* Size (bytes) of valid stack; other pages are guards; <= 'stack_reserve_size' */
               uint32_t    e_heap_reserve_size;    /* Size (bytes) of local heap to reserve */
               uint32_t    e_heap_commit_size;     /* Size (bytes) of valid local heap */
               uint32_t    e_loader_flags;         /* Reserved, must be zero */
               uint32_t    e_num_rvasize_pairs;    /* Number of RVASizePair entries that follow this member; also part of the PE header */
             } __attribute__((packed));

          struct PE64OptHeader_disk {
               uint16_t    e_opt_magic;
               uint16_t    e_lmajor;
               uint16_t    e_lminor;
               uint16_t    e_code_size;
               uint32_t    e_data_size;
               uint32_t    e_bss_size;
               uint32_t    e_entrypoint_rva;
               uint32_t    e_code_rva;
            // uint32_t  e_data_rva;             /* Not present in PE32+ */
               uint64_t    e_image_base;
               uint32_t    e_section_align;
               uint32_t    e_file_align;
               uint16_t    e_os_major;
               uint16_t    e_os_minor;
               uint16_t    e_user_major;
               uint16_t    e_user_minor;
               uint16_t    e_subsys_major;
               uint16_t    e_subsys_minor;
               uint32_t    e_reserved9;
               uint32_t    e_image_size;
               uint32_t    e_header_size;
               uint32_t    e_file_checksum;
               uint16_t    e_subsystem;
               uint16_t    e_dll_flags;
               uint64_t    e_stack_reserve_size;
               uint64_t    e_stack_commit_size;
               uint64_t    e_heap_reserve_size;
               uint64_t    e_heap_commit_size;
               uint32_t    e_loader_flags;
               uint32_t    e_num_rvasize_pairs;
             } __attribute__((packed));

          /* Bit flags for the PE header 'flags' member */
          enum HeaderFlags {
               HF_PROGRAM          = 0x0000,       /* Program image (no non-reserved bits set) */
               HF_EXECUTABLE       = 0x0002,       /* Clear indicates can't load: either link errors or image is being incrementally linked */
               HF_FIXED            = 0x0200,       /* Image *must* be loaded at image_base address or error */
               HF_LIBRARY          = 0x2000,       /* Library image */
               HF_RESERVED_MASK    = 0xddfd        /* Reserved bits */
             };

          /* Values for the PE header 'subsystem' member */
          enum Subsystem {
               HF_SPEC_UNKNOWN     = 0x0000,       /* Specified as 'unknown' in the file */
               HF_NATIVE           = 0x0001,       /* Native */
               HF_WINGUI           = 0x0002,       /* Windows GUI */
               HF_WINCHAR          = 0x0003,       /* Windows character */
               HF_OS2CHAR          = 0x0005,       /* OS/2 character */
               HF_POSIX            = 0x0007        /* POSIX character */
             };

          /* Bit flags for the PE header 'dll_flags' member */
          enum DLLFlags {
               DLL_PROC_INIT       = 0x0001,       /* Per-process library initialization */
               DLL_PROC_TERM       = 0x0002,       /* Per-process library termination */
               DLL_THRD_INIT       = 0x0004,       /* Per-thread library initialization */
               DLL_THRD_TERM       = 0x0008,       /* Per-thread library termination */
               DLL_RESERVED_MASK   = 0xfff0        /* Reserved bits */
             };

     public:
          SgAsmPEFileHeader(SgAsmGenericFile *f, addr_t offset);

       // DQ (8/16/2008): Implemented destructor to delete the p_rvasize_pairs
          virtual ~SgAsmPEFileHeader();

          void add_rvasize_pairs();
          virtual void unparse(FILE*);
          virtual void dump(FILE*, const char *prefix, ssize_t idx);
	  void create_table_sections();

       /* Accessors for protected/private data members */
       // ExtendedDOSHeader *get_dos2_header() {return dos2_header;}
       // void set_dos2_header(ExtendedDOSHeader *h) {dos2_header=h;}
       // PESectionTable *get_section_table() {return section_table;}
       // void set_section_table(PESectionTable *ot) {section_table=ot;}
       // COFFSymtab *get_coff_symtab() {return coff_symtab;}
       // void set_coff_symtab(COFFSymtab *st) {coff_symtab=st;}
    
    /* These are the native-format versions of the same members described in the PEFileHeader_disk format struct. */
       // unsigned    e_cpu_type, e_nsections, e_time;
       // addr_t      e_coff_symtab, e_nt_hdr_size;
       // unsigned    e_coff_nsyms, e_flags, e_opt_magic;
       // unsigned    e_lmajor, e_lminor, e_code_size, e_data_size, e_bss_size, e_entrypoint_rva, e_code_rva, e_data_rva;
      //  addr_t      e_image_base;
       // unsigned    e_section_align, e_file_align, e_os_major, e_os_minor, e_user_major, e_user_minor;
       // unsigned    e_subsys_major, e_subsys_minor, e_reserved9, e_image_size, e_header_size, e_file_checksum, e_subsystem;
       // unsigned    e_dll_flags, e_stack_reserve_size, e_stack_commit_size, e_heap_reserve_size, e_heap_commit_size;
       // unsigned    e_loader_flags, e_num_rvasize_pairs;
       // std::vector<RVASizePair> rvasize_pairs;

     private:
          void ctor(SgAsmGenericFile *f, addr_t offset);
          void *encode(SgAsmPEFileHeader::PEFileHeader_disk*);
          void *encode(SgAsmPEFileHeader::PE32OptHeader_disk*);
          void *encode(SgAsmPEFileHeader::PE64OptHeader_disk*);
       // ExtendedDOSHeader *dos2_header;
       // PESectionTable *section_table;
       // COFFSymtab *coff_symtab;

HEADER_PE_FILE_HEADER_END

HEADER_PE_SECTION_START
     public:
          SgAsmPESection(SgAsmPEFileHeader*, addr_t offset, addr_t size);
       // virtual ~PESection() {}

          virtual void dump(FILE*, const char *prefix, ssize_t idx);

       /* Accessors for protected/private data */
       // PESectionTableEntry *get_st_entry() {return st_entry;}
       // void set_st_entry(PESectionTableEntry *e) {st_entry=e;}

  // private:
       // PESectionTableEntry *st_entry;

HEADER_PE_SECTION_END

HEADER_PE_IMPORT_SECTION_START
     public:
          SgAsmPEImportSection(SgAsmPEFileHeader *fhdr, addr_t offset, addr_t size, addr_t mapped_rva);
       // virtual ~PEImportSection() {}

          virtual void unparse(FILE*);
          virtual void dump(FILE*, const char *prefix, ssize_t idx);
          void add_dll(SgAsmPEDLL *d);

       /* Accessors for protected/private data members */
       // const std::vector<PEDLL*>& get_dlls() {return dlls;}

     private:
          void ctor(addr_t offset, addr_t size, addr_t mapped_rva);
       // std::vector<PEDLL*> dlls;

HEADER_PE_IMPORT_SECTION_END

HEADER_PE_SECTION_TABLE_START
     public:
          SgAsmPESectionTable(SgAsmPEFileHeader *fhdr, addr_t offset, addr_t size);
       // virtual ~SgAsmPESectionTable() {}

          virtual void unparse(FILE*);
          virtual void dump(FILE*, const char *prefix, ssize_t idx);

  private:
          void ctor();

HEADER_PE_SECTION_TABLE_END

HEADER_PE_COFF_SYMBOL_TABLE_START
     public:
          SgAsmCoffSymbolTable(SgAsmPEFileHeader *fhdr);
       // virtual ~COFFSymtab() {}

          virtual void unparse(FILE*);
          virtual void dump(FILE*, const char *prefix, ssize_t idx);

       /* Accessors for protected/private data members */
       // std::vector<SgAsmCoffSymbol*>& get_symbols() {return symbols;}
       // ExecSection *get_strtab() {return strtab;}

     private:
          void ctor();
       // std::vector<COFFSymbol*> symbols;
       // ExecSection *strtab;                /* Section containing symbol names */

HEADER_PE_COFF_SYMBOL_TABLE_END

HEADER_PE_IMPORT_HINT_NAME_START
     public:
       /* Hint/name pairs */
          struct PEImportHintName_disk {
               uint16_t            hint;  /* Possible index into lib's export name pointer table */
            /* NUL-terminated name follows */
            /* Optional byte to pad struct to an even number of bytes */
             };

          SgAsmPEImportHintName(SgAsmGenericSection*, addr_t offset);
       // virtual ~PEImportHintName() {};

          void unparse(FILE *f, SgAsmGenericSection*, addr_t spos); /*not the standard unparse() function*/
          virtual void dump(FILE*, const char *prefix, ssize_t idx);

       /* Accessors for protected/private data members */
       // void set_name(std::string name) {this->name=name;}
       // std::string get_name() {return name;}

     private:
          void ctor(SgAsmGenericSection*, addr_t offset);
       // unsigned hint;
       // std::string name;
       // unsigned char padding;

HEADER_PE_IMPORT_HINT_NAME_END

HEADER_PE_IMPORT_DIRECTORY_START

     public:
          struct PEImportDirectory_disk {
               uint32_t            hintnames_rva;   /* address (RVA) of array of addresses (RVAs) of hint/name pairs */
               uint32_t            time;
               uint32_t            forwarder_chain;
               uint32_t            dll_name_rva;    /* address of NUL-terminated library name */
               uint32_t            bindings_rva;    /* address (RVA) of array of object addresses after binding to DLL */
             } __attribute__((packed));

          SgAsmPEImportDirectory(const SgAsmPEImportDirectory::PEImportDirectory_disk *disk);
       // virtual ~PEImportDirectory() {}

          void *encode(SgAsmPEImportDirectory::PEImportDirectory_disk*);
          virtual void dump(FILE*, const char *prefix, ssize_t idx);

       /* Native versions of the fields in PEImportDirectory_disk */
       // addr_t              hintnames_rva, bindings_rva, dll_name_rva;
       // time_t              time;
       // unsigned            forwarder_chain;

     private:
          void ctor(const SgAsmPEImportDirectory::PEImportDirectory_disk*);

HEADER_PE_IMPORT_DIRECTORY_END

HEADER_PE_EXTENDED_DOS_HEADER_START

     public:
          struct ExtendedDOSHeader_disk {
               unsigned char e_res1[4];    /* 0x00 reserved */
               uint16_t    e_oemid;        /* 0x04 OEM Identifier */
               uint16_t    e_oeminfo;      /* 0x06 other OEM information; oemid specific */
               uint16_t    e_res2[10];     /* 0x08 reserved */
               uint32_t    e_lfanew;       /* 0x1c file offset of new exe (PE) header */
             } __attribute__((packed));    /* 0x20 */

     public:
          SgAsmPEExtendedDOSHeader(SgAsmGenericFile *f, addr_t offset);
       // virtual ~SgAsmPEExtendedDOSHeader() {}

          void *encode(SgAsmPEExtendedDOSHeader::ExtendedDOSHeader_disk*);
          virtual void unparse(FILE*);
          virtual void dump(FILE*, const char *prefix, ssize_t idx);

     private:
          void ctor(SgAsmGenericFile *f, addr_t offset);

HEADER_PE_EXTENDED_DOS_HEADER_END

HEADER_PE_SECTION_TABLE_ENTRY_START

     public:
       /* File format of a section table entry. All fields are little endian. Sections are ordered by RVA. */
          struct PESectionTableEntry_disk {
               char        name[8];                /* NUL-padded */
               uint32_t    virtual_size;           /* virtual memory size (bytes), >= physical_size and difference is zero filled */
               uint32_t    rva;                    /* relative virtual address wrt Image Base; multiple of section_align; dense space */
               uint32_t    physical_size;          /* bytes of initialized data on disk; multiple of file_align & <= virtual_size */
               uint32_t    physical_offset;        /* location of initialized data on disk; multiple of file_align */
               uint32_t    coff_line_nums;         /* file offset of COFF line number info or zero */
               uint32_t    n_relocs;               /* number of relocation entries; should be zero for executables */
               uint32_t    n_coff_line_nums;       /* number of COFF line number entries */
               uint32_t    flags;                  /* PESectionFlags bits: code, data, caching, paging, shared, permissions, etc. */
             } __attribute__((packed));

       /* These come from the windows PE documentation and http://en.wikibooks.org/wiki/X86_Disassembly/Windows_Executable_Files */
          enum PESectionFlags {
               OF_CODE             = 0x00000020,   /* section contains code */
               OF_IDATA            = 0x00000040,   /* initialized data */
               OF_UDATA            = 0x00000080,   /* uninitialized data */
               OF_INFO             = 0x00000200,   /* comments or some other type of info */
               OF_REMOVE           = 0x00000800,   /* section will not become part of image */
               OF_COMDAT           = 0x00001000,   /* section contains comdat */
               OF_NO_DEFER_SPEC_EXC= 0x00004000,   /* reset speculative exception handling bits in the TLB entires for this section */
               OF_GPREL            = 0x00008000,   /* section content can be access relative to GP */
               OF_ALIGN_1          = 0x00100000,   /* no alignment */
               OF_ALIGN_2          = 0x00200000,   /* 2-byte alignment */
               OF_ALIGN_4          = 0x00300000,   /* 4-byte alignment */
               OF_ALIGN_8          = 0x00400000,   /* 8-byte alignment */
               OF_ALIGN_16         = 0x00500000,   /* 16-byte alignment (default if not other alignment specified) */
               OF_ALIGN_32         = 0x00600000,   /* 32-byte alignment */
               OF_ALIGN_64         = 0x00700000,   /* 64-byte alignment */
               OF_ALIGN_128        = 0x00800000,   /* 128-byte alignment */
               OF_ALIGN_256        = 0x00900000,   /* 256-byte alignment */
               OF_ALIGN_512        = 0x00a00000,   /* 512-byte alignment */
               OF_ALIGN_1k         = 0x00b00000,   /* 1024-byte alignment */
               OF_ALIGN_2k         = 0x00c00000,   /* 2048-byte alignment */
               OF_ALIGN_4k         = 0x00d00000,   /* 4096-byte alignment */
               OF_ALIGN_8k         = 0x00e00000,   /* 8192-byte alignment */
               OF_ALIGN_MASK       = 0x00f00000,   /* mask for alignment value */
               OF_NRELOC_OVFL      = 0x01000000,   /* section contains extended relocations */
               OF_DISCARDABLE      = 0x02000000,   /* can be discarded */
               OF_NO_CACHE         = 0x04000000,   /* section must not be cached */
               OF_NO_PAGING        = 0x08000000,   /* section is not pageable */
               OF_SHARED           = 0x10000000,   /* section is shared */
               OF_EXECUTABLE       = 0x20000000,   /* execute permission */
               OF_READABLE         = 0x40000000,   /* read permission */
               OF_WRITABLE         = 0x80000000,   /* write permission */
             };

          SgAsmPESectionTableEntry(const SgAsmPESectionTableEntry::PESectionTableEntry_disk *disk);
       // virtual ~SgAsmPESectionTableEntry() {};

          void *encode(SgAsmPESectionTableEntry::PESectionTableEntry_disk*);
          virtual void dump(FILE*, const char *prefix, ssize_t idx);
    
       /* These are the native-format versions of the same members described in the PESectionTableEntry_disk struct. */
       // std::string name;
       // addr_t      virtual_size, rva, physical_size, physical_offset;
       // unsigned    coff_line_nums, n_relocs, n_coff_line_nums, flags;

     private:
          void ctor(const SgAsmPESectionTableEntry::PESectionTableEntry_disk*);

HEADER_PE_SECTION_TABLE_ENTRY_END

HEADER_PE_DLL_START
     public:
          SgAsmPEDLL(SgAsmGenericString *name);
       // virtual ~SgAsmPEDLL() {}

          virtual void dump(FILE*, const char *prefix, ssize_t idx);
          void add_hintname_rva(addr_t a);
          void add_hintname(SgAsmPEImportHintName *hn);
          void add_binding(addr_t a);

       /* Accessors for protected/private data members */
       // PEImportDirectory *get_idir() {return idir;}
       // void set_idir(PEImportDirectory *d) {idir=d;}
       // const std::vector<addr_t>& get_hintname_rvas() const {return hintname_rvas;}
       // const std::vector<PEImportHintName*>& get_hintnames() const {return hintnames;}
       // const std::vector<addr_t>& get_bindings() const {return bindings;}

  // private:
       // PEImportDirectory *idir;
       // std::vector<addr_t> hintname_rvas;          /* RVAs for the hint/name pairs of the DLL functions */
       // std::vector<PEImportHintName*> hintnames;   /* The hint/name pairs */
       // std::vector<addr_t> bindings;               /* Bindings (RVA) for each function */
	  void ctor();
HEADER_PE_DLL_END



HEADER_PE_COFF_SYMBOL_LIST_START
HEADER_PE_COFF_SYMBOL_LIST_END

HEADER_PE_COFF_SYMBOL_START
     public:

       // This was previously a #define macro in ExecPE.h (so we have to avoid the macro defining it as "static const unsigned int 18 = 18"
          static const unsigned int COFFSymbol_disk_size = 18;

          struct COFFSymbol_disk {
               union {
                   char            st_name[8];
                   struct {
                       uint32_t    st_zero;
                       uint32_t    st_offset;
                   };
               };
               uint32_t            st_value;
               int16_t             st_section_num;
               uint16_t            st_type;
               unsigned char       st_storage_class;
               unsigned char       st_num_aux_entries;
             } __attribute__((packed));

          SgAsmCoffSymbol(SgAsmPEFileHeader *fhdr, SgAsmGenericSection *symtab, SgAsmGenericSection *strtab, size_t idx);
       // virtual ~COFFSymbol() {}
          void *encode(SgAsmCoffSymbol::COFFSymbol_disk*);
          virtual void dump(FILE *f, const char *prefix, ssize_t idx);

       /* Auxilliary data for the symbol */
       // const unsigned char *get_aux_data() {return aux_data;}
       // size_t get_aux_size() {return aux_size;}

       /* Native versions of the COFFSymbol_disk members */
       // std::string         st_name;        /* The original name; super.name might be modified */
       // addr_t              st_name_offset;
       // int                 st_section_num;
       // unsigned            st_type, st_storage_class, st_num_aux_entries;
    
     private:
          void ctor(SgAsmPEFileHeader*, SgAsmGenericSection *symtab, SgAsmGenericSection *strtab, size_t idx);
       // const unsigned char *aux_data;      /* Auxilliary data from table entries that follow */
       // size_t              aux_size;       /* Size (bytes) of auxilliary data */

HEADER_PE_COFF_SYMBOL_END



// ***********************************************
//          NE Binary File Format Support
// ***********************************************

HEADER_NE_FILE_HEADER_START

     public:
       // Overloaded base class virtual function
          const char *format_name();

          static bool is_NE (SgAsmGenericFile*);
          static SgAsmNEFileHeader *parse(SgAsmGenericFile*);

          /* File format of an NE File Header. All fields are little endian.
           *
           * NOTES
           * 
           * e_sssp: The value specified in SS is an index (1-origin) into the segment table. If SS addresses the automatic data segment
           *         and SP is zero then SP is set to the address obtained by adding the size of the automatic data segment to the size
           *         of the stack. */
          struct NEFileHeader_disk {
               unsigned char e_magic[2];           /* 0x00 magic number "NE" */
               unsigned char e_linker_major;       /* 0x02 linker major version number */
               unsigned char e_linker_minor;       /* 0x03 linker minor version number */
               uint16_t    e_entrytab_rfo;         /* 0x04 entry table offset relative to start of header */
               uint16_t    e_entrytab_size;        /* 0x06 size of entry table in bytes */
               uint32_t    e_checksum;             /* 0x08 32-bit CRC of entire file (this word is taken a zero during the calculation) */
               uint16_t    e_flags1;               /* 0x0c file-level bit flags (see HeaderFlags1) */
               uint16_t    e_autodata_sn;          /* 0x0e auto data section number if (flags & 0x3)==0; else zero */
               uint16_t    e_bss_size;             /* 0x10 num bytes added to data segment for BSS */
               uint16_t    e_stack_size;           /* 0x12 num bytes added to data segment for stack (zero of SS!=DS registers) */
               uint32_t    e_csip;                 /* 0x14 section number:offset of CS:IP */
               uint32_t    e_sssp;                 /* 0x18 section number:offset of SS:SP (see note 1 above) */
               uint16_t    e_nsections;            /* 0x1c number of entries in the section table */
               uint16_t    e_nmodrefs;             /* 0x1e number of entries in the module reference table */
               uint16_t    e_nnonresnames;         /* 0x20 number of entries in the non-resident name table */
               uint16_t    e_sectab_rfo;           /* 0x22 offset of section table relative to start of header */
               uint16_t    e_rsrctab_rfo;          /* 0x24 offset of resource table relative to start of header */
               uint16_t    e_resnametab_rfo;       /* 0x26 offset of resident name table relative to start of header */
               uint16_t    e_modreftab_rfo;        /* 0x28 offset of module reference table relative to start of header */
               uint16_t    e_importnametab_rfo;    /* 0x2a offset of imported names table relative to start of header */
               uint32_t    e_nonresnametab_offset; /* 0x2c file offset of non-resident name table */
               uint16_t    e_nmovable_entries;     /* 0x30 number of movable entries in Entry Table */
               uint16_t    e_sector_align;         /* 0x32 sector alignment shift count (log2 of segment sector size) */
               uint16_t    e_nresources;           /* 0x34 number of resource entries */
               unsigned char e_exetype;            /* 0x36 executable type (2==windows) */
               unsigned char e_flags2;             /* 0x37 additional flags (see HeaderFlags2) */
               uint16_t    e_fastload_sector;      /* 0x38 sector offset to fast-load area (only for Windows) */
               uint16_t    e_fastload_nsectors;    /* 0x3a size of fast-load area in sectors (only for Windows) */
               uint16_t    e_res1;                 /* 0x3c reserved */
               uint16_t    e_winvers;              /* 0x3e expected version number for Windows (only for Windows) */
             } __attribute__((packed));              /* 0x40 */

          /* Bit flags for the NE header 'e_flags' member.
           *
           * If HF_LIBRARY (bit 15) is set then the CS:IP registers point to an initialization procedure called with the value in the AX
           * register equal to the module handle. The initialization procedure must execute a far return to the caller. The resulting
           * value in AX is a status indicator (non-zero for success, zero for failure). */
          enum HeaderFlags1 {
               HF1_RESERVED         = 0x57f4,      /* Reserved bits */
               HF1_NO_DATA          = 0x0000,      /* (flags&0x03==0) => an exe not containing a data segment */
               HF1_SINGLE_DATA      = 0x0001,      /* Executable contains one data segment; set if file is a DLL */
               HF1_MULTIPLE_DATA    = 0x0002,      /* Exe with multiple data segments; set if a windows application */
               HF1_LOADER_SEGMENT   = 0x0800,      /* First segment contains code that loads the application */
               HF1_FATAL_ERRORS     = 0x2000,      /* Errors detected at link time; module will not load */
               HF1_LIBRARY          = 0x8000,      /* Module is a library */
             };

          /* Bit flags for the NE header 'e_flags2' member. */
          enum HeaderFlags2 {
               HF2_RESERVED         = 0xf1,        /* Reserved bits */
               HF2_PROTECTED_MODE   = 0x02,        /* Windows 2.x application that runs in 3.x protected mode */
               HF2_PFONTS           = 0x04,        /* Windows 2.x application that supports proportional fonts */
               HF2_FASTLOAD         = 0x08         /* Executable contains a fast-load area */
             };

          SgAsmNEFileHeader(SgAsmGenericFile *f, addr_t offset);
       // virtual ~NEFileHeader() {}

          virtual void unparse(FILE*);
          virtual void dump(FILE*, const char *prefix, ssize_t idx);
       // virtual const char *format_name() {return "NE";}

       /* Accessors for protected/private data members */
       // ExtendedDOSHeader *get_dos2_header() {return dos2_header;}
       // void set_dos2_header(ExtendedDOSHeader *h) {dos2_header=h;}
       // NESectionTable *get_section_table() {return section_table;}
       // void set_section_table(NESectionTable *ot) {section_table=ot;}
       // NENameTable *get_resname_table() {return resname_table;}
       // void set_resname_table(NENameTable *ot) {resname_table=ot;}
       // NENameTable *get_nonresname_table() {return nonresname_table;}
       // void set_nonresname_table(NENameTable *ot) {nonresname_table=ot;}
       // NEModuleTable *get_module_table() {return module_table;}
       // void set_module_table(NEModuleTable *ot) {module_table=ot;}
       // NEEntryTable *get_entry_table() {return entry_table;}
       // void set_entry_table(NEEntryTable *ot) {entry_table=ot;}
    
       /* These are the native-format versions of the same members described in the NEFileHeader_disk format struct. */
       // unsigned    e_linker_major, e_linker_minor, e_checksum, e_flags1, e_autodata_sn, e_bss_size, e_stack_size;
       // unsigned    e_csip, e_sssp, e_nsections, e_nmodrefs, e_nnonresnames, e_nmovable_entries, e_sector_align;
       // unsigned    e_nresources, e_exetype, e_flags2, e_res1, e_winvers;
       // addr_t      e_entrytab_rfo, e_entrytab_size, e_sectab_rfo, e_rsrctab_rfo, e_resnametab_rfo, e_modreftab_rfo;
       // addr_t      e_importnametab_rfo, e_nonresnametab_offset, e_fastload_sector, e_fastload_nsectors;

     private:
          void ctor(SgAsmGenericFile *f, addr_t offset);
          void *encode(SgAsmNEFileHeader::NEFileHeader_disk*);

       // ExtendedDOSHeader *dos2_header;
       // NESectionTable *section_table;
       // NENameTable *resname_table;
       // NENameTable *nonresname_table;
       // NEModuleTable *module_table;
       // NEEntryTable *entry_table;

HEADER_NE_FILE_HEADER_END

HEADER_NE_SECTION_START
     public:
          SgAsmNESection(SgAsmNEFileHeader*, addr_t offset, addr_t size);
       // virtual ~NESection() {}

          virtual void unparse(FILE*);
          virtual void dump(FILE*, const char *prefix, ssize_t idx);

       /* Accessors for protected/private data */
       // NESectionTableEntry *get_st_entry() {return st_entry;}
       // void set_st_entry(NESectionTableEntry *e) {st_entry=e;}
       // NERelocTable *get_reloc_table() {return reloc_table;}
       // void set_reloc_table(NERelocTable *t) {reloc_table=t;}
  // private:
       // NESectionTableEntry *st_entry;
       // NERelocTable *reloc_table;

HEADER_NE_SECTION_END

HEADER_NE_SECTION_TABLE_START
     public:
          SgAsmNESectionTable(SgAsmNEFileHeader *fhdr);
       // virtual ~NESectionTable() {}

          virtual void unparse(FILE*);
          virtual void dump(FILE*, const char *prefix, ssize_t idx);

     private:
          void ctor();

HEADER_NE_SECTION_TABLE_END

HEADER_NE_NAME_TABLE_START
     public:
          SgAsmNENameTable(SgAsmNEFileHeader *fhdr, addr_t offset);
       // virtual ~NENameTable() {}

          virtual void unparse(FILE*);
          virtual void dump(FILE*, const char *prefix, ssize_t idx);
          std::vector<std::string> get_names_by_ordinal(unsigned ordinal);

     private:
          void ctor();
       // std::vector<std::string> names; /*first name is module name; remainder are symbols within the module*/
       // std::vector<unsigned> ordinals; /*first entry is ignored but present in file*/

HEADER_NE_NAME_TABLE_END

HEADER_NE_MODULE_TABLE_START
     public:
          SgAsmNEModuleTable(SgAsmNEFileHeader *fhdr, addr_t offset, addr_t size, SgAsmNEStringTable *strtab);
       // virtual ~NEModuleTable() {}

          virtual void unparse(FILE*);
          virtual void dump(FILE*, const char *prefix, ssize_t idx);

     private:
          void ctor();

       // NEStringTable *strtab;

HEADER_NE_MODULE_TABLE_END

HEADER_NE_STRING_TABLE_START
     public:
          SgAsmNEStringTable(SgAsmNEFileHeader *fhdr, addr_t offset, addr_t length);
       // virtual ~NEStringTable() {}

       // virtual void unparse(FILE*); /*not needed; use parent's implementation*/

          virtual void dump(FILE*, const char *prefix, ssize_t idx);
          std::string get_string(addr_t offset);

     private:
          void ctor();

HEADER_NE_STRING_TABLE_END

HEADER_NE_ENTRY_TABLE_START
     public:
          SgAsmNEEntryTable(SgAsmNEFileHeader *fhdr, addr_t offset, addr_t size);
       // virtual ~NEEntryTable() {}

          void populate_entries();
          virtual void unparse(FILE*);
          virtual void dump(FILE*, const char *prefix, ssize_t idx);

     private:
          void ctor();

       // std::vector<size_t> bundle_sizes;
       // std::vector<NEEntryPoint> entries;

HEADER_NE_ENTRY_TABLE_END

HEADER_NE_RELOC_TABLE_START
     public:
          SgAsmNERelocTable(SgAsmNEFileHeader *fhdr, addr_t offset);
       // virtual ~NERelocTable() {}

          virtual void unparse(FILE*);
          virtual void dump(FILE*, const char *prefix, ssize_t idx);

     private:
          void ctor();

       // std::vector<NERelocEntry> entries;

HEADER_NE_RELOC_TABLE_END

HEADER_NE_EXTENDED_DOS_HEADER_START
     public:
          struct ExtendedDOSHeader_disk {
               uint16_t    e_res1[14];   /* reserved */
               uint32_t    e_lfanew;     /* file offset for NE header */
             } __attribute__((packed));

          SgAsmNEExtendedDOSHeader(SgAsmGenericFile *f, addr_t offset);
       // virtual ~ExtendedDOSHeader() {};

          void *encode(SgAsmNEExtendedDOSHeader::ExtendedDOSHeader_disk*);
          virtual void unparse(FILE*);
          virtual void dump(FILE*, const char *prefix, ssize_t idx);

       /* These are the native-format versions of the same members described in the ExtendedDOSHeader_disk struct. */
       // unsigned e_res1[14];
       // addr_t e_lfanew;

     private:
          void ctor(SgAsmGenericFile *f, addr_t offset);

HEADER_NE_EXTENDED_DOS_HEADER_END

HEADER_NE_ENTRY_POINT_START
          enum NEEntryFlags {
	       EF_ZERO		   = 0x00, /* No flags set */
               EF_RESERVED         = 0xfc, /* Reserved bits */
               EF_EXPORTED         = 0x01, /* Exported */
               EF_GLOBAL           = 0x02  /* Uses a global (shared) data section */
             };

       // SgAsmNEEntryPoint();
          SgAsmNEEntryPoint(SgAsmNEEntryPoint::NEEntryFlags flags, unsigned int3f, unsigned s_idx, unsigned s_off);

          void dump(FILE*, const char *prefix, ssize_t idx) const;

       // NEEntryFlags flags;         /* bit flags */
       // unsigned int3f;             /* always 0x3fxx */
       // unsigned section_idx;       /* zero indicates unused entry */
       // unsigned section_offset;    /* byte offset into section */

HEADER_NE_ENTRY_POINT_END

HEADER_NE_RELOC_ENTRY_START

     public:

       /* NERelocEntry_disk -- variable size with multiple levels of 'union'. It's easier to just parse it in NERelocEntry::ctor()
        * than defining it here as a struct. */

          enum NERelocSrcType {
               RF_SRCTYPE_8OFF     = 0,            /* Byte offset */
               RF_SRCTYPE_WORDSEG  = 2,            /* Word segment, 16-bit selector */
               RF_SRCTYPE_16PTR    = 3,            /* 16-bit far pointer */
               RF_SRCTYPE_16OFF    = 5,            /* 16-bit offset */
               RF_SRCTYPE_32PTR    = 6,            /* 32-bit far pointer */
               RF_SRCTYPE_32OFF    = 7,            /* 32-bit offset */
               RF_SRCTYPE_NEARCALL = 8,            /* near call or jump, WORD/DWROD based on section attribute */
               RF_SRCTYPE_48PTR    = 11,           /* 48-bit pointer */
               RF_SRCTYPE_32OFF_b  = 13            /* 32-bit offset (not sure how this differs from case 7) */
             };

          enum NERelocTgtType {
               RF_TGTTYPE_IREF     = 0,            /* Internal reference */
               RF_TGTTYPE_IORD     = 1,            /* Imported (extern) ordinal */
               RF_TGTTYPE_INAME    = 2,            /* Imported (extern) name */
               RF_TGTTYPE_OSFIXUP  = 3             /* Operating system fixup */ 
             };

          enum NERelocModifiers {
               RF_MODIFIER_SINGLE  = 1,
               RF_MODIFIER_MULTI   = 3
             };

          enum NERelocFlags {
               RF_ADDITIVE         = 0x01,         /* add target to source rather than replace source with target */
               RF_RESERVED         = 0x02,         /* reserved bits */
               RF_2EXTRA           = 0x04,         /* relocation info has size with new two bytes at end */
               RF_32ADD            = 0x08,         /* addition with 32-bits rather than 16 */
               RF_16SECTION        = 0x10,         /* 16-bit object number & module name rather than 8-bit */
               RF_8ORDINAL         = 0x20,         /* Ordinal is 8-bits rather than 16 */
             };

       // DQ (8/7/2008): At only (I hope) the risk of using more memory that required, break the union so that we can better support 
       // this in ROSETTA. One solution might be to implement a common base class of unsigned, unsigned, addr_t; and then use member 
       // functions to access the data in the base class.
          struct iref_type
             { /*tgt_type==0x00: internal reference*/
               unsigned    sect_idx;       /* section index (1-origin) */
               unsigned    res1;           /* reserved */
               addr_t      tgt_offset;
     
            // Added to support RTI support in ROSE
               friend std::ostream & operator<< ( std::ostream & os, const iref_type & x );

               iref_type();
             };

          struct iord_type { /*tgt_type==0x01: imported ordinal*/
               unsigned    modref;         /* 1-based index into import module table */
               unsigned    ordinal;
               addr_t      addend;         /* value to add (only present for flags & RF_2EXTRA) */

            // Added to support RTI support in ROSE
               friend std::ostream & operator<< ( std::ostream & os, const iord_type & x );

               iord_type();
             };

          struct iname_type { /*tgt_type==0x02: imported name*/
               unsigned    modref;         /* 1-based index into import module table */
               unsigned    nm_off;         /* offset into import procedure names */
               addr_t      addend;         /* value to add (only present for flags & RF_2EXTRA) */

            // Added to support RTI support in ROSE
               friend std::ostream & operator<< ( std::ostream & os, const iname_type & x );

               iname_type();
             };

          struct osfixup_type { /*tgt_type==0x03: operating system fixup*/
               unsigned    type;
               unsigned    res3;

            // Added to support RTI support in ROSE
               friend std::ostream & operator<< ( std::ostream & os, const osfixup_type & x );

               osfixup_type();
             };

          SgAsmNERelocEntry(SgAsmGenericSection *relocs, addr_t at, addr_t *rec_size);

          void ctor(SgAsmGenericSection*, addr_t at, addr_t *rec_size);
          addr_t unparse(FILE*, SgAsmGenericSection*, addr_t spos);
          void dump(FILE*, const char *prefix, ssize_t idx);

       // NERelocSrcType      src_type;       /* low nibble of first byte of relocation record */
       // NERelocModifiers    modifier;       /* high nibble of first byte */
       // NERelocTgtType      tgt_type;       /* low two bits of second byte */
       // NERelocFlags        flags;          /* high six bits of second byte */
       // addr_t              src_offset;

       // iref_type iref;
       // iord_type iord;
       // iname_type iname;
       // osfixup_type osfixup;

HEADER_NE_RELOC_ENTRY_END

HEADER_NE_SECTION_TABLE_ENTRY_START
     public:
       /* File format of a section table entry. All fields are little endian. */
          struct NESectionTableEntry_disk {
               uint16_t    sector;                 /* 0x00 File offset (sector size defined in hdr); zero means no file data */
               uint16_t    physical_size;          /* 0x02 Length of segment in file; zero means 64k if sector is non-zero */
               uint16_t    flags;                  /* 0x04 Segment bit flags */
               uint16_t    virtual_size;           /* 0x06 Total size of segment when mapped to memory; zero means 64k */
             } __attribute__((packed));              /* 0x08 */

          enum NESectionFlags {
               SF_RESERVED         = 0x0e08,       /* these bits are reserved */

               SF_TYPE_MASK        = 0x0007,       /* segment-type field */
               SF_CODE             = 0x0000,       /* code-segment type */
               SF_DATA             = 0x0001,       /* data-segment (otherwise segment is code) */
               SF_ALLOC            = 0x0002,       /* loader allocates memory */
               SF_LOAD             = 0x0004,       /* load the segment */

               SF_MOVABLE          = 0x0010,       /* segment is not fixed */
               SF_PURE             = 0x0020,       /* segment is pure, or sharable; otherwise impure or non-sharable */
               SF_PRELOAD          = 0x0040,       /* segment will be preloaded; read-only if this is a data segment */
               SF_NOT_WRITABLE     = 0x0080,       /* code segment is execute only; data segment is read-only */
               SF_RELOCINFO        = 0x0100,       /* segment has relocation records */
               SF_DISCARDABLE      = 0x1000,       /* discardable */
               SF_DISCARD          = 0xf000        /* discard priority */
             };

          SgAsmNESectionTableEntry(const SgAsmNESectionTableEntry::NESectionTableEntry_disk *disk);
       // virtual ~NESectionTableEntry() {};

          void *encode(SgAsmNESectionTableEntry::NESectionTableEntry_disk*);
          virtual void dump(FILE *f, const char *prefix, ssize_t idx) {dump(f, prefix, idx, NULL);}
          void dump(FILE*, const char *prefix, ssize_t idx, SgAsmNEFileHeader *fhdr);

       /* These are the native-format versions of the same members described in the NESectionTableEntry_disk struct. */
       // unsigned    flags, sector;
       // addr_t      physical_size, virtual_size;

     private:
          void ctor(const SgAsmNESectionTableEntry::NESectionTableEntry_disk*);

HEADER_NE_SECTION_TABLE_ENTRY_END



// ***********************************************
//          LE Binary File Format Support
// ***********************************************

HEADER_LE_FILE_HEADER_START

     public:
       // Overloaded base class virtual function
          const char *format_name();

          static bool is_LE (SgAsmGenericFile*);
          static SgAsmLEFileHeader *parse(SgAsmGenericFile*);

       /* File format of an LE/LX File Header (they are identical except bytes 0x2c-0x2f) */
          struct LEFileHeader_disk {
              unsigned char e_magic[2];           /* 0x00 magic number "LX" */
              unsigned char e_byte_order;         /* 0x02 byte order (0=>little endian; otherwise big endian) */
              unsigned char e_word_order;         /* 0x03 word order (0=>little endian; otherwise big endian) */
              uint32_t    e_format_level;         /* 0x04 LX file format version number */
              uint16_t    e_cpu_type;             /* 0x08 1=>80286, 2=>80386, 3=>80486,4=80586, etc. (see ctor) */
              uint16_t    e_os_type;              /* 0x0a 0=>unknown, 1=>0S/2, 2=>Windows, 3=>DOS 4.x, 4=>Windows 386 */
              uint32_t    e_module_version;       /* 0x0c user-specified module version number */
              uint32_t    e_flags;                /* 0x10 bit flags (see LXFileHeaderFlags) */
              uint32_t    e_npages;               /* 0x14 number of physically contained pages (see e_page_size) */
              uint32_t    e_eip_section;          /* 0x18 the section number to which e_eip is relative */
              uint32_t    e_eip;                  /* 0x1c entry address relative to e_eip_section */
              uint32_t    e_esp_section;          /* 0x20 the section number to which e_esp is relative */
              uint32_t    e_esp;                  /* 0x24 starting stack address relative to e_esp_section */
              uint32_t    e_page_size;            /* 0x28 page size in bytes */
              uint32_t    e_lps_or_shift;         /* 0x2c size of last page (LE) or shift for page table's page offset field (LX) */
              uint32_t    e_fixup_sect_size;      /* 0x30 total size of fixup info in bytes (fixup page/record tables + import names) */
              uint32_t    e_fixup_sect_cksum;     /* 0x34 cryptographic checksum of all fixup info, or zero */
              uint32_t    e_loader_sect_size;     /* 0x38 size of memory resident tables (section table through per-page checksum table) */
              uint32_t    e_loader_sect_cksum;    /* 0x3c cryptographic checksum for all loader info, or zero */
              uint32_t    e_secttab_rfo;          /* 0x40 offset of section table relative to this header */
              uint32_t    e_secttab_nentries;     /* 0x44 number of entries in section table */
              uint32_t    e_pagetab_rfo;          /* 0x48 section page table offset relative to this header */
              uint32_t    e_iterpages_offset;     /* 0x4c section iterated pages offset (absolute file offset) */
              uint32_t    e_rsrctab_rfo;          /* 0x50 offset of resource table relative to this header */
              uint32_t    e_rsrctab_nentries;     /* 0x54 number of entries in the resource table */
              uint32_t    e_resnametab_rfo;       /* 0x58 offset of resident name table relative to this header */
              uint32_t    e_entrytab_rfo;         /* 0x5c offset of entry table relative to this header */
              uint32_t    e_fmtdirtab_rfo;        /* 0x60 offset of module format directives relative to this header */
              uint32_t    e_fmtdirtab_nentries;   /* 0x64 number of entries in module format directives table */
              uint32_t    e_fixup_pagetab_rfo;    /* 0x68 offset of fixup page table relative to this header */
              uint32_t    e_fixup_rectab_rfo;     /* 0x6c offset of fixup record table relative to this header */
              uint32_t    e_import_modtab_rfo;    /* 0x70 offset of import module name table relative to this header */
              uint32_t    e_import_modtab_nentries;/*0x74 number of entries in import module name table */
              uint32_t    e_import_proctab_rfo;   /* 0x78 offset of import procedure name table relative to this header */
              uint32_t    e_ppcksumtab_rfo;       /* 0x7c offset of per-page checksum table relative to this header */
              uint32_t    e_data_pages_offset;    /* 0x80 offset of data pages (absolute file offset) */
              uint32_t    e_preload_npages;       /* 0x84 number of preload pages (not respected by OS/2) */
              uint32_t    e_nonresnametab_offset; /* 0x88 offset of non-resident name table (absolute file offset) */
              uint32_t    e_nonresnametab_size;   /* 0x8c size of non-resident name table in bytes */
              uint32_t    e_nonresnametab_cksum;  /* 0x90 cryptographic checksum of the non-resident name table */
              uint32_t    e_auto_ds_section;      /* 0x94 auto data segment section number (not used by 32-bit modules) */
              uint32_t    e_debug_info_rfo;       /* 0x98 offset of debug information relative to this header */
              uint32_t    e_debug_info_size;      /* 0x9c size of debug information in bytes */
              uint32_t    e_num_instance_preload; /* 0xa0 number of instance data pages found in the preload section */
              uint32_t    e_num_instance_demand;  /* 0xa4 number of instance data pages found in the demand section */
              uint32_t    e_heap_size;            /* 0xa8 number of bytes added to auto data segment by loader (not used by 32-bit) */
          } __attribute__((packed));              /* 0xac */

          enum LEFileHeaderFlags {
              HF_RESERVED         = 0xbffc5ccb,   /* Reserved bits */
              HF_PROC_LIB_INIT    = 0x00000004,   /* Per-process library initialization; not used for executables */
              HF_IFIXUPS_APPLIED  = 0x00000010,   /* Sections have preferred load addresses and internal relocs have been applied */
              HF_EFIXUPS_APPLIED  = 0x00000020,   /* External fixups for the module have been applied */
              HF_PM_WINDOW_NO     = 0x00000100,   /* Incompatible with PM windowing */
              HF_PM_WINDOW_OK     = 0x00000200,   /* Compatible with PM windowing */
              HF_PM_WINDOW_USE    = 0x00000300,   /* Uses PM windowing API */
              HF_NOT_LOADABLE     = 0x00002000,   /* Module is not loadable (has errors or incrementally linked) */
              HF_PROC_LIB_TERM    = 0x40000000,   /* Per-process library termination; not used for executables */
    
              HF_MODTYPE_MASK     = 0x00038000,   /* Module type mask */
              HF_MODTYPE_PROG     = 0x00000000,   /* Program module (other modules cannot link to this one) */
              HF_MODTYPE_LIB      = 0x00008000,   /* Library module */
              HF_MODTYPE_PLIB     = 0x00018000,   /* Protected memory library module */
              HF_MODTYPE_PDEV     = 0x00020000,   /* Physical device driver module */
              HF_MODTYPE_VDEV     = 0x00028000,   /* Virtual device driver module */
          };

          SgAsmLEFileHeader(SgAsmGenericFile *f, addr_t offset);
       // virtual ~LEFileHeader() {}

          virtual void unparse(FILE*);
          virtual void dump(FILE*, const char *prefix, ssize_t idx);
       // virtual const char *format_name();

       /* Accessors for protected/private data members */
       // ExtendedDOSHeader *get_dos2_header() {return dos2_header;}
       // void set_dos2_header(ExtendedDOSHeader *h) {dos2_header=h;}
       // LESectionTable *get_section_table() {return section_table;}
       // void set_section_table(LESectionTable *t) {section_table=t;}
       // LEPageTable *get_page_table() {return page_table;}
       // void set_page_table(LEPageTable *t) {page_table=t;}
       // LENameTable *get_resname_table() {return resname_table;}
       // void set_resname_table(LENameTable *t) {resname_table=t;}
       // LENameTable *get_nonresname_table() {return nonresname_table;}
       // void set_nonresname_table(LENameTable *t) {nonresname_table=t;}
       // LEEntryTable *get_entry_table() {return entry_table;}
       // void set_entry_table(LEEntryTable *t) {entry_table=t;}
       // LERelocTable *get_reloc_table() {return reloc_table;}
       // void set_reloc_table(LERelocTable *t) {reloc_table=t;}
    
       /* These are the native-format versions of the same members described in the NEFileHeader_disk format struct. */
       // unsigned e_byte_order, e_word_order, e_format_level, e_cpu_type, e_os_type, e_module_version, e_flags;
       // unsigned e_eip_section, e_esp_section, e_last_page_size, e_page_offset_shift, e_fixup_sect_cksum, e_loader_sect_cksum;
       // unsigned e_secttab_nentries, e_rsrctab_nentries, e_fmtdirtab_nentries, e_import_modtab_nentries, e_preload_npages;
       // unsigned e_nonresnametab_size, e_nonresnametab_cksum, e_auto_ds_section, e_debug_info_size, e_num_instance_preload;
       // unsigned e_num_instance_demand, e_heap_size;
    
       // addr_t e_npages, e_eip, e_esp, e_page_size, e_fixup_sect_size, e_loader_sect_size, e_secttab_rfo, e_pagetab_rfo;
       // addr_t e_iterpages_offset, e_rsrctab_rfo, e_resnametab_rfo, e_entrytab_rfo, e_fmtdirtab_rfo, e_fixup_pagetab_rfo;
       // addr_t e_fixup_rectab_rfo, e_import_modtab_rfo, e_import_proctab_rfo, e_ppcksumtab_rfo, e_data_pages_offset;
       // addr_t e_nonresnametab_offset, e_debug_info_rfo;

     private:
          void ctor(SgAsmGenericFile *f, addr_t offset);
          void *encode(SgAsmExecutableFileFormat::ByteOrder sex, SgAsmLEFileHeader::LEFileHeader_disk*);

       // ExtendedDOSHeader *dos2_header;
       // LESectionTable *section_table;
       // LEPageTable *page_table;
       // LENameTable *resname_table;
       // LENameTable *nonresname_table;
       // LEEntryTable *entry_table;
       // LERelocTable *reloc_table;

HEADER_LE_FILE_HEADER_END

HEADER_LE_SECTION_START
     public:
          SgAsmLESection(SgAsmLEFileHeader*, addr_t offset, addr_t size);
       // virtual ~LESection() {}

       // virtual void unparse(FILE*); /*nothing special to do*/
          virtual void dump(FILE*, const char *prefix, ssize_t idx);

       /* Accessors for protected/private data */
       // LESectionTableEntry *get_st_entry() {return st_entry;}
       // void set_st_entry(LESectionTableEntry *e) {st_entry=e;}

  // private:
       // LESectionTableEntry *st_entry;

HEADER_LE_SECTION_END

HEADER_LE_SECTION_TABLE_START
     public:
          SgAsmLESectionTable(SgAsmLEFileHeader *fhdr, addr_t offset, addr_t size);
       // virtual ~LESectionTable() {}

          virtual void unparse(FILE*);
          virtual void dump(FILE*, const char *prefix, ssize_t idx);

     private:
          void ctor();

HEADER_LE_SECTION_TABLE_END

HEADER_LE_NAME_TABLE_START

     public:

       /* This table contains a module name followed by the list of exported function names. Each name is associated with an "ordinal"
        * which serves as an index into the Entry Table. The ordinal for the first string (module name) is meaningless and should be
        * zero. In the non-resident name table the first entry is a module description and the functions are not always resident in
        * system memory (they are discardable). */

          SgAsmLENameTable(SgAsmLEFileHeader *fhdr, addr_t offset);
       // virtual ~LENameTable() {}

          virtual void unparse(FILE*);
          virtual void dump(FILE*, const char *prefix, ssize_t idx);

     private:
          void ctor();

       // std::vector<std::string> names; /*first name is module name; remainder are symbols within the module*/
       // std::vector<unsigned> ordinals; /*first entry is ignored but present in file*/

HEADER_LE_NAME_TABLE_END

HEADER_LE_PAGE_TABLE_START
     public:
          SgAsmLEPageTable(SgAsmLEFileHeader *fhdr, addr_t offset, addr_t size);
       // virtual ~LEPageTable() {}

          virtual void unparse(FILE*);
          virtual void dump(FILE*, const char *prefix, ssize_t idx);
          SgAsmLEPageTableEntry *get_page(size_t idx);

     private:
          void ctor();

       // std::vector<LEPageTableEntry*> entries;

HEADER_LE_PAGE_TABLE_END

HEADER_LE_ENTRY_TABLE_START
     public:
          SgAsmLEEntryTable(SgAsmLEFileHeader *fhdr, addr_t offset);
       // virtual ~LEEntryTable() {}

          virtual void unparse(FILE*);
          virtual void dump(FILE*, const char *prefix, ssize_t idx);

     private:
          void ctor();

       // std::vector<size_t> bundle_sizes;
       // std::vector<LEEntryPoint> entries;

HEADER_LE_ENTRY_TABLE_END

HEADER_LE_RELOC_TABLE_START
     public:
          SgAsmLERelocTable(SgAsmLEFileHeader *fhdr, addr_t offset);
       // virtual ~LERelocTable() {}

       // virtual void unparse(FILE*);
          virtual void dump(FILE*, const char *prefix, ssize_t idx);

     private:
          void ctor();

       // std::vector<LERelocEntry> entries;

HEADER_LE_RELOC_TABLE_END

HEADER_LE_PAGE_TABLE_ENTRY_START
     public:
       /* The object page table provides information about a logical page in a section. A logical page may be an enumerated page, a
        * pseudo page, or an iterated page. The page table allows for efficient access to a page when a page fault occurs, while
        * still allowing the physical page to be located in the preload page, demand load page, or iterated data page sections of the
        * executable file. Entries in the page table use 1-origin indices.  This table is parallel with the Fixup Page Table (they
        * are both indexed by the logical page number). */

       /* File format for a page table entry */
          struct LEPageTableEntry_disk {
               uint16_t            pageno_hi;
               unsigned char       pageno_lo;
               unsigned char       flags;
             } __attribute__((packed));

          SgAsmLEPageTableEntry(SgAsmExecutableFileFormat::ByteOrder sex, const SgAsmLEPageTableEntry::LEPageTableEntry_disk *disk);

          void dump(FILE*, const char *prefix, ssize_t idx);
          void *encode(SgAsmExecutableFileFormat::ByteOrder, SgAsmLEPageTableEntry::LEPageTableEntry_disk*);

       // unsigned get_pageno() {return pageno;}

     private:
          void ctor(SgAsmExecutableFileFormat::ByteOrder, const SgAsmLEPageTableEntry::LEPageTableEntry_disk*);

       // unsigned    pageno;
       // unsigned    flags;

HEADER_LE_PAGE_TABLE_ENTRY_END

HEADER_LE_ENTRY_POINT_START

     public:
       /* If 0x01 bit of "flags" is clear then the remainder (next 9 bytes) of the entry point is not stored in the file and the
        * next entry point description follows immediately after the flag. */
          struct LEEntryPoint_disk {
              uint8_t     flags;          /* 0x00 Bit flags (0x01=>non-empty bundle; 0x02=>32-bit entry*/
              uint16_t    objnum;         /* 0x01 Object number */
              uint8_t     entry_type;     /* 0x03 Flags for entry type */
              uint32_t    entry_offset;   /* 0x04 Offset of entry point */
              uint16_t    res1;           /* 0x08 Reserved */
          } __attribute__((packed));      /* 0x0a */

          SgAsmLEEntryPoint(SgAsmExecutableFileFormat::ByteOrder sex, const SgAsmLEEntryPoint::LEEntryPoint_disk *disk);
          SgAsmLEEntryPoint(SgAsmExecutableFileFormat::ByteOrder sex, unsigned flags);

          addr_t unparse(FILE*, SgAsmExecutableFileFormat::ByteOrder, SgAsmGenericSection*, addr_t spos);
          void dump(FILE*, const char *prefix, ssize_t idx);

     private:
          void ctor(SgAsmExecutableFileFormat::ByteOrder, const SgAsmLEEntryPoint::LEEntryPoint_disk*);

       // std::vector<LEEntryPoint> entries;
       // unsigned flags, objnum, entry_type, res1;
       // addr_t entry_offset;

HEADER_LE_ENTRY_POINT_END

HEADER_LE_SECTION_TABLE_ENTRY_START

     public:
       /* File format of a section table entry. Fields are big- or little-endian depending on file header. */
          struct LESectionTableEntry_disk {
               uint32_t    mapped_size;            /* 0x00 virtual segment size in bytes */
               uint32_t    base_addr;              /* 0x04 relocation base address */
               uint32_t    flags;                  /* 0x08 bit flags, see LESectionFlags */
               uint32_t    pagemap_index;          /* 0x0c */
               uint32_t    pagemap_nentries;       /* 0x10 number of entries in the page map */
               uint32_t    res1;                   /* 0x14 reserved */
             } __attribute__((packed));              /* 0x18 */

       /* SF_BIG_BIT: The "big/default" bit, for data segments, controls the setting of the Big bit in the segment descriptor. (The
        *             Big bit, or B-bit, determines whether ESP or SP is used as the stack pointer.) For code segments, this bit
        *             controls the setting of the Default bit in the segment descriptor. (The Default bit, or D-bit, determines
        *             whether the default word size is 32-bits or 16-bits. It also affects the interpretation of the instruction
        *             stream.) */
          enum LESectionFlags {
               SF_RESERVED         = 0xffff0800,   /* Reserved bits (FIXME) */
    
               SF_READABLE         = 0x00000001,   /* Read permission granted when mapped */
               SF_WRITABLE         = 0x00000002,   /* Write permission granted when mapped */
               SF_EXECUTABLE       = 0x00000004,   /* Execute permission granted when mapped */
    
               SF_RESOURCE         = 0x00000008,   /* Section contains resource objects */
               SF_DISCARDABLE      = 0x00000010,   /* Discardable section */
               SF_SHARED           = 0x00000020,   /* Section is shared */
               SF_PRELOAD_PAGES    = 0x00000040,   /* Section has preload pages */
               SF_INVALID_PAGES    = 0x00000080,   /* Section has invalid pages */

               SF_TYPE_MASK        = 0x00000300,
               SF_TYPE_NORMAL      = 0x00000000,
               SF_TYPE_ZERO        = 0x00000100,   /* Section has zero-filled pages */
               SF_TYPE_RESIDENT    = 0x00000200,   /* Section is resident (valid for VDDs and PDDs only) */
               SF_TYPE_RESCONT     = 0x00000300,   /* Section is resident and contiguous */
    
               SF_RES_LONG_LOCK    = 0x00000400,   /* Section is resident and "long-lockable" (VDDs and PDDs only) */
               SF_1616_ALIAS       = 0x00001000,   /* 16:16 alias required (80x86 specific) */
               SF_BIG_BIT          = 0x00002000,   /* Big/default bit setting (80x86 specific); see note above */
               SF_CODE_CONFORM     = 0x00004000,   /* Section is conforming for code (80x86 specific) */
               SF_IO_PRIV          = 0x00008000,   /* Section I/O privilege level (80x86 specific; used only for 16:16 alias objects) */
             };

          SgAsmLESectionTableEntry(SgAsmExecutableFileFormat::ByteOrder sex, const SgAsmLESectionTableEntry::LESectionTableEntry_disk *disk);
       // virtual ~LESectionTableEntry() {};

          void *encode(SgAsmExecutableFileFormat::ByteOrder, SgAsmLESectionTableEntry::LESectionTableEntry_disk*);
          virtual void dump(FILE *f, const char *prefix, ssize_t idx);
    
       /* These are the native-format versions of the same members described in the NESectionTableEntry_disk struct. */
       // unsigned    flags, pagemap_index, pagemap_nentries, res1;
       // addr_t      mapped_size, base_addr;

     private:
          void ctor(SgAsmExecutableFileFormat::ByteOrder, const SgAsmLESectionTableEntry::LESectionTableEntry_disk*);

HEADER_LE_SECTION_TABLE_ENTRY_END




// ***********************************************
//          DOS Binary File Format Support
// ***********************************************

HEADER_DOS_HEADER_START
     public:
          struct DOSFileHeader_disk {
               unsigned char e_magic[2];           /* 0x00 "MZ" */
               uint16_t    e_last_page_size;       /* 0x02 bytes used on last page of file (1 page == 512 bytes); zero if last page is full */
               uint16_t    e_total_pages;          /* 0x04 number of pages (including last possibly partial page) in file */
               uint16_t    e_nrelocs;              /* 0x06 number of relocation entries stored after this header */
               uint16_t    e_header_paragraphs;    /* 0x08 header size in paragraphs (16-byte blocks) including relocations */
               uint16_t    e_minalloc;             /* 0x0a number of extra paragraphs needed, similar to BSS in Unix */
               uint16_t    e_maxalloc;             /* 0x0c max paragraphs to allocate for BSS */
               uint16_t    e_ss;                   /* 0x0e initial value of SS register relative to program load segment */
               uint16_t    e_sp;                   /* 0x10 initial value for SP register */
               uint16_t    e_cksum;                /* 0x12 checksum; 16-bit sum of all words in file should be zero (usually not filled in) */
               uint16_t    e_ip;                   /* 0x14 initial value for IP register */
               uint16_t    e_cs;                   /* 0x16 initial value for CS register relative to program load segment */
               uint16_t    e_relocs_offset;        /* 0x18 file address of relocation table */
               uint16_t    e_overlay;              /* 0x1a overlay number (zero indicates main program) */
               unsigned char e_res1[4];            /* 0x1c unknown purpose */
            } __attribute__((packed));              /* 0x20 */

          struct DOSRelocEntry_disk {
               uint16_t    offset;
               uint16_t    segment;
             } __attribute__((packed));

          SgAsmDOSFileHeader(SgAsmGenericFile *f, addr_t offset);
       // virtual ~DOSFileHeader() {}

          virtual void unparse(FILE*);
          virtual void dump(FILE*, const char *prefix, ssize_t idx);

       // Required function to overload base class (ROSETTA does not permit the base class function to be pure virtual, as I recall)
          virtual const char *format_name();

          SgAsmGenericSection *add_rm_section(addr_t max_offset=0);

       // Use the automatically generated access functions 
       // SgAsmGenericSection *get_relocs() {return relocs;}
       // void set_relocs(SgAsmGenericSection *s) {relocs=s;}
       // SgAsmGenericSection *get_rm_section() {return rm_section;}
       // void set_rm_section(ExecSection *s) {rm_section=s;}

       // DQ (8/9/2008): Added these member functions from the Exec namespace, since we don't have that namespace available in ROSE (long term).
          static SgAsmDOSFileHeader *parse( SgAsmGenericFile*, bool define_rm_section = true );

          static bool is_DOS(SgAsmGenericFile*);

     private:
          void ctor(SgAsmGenericFile *f, addr_t offset);
          void *encode(SgAsmDOSFileHeader::DOSFileHeader_disk*);

HEADER_DOS_HEADER_END








SOURCE_BINARY_FILE_SECTION_HEADER_LIST_START

#if 0
const SgAsmSectionHeaderPtrList &
SgAsmSectionHeaderList::get_section_headers() const
   {
     return p_section_headers;
   }

SgAsmSectionHeaderPtrList &
SgAsmSectionHeaderList::get_section_headers()
   {
     return p_section_headers;
   }
#endif

SOURCE_BINARY_FILE_SECTION_HEADER_LIST_END

SOURCE_BINARY_FILE_PROGRAM_HEADER_LIST_START

#if 0
const SgAsmProgramHeaderPtrList &
SgAsmProgramHeaderList::get_program_headers() const
   {
     return p_program_headers;
   }

SgAsmProgramHeaderPtrList &
SgAsmProgramHeaderList::get_program_headers()
   {
     return p_program_headers;
   }
#endif

SOURCE_BINARY_FILE_PROGRAM_HEADER_LIST_END


HEADER_BINARY_X86_INSTRUCTION_START
  public:

HEADER_BINARY_X86_INSTRUCTION_END


HEADER_BINARY_DECLARATION_START
HEADER_BINARY_DECLARATION_END


HEADER_BINARY_RET_START
   void append_dest( SgAsmStatement* instruction );	
HEADER_BINARY_RET_END


HEADER_BINARY_FUNCTION_CALL_START
HEADER_BINARY_FUNCTION_CALL_END

HEADER_BINARY_BLOCK_START
          void append_statement( SgAsmStatement* statement );
          void remove_statement( SgAsmStatement* statement );
          void remove_children (  );
HEADER_BINARY_BLOCK_END



HEADER_BINARY_OPERAND_LIST_START
          void append_operand( SgAsmExpression* operand );
HEADER_BINARY_OPERAND_LIST_END



HEADER_BINARY_FUNCTION_DECLARATION_START
	int nrOfValidInstructions(std::vector<SgNode*>& succs);
          //void append_block( SgAsmBlock* operand );
          void append_statement( SgAsmStatement* statement );
          void remove_statement( SgAsmStatement* statement );	
	  void append_dest( SgAsmStatement* instruction );		
          void remove_children (  );

       //! enum declaration as specified in proposed Sabre database schema
          enum function_kind_enum
             {
               e_unknown  = 0,
               e_standard = 1,
               e_library  = 2,
               e_imported = 3,
               e_thunk    = 4,
               e_last
             };
HEADER_BINARY_FUNCTION_DECLARATION_END

HEADER_BINARY_DATA_STRUCTURE_START
          void append_declaration( SgAsmDeclaration* declaration );

       // SgAsmDeclarationPtrList & get_declarationList();

     protected:

          SgAsmDeclarationPtrList p_declarationList;

     public:
HEADER_BINARY_DATA_STRUCTURE_END




HEADER_BINARY_EXPRESSION_START

      //! Generate the type for the expression
          virtual SgAsmType* get_type();

      //! Return the precedence of the operator (see C and C++ examples for details)
      //  virtual int get_precedence();

HEADER_BINARY_EXPRESSION_END



HEADER_BINARY_TYPE_START

       // static SgAsmType* createType();

HEADER_BINARY_TYPE_END

HEADER_BINARY_TYPE_BYTE_START
          static SgAsmTypeByte* createType();
HEADER_BINARY_TYPE_BYTE_END

HEADER_BINARY_TYPE_WORD_START
          static SgAsmTypeWord* createType();
HEADER_BINARY_TYPE_WORD_END

HEADER_BINARY_TYPE_DOUBLE_WORD_START
          static SgAsmTypeDoubleWord* createType();
HEADER_BINARY_TYPE_DOUBLE_WORD_END

HEADER_BINARY_TYPE_QUAD_WORD_START
          static SgAsmTypeQuadWord* createType();
HEADER_BINARY_TYPE_QUAD_WORD_END

HEADER_BINARY_TYPE_DOUBLE_QUAD_WORD_START
          static SgAsmTypeDoubleQuadWord* createType();
HEADER_BINARY_TYPE_DOUBLE_QUAD_WORD_END

HEADER_BINARY_TYPE_SINGLE_FLOAT_START
          static SgAsmTypeSingleFloat* createType();
HEADER_BINARY_TYPE_SINGLE_FLOAT_END

HEADER_BINARY_TYPE_DOUBLE_FLOAT_START
          static SgAsmTypeDoubleFloat* createType();
HEADER_BINARY_TYPE_DOUBLE_FLOAT_END

HEADER_BINARY_TYPE_VECTOR_START
          static SgAsmTypeVector* createType(int elementCount, SgAsmType* elementType);
HEADER_BINARY_TYPE_VECTOR_END

HEADER_BINARY_TYPE_80bit_FLOAT_START
          static SgAsmType80bitFloat* createType();
HEADER_BINARY_TYPE_80bit_FLOAT_END

HEADER_BINARY_TYPE_128bit_FLOAT_START
          static SgAsmType128bitFloat* createType();
HEADER_BINARY_TYPE_128bit_FLOAT_END

HEADER_BINARY_REGISTER_REFERENCE_EXPRESSION_START

         // Note that the auto-generated version of this is const
         virtual SgAsmType* get_type();

HEADER_BINARY_REGISTER_REFERENCE_EXPRESSION_END

HEADER_BINARY_X86_REGISTER_REFERENCE_EXPRESSION_START

             // Note that the auto-generated version of this is const
             virtual SgAsmType* get_type();

             //! Get a unique identifier for this particular register
             std::pair<X86RegisterClass, int> get_identifier() const;

HEADER_BINARY_X86_REGISTER_REFERENCE_EXPRESSION_END

HEADER_BINARY_ARM_REGISTER_REFERENCE_EXPRESSION_START

          enum arm_register_enum
             { // The exact numbers here are important
               undefined_arm_register = 0, /*!< unknown (error or unitialized value) */
               reg0 = 1,
               reg1 = 2,
               reg2 = 3,
               reg3 = 4,
               reg4 = 5,
               reg5 = 6,
               reg6 = 7,
               reg7 = 8,
               reg8 = 9,
               reg9  = 10,
               reg10 = 11,
               reg11 = 12,
               reg12 = 13,
               reg13 = 14,
               reg14 = 15,
               reg15 = 16,
               cpsr = 17,
               spsr = 18,
               cpsr_fields = 19, /* 16 values -- add arm_suffix_field_enum */
               spsr_fields = 35, /* 16 values -- add arm_suffix_field_enum */
               last_arm_register = spsr_fields + 16
             };

          enum arm_position_in_register_enum
             {
               undefined_arm_position_in_register = 0, /*!< unknown (error or unitialized value) */
               arm_dword = 1, /*!< lower 32 bit part of larger register (typically the first part of a 64 bit register) */
               arm_qword = 2, /*!< 64 bit part of 128 bit register (not in common use) */
               last_arm_position_in_register
             };

          enum arm_suffix_field_enum
             {
               undefined_position_in_suffix = 0, /*!< unknown (error or unitialized value) */
               c = 1, // control field mask bit
               x = 2, // extension field mask bit
               s = 4, // status field mask bit
               f = 8, // flags field mask bit
               last_position_in_suffix
             };

             // Note that the auto-generated version of this is const
             virtual SgAsmType* get_type();

HEADER_BINARY_ARM_REGISTER_REFERENCE_EXPRESSION_END

HEADER_BINARY_MEMORY_REFERENCE_EXPRESSION_START

             // Note that the auto-generated version of this is const
             virtual SgAsmType* get_type();

HEADER_BINARY_MEMORY_REFERENCE_EXPRESSION_END





/* --------------------------------------------------------------------------------- */
/* --------------------------------------------------------------------------------- */
/* --------------------------------------------------------------------------------- */
/* --------------------------------------------------------------------------------- */
/* --------------------------------------------------------------------------------- */


SOURCE_BINARY_FILE_START
void
SgAsmFile::post_construction_initialization()
   {
  // Build the list IR node

  // DQ (8/16/2008): Make the SgAsmGenericFile the root of the AST for the binary executable format
  // p_headers = new SgAsmGenericHeaderList();
  // p_headers->set_parent(this);
   }

SOURCE_BINARY_FILE_END

SOURCE_BINARY_BLOCK_START
void
SgAsmBlock::append_statement( SgAsmStatement* statement )
   {
     p_statementList.push_back(statement);
   }

void
SgAsmBlock::remove_children(  )
   {
     p_statementList.clear();
   }

void
SgAsmBlock::remove_statement( SgAsmStatement* statement )
   {
     SgAsmStatementPtrList::iterator l = p_statementList.begin();
     for (;l!=p_statementList.end();l++) {
	SgAsmStatement* st = *l;
	if (st==statement) {
             break;
        }
     }	
	if (l!=p_statementList.end())
            p_statementList.erase(l);
   }

SOURCE_BINARY_BLOCK_END



SOURCE_BINARY_RET_START
void
SgAsmx86Ret::append_dest( SgAsmStatement* statement )
   {
     p_dest.push_back(statement);
   }

SOURCE_BINARY_RET_END



SOURCE_BINARY_OPERAND_LIST_START
void
SgAsmOperandList::append_operand( SgAsmExpression* operand )
   {
  /* implemented directly until we can fix how the statementList is built */
     p_operands.push_back(operand);
   }

SOURCE_BINARY_OPERAND_LIST_END


SOURCE_BINARY_DATA_STRUCTURE_START
void
SgAsmDataStructureDeclaration::append_declaration( SgAsmDeclaration* declaration )
   {
     p_declarationList.push_back(declaration);
   }

SOURCE_BINARY_DATA_STRUCTURE_END


SOURCE_BINARY_FUNCTION_DECLARATION_START
int 
SgAsmFunctionDeclaration::nrOfValidInstructions( std::vector<SgNode*>& succs  ) {
//  std::vector<SgNode*> succs = this->get_traversalSuccessorContainer();
  std::vector<SgNode*>::reverse_iterator j = succs.rbegin();
  int instructions = succs.size();
  bool foundRet=false;
  bool nodeOtherThanNopAfterRetExists=false;	
/*
  if (j!=succs.begin())
    j--;
  else
    return 0;
*/
  for (;j!=succs.rend(); j++) {
     SgAsmx86Instruction* n = isSgAsmx86Instruction(*j);
     if (n && (n->get_kind() == x86_ret || n->get_kind() == x86_hlt)) {
          foundRet=true;
          break;
    } else {
       if (n && n->get_kind() != x86_nop) {
          nodeOtherThanNopAfterRetExists= true;
       }
       instructions--;
    }
  }
  if (!foundRet)
     instructions = succs.size();
  // if we find a return and there are NOPs following it somewhere,
  // we cut off the CFG at the NOP but we keep valid instructions
  // after the RET
  if (foundRet)
    if (nodeOtherThanNopAfterRetExists)
      return succs.size();
   
  return instructions;
}

void
SgAsmFunctionDeclaration::remove_children(  )
   {
     p_statementList.clear();
   }

void
SgAsmFunctionDeclaration::append_dest( SgAsmStatement* statement )
   {
     p_dest.push_back(statement);
   }

void
SgAsmFunctionDeclaration::append_statement( SgAsmStatement* statement )
   {
     p_statementList.push_back(statement);
   }

void
SgAsmFunctionDeclaration::remove_statement( SgAsmStatement* statement )
   {
     SgAsmStatementPtrList::iterator l = p_statementList.begin();
     for (;l!=p_statementList.end();l++) {
	SgAsmStatement* st = *l;
	if (st==statement) {
             break;
        }
     }	
	if (l!=p_statementList.end())
            p_statementList.erase(l);
   }


/*
void
SgAsmFunctionDeclaration::append_block( SgAsmBlock* operand )
   {
     p_body.push_back(operand);
   }
*/

SOURCE_BINARY_FUNCTION_DECLARATION_END


SOURCE_BINARY_INSTRUCTION_START

void
SgAsmInstruction::append_sources( SgAsmInstruction* inst )
   {
     p_sources.push_back(inst);
   }

SgAsmInstruction*
SgAsmInstruction::cfgBinFlowOutEdge(const VirtualBinCFG::AuxiliaryInformation* info) {
  if (!isAsmUnconditionalBranch(this)) {
    SgAsmInstruction* next = info->getInstructionAtAddress(this->get_address() + this->get_raw_bytes().size());
    return next;
  }
  return NULL;
}

std::vector<VirtualBinCFG::CFGEdge>
SgAsmInstruction::cfgBinOutEdges(const VirtualBinCFG::AuxiliaryInformation* info) {
  //cerr << "cfgBinOutEdges: " << std::hex << this->get_address() << " " << (isSgAsmx86Instruction(this) ? "x86" : "unknown") << " " << (isSgAsmx86Instruction(this) ? toString(isSgAsmx86Instruction(this)->get_kind()) : "") << endl;
  std::vector<VirtualBinCFG::CFGEdge> result;
  uint64_t nextAddr = this->get_address() + this->get_raw_bytes().size();

  if (isAsmBranch(this)) {
    //cout << "Found branch" << endl;
    uint64_t addr = 0;
    bool knownTarget = getAsmKnownBranchTarget(this, addr);
    if (knownTarget) {
      //cout << "Has known target " << std::hex << addr << endl;
      SgAsmInstruction* tgt = info->getInstructionAtAddress(addr);
      if (tgt) {
        makeEdge(this, tgt, info, result);
      }
    } else { // Unknown target
      //cout << "Unknown target" << endl;
      const std::set<uint64_t> successorAddrs = info->getPossibleSuccessors(this);
      for (std::set<uint64_t>::const_iterator i = successorAddrs.begin(); i != successorAddrs.end(); ++i) {
        //cout << "Found succ address " << std::hex << *i << endl;
        SgAsmInstruction* tgt = info->getInstructionAtAddress(*i);
        if (tgt) {
          makeEdge(this, tgt, info, result);
        }
      }
#if 0
      if (successorAddrs.empty()) {
	// FIXME: For bug-compatibility with old version
	SgAsmInstruction* next = info->getInstructionAtAddress(nextAddr);
	if (next) makeEdge(this, next, info, result);
      }
#endif
    } // else
  } // if

  if ((!isSgAsmx86Instruction(this) || isSgAsmx86Instruction(this)->get_kind() != x86_ret && isSgAsmx86Instruction(this)->get_kind() != x86_hlt) /* || !isAsmUnconditionalBranch(this) || (isSgAsmx86Instruction(this) && isSgAsmx86Instruction(this)->get_kind() == x86_call) */ ) {
    //cout << "Next insn is at " << std::hex << nextAddr << endl;
    SgAsmInstruction* next = info->getInstructionAtAddress(nextAddr);
    //ROSE_ASSERT (next);
    if (next) makeEdge(this, next, info, result);
  }

  return result;
}


std::vector<VirtualBinCFG::CFGEdge>
SgAsmInstruction::cfgBinInEdges(const VirtualBinCFG::AuxiliaryInformation* info) {
  std::vector<VirtualBinCFG::CFGEdge> result;
  const std::set<uint64_t>& preds = info->getPossiblePredecessors(this);
  for (std::set<uint64_t>::const_iterator i = preds.begin(); i != preds.end(); ++i) {
    SgAsmInstruction* tgt = info->getInstructionAtAddress(*i);
    if (tgt) {
      makeEdge(this, tgt, info, result);
    }
  }
  return result;
}

SOURCE_BINARY_INSTRUCTION_END

SOURCE_BINARY_X86_INSTRUCTION_START

SOURCE_BINARY_X86_INSTRUCTION_END


SOURCE_BINARY_EXPRESSION_START

SgAsmType* SgAsmExpression::get_type() {
  ROSE_ASSERT (!"Cannot get the type of this SgAsmExpression");
}

SOURCE_BINARY_EXPRESSION_END

SOURCE_BINARY_TYPE_START
SOURCE_BINARY_TYPE_END

SOURCE_BINARY_TYPE_BYTE_START

$CLASSNAME* $CLASSNAME::p_builtin_type = NULL;

// This is from the version for non-asm types
$CLASSNAME* $CLASSNAME::createType() {
  if (p_builtin_type == NULL) {
    p_builtin_type = new $CLASSNAME();
    ROSE_ASSERT(p_builtin_type != NULL);
  }
  return p_builtin_type;
}

SOURCE_BINARY_TYPE_BYTE_END

SOURCE_BINARY_TYPE_WORD_START

$CLASSNAME* $CLASSNAME::p_builtin_type = NULL;

// This is from the version for non-asm types
$CLASSNAME* $CLASSNAME::createType() {
  if (p_builtin_type == NULL) {
    p_builtin_type = new $CLASSNAME();
    ROSE_ASSERT(p_builtin_type != NULL);
  }
  return p_builtin_type;
}

SOURCE_BINARY_TYPE_WORD_END

SOURCE_BINARY_TYPE_DOUBLE_WORD_START

$CLASSNAME* $CLASSNAME::p_builtin_type = NULL;

// This is from the version for non-asm types
$CLASSNAME* $CLASSNAME::createType() {
  if (p_builtin_type == NULL) {
    p_builtin_type = new $CLASSNAME();
    ROSE_ASSERT(p_builtin_type != NULL);
  }
  return p_builtin_type;
}

SOURCE_BINARY_TYPE_DOUBLE_WORD_END

SOURCE_BINARY_TYPE_QUAD_WORD_START

$CLASSNAME* $CLASSNAME::p_builtin_type = NULL;

// This is from the version for non-asm types
$CLASSNAME* $CLASSNAME::createType() {
  if (p_builtin_type == NULL) {
    p_builtin_type = new $CLASSNAME();
    ROSE_ASSERT(p_builtin_type != NULL);
  }
  return p_builtin_type;
}

SOURCE_BINARY_TYPE_QUAD_WORD_END

SOURCE_BINARY_TYPE_DOUBLE_QUAD_WORD_START

$CLASSNAME* $CLASSNAME::p_builtin_type = NULL;

// This is from the version for non-asm types
$CLASSNAME* $CLASSNAME::createType() {
  if (p_builtin_type == NULL) {
    p_builtin_type = new $CLASSNAME();
    ROSE_ASSERT(p_builtin_type != NULL);
  }
  return p_builtin_type;
}

SOURCE_BINARY_TYPE_DOUBLE_QUAD_WORD_END

SOURCE_BINARY_TYPE_SINGLE_FLOAT_START

$CLASSNAME* $CLASSNAME::p_builtin_type = NULL;

// This is from the version for non-asm types
$CLASSNAME* $CLASSNAME::createType() {
  if (p_builtin_type == NULL) {
    p_builtin_type = new $CLASSNAME();
    ROSE_ASSERT(p_builtin_type != NULL);
  }
  return p_builtin_type;
}

SOURCE_BINARY_TYPE_SINGLE_FLOAT_END

SOURCE_BINARY_TYPE_DOUBLE_FLOAT_START

$CLASSNAME* $CLASSNAME::p_builtin_type = NULL;

// This is from the version for non-asm types
$CLASSNAME* $CLASSNAME::createType() {
  if (p_builtin_type == NULL) {
    p_builtin_type = new $CLASSNAME();
    ROSE_ASSERT(p_builtin_type != NULL);
  }
  return p_builtin_type;
}

SOURCE_BINARY_TYPE_DOUBLE_FLOAT_END


SOURCE_BINARY_TYPE_80bit_FLOAT_START
$CLASSNAME* $CLASSNAME::p_builtin_type = NULL;

// This is from the version for non-asm types
$CLASSNAME* $CLASSNAME::createType() {
  if (p_builtin_type == NULL) {
    p_builtin_type = new $CLASSNAME();
    ROSE_ASSERT(p_builtin_type != NULL);
  }
  return p_builtin_type;
}
       
SOURCE_BINARY_TYPE_80bit_FLOAT_END


SOURCE_BINARY_TYPE_128bit_FLOAT_START
$CLASSNAME* $CLASSNAME::p_builtin_type = NULL;

// This is from the version for non-asm types
$CLASSNAME* $CLASSNAME::createType() {
  if (p_builtin_type == NULL) {
    p_builtin_type = new $CLASSNAME();
    ROSE_ASSERT(p_builtin_type != NULL);
  }
  return p_builtin_type;
}
       
SOURCE_BINARY_TYPE_128bit_FLOAT_END


SOURCE_BINARY_TYPE_VECTOR_START

$CLASSNAME* $CLASSNAME::createType(int elementCount, SgAsmType* elementType) {
  // This does not need to be saved during file I/O, so it doesn't need to be a
  // class member
  static std::map<std::pair<int, SgAsmType*>, SgAsmTypeVector*> cache;
  std::pair<int, SgAsmType*> vectorInfo(elementCount, elementType);
  std::map<std::pair<int, SgAsmType*>, SgAsmTypeVector*>::const_iterator i = cache.find(vectorInfo);
  if (i != cache.end()) {
    return i->second;
  } else {
    SgAsmTypeVector* tv = new SgAsmTypeVector(elementCount, elementType);
    cache.insert(std::make_pair(vectorInfo, tv));
    return tv;
  }
}

SOURCE_BINARY_TYPE_VECTOR_END


SOURCE_BINARY_NODE_START

SOURCE_BINARY_NODE_END

SOURCE_BINARY_BYTE_VALUE_EXPRESSION_START

SgAsmType* $CLASSNAME::get_type() {
  return SgAsmTypeByte::createType();
}

SOURCE_BINARY_BYTE_VALUE_EXPRESSION_END

SOURCE_BINARY_DOUBLE_FLOAT_VALUE_EXPRESSION_START

SgAsmType* $CLASSNAME::get_type() {
  return SgAsmTypeDoubleFloat::createType();
}

SOURCE_BINARY_DOUBLE_FLOAT_VALUE_EXPRESSION_END

SOURCE_BINARY_DOUBLE_WORD_VALUE_EXPRESSION_START

SgAsmType* $CLASSNAME::get_type() {
  return SgAsmTypeDoubleWord::createType();
}

SOURCE_BINARY_DOUBLE_WORD_VALUE_EXPRESSION_END

SOURCE_BINARY_QUAD_WORD_VALUE_EXPRESSION_START

SgAsmType* $CLASSNAME::get_type() {
  return SgAsmTypeQuadWord::createType();
}

SOURCE_BINARY_QUAD_WORD_VALUE_EXPRESSION_END

SOURCE_BINARY_SINGLE_FLOAT_VALUE_EXPRESSION_START

SgAsmType* $CLASSNAME::get_type() {
  return SgAsmTypeSingleFloat::createType();
}

SOURCE_BINARY_SINGLE_FLOAT_VALUE_EXPRESSION_END

SOURCE_BINARY_VECTOR_VALUE_EXPRESSION_START

// Note that the auto-generated version of this is const
SgAsmType* SgAsmVectorValueExpression::get_type() {
  return p_type;
}

SOURCE_BINARY_VECTOR_VALUE_EXPRESSION_END

SOURCE_BINARY_WORD_VALUE_EXPRESSION_START

SgAsmType* $CLASSNAME::get_type() {
  return SgAsmTypeWord::createType();
}

SOURCE_BINARY_WORD_VALUE_EXPRESSION_END

SOURCE_BINARY_REGISTER_REFERENCE_EXPRESSION_START

// Note that the auto-generated version of this is const
SgAsmType* SgAsmRegisterReferenceExpression::get_type() {
  ROSE_ASSERT (false);
}

SOURCE_BINARY_REGISTER_REFERENCE_EXPRESSION_END

SOURCE_BINARY_X86_REGISTER_REFERENCE_EXPRESSION_START

// Note that the auto-generated version of this is const
SgAsmType* SgAsmx86RegisterReferenceExpression::get_type() {
  return p_type;
}

std::pair<X86RegisterClass, int>
SgAsmx86RegisterReferenceExpression::get_identifier() const {
  return std::make_pair(this->get_register_class(), this->get_register_number());
}

SOURCE_BINARY_X86_REGISTER_REFERENCE_EXPRESSION_END

SOURCE_BINARY_ARM_REGISTER_REFERENCE_EXPRESSION_START

// Note that the auto-generated version of this is const
SgAsmType* SgAsmArmRegisterReferenceExpression::get_type() {
  return p_type;
}

SOURCE_BINARY_ARM_REGISTER_REFERENCE_EXPRESSION_END

SOURCE_BINARY_MEMORY_REFERENCE_EXPRESSION_START

// Note that the auto-generated version of this is const
SgAsmType* SgAsmMemoryReferenceExpression::get_type() {
  return p_type;
}

SOURCE_BINARY_MEMORY_REFERENCE_EXPRESSION_END










// *************************************
//      Binary File Format Support
// *************************************

SOURCE_EXECUTABLE_FILE_FORMAT_START

SgAsmExecutableFileFormat::ByteOrder
SgAsmExecutableFileFormat::host_order()
   {
     static const int i = 1;
     return *(unsigned char*)&i ? ORDER_LSB : ORDER_MSB;
   }

/* Swap (reverse) bytes taking care of sign extension */
uint8_t
SgAsmExecutableFileFormat::swap_bytes(uint8_t n)
   {
     return n;
   }

uint16_t
SgAsmExecutableFileFormat::swap_bytes(uint16_t n)
   {
     return ((n>>8) & 0xff) | ((n<<8) & 0xff00);
   }

uint32_t
SgAsmExecutableFileFormat::swap_bytes(uint32_t n)
   {
     return ((n>>24) & 0xff) | ((n>>8) & 0xff00) | ((n<<8) & 0xff0000) | ((n<<24) & 0xff000000u);
   }

uint64_t
SgAsmExecutableFileFormat::swap_bytes(uint64_t n)
   {
     return (((n>>56) & (0xffull<<0 )) | ((n>>40) & (0xffull<<8 )) | ((n>>24) & (0xffull<<16)) | ((n>>8 ) & (0xffull<<24)) |
             ((n<<8 ) & (0xffull<<32)) | ((n<<24) & (0xffull<<40)) | ((n<<40) & (0xffull<<48)) | ((n<<56) & (0xffull<<56)));
   }

int8_t
SgAsmExecutableFileFormat::swap_bytes(int8_t n)
   {
     return swap_bytes((uint8_t)n);
   }

int16_t
SgAsmExecutableFileFormat::swap_bytes(int16_t n)
   {
     return swap_bytes((uint16_t)n);
   }

int32_t
SgAsmExecutableFileFormat::swap_bytes(int32_t n)
   {
     return swap_bytes((uint32_t)n);
   }

int64_t
SgAsmExecutableFileFormat::swap_bytes(int64_t n)
   {
     return swap_bytes((uint64_t)n);
   }

/* Little-endian byte order conversions */
uint8_t
SgAsmExecutableFileFormat::le_to_host(uint8_t n)
   {
     return ORDER_LSB==host_order() ? n : swap_bytes(n);
   }

uint16_t
SgAsmExecutableFileFormat::le_to_host(uint16_t n)
   {
     return ORDER_LSB==host_order() ? n : swap_bytes(n);
   }

uint32_t
SgAsmExecutableFileFormat::le_to_host(uint32_t n)
   {
     return ORDER_LSB==host_order() ? n : swap_bytes(n);
   }

uint64_t
SgAsmExecutableFileFormat::le_to_host(uint64_t n)
   {
     return ORDER_LSB==host_order() ? n : swap_bytes(n);
   }

int8_t
SgAsmExecutableFileFormat::le_to_host(int8_t n)
   {
     return ORDER_LSB==host_order() ? n : swap_bytes(n);
   }

int16_t
SgAsmExecutableFileFormat::le_to_host(int16_t n)
   {
     return ORDER_LSB==host_order() ? n : swap_bytes(n);
   }

int32_t
SgAsmExecutableFileFormat::le_to_host(int32_t n)
   {
     return ORDER_LSB==host_order() ? n : swap_bytes(n);
   }

int64_t
SgAsmExecutableFileFormat::le_to_host(int64_t n)
   {
     return ORDER_LSB==host_order() ? n : swap_bytes(n);
   }

void
SgAsmExecutableFileFormat::host_to_le(unsigned h, uint8_t *n)
   {
     assert(0==(h & ~0xff));
     uint8_t hh = h;
     *n = ORDER_LSB==host_order() ? hh : swap_bytes(hh);
   }

void
SgAsmExecutableFileFormat::host_to_le(unsigned h, uint16_t *n)
   {
     assert(0==(h & ~0xffff));
     uint16_t hh = h;
     *n = ORDER_LSB==host_order() ? hh : swap_bytes(hh);
   }

void
SgAsmExecutableFileFormat::host_to_le(unsigned h, uint32_t *n)
   {
     assert(0==(h & ~0xfffffffful));
     uint32_t hh = h;
     *n = ORDER_LSB==host_order() ? hh : swap_bytes(hh);
   }

void
SgAsmExecutableFileFormat::host_to_le(addr_t h, uint64_t *n)
   {
     assert(0==(h & ~0xffffffffffffffffull));
     uint64_t hh = h;
     *n = ORDER_LSB==host_order() ? hh : swap_bytes(hh);
   }

void
SgAsmExecutableFileFormat::host_to_le(int h, int8_t *n)
   {
     assert((unsigned)h<=0x8f || ((unsigned)h|0xff)==(unsigned)-1);
     int8_t hh = h;
     *n = ORDER_LSB==host_order() ? hh : swap_bytes(hh);
   }

void
SgAsmExecutableFileFormat::host_to_le(int h, int16_t *n)
   {
     assert((unsigned)h<=0x8fff || ((unsigned)h|0xffff)==(unsigned)-1);
     int16_t hh = h;
     *n = ORDER_LSB==host_order() ? hh : swap_bytes(hh);
   }

void
SgAsmExecutableFileFormat::host_to_le(int h, int32_t *n)
   {
     assert((unsigned)h<=0x8fffffffu || ((unsigned)h|0xffffffffu)==(unsigned)-1);
     int32_t hh = h;
     *n = ORDER_LSB==host_order() ? hh : swap_bytes(hh);
   }

void
SgAsmExecutableFileFormat::host_to_le(int64_t h, int64_t *n)
   {
     *n = ORDER_LSB==host_order() ? h : swap_bytes(h);
   }

/* Big-endian byte order conversions */
uint8_t
SgAsmExecutableFileFormat::be_to_host(uint8_t n)
   {
     return ORDER_MSB==host_order() ? n : swap_bytes(n);
   }

uint16_t
SgAsmExecutableFileFormat::be_to_host(uint16_t n)
   {
     return ORDER_MSB==host_order() ? n : swap_bytes(n);
   }

uint32_t
SgAsmExecutableFileFormat::be_to_host(uint32_t n)
   {
     return ORDER_MSB==host_order() ? n : swap_bytes(n);
   }

uint64_t
SgAsmExecutableFileFormat::be_to_host(uint64_t n)
   {
     return ORDER_MSB==host_order() ? n : swap_bytes(n);
   }

int8_t
SgAsmExecutableFileFormat::be_to_host(int8_t n)
   {
     return ORDER_MSB==host_order() ? n : swap_bytes(n);
   }

int16_t
SgAsmExecutableFileFormat::be_to_host(int16_t n)
   {
     return ORDER_MSB==host_order() ? n : swap_bytes(n);
   }

int32_t
SgAsmExecutableFileFormat::be_to_host(int32_t n)
   {
     return ORDER_MSB==host_order() ? n : swap_bytes(n);
   }

int64_t
SgAsmExecutableFileFormat::be_to_host(int64_t n)
   {
     return ORDER_MSB==host_order() ? n : swap_bytes(n);
   }

void
SgAsmExecutableFileFormat::host_to_be(unsigned h, uint8_t *n)
   {
     assert(0==(h & ~0xff));
     uint8_t hh = h;
     *n = ORDER_MSB==host_order() ? hh : swap_bytes(hh);
   }

void
SgAsmExecutableFileFormat::host_to_be(unsigned h, uint16_t *n)
   {
     assert(0==(h & ~0xffff));
     uint16_t hh = h;
     *n = ORDER_MSB==host_order() ? hh : swap_bytes(hh);
   }

void
SgAsmExecutableFileFormat::host_to_be(unsigned h, uint32_t *n)
   {
     assert(0==(h & ~0xfffffffful));
     uint32_t hh = h;
     *n = ORDER_MSB==host_order() ? hh : swap_bytes(hh);
   }

void
SgAsmExecutableFileFormat::host_to_be(addr_t h, uint64_t *n)
   {
     assert(0==(h & ~0xffffffffffffffffull));
     uint64_t hh = h;
     *n = ORDER_MSB==host_order() ? hh : swap_bytes(hh);
   }

void
SgAsmExecutableFileFormat::host_to_be(int h, int8_t *n)
   {
     assert((unsigned)h<0x8f || ((unsigned)h|0xff)==(unsigned)-1);
     int8_t hh = h;
     *n = ORDER_MSB==host_order() ? hh : swap_bytes(hh);
   }

void
SgAsmExecutableFileFormat::host_to_be(int h, int16_t *n)
   {
     assert((unsigned)h<0x8fff || ((unsigned)h|0xffff)==(unsigned)-1);
     int16_t hh = h;
     *n = ORDER_MSB==host_order() ? hh : swap_bytes(hh);
   }

void
SgAsmExecutableFileFormat::host_to_be(int h, int32_t *n)
   {
     assert((unsigned)h<0x8ffffffful || ((unsigned)h|0xfffffffful)==(unsigned)-1);
     int32_t hh = h;
     *n = ORDER_MSB==host_order() ? hh : swap_bytes(hh);
   }

void
SgAsmExecutableFileFormat::host_to_be(int64_t h, int64_t *n)
   {
     *n = ORDER_MSB==host_order() ? h : swap_bytes(h);
   }

/* Caller-specified byte order conversions */
uint8_t
SgAsmExecutableFileFormat::disk_to_host(SgAsmExecutableFileFormat::ByteOrder sex, uint8_t n)
   {
     return ORDER_LSB==sex ? le_to_host(n) : be_to_host(n);
   }

uint16_t
SgAsmExecutableFileFormat::disk_to_host(SgAsmExecutableFileFormat::ByteOrder sex, uint16_t n)
   {
     return ORDER_LSB==sex ? le_to_host(n) : be_to_host(n);
   }

uint32_t
SgAsmExecutableFileFormat::disk_to_host(SgAsmExecutableFileFormat::ByteOrder sex, uint32_t n)
   {
     return ORDER_LSB==sex ? le_to_host(n) : be_to_host(n);
   }

uint64_t
SgAsmExecutableFileFormat::disk_to_host(SgAsmExecutableFileFormat::ByteOrder sex, uint64_t n)
   {
     return ORDER_LSB==sex ? le_to_host(n) : be_to_host(n);
   }

int8_t
SgAsmExecutableFileFormat::disk_to_host(SgAsmExecutableFileFormat::ByteOrder sex, int8_t n)
   {
     return ORDER_LSB==sex ? le_to_host(n) : be_to_host(n);
   }

int16_t
SgAsmExecutableFileFormat::disk_to_host(SgAsmExecutableFileFormat::ByteOrder sex, int16_t n)
   {
     return ORDER_LSB==sex ? le_to_host(n) : be_to_host(n);
   }

int32_t
SgAsmExecutableFileFormat::disk_to_host(SgAsmExecutableFileFormat::ByteOrder sex, int32_t n)
   {
     return ORDER_LSB==sex ? le_to_host(n) : be_to_host(n);
   }

int64_t
SgAsmExecutableFileFormat::disk_to_host(SgAsmExecutableFileFormat::ByteOrder sex, int64_t n)
   {
     return ORDER_LSB==sex ? le_to_host(n) : be_to_host(n);
   }

// void SgAsmExecutableFileFormat::host_to_disk(SgAsmExecutableFileFormat::ByteOrder, unsigned char h, unsigned char *np)
//    {
//      *np = h;
//    }

void
SgAsmExecutableFileFormat::host_to_disk(SgAsmExecutableFileFormat::ByteOrder sex, unsigned h, uint8_t *np)
   {
     ORDER_LSB==sex ? host_to_le(h, np) : host_to_be(h, np);
   }

void
SgAsmExecutableFileFormat::host_to_disk(SgAsmExecutableFileFormat::ByteOrder sex, unsigned h, uint16_t *np)
   {
     ORDER_LSB==sex ? host_to_le(h, np) : host_to_be(h, np);
   }

void
SgAsmExecutableFileFormat::host_to_disk(SgAsmExecutableFileFormat::ByteOrder sex, unsigned h, uint32_t *np)
   {
     ORDER_LSB==sex ? host_to_le(h, np) : host_to_be(h, np);
   }

void
SgAsmExecutableFileFormat::host_to_disk(SgAsmExecutableFileFormat::ByteOrder sex, addr_t h, uint64_t *np)
   {
     ORDER_LSB==sex ? host_to_le(h, np) : host_to_be(h, np);
   }

void
SgAsmExecutableFileFormat::host_to_disk(SgAsmExecutableFileFormat::ByteOrder sex, int h, int8_t *np)
   {
     ORDER_LSB==sex ? host_to_le(h, np) : host_to_be(h, np);
   }

void
SgAsmExecutableFileFormat::host_to_disk(SgAsmExecutableFileFormat::ByteOrder sex, int h, int16_t *np)
   {
     ORDER_LSB==sex ? host_to_le(h, np) : host_to_be(h, np);
   }

void
SgAsmExecutableFileFormat::host_to_disk(SgAsmExecutableFileFormat::ByteOrder sex, int h, int32_t *np)
   {
     ORDER_LSB==sex ? host_to_le(h, np) : host_to_be(h, np);
   }

void
SgAsmExecutableFileFormat::host_to_disk(SgAsmExecutableFileFormat::ByteOrder sex, int64_t h, int64_t *np)
   {
     ORDER_LSB==sex ? host_to_le(h, np) : host_to_be(h, np);
   }

SOURCE_EXECUTABLE_FILE_FORMAT_END


SOURCE_GENERIC_SECTION_START

SgAsmGenericSection::SgAsmGenericSection(SgAsmGenericFile *f, SgAsmGenericHeader *fhdr, addr_t offset, addr_t size)
   : p_header(NULL), p_offset(0), p_purpose(SP_UNSPECIFIED), p_synthesized(false), p_id(-1), p_name(0),
     p_mapped_rva(0), p_mapped_size(0), p_mapped_rperm(false), p_mapped_wperm(false), p_mapped_xperm(false),
     p_congealed(false)
   {
     ctor(f, fhdr, offset, size);
   }

SOURCE_GENERIC_SECTION_END

SOURCE_GENERIC_HEADER_START

SgAsmGenericHeader::SgAsmGenericHeader(SgAsmGenericFile *ef, addr_t offset, addr_t size)
   : SgAsmGenericSection(ef, NULL, offset, size),
     p_exec_format(NULL), p_isa(ISA_OTHER), p_base_va(0), p_dlls(NULL), p_symbols(NULL), p_sections(NULL)
   {
     ctor(ef, offset, size);
   }

const char *
SgAsmGenericHeader::format_name()
   {
     return "ASM_GENERIC_HEADER";
   }

SgAsmGenericSymbolPtrList & 
SgAsmGenericHeader::get_symbol_list()
   {
     ROSE_ASSERT(p_symbols != NULL);
     return p_symbols->get_symbols();
   }

SgAsmGenericFormat::ByteOrder
SgAsmGenericHeader::get_sex() const
   {
     ROSE_ASSERT(p_exec_format != NULL);
     return p_exec_format->get_sex();
   }

size_t
SgAsmGenericHeader::get_word_size() const
   {
     ROSE_ASSERT(p_exec_format != NULL);
     return p_exec_format->get_word_size();
   }

SOURCE_GENERIC_HEADER_END

SOURCE_GENERIC_FILE_START

SgAsmGenericFile::SgAsmGenericFile(std::string file_name)
   : p_fd(-1), p_headers(NULL), p_holes(NULL)
   {
     ctor(file_name);
   }

SOURCE_GENERIC_FILE_END

SOURCE_GENERIC_FORMAT_START
SOURCE_GENERIC_FORMAT_END

SOURCE_GENERIC_ARCHITECTURE_START
SOURCE_GENERIC_ARCHITECTURE_END

SOURCE_GENERIC_SYMBOL_START

std::string
SgAsmGenericSymbol::stringifyDefState() const
   {
     std::string s;
     switch (p_def_state)
        {
          case SYM_UNDEFINED: 
             {
               s = "SYM_UNDEFINED";
               break;
             }

          case SYM_TENTATIVE: 
             {
               s = "SYM_TENTATIVE";
               break;
             }

          case SYM_DEFINED:
             {
               s = "SYM_DEFINED";
               break;
             }

          default:
             {
               printf ("Error: (out of range) p_def_state = %d \n",p_def_state);
               ROSE_ASSERT(false);
             }
        }

     return s;
   }

std::string
SgAsmGenericSymbol::stringifyType() const
   {
     std::string s;
     switch (p_type)
        {
          case SYM_NO_TYPE: 
             {
               s = "SYM_NO_TYPE";
               break;
             }

          case SYM_DATA: 
             {
               s = "SYM_DATA";
               break;
             }

          case SYM_FUNC:
             {
               s = "SYM_FUNC";
               break;
             }

          case SYM_SECTION:
             {
               s = "SYM_SECTION";
               break;
             }

          case SYM_FILE:
             {
               s = "SYM_FILE";
               break;
             }

          case SYM_ARRAY:
             {
               s = "SYM_ARRAY";
               break;
             }

          case SYM_TLS:
             {
               s = "SYM_TLS";
               break;
             }

          case SYM_REGISTER:
             {
               s = "SYM_REGISTER";
               break;
             }

          default:
             {
               printf ("Error: (out of range) p_def_state = %d \n",p_def_state);
               ROSE_ASSERT(false);
             }
        }

     return s;
   }

std::string
SgAsmGenericSymbol::stringifyBinding() const
   {
     std::string s;
     switch (p_binding)
        {
          case SYM_NO_BINDING: 
             {
               s = "SYM_NO_BINDING";
               break;
             }

          case SYM_LOCAL: 
             {
               s = "SYM_LOCAL";
               break;
             }

          case SYM_GLOBAL:
             {
               s = "SYM_GLOBAL";
               break;
             }

          case SYM_WEAK:
             {
               s = "SYM_WEAK";
               break;
             }

          default:
             {
               printf ("Error: (out of range) p_def_state = %d \n",p_def_state);
               ROSE_ASSERT(false);
             }
        }

     return s;
   }

SOURCE_GENERIC_SYMBOL_END

SOURCE_GENERIC_SYMBOL_LIST_START
SOURCE_GENERIC_SYMBOL_LIST_END

SOURCE_GENERIC_DLL_START

SgAsmGenericDLL::SgAsmGenericDLL(SgAsmGenericString *s)
    : p_name(s)
    {
	s->set_parent(this);
    }

SOURCE_GENERIC_DLL_END

SOURCE_GENERIC_DLL_LIST_START
SOURCE_GENERIC_DLL_LIST_END

SOURCE_BASIC_STRING_START
SOURCE_BASIC_STRING_END

SOURCE_GENERIC_STRING_START

std::string
SgAsmGenericString::get_string() const
   {
     printf ("Based class SgAsmGenericString::get_string() should not be called! \n");
     ROSE_ASSERT(false);
   }

void
SgAsmGenericString::set_string(const std::string &s)
   {
     printf ("Based class SgAsmGenericString::set_string() should not be called! \n");
     ROSE_ASSERT(false);
   }

void
SgAsmGenericString::dump(FILE*, const char *prefix, ssize_t idx)
   {
     printf ("Based class SgAsmGenericString::dump() should not be called! \n");
     ROSE_ASSERT(false);
   }

SOURCE_GENERIC_STRING_END

SOURCE_ELF_STRING_STORAGE_START
SOURCE_ELF_STRING_STORAGE_END

SOURCE_ELF_STRING_START
SOURCE_ELF_STRING_END

SOURCE_ELF_HEADER_START

const char *
SgAsmElfFileHeader::format_name()
   {
     return "ELF";
   }


SOURCE_ELF_HEADER_END

SOURCE_ELF_SECTION_TABLE_START
SgAsmElfSectionTable::SgAsmElfSectionTable(SgAsmElfFileHeader *fhdr)
   : SgAsmGenericSection(fhdr->get_file(), fhdr, fhdr->get_e_shoff(), fhdr->get_e_shnum() * fhdr->get_e_shentsize())
   {
     ctor();
   }

SOURCE_ELF_SECTION_TABLE_END

SOURCE_ELF_SECTION_TABLE_ENTRY_START
SgAsmElfSectionTableEntry::SgAsmElfSectionTableEntry(SgAsmExecutableFileFormat::ByteOrder sex, const SgAsmElfSectionTableEntry::Elf32SectionTableEntry_disk *disk)
   : p_nextra(0)
   {
     ctor(sex, disk);
   }

SgAsmElfSectionTableEntry::SgAsmElfSectionTableEntry(SgAsmExecutableFileFormat::ByteOrder sex, const SgAsmElfSectionTableEntry::Elf64SectionTableEntry_disk *disk)
   : p_nextra(0)
   {
     ctor(sex, disk);
   }

SOURCE_ELF_SECTION_TABLE_ENTRY_END

SOURCE_ELF_SEGMENT_TABLE_ENTRY_LIST_START
SOURCE_ELF_SEGMENT_TABLE_ENTRY_LIST_END

SOURCE_ELF_SECTION_START

/* Constructor for sections defined in the ELF Section Table */
SgAsmElfSection::SgAsmElfSection(SgAsmElfFileHeader *fhdr, SgAsmElfSectionTableEntry *shdr)
   : SgAsmGenericSection(fhdr->get_file(), fhdr, shdr->get_sh_offset(), shdr->get_sh_size()),
     p_linked_section(NULL), p_section_entry(shdr), p_segment_entry(NULL)
   {
     ctor(shdr);
   }

/* Constructor for sections defined in the ELF Segment Table */
SgAsmElfSection::SgAsmElfSection(SgAsmElfFileHeader *fhdr, SgAsmElfSegmentTableEntry *shdr)
   : SgAsmGenericSection(fhdr->get_file(), fhdr, shdr->get_offset(), shdr->get_filesz()),
     p_linked_section(NULL), p_section_entry(NULL), p_segment_entry(shdr)
   {
     ctor(shdr);
   }

/* Constructor for explicit size (e.g., BSS sections where file size is always zero) */
SgAsmElfSection::SgAsmElfSection(SgAsmElfFileHeader *fhdr, SgAsmElfSectionTableEntry *shdr, addr_t file_size)
   : SgAsmGenericSection(fhdr->get_file(), fhdr, shdr->get_sh_offset(), file_size),
     p_linked_section(NULL), p_section_entry(shdr), p_segment_entry(NULL)
   {
     ctor(shdr);
   }

SgAsmElfFileHeader*
SgAsmElfSection::get_elf_header()
   {
     return dynamic_cast<SgAsmElfFileHeader*>(get_header());
   }


// DQ (8/22/2008): These are not automatically generated since one of them must be virtual.
SgAsmElfSection* 
SgAsmElfSection::get_linked_section () const
   {
     ROSE_ASSERT (this != NULL);
     return p_linked_section;
   }

// DQ (8/22/2008): These are not automatically generated since one of them must be virtual.
void
SgAsmElfSection::set_linked_section ( SgAsmElfSection* linked_section )
   {
     ROSE_ASSERT (this != NULL);
     set_isModified(true);

#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_linked_section != NULL && linked_section != NULL && p_linked_section != linked_section)
        {
          printf ("Warning: linked_section = %p overwriting valid pointer p_linked_section = %p \n",linked_section,p_linked_section);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_linked_section != NULL && linked_section != NULL && p_linked_section != linked_section) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_linked_section = linked_section;
   }

SOURCE_ELF_SECTION_END

SOURCE_ELF_STRING_TABLE_START
SOURCE_ELF_STRING_TABLE_END

SOURCE_ELF_DYNAMIC_SECTION_START
SOURCE_ELF_DYNAMIC_SECTION_END

SOURCE_ELF_DYNAMIC_ENTRY_START
SOURCE_ELF_DYNAMIC_ENTRY_END

SOURCE_ELF_SEGMENT_TABLE_START
SgAsmElfSegmentTable::SgAsmElfSegmentTable(SgAsmElfFileHeader *fhdr)
   : SgAsmGenericSection(fhdr->get_file(), fhdr, fhdr->get_e_phoff(), fhdr->get_e_phnum() * fhdr->get_e_phentsize())
   {
     ctor();
   }

SOURCE_ELF_SEGMENT_TABLE_END

SOURCE_ELF_SEGMENT_TABLE_ENTRY_START
SgAsmElfSegmentTableEntry::SgAsmElfSegmentTableEntry(SgAsmExecutableFileFormat::ByteOrder sex, const SgAsmElfSegmentTableEntry::Elf32SegmentTableEntry_disk *disk)
   {
     ctor(sex, disk);
   }

SgAsmElfSegmentTableEntry::SgAsmElfSegmentTableEntry(SgAsmExecutableFileFormat::ByteOrder sex, const SgAsmElfSegmentTableEntry::Elf64SegmentTableEntry_disk *disk)
   {
     ctor(sex, disk);
   }

SOURCE_ELF_SEGMENT_TABLE_ENTRY_END

SOURCE_ELF_SEGMENT_ENTRY_START
SOURCE_ELF_SEGMENT_ENTRY_END

SOURCE_ELF_SEGMENT_ENTRY_LIST_START
SOURCE_ELF_SEGMENT_ENTRY_LIST_END

SOURCE_ELF_SYMBOL_SECTION_START
SgAsmElfSymbolSection::SgAsmElfSymbolSection(SgAsmElfFileHeader *fhdr, SgAsmElfSectionTableEntry *shdr)
   : SgAsmElfSection(fhdr, shdr)
   { 
     ctor(shdr);
   }

SOURCE_ELF_SYMBOL_SECTION_END

SOURCE_ELF_SYMBOL_LIST_START
SOURCE_ELF_SYMBOL_LIST_END

SOURCE_ELF_SYMBOL_START
SgAsmElfSymbol::SgAsmElfSymbol(SgAsmExecutableFileFormat::ByteOrder sex, const SgAsmElfSymbol::Elf32SymbolEntry_disk *disk)
   {
     ctor(sex, disk);
   }

SgAsmElfSymbol::SgAsmElfSymbol(SgAsmExecutableFileFormat::ByteOrder sex, const SgAsmElfSymbol::Elf64SymbolEntry_disk *disk)
   {
     ctor(sex, disk);
   }

void
SgAsmElfSymbol::dump(FILE *f, const char *prefix, ssize_t idx)
   {
     dump(f, prefix, idx, NULL);
   }

SgAsmElfSymbol::ElfSymBinding
SgAsmElfSymbol::get_elf_binding()
   {
     return (ElfSymBinding)(p_st_info >> 4);
   }

SgAsmElfSymbol::ElfSymType
SgAsmElfSymbol::get_elf_type()
   {
     return (ElfSymType)(p_st_info & 0xf);
   }

SOURCE_ELF_SYMBOL_END


SOURCE_PE_RVA_SIZE_PAIR_START
SgAsmPERVASizePair::SgAsmPERVASizePair(const SgAsmPERVASizePair::RVASizePair_disk *disk)
   {
     p_e_rva  = le_to_host(disk->e_rva);
     p_e_size = le_to_host(disk->e_size);
   }

void*
SgAsmPERVASizePair::encode(SgAsmPERVASizePair::RVASizePair_disk *disk)
   {
     host_to_le(p_e_rva,  &(disk->e_rva));
     host_to_le(p_e_size, &(disk->e_size));

     return disk;
   }

SOURCE_PE_RVA_SIZE_PAIR_END


SOURCE_PE_RVA_SIZE_PAIR_LIST_START
SOURCE_PE_RVA_SIZE_PAIR_LIST_END


SOURCE_PE_FILE_HEADER_START

SgAsmPEFileHeader::SgAsmPEFileHeader(SgAsmGenericFile *f, addr_t offset)
   : SgAsmGenericHeader(f, offset, sizeof(SgAsmPEFileHeader::PEFileHeader_disk)), /*extended in ctor()*/ p_dos2_header(NULL), p_section_table(NULL), p_coff_symtab(NULL)
   {
     ctor(f, offset);
   }

const char *
SgAsmPEFileHeader::format_name()
   {
     return "PE";
   }

#if 0
// This function is in ROSE_ExecPE.C
bool
SgAsmPEFileHeader::is_PE(SgAsmGenericFile *f)
{
    printf ("SgAsmPEFileHeader::is_PE() member function incomplete! \n");
    ROSE_ASSERT(false);

    return true;
}
#endif

#if 0
// This function is in ROSE_ExecPE.C
// Parses the structure of an ELF file and adds the info to the SgAsmGenericFile
SgAsmPEFileHeader *
SgAsmPEFileHeader::parse(SgAsmGenericFile *ef)
{
    ROSE_ASSERT(ef);
    
    printf ("SgAsmPEFileHeader::parse() member function incomplete! \n");
    ROSE_ASSERT(false);

    return NULL;
}
#endif

SOURCE_PE_FILE_HEADER_END

SOURCE_PE_SECTION_START
SgAsmPESection::SgAsmPESection(SgAsmPEFileHeader *fhdr, addr_t offset, addr_t size)
   : SgAsmGenericSection(fhdr->get_file(), fhdr, offset, size), p_st_entry(NULL)
   {
   }

SOURCE_PE_SECTION_END

SOURCE_PE_IMPORT_SECTION_START

SgAsmPEImportSection::SgAsmPEImportSection(SgAsmPEFileHeader *fhdr, addr_t offset, addr_t size, addr_t mapped_rva)
   : SgAsmPESection(fhdr, offset, size)
   {
     ctor(offset, size, mapped_rva);
   }

void
SgAsmPEImportSection::add_dll(SgAsmPEDLL *d)
   {
     ROSE_ASSERT(p_dlls != NULL);
     p_dlls->get_dlls().push_back(d);
   }

SOURCE_PE_IMPORT_SECTION_END

SOURCE_PE_SECTION_TABLE_START
SgAsmPESectionTable::SgAsmPESectionTable(SgAsmPEFileHeader *fhdr, addr_t offset, addr_t size)
   : SgAsmGenericSection(fhdr->get_file(), fhdr, offset, size)
   {
     ctor();
   }

SOURCE_PE_SECTION_TABLE_END

SOURCE_PE_COFF_SYMBOL_TABLE_START
SgAsmCoffSymbolTable::SgAsmCoffSymbolTable(SgAsmPEFileHeader *fhdr)
   : SgAsmGenericSection(fhdr->get_file(), fhdr, fhdr->get_e_coff_symtab(),
	                 fhdr->get_e_coff_nsyms() * SgAsmCoffSymbol::COFFSymbol_disk_size)
   {
     ctor();
   }

SOURCE_PE_COFF_SYMBOL_TABLE_END

SOURCE_PE_IMPORT_HINT_NAME_START
SgAsmPEImportHintName::SgAsmPEImportHintName(SgAsmGenericSection *section, addr_t offset)
   : p_hint(0), p_padding('\0')
   {
     ctor(section, offset);
   }

SOURCE_PE_IMPORT_HINT_NAME_END

SOURCE_PE_IMPORT_DIRECTORY_START
SgAsmPEImportDirectory::SgAsmPEImportDirectory(const SgAsmPEImportDirectory::PEImportDirectory_disk *disk)
   {
     ctor(disk);
   }

SOURCE_PE_IMPORT_DIRECTORY_END

SOURCE_PE_EXTENDED_DOS_HEADER_START
SgAsmPEExtendedDOSHeader::SgAsmPEExtendedDOSHeader(SgAsmGenericFile *f, addr_t offset)
   : SgAsmGenericSection(f, NULL, offset, sizeof(SgAsmPEExtendedDOSHeader::ExtendedDOSHeader_disk))
   {
     ctor(f, offset);
   }

SOURCE_PE_EXTENDED_DOS_HEADER_END

SOURCE_PE_SECTION_TABLE_ENTRY_START
SgAsmPESectionTableEntry::SgAsmPESectionTableEntry(const SgAsmPESectionTableEntry::PESectionTableEntry_disk *disk)
   {
     ctor(disk);
   }

SOURCE_PE_SECTION_TABLE_ENTRY_END

SOURCE_PE_COFF_SYMBOL_START
SgAsmCoffSymbol::SgAsmCoffSymbol(SgAsmPEFileHeader *fhdr, SgAsmGenericSection *symtab, SgAsmGenericSection *strtab, size_t idx)
   : p_st_name_offset(0), p_st_section_num(0), p_st_type(0), p_st_storage_class(0), p_st_num_aux_entries(0)
   {
     ctor(fhdr, symtab, strtab, idx);
   }

SOURCE_PE_COFF_SYMBOL_END

SOURCE_PE_DLL_START
SgAsmPEDLL::SgAsmPEDLL(SgAsmGenericString *name)
   : SgAsmGenericDLL(name), p_idir(NULL)
   {
     ctor();
   }

void
SgAsmPEDLL::add_hintname_rva(addr_t a)
   {
     p_hintname_rvas.push_back(a);
   }

void
SgAsmPEDLL::add_hintname(SgAsmPEImportHintName *hn)
   {
     ROSE_ASSERT(p_hintnames != NULL);
     p_hintnames->get_hintnames().push_back(hn);
   }

void
SgAsmPEDLL::add_binding(addr_t a)
   {
     p_bindings.push_back(a);
   }

SOURCE_PE_DLL_END


SOURCE_NE_FILE_HEADER_START

SgAsmNEFileHeader::SgAsmNEFileHeader(SgAsmGenericFile *f, addr_t offset)
   : SgAsmGenericHeader(f, offset, sizeof(SgAsmNEFileHeader::NEFileHeader_disk)), p_dos2_header(NULL), p_section_table(NULL), p_resname_table(NULL), p_nonresname_table(NULL), p_module_table(NULL), p_entry_table(NULL)
   {
     ctor(f, offset);
   }

const char *
SgAsmNEFileHeader::format_name()
   {
     return "NE";
   }

#if 0
bool
SgAsmNEFileHeader::is_NE(SgAsmGenericFile *f)
{
    printf ("SgAsmNEFileHeader::is_PE() member function incomplete! \n");
    ROSE_ASSERT(false);

    return true;
}
#endif

#if 0
// Parses the structure of an ELF file and adds the info to the SgAsmGenericFile
SgAsmNEFileHeader *
SgAsmNEFileHeader::parse(SgAsmGenericFile *ef)
{
    ROSE_ASSERT(ef);
    
    printf ("SgAsmNEFileHeader::parse() member function incomplete! \n");
    ROSE_ASSERT(false);

    return NULL;
}
#endif

SOURCE_NE_FILE_HEADER_END

SOURCE_NE_SECTION_START
SgAsmNESection::SgAsmNESection(SgAsmNEFileHeader *fhdr, addr_t offset, addr_t size)
   : SgAsmGenericSection(fhdr->get_file(), fhdr, offset, size), p_st_entry(NULL), p_reloc_table(NULL)
   {
   }

SOURCE_NE_SECTION_END

SOURCE_NE_SECTION_TABLE_START
SgAsmNESectionTable::SgAsmNESectionTable(SgAsmNEFileHeader *fhdr)
   : SgAsmGenericSection(fhdr->get_file(), fhdr, fhdr->get_end_offset(),
                         fhdr->get_e_nsections() * sizeof(SgAsmNESectionTableEntry::NESectionTableEntry_disk))
   {
     ctor();
   }

SOURCE_NE_SECTION_TABLE_END

SOURCE_NE_NAME_TABLE_START
SgAsmNENameTable::SgAsmNENameTable(SgAsmNEFileHeader *fhdr, addr_t offset)
   : SgAsmGenericSection(fhdr->get_file(), fhdr, offset, 0)
   {
     ctor();
   }

SOURCE_NE_NAME_TABLE_END

SOURCE_NE_MODULE_TABLE_START
SgAsmNEModuleTable::SgAsmNEModuleTable(SgAsmNEFileHeader *fhdr, addr_t offset, addr_t size, SgAsmNEStringTable *strtab)
   : SgAsmGenericSection(fhdr->get_file(), fhdr, offset, size), p_strtab(strtab)
   {
     ctor();
   }

SOURCE_NE_MODULE_TABLE_END

SOURCE_NE_STRING_TABLE_START
SgAsmNEStringTable::SgAsmNEStringTable(SgAsmNEFileHeader *fhdr, addr_t offset, addr_t length)
   : SgAsmGenericSection(fhdr->get_file(), fhdr, offset, length)
   {
     ctor();
   }

SOURCE_NE_STRING_TABLE_END

SOURCE_NE_ENTRY_TABLE_START
SgAsmNEEntryTable::SgAsmNEEntryTable(SgAsmNEFileHeader *fhdr, addr_t offset, addr_t size)
   : SgAsmGenericSection(fhdr->get_file(), fhdr, offset, size)
   {
     ctor();
   }

SOURCE_NE_ENTRY_TABLE_END

SOURCE_NE_RELOC_TABLE_START
SgAsmNERelocTable::SgAsmNERelocTable(SgAsmNEFileHeader *fhdr, addr_t offset)
   : SgAsmGenericSection(fhdr->get_file(), fhdr, offset, 0)
   {
     ctor();
   }

SOURCE_NE_RELOC_TABLE_END

SOURCE_NE_EXTENDED_DOS_HEADER_START
SgAsmNEExtendedDOSHeader::SgAsmNEExtendedDOSHeader(SgAsmGenericFile *f, addr_t offset)
   : SgAsmGenericSection(f, NULL, offset, sizeof(SgAsmNEExtendedDOSHeader::ExtendedDOSHeader_disk))
   {
     ctor(f, offset);
   }

SOURCE_NE_EXTENDED_DOS_HEADER_END

SOURCE_NE_ENTRY_POINT_START

//SgAsmNEEntryPoint::SgAsmNEEntryPoint()
//   : p_flags((SgAsmNEEntryPoint::EF_ZERO), p_int3f(0), p_section_idx(0), p_section_offset(0)
//   {}

SgAsmNEEntryPoint::SgAsmNEEntryPoint(SgAsmNEEntryPoint::NEEntryFlags flags, unsigned int3f, unsigned s_idx, unsigned s_off)
   : p_flags(flags), p_int3f(int3f), p_section_idx(s_idx), p_section_offset(s_off)
   {
   }

SOURCE_NE_ENTRY_POINT_END

SOURCE_NE_RELOC_ENTRY_START
SgAsmNERelocEntry::SgAsmNERelocEntry(SgAsmGenericSection *relocs, addr_t at, addr_t *rec_size)
   {
     ctor(relocs, at, rec_size);
   }

SOURCE_NE_RELOC_ENTRY_END

SOURCE_NE_SECTION_TABLE_ENTRY_START
SgAsmNESectionTableEntry::SgAsmNESectionTableEntry(const SgAsmNESectionTableEntry::NESectionTableEntry_disk *disk)
   {
     ctor(disk);
   }

SOURCE_NE_SECTION_TABLE_ENTRY_END



SOURCE_LE_FILE_HEADER_START

SgAsmLEFileHeader::SgAsmLEFileHeader(SgAsmGenericFile *f, addr_t offset)
   : SgAsmGenericHeader(f, offset, sizeof(SgAsmLEFileHeader::LEFileHeader_disk)), p_dos2_header(NULL), p_section_table(NULL), p_page_table(NULL), p_resname_table(NULL), p_nonresname_table(NULL), p_entry_table(NULL), p_reloc_table(NULL)
   {
     ctor(f, offset);
   }

#if 0
// The correct implementation is more complex than this code below and is implemented in ROSE_ExecLE.C.
const char *
SgAsmLEFileHeader::format_name()
   {
     return "LE";
   }
#endif


#if 0
bool
SgAsmLEFileHeader::is_LE(SgAsmGenericFile *f)
{
    printf ("SgAsmLEFileHeader::is_PE() member function incomplete! \n");
    ROSE_ASSERT(false);

    return true;
}
#endif

#if 0
// Parses the structure of an ELF file and adds the info to the SgAsmGenericFile
SgAsmLEFileHeader *
SgAsmLEFileHeader::parse(SgAsmGenericFile *ef)
{
    ROSE_ASSERT(ef);
    
    printf ("SgAsmLEFileHeader::parse() member function incomplete! \n");
    ROSE_ASSERT(false);

    return NULL;
}
#endif

SOURCE_LE_FILE_HEADER_END

SOURCE_LE_SECTION_START
SgAsmLESection::SgAsmLESection(SgAsmLEFileHeader *fhdr, addr_t offset, addr_t size)
   : SgAsmGenericSection(fhdr->get_file(), fhdr, offset, size), p_st_entry(NULL)
   {
   }

SOURCE_LE_SECTION_END

SOURCE_LE_SECTION_TABLE_START
SgAsmLESectionTable::SgAsmLESectionTable(SgAsmLEFileHeader *fhdr, addr_t offset, addr_t size)
   : SgAsmGenericSection(fhdr->get_file(), fhdr, offset, size)
   {
     ctor();
   }

SOURCE_LE_SECTION_TABLE_END

SOURCE_LE_NAME_TABLE_START
SgAsmLENameTable::SgAsmLENameTable(SgAsmLEFileHeader *fhdr, addr_t offset)
   : SgAsmGenericSection(fhdr->get_file(), fhdr, offset, 0)
   {
     ctor();
   }

SOURCE_LE_NAME_TABLE_END

SOURCE_LE_PAGE_TABLE_START
SgAsmLEPageTable::SgAsmLEPageTable(SgAsmLEFileHeader *fhdr, addr_t offset, addr_t size)
   : SgAsmGenericSection(fhdr->get_file(), fhdr, offset, size)
   {
     ctor();
   }

SOURCE_LE_PAGE_TABLE_END

SOURCE_LE_ENTRY_TABLE_START
SgAsmLEEntryTable::SgAsmLEEntryTable(SgAsmLEFileHeader *fhdr, addr_t offset)
   : SgAsmGenericSection(fhdr->get_file(), fhdr, offset, 0)
   {
     ctor();
   }

SOURCE_LE_ENTRY_TABLE_END

SOURCE_LE_RELOC_TABLE_START
SgAsmLERelocTable::SgAsmLERelocTable(SgAsmLEFileHeader *fhdr, addr_t offset)
   : SgAsmGenericSection(fhdr->get_file(), fhdr, offset, 0)
   {
     ctor();
   }

SOURCE_LE_RELOC_TABLE_END

SOURCE_LE_PAGE_TABLE_ENTRY_START
SgAsmLEPageTableEntry::SgAsmLEPageTableEntry(SgAsmExecutableFileFormat::ByteOrder sex, const SgAsmLEPageTableEntry::LEPageTableEntry_disk *disk)
   : p_pageno(0), p_flags(0)
   {
     ctor(sex, disk);
   }

SOURCE_LE_PAGE_TABLE_ENTRY_END

SOURCE_LE_ENTRY_POINT_START
SgAsmLEEntryPoint::SgAsmLEEntryPoint(SgAsmExecutableFileFormat::ByteOrder sex, const SgAsmLEEntryPoint::LEEntryPoint_disk *disk)
   : p_flags(0), p_objnum(0), p_entry_type(0), p_res1(0), p_entry_offset(0)
   {
     ctor(sex, disk);
   }

SgAsmLEEntryPoint::SgAsmLEEntryPoint(SgAsmExecutableFileFormat::ByteOrder sex, unsigned flags)
   : p_flags(flags), p_objnum(0), p_entry_type(0), p_res1(0), p_entry_offset(0)
   {
   }

SOURCE_LE_ENTRY_POINT_END

SOURCE_LE_SECTION_TABLE_ENTRY_START
SgAsmLESectionTableEntry::SgAsmLESectionTableEntry(SgAsmExecutableFileFormat::ByteOrder sex, const SgAsmLESectionTableEntry::LESectionTableEntry_disk *disk)
   {
     ctor(sex, disk);
   }

SOURCE_LE_SECTION_TABLE_ENTRY_END



SOURCE_DOS_HEADER_START

SgAsmDOSFileHeader::SgAsmDOSFileHeader(SgAsmGenericFile *f, addr_t offset)
   : SgAsmGenericHeader(f, offset, sizeof(SgAsmDOSFileHeader::DOSFileHeader_disk)), p_relocs(NULL), p_rm_section(NULL)
   {
     ctor(f, offset);
   }

const char *
SgAsmDOSFileHeader::format_name()
   {
     return "DOS";
   }


SOURCE_DOS_HEADER_END





// #########################################################
// #########################################################
//                      HEADER CODE
// #########################################################
// #########################################################



HEADER_BINARY_X86_INSTRUCTION_PREDECLARATION_START
#include "x86InstructionEnum.h"
HEADER_BINARY_X86_INSTRUCTION_PREDECLARATION_END

HEADER_BINARY_ARM_INSTRUCTION_PREDECLARATION_START
#include "armInstructionEnum.h"
HEADER_BINARY_ARM_INSTRUCTION_PREDECLARATION_END

HEADER_BINARY_POWERPC_INSTRUCTION_PREDECLARATION_START
#include "powerpcInstructionEnum.h"
HEADER_BINARY_POWERPC_INSTRUCTION_PREDECLARATION_END

HEADER_BINARY_START

 /*  This class forms a base class for all of the types represented in the Asm Instruction grammar.
     All Asm Instructions are derived from this class and thus contain the following functionality.
  */

  public:

HEADER_BINARY_END


HEADER_BINARY_INSTRUCTION_START
  public:
   SgAsmInstruction* cfgBinFlowOutEdge(const VirtualBinCFG::AuxiliaryInformation* info);
   std::vector<VirtualBinCFG::CFGEdge> cfgBinOutEdges(const VirtualBinCFG::AuxiliaryInformation* info);
   std::vector<VirtualBinCFG::CFGEdge> cfgBinInEdges(const VirtualBinCFG::AuxiliaryInformation* info);
   void append_sources( SgAsmInstruction* instruction );	
HEADER_BINARY_INSTRUCTION_END


HEADER_BINARY_FILE_START

#if 0
       // enums for ELF header information

#error "DEAD CODE!"

       // unsigned char	e_ident[EI_NIDENT]
       // typedef unsigned char magic_number_vector_type[EI_NIDENT];

       // Executable and Linking Format class kind
          enum elf_class_kind_enum
             {
               e_class_error   = 0,
               e_class_unknown = 1,
               e_class_none    = 2, // value maps to ELFCLASSNONE
               e_class_32      = 3, // value maps to ELFCLASS32
               e_class_64      = 4, // value maps to ELFCLASS64
               e_class_last
             };

#error "DEAD CODE!"

          enum elf_data_encoding_enum
             {
               e_data_encoding_error                  = 0,
               e_data_encoding_unknown                = 1,
               e_data_encoding_none                   = 2, // value maps to ELFDATANONE
               e_data_encoding_least_significant_byte = 3, // value maps to ELFDATA2LSB
               e_data_encoding_most_significant_byte  = 4, // value maps to ELFDATA2MSB
               e_data_encoding_last
             };

          enum elf_version_enum
             {
               e_version_error   = 0,
               e_version_unknown = 1,
               e_version_none    = 2, // value maps to EV_NONE
               e_version_current = 3, // value maps to EV_CURRENT
               e_version_last
             };


#error "DEAD CODE!"

          enum elf_OS_ABI_identification_enum
             {
               e_OS_ABI_error      = 0,
               e_OS_ABI_unknown    = 1,
               e_OS_ABI_none       = 2,
               e_OS_ABI_SYSV       = 3, // Note that ELFOSABI_SYSV == ELFOSABI_NONE (the two are alised)
               e_OS_ABI_HPUX       = 4,
               e_OS_ABI_NETBSD     = 5,
               e_OS_ABI_LINUX      = 6,
               e_OS_ABI_SOLARIS    = 7,
               e_OS_ABI_AIX        = 8,
               e_OS_ABI_IRIX       = 9,
               e_OS_ABI_FREEBSD    = 10,
               e_OS_ABI_TRU64      = 11,
               e_OS_ABI_MODESTO    = 12,
               e_OS_ABI_OPENBSD    = 13,
               e_OS_ABI_ARM        = 14,
               e_OS_ABI_STANDALONE = 15,
               e_OS_ABI_last
             };

#error "DEAD CODE!"

          enum elf_object_file_type_enum
             {
               e_file_type_error       = 0,
               e_file_type_unknown     = 1,
               e_file_type_none        = 2,
               e_file_type_relocatable = 3,
               e_file_type_executable  = 4,
               e_file_type_shared      = 5,
               e_file_type_core        = 6,
               e_file_type_last
             };


#error "DEAD CODE!"

       // DQ (1/8/2008): For a collection of interesting binaries go to: http://www.distributed.net/source/
          enum elf_machine_architecture_enum
             {
               e_machine_architecture_error                    = 0,
               e_machine_architecture_unknown                  = 1,
               e_machine_architecture_none                     = 2, // Maps to EM_NONE
               e_machine_architecture_ATT_WE_32100             = 3,
               e_machine_architecture_Sun_Sparc                = 4,
               e_machine_architecture_Intel_80386              = 5,
               e_machine_architecture_Motorola_m68k_family     = 6,
               e_machine_architecture_Motorola_m88k_family     = 7,
               e_machine_architecture_Intel_80860              = 8,
               e_machine_architecture_MIPS_R3000_big_endian    = 9,
               e_machine_architecture_IBM_System_370           = 10,
               e_machine_architecture_MIPS_R3000_little_endian = 11,
               e_machine_architecture_HPPA                     = 12,
               e_machine_architecture_Fujitsu_VPP500           = 13,
               e_machine_architecture_Sun_v8plus               = 14,
               e_machine_architecture_Intel_80960              = 15,
               e_machine_architecture_PowerPC                  = 16,
               e_machine_architecture_PowerPC_64bit            = 17,
               e_machine_architecture_IBM_S390                 = 18,
               e_machine_architecture_NEC_V800_series          = 19,
               e_machine_architecture_Fujitsu_FR20             = 20,
               e_machine_architecture_TRW_RH_32                = 21,
               e_machine_architecture_Motorola_RCE             = 22,
               e_machine_architecture_ARM                      = 23,
               e_machine_architecture_Digital_Alpha_fake       = 24,
               e_machine_architecture_Hitachi_SH               = 25,
               e_machine_architecture_SPARC_v9_64bit           = 26,
               e_machine_architecture_Siemens_Tricore          = 27,
               e_machine_architecture_Argonaut_RISC_Core       = 28,
               e_machine_architecture_Hitachi_H8_300           = 29,
               e_machine_architecture_Hitachi_H8_300H          = 30,
               e_machine_architecture_Hitachi_H8S              = 31,
               e_machine_architecture_Hitachi_H8_500           = 32,
               e_machine_architecture_Intel_Merced             = 33,
               e_machine_architecture_Stanford_MIPS_X          = 34,
               e_machine_architecture_Motorola_Coldfire        = 35,
               e_machine_architecture_Motorola_M68HC12         = 36,
               e_machine_architecture_Fujitsu_MMA_Multimedia_Accelerator                  = 37,
               e_machine_architecture_Siemens_PCP                                         = 38,
               e_machine_architecture_Sony_nCPU_embeeded_RISC                             = 39,
               e_machine_architecture_Denso_NDR1_microprocessor                           = 40,
               e_machine_architecture_Motorola_Start_Core_processor                       = 41,
               e_machine_architecture_Toyota_ME16_processor                               = 42,
               e_machine_architecture_STMicroelectronic_ST100_processor                   = 43,
               e_machine_architecture_Advanced_Logic_Corp_Tinyj_emb_family                = 44,
               e_machine_architecture_AMD_x86_64_architecture                             = 45,
               e_machine_architecture_Sony_DSP_Processor                                  = 46,
               e_machine_architecture_Siemens_FX66_microcontroller                        = 47,
               e_machine_architecture_STMicroelectronics_ST9_plus_8_16_microcontroller    = 48,
               e_machine_architecture_STMicroelectronics_ST7_8bit_microcontroller         = 49,
               e_machine_architecture_Motorola_MC68HC16_microcontroller                   = 50,
               e_machine_architecture_Motorola_MC68HC11_microcontroller                   = 51,
               e_machine_architecture_Motorola_MC68HC08_microcontroller                   = 52,
               e_machine_architecture_Motorola_MC68HC05_microcontroller                   = 53,
               e_machine_architecture_Silicon_Graphics_SVx                                = 54,
               e_machine_architecture_STMicroelectronics_ST19_8bit_microcontroller        = 55,
               e_machine_architecture_Digital_VAX                                         = 56,
               e_machine_architecture_Axis_Communications_32bit_embedded_processor        = 57,
               e_machine_architecture_Infineon_Technologies_32bit_embedded_processor      = 58,
               e_machine_architecture_Element_14_64bit_DSP_Processor                      = 59,
               e_machine_architecture_LSI_Logic_16bit_DSP_Processor                       = 60,
               e_machine_architecture_Donald_Knuths_educational_64bit_processor           = 61,
               e_machine_architecture_Harvard_University_machine_independent_object_files = 62,
               e_machine_architecture_SiTera_Prism                                        = 63,
               e_machine_architecture_Atmel_AVR_8bit_microcontroller                      = 64,
               e_machine_architecture_Fujitsu_FR30                                        = 65,
               e_machine_architecture_Mitsubishi_D10V                                     = 66,
               e_machine_architecture_Mitsubishi_D30V                                     = 67,
               e_machine_architecture_NEC_v850                                            = 68,
               e_machine_architecture_Mitsubishi_M32R                                     = 69,
               e_machine_architecture_Matsushita_MN10300                                  = 70,
               e_machine_architecture_Matsushita_MN10200                                  = 71,
               e_machine_architecture_picoJava                                            = 72,
               e_machine_architecture_OpenRISC_32bit_embedded_processor                   = 73,
               e_machine_architecture_ARC_Cores_Tangent_A5                                = 74,
               e_machine_architecture_Tensilica_Xtensa_Architecture                       = 75,
               e_machine_architecture_Digital_Alpha                                       = 76,
               e_machine_architecture_last
             };

#error "DEAD CODE!"

       // DQ (2/11/2008): Added support for Windows binaries
          enum pe_processor_architecture_enum
             {
               e_processor_architecture_error   = 0,
               e_processor_architecture_unknown = 1,
               e_processor_architecture_none    = 2,
               e_processor_architecture_INTEL   = 3,
               e_processor_architecture_MIPS    = 4,
               e_processor_architecture_ALPHA   = 5,
               e_processor_architecture_PPC     = 6,
               e_processor_architecture_SHX     = 7,
               e_processor_architecture_ARM     = 8,
               e_processor_architecture_IA64    = 9,
               e_processor_architecture_ALPHA64 = 10,
               e_processor_architecture_MSIL    = 11,
               e_processor_architecture_AMD64   = 12,
               e_processor_architecture_UNKNOWN = 13,
               e_processor_architecture_last
             };

#error "DEAD CODE!"

       // DQ (2/11/2008): Added support for Windows binaries
          enum pe_processor_type_enum
             {
               e_processor_type_error         = 0,
               e_processor_type_unknown       = 1,
               e_processor_type_none          = 2,
               e_processor_type_INTEL_386     = 3,
               e_processor_type_INTEL_486     = 4,
               e_processor_type_INTEL_PENTIUM = 5,
               e_processor_type_INTEL_860     = 6,
               e_processor_type_INTEL_IA64    = 7,
               e_processor_type_AMD_X8664     = 8,
               e_processor_type_MIPS_R2000    = 9,
               e_processor_type_MIPS_R3000    = 10,
               e_processor_type_MIPS_R4000    = 11,
               e_processor_type_ALPHA_21064   = 12,
               e_processor_type_PPC_601       = 13,
               e_processor_type_PPC_603       = 14,
               e_processor_type_PPC_604       = 15,
               e_processor_type_PPC_620       = 16,
               e_processor_type_HITACHI_SH3   = 17,
               e_processor_type_HITACHI_SH3E  = 18,
               e_processor_type_HITACHI_SH4   = 19,
               e_processor_type_MOTOROLA_821  = 20,
               e_processor_type_SHx_SH3       = 21,
               e_processor_type_SHx_SH4       = 22,
               e_processor_type_STRONGARM     = 23,
               e_processor_type_ARM720        = 24,
               e_processor_type_ARM820        = 25,
               e_processor_type_ARM920        = 26,
               e_processor_type_ARM_7TDMI     = 27,
               e_processor_type_last
             };

       // DQ (6/15/2008): Adding interface to simplify migration to newer executable formate IR nodes.
       // JJW (6/18/2008): Commenting out because this function doesn't have a definition
       // SgAsmGenericSectionPtrList & get_sectionList();
#endif

          void post_construction_initialization();

HEADER_BINARY_FILE_END


HEADER_BINARY_FILE_SECTION_HEADER_START

#if 0
          enum elf_version_enum
             {
               e_version_error   = 0,
               e_version_unknown = 1,
               e_version_none    = 2, // value maps to EV_NONE
               e_version_current = 3, // value maps to EV_CURRENT
               e_version_last
             };
#endif

HEADER_BINARY_FILE_SECTION_HEADER_END


HEADER_BINARY_FILE_PROGRAM_HEADER_START

#if 0
          enum elf_type_enum
             {
               e_type_error                = 0,
               e_type_unknown              = 1,
               e_type_null                 = 2,
               e_type_loadable_segment     = 3,
               e_type_dynamic_linking_info = 4,
               e_type_interpreter          = 5,
               e_type_note                 = 6,
               e_type_shlib_reserved       = 7,
               e_type_program_header_table = 8,
               e_type_processor_specific   = 9,
               e_type_last
             };
#endif

HEADER_BINARY_FILE_PROGRAM_HEADER_END


HEADER_BINARY_FILE_SECTION_HEADER_LIST_START
       // const SgAsmSectionHeaderPtrList & get_section_headers() const;
       // SgAsmSectionHeaderPtrList & get_section_headers();

HEADER_BINARY_FILE_SECTION_HEADER_LIST_END


HEADER_BINARY_FILE_PROGRAM_HEADER_LIST_START
       // const SgAsmProgramHeaderPtrList & get_program_headers() const;
       // SgAsmProgramHeaderPtrList & get_program_headers();

HEADER_BINARY_FILE_PROGRAM_HEADER_LIST_END

HEADER_BINARY_BYTE_VALUE_EXPRESSION_START

          virtual SgAsmType* get_type();

HEADER_BINARY_BYTE_VALUE_EXPRESSION_END

HEADER_BINARY_DOUBLE_FLOAT_VALUE_EXPRESSION_START

          virtual SgAsmType* get_type();

HEADER_BINARY_DOUBLE_FLOAT_VALUE_EXPRESSION_END

HEADER_BINARY_DOUBLE_WORD_VALUE_EXPRESSION_START

          virtual SgAsmType* get_type();

HEADER_BINARY_DOUBLE_WORD_VALUE_EXPRESSION_END

HEADER_BINARY_QUAD_WORD_VALUE_EXPRESSION_START

          virtual SgAsmType* get_type();

HEADER_BINARY_QUAD_WORD_VALUE_EXPRESSION_END

HEADER_BINARY_SINGLE_FLOAT_VALUE_EXPRESSION_START

          virtual SgAsmType* get_type();

HEADER_BINARY_SINGLE_FLOAT_VALUE_EXPRESSION_END

HEADER_BINARY_VECTOR_VALUE_EXPRESSION_START

          virtual SgAsmType* get_type();

HEADER_BINARY_VECTOR_VALUE_EXPRESSION_END

HEADER_BINARY_WORD_VALUE_EXPRESSION_START

          virtual SgAsmType* get_type();

HEADER_BINARY_WORD_VALUE_EXPRESSION_END



// ************************************
// NEW IR NODES FOR BINARY FILE FORMATS
// ************************************

HEADER_EXECUTABLE_FILE_FORMAT_START

     public:
       // DQ (8/21/2008): We need something to be in global scope (or not nested here) so that a few references in Node.code can be made.
          typedef rose_addr_t addr_t; // address and size (file and memory)
	  typedef rose_rva_t rva_t;   // relative virtual address

       // DQ (8/21/2008): Moved this from Node.code to make it local since we can't reference the nested addr_t directly from glogal scope.
       // typedef Rose_STL_Container<addr_t> SgAddressList;
       // typedef SgAddressList*             SgAddressListPtr;

       /* Thrown when an attempt is made to read past the end of a file, section, header, segment, etc. */
          class ShortRead {
               public:
                    ShortRead(const class SgAsmGenericSection *section, size_t offset, size_t size)
                       : section(section), offset(offset), size(size) {}
                    ShortRead(const class SgAsmGenericSection *section, size_t offset, size_t size, const std::string &mesg)
                       : section(section), offset(offset), size(size), mesg(mesg) {}
                    ShortRead(const class SgAsmGenericSection *section, size_t offset, size_t size, const char *mesg)
                       : section(section), offset(offset), size(size), mesg(mesg) {}
                    const SgAsmGenericSection *section;   /* Section from which read occurred; null implies file-level write */
                    addr_t         offset;    /* Byte offset into section (or file) */
                    addr_t         size;      /* Number of bytes of attempted read */
                    std::string          mesg;      /* Optional message */
             };

       /* Thrown when an attempt is made to write past the end of a file, section, header, segment, etc. */
          class ShortWrite {
               public:
                    ShortWrite(const class SgAsmGenericSection *section, size_t offset, size_t size)
                       : section(section), offset(offset), size(size) {}
                    ShortWrite(const class SgAsmGenericSection *section, size_t offset, size_t size, const std::string &mesg)
                       : section(section), offset(offset), size(size), mesg(mesg) {}
                    ShortWrite(const class SgAsmGenericSection *section, size_t offset, size_t size, const char *mesg)
                       : section(section), offset(offset), size(size), mesg(mesg) {}
                    const SgAsmGenericSection *section;  /* Section to which write occurred; null implies file-level write */
                    addr_t         offset;   /* Byte offset into section (or file) */
                    addr_t         size;     /* Number of bytes of attempted write */
                    std::string          mesg;     /* Optional message */
             };

       /* Thrown when the file contains an error that prevents us from parsing it. */
          class FormatError {
               public:
                    FormatError(const std::string &mesg) {this->mesg=mesg;}
                    FormatError(const char *mesg) {this->mesg=mesg;}
                    std::string mesg;
             };


          typedef struct stat fileDetails;

          enum ByteOrder {
              ORDER_UNSPECIFIED,
              ORDER_LSB,                                          /* little-endian; least significant byte first */
              ORDER_MSB,                                          /* big-endian; most significant byte first */
             };
    
          enum ExecFamily {
              FAMILY_UNSPECIFIED,
              FAMILY_DOS,                                         /* Microsoft DOS format */
              FAMILY_ELF,                                         /* Unix Executable and Linking Format */
              FAMILY_LE,                                          /* Microsft Linear Executable format */
              FAMILY_LX,                                          /* OS/2 LX (Windows 9x VxD device drivers, extension of LE) */
              FAMILY_NE,                                          /* Microsoft New Executable Format */
              FAMILY_PE                                           /* Microsoft Portable Executable Format */
             };

          enum ExecABI {
              ABI_UNSPECIFIED,                                    /* Not specified in file and could not be inferred */
              ABI_OTHER,                                          /* Anything other than values below */
              ABI_86OPEN,                                         /* 86Open Common IA32 */
              ABI_AIX,                                            /* AIX */
              ABI_ARM,                                            /* ARM architecture */
              ABI_FREEBSD,                                        /* FreeBSD */
              ABI_HPUX,                                           /* HP/UX */
              ABI_IRIX,                                           /* IRIX */
              ABI_HURD,                                           /* GNU/Hurd */
              ABI_LINUX,                                          /* GNU/Linux */
              ABI_MODESTO,                                        /* Novell Modesto */
              ABI_MONTEREY,                                       /* Monterey project */
              ABI_MSDOS,                                          /* Microsoft DOS */
              ABI_NT,                                             /* Windows NT */
              ABI_NETBSD,                                         /* NetBSD */
              ABI_OS2,                                            /* OS/2 */
              ABI_SOLARIS,                                        /* Sun Solaris */
              ABI_SYSV,                                           /* SysV R4 */
              ABI_TRU64,                                          /* Compaq TRU64 UNIX */
              ABI_WIN386                                          /* Microsoft Windows */
             };

          /* Instruction sets organized by families */
          enum InsSetArchitecture {
              ISA_UNSPECIFIED             = 0x0000,               /* File does not specify an architecture */
              ISA_OTHER                   = 0xffff,               /* Architecture is something other than below */
              ISA_FAMILY_MASK             = 0xff00,               /* Mask to get family part of ISA */

              ISA_IA32_Family             = 0x0100,               /* x86 IA-32 family of architectures; Intel, AMD, VIA, ... */
              ISA_IA32_286                = 0x0101,               /* 80286 */
              ISA_IA32_386                = 0x0102,               /* MMU with paging */
              ISA_IA32_486                = 0x0103,               /* risc-like pipelining, integrated FPU, on-chip cache */
              ISA_IA32_Pentium            = 0x0104,               /* superscalar, 64-bit databus, MMX */
              ISA_IA32_Cyrix6x86          = 0x0105,               /* register renaming, speculative execution */
              ISA_IA32_AMDK5              = 0x0106,               /* micro-op translation */
              ISA_IA32_PentiumPro         = 0x0107,               /* PAE, integrated L2 cache */
              ISA_IA32_PentiumII          = 0x0108,               /* L3-cache, 3D Now, SSE */
              ISA_IA32_Athlon             = 0x0109,               /* superscalar FPU, wide design */
              ISA_IA32_Pentium4           = 0x010a,               /* deeply pipelined, high frequency, SSE2, hyper-threading */
              ISA_IA32_PentiumM           = 0x010b,               /* low power */

              ISA_X8664_Family            = 0x0200,               /* x86-64 family of architectures: Intel, AMD, VIA, ... */
              ISA_X8664_Athlon64          = 0x0201,               /* on-die memory controller, 40-bit phys address space */
              ISA_X8664_Prescott          = 0x0202,               /* deeply pipelined, high frequency, SSE3 */
              ISA_X8664_IntelCore         = 0x0203,               /* low power, multi-core, lower clock frequency */
              ISA_X8664_AMDPhenom         = 0x0204,               /* quad core, 128-bit FPUs, SSE4a, native mem ctrl, on-die L3 cache */

              ISA_SPARC_Family            = 0x0300,               /* SPARC family of architectures; Sun Microsystems */
              ISA_SPARC_V7                = 0x0301,
              ISA_SPARC_V8                = 0x0302,
              ISA_SPARC_V8E               = 0x0303,
              ISA_SPARC_V9                = 0x0304,
              ISA_SPARC_V9JPS1            = 0x0305,
              ISA_SPARC_V9UA              = 0x0306,
              ISA_SPARC_V9JPS2            = 0x0307,

              ISA_M68K_Family             = 0x0400,               /* Motorala m68k family */
              ISA_M68K_68000              = 0x0401,               /* generation one: 16/32 internal; 8-, 16-, 32-bit interface */
              ISA_M68K_68EC000            = 0x0402,
              ISA_M68K_68HC000            = 0x0403,
              ISA_M68K_68008              = 0x0404,
              ISA_M68K_68010              = 0x0405,
              ISA_M68K_68012              = 0x0406,
              ISA_M68K_68020              = 0x0407,               /* generation two: fully 32-bit */
              ISA_M68K_68EC020            = 0x0408,
              ISA_M68K_68030              = 0x0409,
              ISA_M68K_68EC030            = 0x040a,
              ISA_M68K_68040              = 0x040b,               /* generation three: pipelined */
              ISA_M68K_68EC040            = 0x040c,
              ISA_M68K_68LC040            = 0x040d,
              ISA_M68K_68060              = 0x040e,               /* generation four: superscalar */
              ISA_M68K_ColdFire           = 0x040f,               /* other */
              ISA_M68K_DragonBall         = 0x0410,               /* other */

              ISA_M88K_Family             = 0x0500,               /* Motorola m88k family (not very popular) */
              ISA_M88K_88100              = 0x0501,               /* 32-bit, integrated FPU mated with 88200 MMU and cache controller */
              ISA_M88K_88110              = 0x0502,               /* single package of 88100+88200 */
              ISA_M88K_88110MP            = 0x0503,               /* on-chip comm for use in multi-processor systems */
              ISA_M88K_88120              = 0x0504,               /* superscalar (never actually released) */

              ISA_MIPS_Family             = 0x0600,               /* 32/64-bit RISC; MIPS Technologies, Inc. */
              ISA_MIPS_MarkI              = 0x0601,               /* R2000, R3000 */
              ISA_MIPS_MarkII             = 0x0602,               /* R6000 */
              ISA_MIPS_MarkIII            = 0x0603,               /* R4000 */
              ISA_MIPS_R2000              = 0x0604,               /* 32-bit, Big or little endian */
              ISA_MIPS_R3000              = 0x0605,               /* virtual identical: Pacempi's R3400, IDT's R3500, Toshiba R3900 */
              ISA_MIPS_R4000              = 0x0606,               /* 64-bit; others in the series had larger caches and bug fixes */
              ISA_MIPS_R4200              = 0x0607,               /* low-cost version of R4000 */
              ISA_MIPS_R4300              = 0x0608,               /* low-cost version of R4000 with 32-bit external bus */
              ISA_MIPS_R4600              = 0x0609,               /* "Orion" by Qauntum Effect Devices (QED); larger caches */
              ISA_MIPS_R4650              = 0x060a,               /* by QED */
              ISA_MIPS_R4700              = 0x060b,               /* "Orion" by QED */
              ISA_MIPS_R5000              = 0x060c,               /* by QED */
              ISA_MIPS_RM7000             = 0x060d,               /* by PMC-Sierra; 256kB L2 and optional L3 */
              ISA_MIPS_R8000              = 0x060e,               /* superscalar, fairly rare */
              ISA_MIPS_R10000             = 0x060f,               /* R8000 on a single chip; 32kB caches; out-of-order */
              ISA_MIPS_R12000             = 0x0610,               /* R10000 + higher clock rates */
              ISA_MIPS_R14000             = 0x0611,               /* R12000 + support for DDR SRAM; 200MHz front side bus */
              ISA_MIPS_R16000             = 0x0612,               /* R14000 + increased freq, more L1, smaller die */
              ISA_MIPS_R16000A            = 0x0613,
              ISA_MIPS_16                 = 0x0614,               /* Unknown. Windows PE architecture 0x266 "MIPS16" */
              ISA_MIPS_FPU                = 0x0615,               /* Unknown. Windows PE architecture 0x366 "MIPS with FPU" */
              ISA_MIPS_16FPU              = 0x0616,               /* Unknown. Windows PE architecture 0x466 "MIPS16 with FPU" */

              ISA_I860_Family             = 0x0700,               /* Intel i860 family; 1989-mid 90's; RISC VLIW */
              ISA_I860_860XR              = 0x0701,               /* (code named N10) 25-40MHz */
              ISA_I860_860XP              = 0x0702,               /* (code named N11) larger caches; 40-50MHz; same IS as XR */

              ISA_IA64_Family             = 0x0800,               /* Intel 64-bit architecture */
              ISA_IA64_Itanium            = 0x0801,               /* First generation */
              ISA_IA64_Itanium2           = 0x0802,               /* Second generation starting Nov 2007 */

              /* See http://en.wikipedia.org/wiki/ARM_architecture */
              ISA_ARM_Family              = 0x0900,               /* Acorn RISC Machine, Advanced RISC Machines, ARM Limited */
              ISA_ARM_ARM1                = 0x0901,               /* ARM evaluation system */
              ISA_ARM_ARM2                = 0x0902,               /* ARM2, ARM250 cores */
              ISA_ARM_ARM3                = 0x0903,               /* ARM2a core */
              ISA_ARM_ARM6                = 0x0904,               /* ARM60, ARM600, ARM610 cores */
              ISA_ARM_ARM7                = 0x0905,               /* ARM{700,710,710a,7100,7500,7500FE} cores */
              ISA_ARM_ARM7TDMI            = 0x0906,               /* ARM{7TDMI,7TDMI-S,710T,720T,740T,7EJ-S} cores */
              ISA_ARM_StrongARM           = 0x0907,               /* SA-110, SA-1110 cores */
              ISA_ARM_ARM8                = 0x0908,               /* ARM810 core */
              ISA_ARM_ARM9TDMI            = 0x0909,               /* ARM{9TDMI,920T,922T,940T} cores */
              ISA_ARM_ARM9E               = 0x090a,               /* ARM{946E-S,966E-S,968E-S,926EJ-S,966HS} cores */
              ISA_ARM_ARM10E              = 0x090b,               /* ARM{1020E,1022E,1026EJ-S} cores */
              ISA_ARM_XScale              = 0x090c,               /* 80200, IOP310, IOP315, 80219, IOP321, IOP33x, IOP34x, PXA210,
                                                         * PXA250, PXA255, PXA26x, PXA27x, PXA800(E)F, Monahans, PXA900,
                                                         * IXC1100, IXP2400, IXP2800, IXP2850, IXP2325, IXP2350, IXP42x,
                                                         * IXP460, IXP465 cores */
              ISA_ARM_ARM11               = 0x090d,               /* ARMv{6,6T2,6KZ,6K} cores */
              ISA_ARM_Cortex              = 0x090e,               /* Cortex-{A8,A9,A9 MPCore,R4(F),M3,M1} cores */
          
              /* Others, not yet incorporated into this enum */
              ISA_OTHER_Family            = 0xf000,

              ISA_ATT_WE_32100            = 0xf001,               /* sometimes simply "M32" */
              ISA_IBM_System_370          = 0xf002,
              ISA_HPPA                    = 0xf003,
              ISA_Fujitsu_VPP500          = 0xf004,
              ISA_Sun_v8plus              = 0xf005,
              ISA_PowerPC                 = 0xf006,
              ISA_PowerPC_64bit           = 0xf007,
              ISA_IBM_S390                = 0xf008,
              ISA_NEC_V800_series         = 0xf009,
              ISA_Fujitsu_FR20            = 0xf00a,
              ISA_TRW_RH_32               = 0xf00b,
              ISA_Motorola_RCE            = 0xf00c,
              ISA_Digital_Alpha_fake      = 0xf00e,
              ISA_Hitachi_SH              = 0xf00f,
              ISA_Siemens_Tricore         = 0xf010,
              ISA_Argonaut_RISC_Core      = 0xf011,
              ISA_Hitachi_H8_300          = 0xf012,
              ISA_Hitachi_H8_300H         = 0xf013,
              ISA_Hitachi_H8S             = 0xf014,
              ISA_Hitachi_H8_500          = 0xf015,
              ISA_Stanford_MIPS_X         = 0xf016,
              ISA_Motorola_M68HC12        = 0xf017,
              ISA_Fujitsu_MMA_Multimedia_Accelerator=0xf018,
              ISA_Siemens_PCP             = 0xf019,
              ISA_Sony_nCPU_embeeded_RISC = 0xf01a,
              ISA_Denso_NDR1_microprocessor=0xf01b,
              ISA_Motorola_Start_Core_processor=0xf01c,
              ISA_Toyota_ME16_processor   = 0xf01d,
              ISA_STMicroelectronic_ST100_processor=0xf01e,
              ISA_Advanced_Logic_Corp_Tinyj_emb_family=0xf01f,
              ISA_AMD_x86_64_architecture = 0xf020,
              ISA_Sony_DSP_Processor      = 0xf021,
              ISA_Siemens_FX66_microcontroller=0xf022,
              ISA_STMicroelectronics_ST9_plus_8_16_microcontroller=0xf023,
              ISA_STMicroelectronics_ST7_8bit_microcontroller=0xf024,
              ISA_Motorola_MC68HC16_microcontroller=0xf025,
              ISA_Motorola_MC68HC11_microcontroller=0xf026,
              ISA_Motorola_MC68HC08_microcontroller=0xf027,
              ISA_Motorola_MC68HC05_microcontroller=0xf028,
              ISA_Silicon_Graphics_SVx    = 0xf029,
              ISA_STMicroelectronics_ST19_8bit_microcontroller=0xf02a,
              ISA_Digital_VAX             = 0xf02b,
              ISA_Axis_Communications_32bit_embedded_processor=0xf02c,
              ISA_Infineon_Technologies_32bit_embedded_processor=0xf02d,
              ISA_Element_14_64bit_DSP_Processor=0xf02e,
              ISA_LSI_Logic_16bit_DSP_Processor=0xf02f,
              ISA_Donald_Knuths_educational_64bit_processor=0xf030,
              ISA_Harvard_University_machine_independent_object_files=0xf031,
              ISA_SiTera_Prism            = 0xf032,
              ISA_Atmel_AVR_8bit_microcontroller=0xf033,
              ISA_Fujitsu_FR30            = 0xf034,
              ISA_Mitsubishi_D10V         = 0xf035,
              ISA_Mitsubishi_D30V         = 0xf036,
              ISA_NEC_v850                = 0xf037,
              ISA_Mitsubishi_M32R         = 0xf038,
              ISA_Matsushita_MN10300      = 0xf039,
              ISA_Matsushita_MN10200      = 0xf03a,
              ISA_picoJava                = 0xf03b,
              ISA_OpenRISC_32bit_embedded_processor=0xf03c,
              ISA_ARC_Cores_Tangent_A5    = 0xf03d,
              ISA_Tensilica_Xtensa_Architecture=0xf03e,
              ISA_Digital_Alpha		= 0xf03f,
              ISA_Matsushita_AM33         = 0xf040,
              ISA_EFI_ByteCode            = 0xf041
             };

       /* General purpose of a binary executable file */
          enum ExecPurpose {
              PURPOSE_UNSPECIFIED,                                /* Purpose is not specified and could not be inferred */
              PURPOSE_OTHER,                                      /* A purpose other than any defined below */
              PURPOSE_EXECUTABLE,                                 /* Executable program */
              PURPOSE_LIBRARY,                                    /* Library (shared or relocatable) */
              PURPOSE_CORE_DUMP,                                  /* Post mortem image */
              PURPOSE_OS_SPECIFIC,                                /* Some operating system specific purpose */
              PURPOSE_PROC_SPECIFIC                               /* Some processor specific purpose */
          };


       // DQ (12/8/2008): Hook into the construction of the binary file format support.
          static void parseBinaryFormat(const std::string & name, SgAsmFile* asmFile);
          static SgAsmGenericFile *parseBinaryFormat(const char *name);
          static void unparseBinaryFormat(const std::string &name, SgAsmFile *asmFile);
	  static void unparseBinaryFormat(std::ostream&, SgAsmFile*);

       // DQ (11/8/2008): used in the PE support.
       // Looking for function: hexdump(_IO_FILE*&, long unsigned int, const char[5], SgCharList&, size_t&)
          static void hexdump(FILE *f, addr_t base_addr, const char *prefix, const unsigned char *data, size_t n);
       // static void hexdump(FILE *f, addr_t base_addr, const std::string &prefix, const SgCharList &data);
          static void hexdump(FILE *f, addr_t base_addr, const std::string &prefix, const SgUnsignedCharList &data);
          static void hexdump(FILE *f, addr_t base_addr, const std::string &prefix, const SgFileContentList &data);

       /* Return byte order of caller */
          static SgAsmExecutableFileFormat::ByteOrder host_order();

       /* Swap (reverse) bytes taking care of sign extension */
          static uint8_t swap_bytes(uint8_t n);
          static uint16_t swap_bytes(uint16_t n);
          static uint32_t swap_bytes(uint32_t n);
          static uint64_t swap_bytes(uint64_t n);
          static int8_t swap_bytes(int8_t n);
          static int16_t swap_bytes(int16_t n);
          static int32_t swap_bytes(int32_t n);
          static int64_t swap_bytes(int64_t n);


       /* Little-endian byte order conversions */
          static uint8_t le_to_host(uint8_t n);
          static uint16_t le_to_host(uint16_t n);
          static uint32_t le_to_host(uint32_t n);
          static uint64_t le_to_host(uint64_t n);
          static int8_t le_to_host(int8_t n);
          static int16_t le_to_host(int16_t n);
          static int32_t le_to_host(int32_t n);
          static int64_t le_to_host(int64_t n);

          static void host_to_le(unsigned h, uint8_t *n);
          static void host_to_le(unsigned h, uint16_t *n);
          static void host_to_le(unsigned h, uint32_t *n);
          static void host_to_le(addr_t h, uint64_t *n);
	  static void host_to_le(rva_t h, uint32_t *n);
	  static void host_to_le(rva_t h, uint64_t *n);
          static void host_to_le(int h, int8_t *n);
          static void host_to_le(int h, int16_t *n);
          static void host_to_le(int h, int32_t *n);
          static void host_to_le(int64_t h, int64_t *n);

       /* Big-endian byte order conversions */
          static uint8_t be_to_host(uint8_t n);
          static uint16_t be_to_host(uint16_t n);
          static uint32_t be_to_host(uint32_t n);
          static uint64_t be_to_host(uint64_t n);
          static int8_t be_to_host(int8_t n);
          static int16_t be_to_host(int16_t n);
          static int32_t be_to_host(int32_t n);
          static int64_t be_to_host(int64_t n);

          static void host_to_be(unsigned h, uint8_t *n);
          static void host_to_be(unsigned h, uint16_t *n);
          static void host_to_be(unsigned h, uint32_t *n);
          static void host_to_be(addr_t h, uint64_t *n);
	  static void host_to_be(rva_t h, uint32_t *n);
	  static void host_to_be(rva_t h, uint64_t *n);
          static void host_to_be(int h, int8_t *n);
          static void host_to_be(int h, int16_t *n);
          static void host_to_be(int h, int32_t *n);
          static void host_to_be(int64_t h, int64_t *n);

       /* Caller-specified byte order conversions */
          static uint8_t disk_to_host(SgAsmExecutableFileFormat::ByteOrder sex, uint8_t n);
          static uint16_t disk_to_host(SgAsmExecutableFileFormat::ByteOrder sex, uint16_t n);
          static uint32_t disk_to_host(SgAsmExecutableFileFormat::ByteOrder sex, uint32_t n);
          static uint64_t disk_to_host(SgAsmExecutableFileFormat::ByteOrder sex, uint64_t n);
          static int8_t disk_to_host(SgAsmExecutableFileFormat::ByteOrder sex, int8_t n);
          static int16_t disk_to_host(SgAsmExecutableFileFormat::ByteOrder sex, int16_t n);
          static int32_t disk_to_host(SgAsmExecutableFileFormat::ByteOrder sex, int32_t n);
          static int64_t disk_to_host(SgAsmExecutableFileFormat::ByteOrder sex, int64_t n);

       // static void host_to_disk(SgAsmExecutableFileFormat::ByteOrder, unsigned char h, unsigned char *np);
          static void host_to_disk(SgAsmExecutableFileFormat::ByteOrder sex, unsigned h, uint8_t *np);
          static void host_to_disk(SgAsmExecutableFileFormat::ByteOrder sex, unsigned h, uint16_t *np);
          static void host_to_disk(SgAsmExecutableFileFormat::ByteOrder sex, unsigned h, uint32_t *np);
          static void host_to_disk(SgAsmExecutableFileFormat::ByteOrder sex, addr_t h, uint64_t *np);
	  static void host_to_disk(SgAsmExecutableFileFormat::ByteOrder sex, rva_t h, uint64_t *np);
          static void host_to_disk(SgAsmExecutableFileFormat::ByteOrder sex, int h, int8_t *np);
          static void host_to_disk(SgAsmExecutableFileFormat::ByteOrder sex, int h, int16_t *np);
          static void host_to_disk(SgAsmExecutableFileFormat::ByteOrder sex, int h, int32_t *np);
          static void host_to_disk(SgAsmExecutableFileFormat::ByteOrder sex, int64_t h, int64_t *np);

HEADER_EXECUTABLE_FILE_FORMAT_END



HEADER_GENERIC_SECTION_START
	public:
		// RPM (8/27/2008): Is this right? get_offset() returns file offset; get_mapped_rva() returns memory addr*/
		// This can be mapped to the offset data member
		unsigned long get_starting_memory_address() { return get_offset(); }

		// DQ (8/7/2008): These are a few data member access functions that were required 
		// to compile when first adding the new IR nodes (these should be removed).
		unsigned long get_starting_file_offset() { return 0; }
		unsigned long get_flags() { return 0; }
		unsigned long get_type() { return 0; }


		/* Reason for section's existence. This is a union of all the section purposes from the various supported file
		 * formats.  However, at this time we're only interested in a few kinds of sections and therefore most will fall
		 * into the SP_OTHER category. */
		enum SectionPurpose {
			SP_UNSPECIFIED,			/* File format did not specify a reason and none could be determined */
			SP_PROGRAM,             	/* Program-supplied data, code, etc. */
			SP_HEADER,              	/* Section contains a header for the executable file format */
			SP_SYMTAB,              	/* Symbol table */
			SP_OTHER                	/* File-specified purpose other than any given in this enum */
		};

		SgAsmGenericSection(SgAsmGenericFile *f, SgAsmGenericHeader *fhdr)
			: p_header(NULL), p_size(0), p_offset(0), p_file_alignment(0), p_purpose(SP_UNSPECIFIED),
			p_synthesized(false), p_id(-1), p_name(0), p_mapped_rva(0), p_mapped_size(0), p_mapped_alignment(0),
			p_mapped_rperm(false), p_mapped_wperm(false), p_mapped_xperm(false), p_congealed(false)
			{ctor(f, fhdr);}

		SgAsmGenericSection(SgAsmGenericFile *f, SgAsmGenericHeader *fhdr, addr_t offset, addr_t size)
			: p_header(NULL), p_size(0), p_offset(0), p_file_alignment(0), p_purpose(SP_UNSPECIFIED),
			p_synthesized(false), p_id(-1), p_name(0), p_mapped_rva(0), p_mapped_size(0), p_mapped_alignment(0),
			p_mapped_rperm(false), p_mapped_wperm(false), p_mapped_xperm(false), p_congealed(false)
			{ctor(f, fhdr, offset, size);}

		// This destructor modifies the SgAsmGenericFile data to remove its section from the section list!
		virtual ~SgAsmGenericSection();

		static void dump_containing_sections(FILE *f, const std::string &prefix, rose_rva_t rva,
			const SgAsmGenericSectionPtrList&);
		void grab_content();
		virtual SgAsmGenericSection* parse() {grab_content(); return this;}
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
		virtual bool reallocate() {return false;}
		virtual void unparse(std::ostream&) const;
		void unparse(std::ostream&, const ExtentMap&) const;
		void unparse_holes(std::ostream&) const;
		SgAsmGenericHeader *is_file_header();	/* true if section represents a top level file header */

		/* Functions for section extent within the file */
		addr_t        get_size() const;
		virtual void  set_size(addr_t);		/* Resize a section w/o regard to other sections or mapping */
		addr_t        get_offset() const;
		virtual void  set_offset(addr_t);		/* Move a section w/o regard to other sections or mapping */
		addr_t        get_end_offset(); /* file offset for end of section */
		void          extend(addr_t nbytes);         	/* make section larger by extending the end */
		addr_t        write(std::ostream&, addr_t offset, size_t bufsize, const void *buf) const;
		addr_t        write(std::ostream&, addr_t offset, const std::string &str) const;
		addr_t        write(std::ostream&, addr_t offset, char c) const;
		addr_t        write(std::ostream&, addr_t offset, const SgFileContentList &buf) const;
		addr_t	write(std::ostream&, addr_t offset, const SgUnsignedCharList &buf) const;

		/* Functions for accessing content */
		const unsigned char *content(addr_t offset, addr_t size);/*returns ptr to SIZE bytes starting at OFFSET */
		const SgUnsignedCharList content_ucl(addr_t offset, addr_t size);/*returns ptr to SIZE bytes starting at OFFSET */
		void content(addr_t offset, addr_t size, void *buf); /* copies content into BUF */
		std::string content_str(addr_t offset, bool relax=true);/* ptr to NUL-terminated string starting at OFFSET */
		ExtentMap get_internal_holes() const;		/* weak form of congeal() */
		const ExtentMap& congeal();                     /* congeal referenced areas into holes */
		const ExtentMap& uncongeal();                   /* uncongeal holes back into references */

		/* Functions related to mapping of sections into executable memory */
		bool   	      is_mapped() const;                /* True iff non-zero mapped address and size */
		void   	      clear_mapped();                 	/* Set mapped address and size to zero (unmapped)*/
		addr_t        get_mapped_size() const;
		virtual void  set_mapped_size(addr_t);	      	/* Set mapped size w/o regard to other section mappings */
		addr_t	      get_mapped_rva() const;
		virtual void  set_mapped_rva(addr_t);         	/* Move a section w/o regard to other section mappings */
		addr_t 	      get_base_va() const;            	/* Convenience to get header's base VA */
		addr_t 	      get_mapped_va();		      	/* Like get_mapped_rva() except returns VA */
		addr_t        get_va_offset(addr_t va);       	/* Return file offset for specified virtual address */
		addr_t	      get_rva_offset(addr_t rva);     	/* Return file offset for specified relative virtual address */

		/* Accessors for private members */
		SgAsmGenericString *get_name() const;		/* Same as standard ROSETTA accessor */
		void set_name(SgAsmGenericString *s);		/* Like std accessor but sets parent of 's' */

		/* Convenience functions */
		ExtentPair get_file_extent() const;		/* Returns get_offset() and get_size() */
		ExtentPair get_mapped_extent() const;	        /* Returns get_mapped_rva() and get_mapped_size() */

	protected:
		void ctor(SgAsmGenericFile*, SgAsmGenericHeader*);
		void ctor(SgAsmGenericFile*, SgAsmGenericHeader*, addr_t offset, addr_t size);
HEADER_GENERIC_SECTION_END



HEADER_GENERIC_HEADER_START

     public:
          SgAsmGenericHeader(SgAsmGenericFile *ef, addr_t offset, addr_t size);
          virtual ~SgAsmGenericHeader();
	  virtual bool reallocate();
	  virtual void unparse(std::ostream&) const;
          virtual void dump(FILE*, const char *prefix, ssize_t idx) const;

       // DQ (8/8/2008): We can't make this pure virtual since then we can't allocate this class.
       // virtual const char *format_name() = 0;
          virtual const char *format_name() const;
    
       /* Functions for dynamically linked libraries (DLLs) */
          void add_dll(SgAsmGenericDLL *dll);                         /* Add new DLL to list of DLLs for this file */
       // std::vector<SgAsmGenericDLL*>& get_dlls() {return p_dlls;}    /* all necessary dynamically loaded libraries */
          std::vector<SgAsmGenericDLL*>& get_dlls() { ROSE_ASSERT(p_dlls != NULL); return p_dlls->get_dlls(); }    /* all necessary dynamically loaded libraries */

       /* Functions for symbols */
          void add_symbol(SgAsmGenericSymbol*);                       /* add a new symbol to the symbol table. Duplicates are allowed. */
       // std::vector<SgAsmGenericSymbol*>& get_symbol() { ROSE_ASSERT(p_symbols != NULL); return p_symbols->get_symbols(); }
          SgAsmGenericSymbolPtrList & get_symbol_list();

       /* Accessors for protected/private members */
       // SgAsmGenericFormat & get_exec_format() {return p_exec_format;}
          std::vector<unsigned char>& get_magic() {return p_magic;}
       // addr_t get_base_va() const {return p_base_va;}
          addr_t get_entry_rva() const;
          void add_entry_rva(const rose_rva_t &rva) { p_entry_rvas.push_back(rva);}

       /* Convenience functions */
       // SgAsmGenericFormat::ByteOrder get_sex() const { return p_exec_format.p_sex; }
          SgAsmExecutableFileFormat::ByteOrder get_sex() const;
       // size_t get_word_size() const {return p_exec_format.p_word_size;}
          size_t get_word_size() const;

       /* Functions for sections */
          void add_section(SgAsmGenericSection*);             /* Add new section to the file; called implicitly by section ctor */
          void remove_section(SgAsmGenericSection*); 	      /* Remove section from the file */

       /* Section lookup functions (plural) */
	  SgAsmGenericSectionPtrList get_mapped_sections() const;
	  SgAsmGenericSectionPtrList get_sections_by_id(int id) const;
	  SgAsmGenericSectionPtrList get_sections_by_name(std::string, char sep=0) const;
	  SgAsmGenericSectionPtrList get_sections_by_offset(addr_t offset, addr_t size) const;
	  SgAsmGenericSectionPtrList get_sections_by_rva(addr_t rva) const;
	  SgAsmGenericSectionPtrList get_sections_by_va(addr_t va) const;

       /* Section lookup functions (singular) */
	  SgAsmGenericSection *get_section_by_id(int id, size_t *nfound=0) const;
	  SgAsmGenericSection *get_section_by_name(const std::string&, char sep=0, size_t *nfound=0) const;
	  SgAsmGenericSection *get_section_by_offset(addr_t offset, addr_t size, size_t *nfound=0) const;
          SgAsmGenericSection *get_section_by_rva(addr_t rva, size_t *nfound=0) const;
	  SgAsmGenericSection *get_section_by_va(addr_t va, size_t *nfound=0) const;
	  SgAsmGenericSection *get_best_section_by_va(addr_t va, size_t *nfound=0) const;


  // protected:
       // ExecFormat          exec_format;                    /* General info about the executable format */
       // std::vector<unsigned char> magic;                   /* Optional magic number in file byte order */
       // InsSetArchitecture  target;                         /* Machine for which this header and its sections, etc. was compiled */
       // addr_t              base_va;                        /* Base virtual address used by all "relative virtual addresses" (RVA) */
       // std::vector<addr_t> entry_rvas;                     /* Code entry points wrt base_va */
       // std::vector<ExecDLL*> dlls;                         /* List of dynamic libraries needed by this executable */
       // std::vector<ExecSymbol*> symbols;                   /* All symbols defined for this header */

     private:
          void ctor(SgAsmGenericFile *f, addr_t offset, addr_t size);

HEADER_GENERIC_HEADER_END



HEADER_GENERIC_FILE_START
	public:
		SgAsmGenericFile()					/* Non-parsing constructor */
			: p_fd(-1), p_headers(NULL), p_holes(NULL)
			{ctor();}
		virtual ~SgAsmGenericFile();				/* Destructor deletes children and unmaps/closes file */
		SgAsmGenericFile* parse(std::string file_name);		/* Attach an existing file for parsing */
		void reallocate();					/* Make consistent before calling unparse */
		void unparse(std::ostream&) const;			/* Unparse the file -- mirror image of parsing */
		void extend_to_eof(std::ostream&);			/* Write zeros to logical EOF */
		void dump(FILE*) const;                                 /* Print some debugging info */

		/* File contents */
		rose_addr_t get_current_size() const;			/* Current size based on defined sections */
		rose_addr_t get_orig_size() const;              	/* Original size based on actual file size */
		const SgFileContentList& content() {			/* Entire file contents */
			return p_data;
		}
		SgFileContentList content(addr_t offset, addr_t size, bool relax=true);	/* Partial file contents */

		/* Section lookup functions (plural) */
		SgAsmGenericSectionPtrList get_mapped_sections() const;
		SgAsmGenericSectionPtrList get_sections(bool include_holes=true) const;
		SgAsmGenericSectionPtrList get_sections_by_id(int id) const;
		SgAsmGenericSectionPtrList get_sections_by_name(std::string, char sep='\0') const;
		SgAsmGenericSectionPtrList get_sections_by_offset(addr_t offset, addr_t size) const;
		SgAsmGenericSectionPtrList get_sections_by_rva(addr_t rva) const;
		SgAsmGenericSectionPtrList get_sections_by_va(addr_t va) const;

		/* Section lookup functions (singular) */
		SgAsmGenericSection *get_section_by_id(int id, size_t *nfound=0) const;
		SgAsmGenericSection *get_section_by_name(const std::string&, char sep=0, size_t *nfound=0) const;
		SgAsmGenericSection *get_section_by_offset(addr_t offset, addr_t size, size_t *nfound=0) const;
		SgAsmGenericSection *get_section_by_rva(addr_t rva, size_t *nfound=0) const;
		SgAsmGenericSection *get_section_by_va(addr_t va, size_t *nfound=0) const;
		SgAsmGenericSection *get_best_section_by_va(addr_t va, size_t *nfound=0) const;
		static SgAsmGenericSection *best_section_by_va(const SgAsmGenericSectionPtrList &sections, addr_t va);

		/* Section modification functions */
		enum AddressSpace {					/* Bit flags for address spaces for shift_extend() */
			ADDRSP_MEMORY = 0x0001,
			ADDRSP_FILE   = 0x0002,
			ADDRSP_ALL    = 0x0003,
		};
		enum Elasticity {					/* Elasticity argument for shift_extend() */
			ELASTIC_NONE  = 0,				/* Nothing is elastic; other parts of space are shifted */
			ELASTIC_UNREF = 1,				/* Unreferenced address space is elastic */
			ELASTIC_HOLE  = 2,				/* Unreferenced and "hole" sections are elastic */
		};
		void shift_extend(SgAsmGenericSection *s, addr_t sa, addr_t sn)
			{shift_extend(s, sa, sn, ADDRSP_ALL, ELASTIC_UNREF);}
		void shift_extend(SgAsmGenericSection*, addr_t sa, addr_t sn, AddressSpace, Elasticity);

		/* Holes (unreferenced regions in the file) */	
		void congeal();                                     	/* Identify and freeze all unreferenced regions */
		addr_t get_next_section_offset(addr_t offset);      	/* Find file offset for next section */
		void add_hole(SgAsmGenericSection*);		      	/* Add section to list of holes */
		void remove_hole(SgAsmGenericSection*);             	/* Remove section from list of holes */
		void fill_holes();                                  	/* Find holes in file and create sections to fill them */
		void unfill_holes();                                	/* Undoes what fill_holes() did */

		/* Functions for file headers (a kind of section) */
		void add_header(SgAsmGenericHeader*);               	/* Add a new file header to the list of headers */
		void remove_header(SgAsmGenericHeader*);            	/* Remove file header from the file */
		SgAsmGenericHeader *get_header(SgAsmGenericFormat::ExecFamily);/* Returns the specified header or exception */
		const char *format_name() const;                        /* Return a string describing the file format */

		const SgAsmGenericFormat::fileDetails &get_sb() {
			return p_sb;
		}
		void set_sb(const SgAsmGenericFormat::fileDetails &sb) {
			printf("set_sb() not implemented!\n");
			ROSE_ASSERT(false);
		}

		// DQ (8/26/2008): Added support for alternative section selection for use in disassembler.
		SgAsmGenericSection* get_best_possible_section_by_va(addr_t va);

	private:
		void ctor();
HEADER_GENERIC_FILE_END



HEADER_GENERIC_FORMAT_START
     public:

// typedef uint64_t addr_t;                                /* address and size (file and memory) */


#if 0
       // This is automatically generated.
          SgAsmGenericFormat() :
               family(FAMILY_UNSPECIFIED),
               purpose(PURPOSE_UNSPECIFIED),
               sex(ORDER_UNSPECIFIED),
               version(0),
               is_current_version(false),
               abi(ABI_UNSPECIFIED),
               abi_version(0),
               word_size(4)
             {}
#endif

    void dump(FILE*, const char *prefix, ssize_t idx) const;

HEADER_GENERIC_FORMAT_END



HEADER_GENERIC_DLL_START
	public:
		explicit SgAsmGenericDLL(SgAsmGenericString *s);
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
		void add_symbol(const std::string &s) 			/* Add a needed symbol to the import list for this DLL */
			{p_symbols.push_back(s);}

		/* Override ROSETTA accessors */
		SgAsmGenericString *get_name() const;
		void set_name(SgAsmGenericString *s);
HEADER_GENERIC_DLL_END



HEADER_GENERIC_DLL_LIST_START
HEADER_GENERIC_DLL_LIST_END



HEADER_GENERIC_SYMBOL_START
	public:
		enum SymbolDefState {
			SYM_UNDEFINED,		/* Symbol has not been defined yet */
			SYM_TENTATIVE,          /* Does not have size/value yet (uninitialized C or Fortran common blks) */
			SYM_DEFINED             /* Created and assigned storage */
		};

		enum SymbolType {
			SYM_NO_TYPE,            /* No type or type is unknown */
			SYM_DATA,               /* Normal variable definitions */
			SYM_FUNC,               /* Function or other code */
			SYM_SECTION,            /* Section of a file */
			SYM_FILE,               /* Name of a file */
			SYM_ARRAY,              /* Array of some other type */
			SYM_TLS,                /* Thread-local storage */
			SYM_REGISTER,           /* CPU register value (see Sparc) */
			SYM_COMMON		/* Common block */
		};

		enum SymbolBinding {
			SYM_NO_BINDING,         /* Unknown binding */
			SYM_LOCAL,
			SYM_GLOBAL,
			SYM_WEAK
		};

		explicit SgAsmGenericSymbol(SgAsmGenericString *name)
			: p_def_state(SYM_UNDEFINED), p_binding(SYM_NO_BINDING), p_type(SYM_NO_TYPE), p_value(0), p_size(0),
			p_bound(NULL), p_name(NULL)
			{set_name(name);}

		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
		std::string stringifyDefState() const;
		std::string stringifyType() const;
		std::string stringifyBinding() const;

		// Accessors
		SgAsmGenericString *get_name() const; // same as ROSETTA-generated version
		void set_name(SgAsmGenericString *s); // also sets s.parent
HEADER_GENERIC_SYMBOL_END



HEADER_GENERIC_SYMBOL_LIST_START
HEADER_GENERIC_SYMBOL_LIST_END



HEADER_BASIC_STRING_START
	public:
		//SgAsmBasicString() {ctor();}
		explicit SgAsmBasicString(const std::string &s)
			: p_string(s) {ctor();}
		explicit SgAsmBasicString(const char *s)
			: p_string(s) {ctor();}
		// virtual ~SgAsmBasicString() {}
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
		virtual std::string get_string() const;
		virtual void set_string(const std::string&);
	private:
		void ctor();
HEADER_BASIC_STRING_END



HEADER_GENERIC_STRING_START
	public:
		//virtual ~SgAsmGenericString() {};
		static const rose_addr_t unallocated = ~(rose_addr_t)0;

		// These aren't the ROSETTA-generated versions because they hook into string table allocation functions
		virtual std::string get_string() const;
		virtual void set_string(const std::string &s);
		virtual rose_addr_t get_offset() const {return unallocated;}
		const char *c_str() const;

		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
HEADER_GENERIC_STRING_END



HEADER_STRING_STORAGE_START
     public:
          SgAsmStringStorage(SgAsmGenericStrtab *strtab, const std::string &string, rose_addr_t offset)
             : p_strtab(strtab), p_string(string), p_offset(offset) {}
          void dump(FILE *s, const char *prefix, ssize_t idx) const;

       /* Accessors. The set_* accessors are private because we don't want anyone messing with them. These data members are used
        * to control string allocation in ELF string tables and must only be modified by allocators in closely related classes.
        * For instance, to change the value of the string one should call SgAsmGenericString::set_string() instead. */

#if 0
       // Let the access function generated by ROSETTA be used.
	  SgAsmElfStrtab* get_strtab() const {
	       return p_strtab;
	     }
	  const std::string& get_string() const {             /*read-only; set string with SgAsmGenericString::set_string()*/
	       return p_string;
	     }
	  const rose_addr_t get_offset() const {              /*read-only; set only by the string table allocator*/
	       return p_offset;                               /*does not trigger reallocation; cf. SgAsmStoredString::get_offset()*/
	     }
#endif

     private:
          friend class SgAsmStoredString;                     /*allowed to set private data members*/
          friend class SgAsmStoredStrtab;                     /*allowed to set private data members*/
#if 0
       // Let the access function generated by ROSETTA be used.
          void set_string(const std::string &s) {
               p_string = s;
             }
          void set_strtab(SgAsmElfStrtab *strtab) {
               p_strtab = strtab;
             }
          void set_offset(rose_addr_t offset) {
               p_offset = offset;
             }
          SgAsmStringStorage() {abort();}                    /*no default constructor; cf. SgAsmStoredString::create_storage()*/
#endif

HEADER_STRING_STORAGE_END

HEADER_GENERIC_STRTAB_START
	public:
		explicit SgAsmGenericStrtab(SgAsmGenericSection *container)
			: p_container(container), p_dont_free(0), p_num_freed(0) {}
		virtual ~SgAsmGenericStrtab() {}
		virtual SgAsmGenericStrtab* parse() {return this;}
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
		SgAsmStoredString *create_string(addr_t offset, bool shared);
		void free(SgAsmStringStorage*);
		void free(addr_t offset, addr_t size); /*mark part of table as free*/
		void free_all_strings(bool blow_away_holes=false);
		virtual void allocate_overlap(SgAsmStringStorage*) {};
		bool reallocate(bool shrink); /*allocate storage for all unallocated strings*/

		/* Free list accessors. Overriding ROSETTA because get_freelist() must return a modifiable free list. */
		const ExtentMap& get_freelist() const;
		ExtentMap& get_freelist();

		//These should be pure virtual but ROSETTA apparently doesn't support that (RPM 2008-10-03)
		virtual SgAsmStringStorage *create_storage(addr_t offset, bool shared) {abort();}
		virtual addr_t get_storage_size(const SgAsmStringStorage*) {abort();}
		typedef std::vector<class SgAsmStringStorage*> referenced_t;
	private:
		void ctor();
HEADER_GENERIC_STRTAB_END

// ***********************************************
//          ELF Binary File Format Support
// ***********************************************

HEADER_ELF_HEADER_START
	public:
		/* File format of an ELF header. Byte order of members depends on e_ident value. This code comes directly from
		 * "System V Application Binary Interface, Edition 4.1" and the FreeBSD elf(5) man page, and the "Executable and
		 * Linkable Format (ELF) Portable Formats Specifications, Version 1.2" and not from any header file. */
		struct Elf32FileHeader_disk {
			unsigned char       e_ident_magic[4];       /* 0x7f, 'E', 'L', 'F' */
			unsigned char       e_ident_file_class;     /* 1=>32-bit; 2=>64-bit; other is error */
			unsigned char       e_ident_data_encoding;  /* 1=>LSB; 2=>MSB; other is error */
			unsigned char       e_ident_file_version;   /* Format version number (same as e_version); must be 1 */
			unsigned char       e_ident_padding[9];     /* padding to byte 16; must be zero */
			uint16_t            e_type;                 /* object file type: relocatable, executable, lib, core */
			uint16_t            e_machine;              /* required architecture for an individual file */
			uint32_t            e_version;              /* object file version, currently zero or one */
			uint32_t            e_entry;                /* entry virtual address or zero if none */
			uint32_t            e_phoff;                /* file offset of program header table or zero if none */
			uint32_t            e_shoff;                /* file offset of section header table or zero if none */
			uint32_t            e_flags;                /* processor-specific flags (EF_* constants in docs) */
			uint16_t            e_ehsize;               /* size of ELF header in bytes */
			uint16_t            e_phentsize;            /* size of each entry in the program header table */
			uint16_t            e_phnum;                /* number of program headers, or PN_XNUM, or zero */
			uint16_t            e_shentsize;            /* size of each entry in the section header table */
			uint16_t            e_shnum;                /* number of section headers, or zero for extended entries */
			uint16_t            e_shstrndx;             /* index of name section, or SHN_UNDEF, or SHN_XINDEX */
		} __attribute__((packed));

		struct Elf64FileHeader_disk {
			unsigned char       e_ident_magic[4];
			unsigned char       e_ident_file_class;
			unsigned char       e_ident_data_encoding;
			unsigned char       e_ident_file_version;
			unsigned char       e_ident_padding[9];
			uint16_t            e_type;
			uint16_t            e_machine;
			uint32_t            e_version;
			uint64_t            e_entry;
			uint64_t            e_phoff;
			uint64_t            e_shoff;
			uint32_t            e_flags;
			uint16_t            e_ehsize;
			uint16_t            e_phentsize;
			uint16_t            e_phnum;
			uint16_t            e_shentsize;
			uint16_t            e_shnum;
			uint16_t            e_shstrndx;
		} __attribute__((packed));

		/* Non-parsing constructor */
		explicit SgAsmElfFileHeader(SgAsmGenericFile *f)
			: SgAsmGenericHeader(f, 0, 1)
			{ctor();}

		uint64_t max_page_size();
		virtual SgAsmElfFileHeader *parse();
		virtual bool reallocate();
		virtual void unparse(std::ostream&) const;
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;

		virtual const char *format_name() const;
		static bool is_ELF(SgAsmGenericFile*);
		SgAsmGenericSectionPtrList get_sectab_sections();
		SgAsmGenericSectionPtrList get_segtab_sections();

	private:
		void ctor();
		void *encode(SgAsmExecutableFileFormat::ByteOrder, SgAsmElfFileHeader::Elf32FileHeader_disk*) const;
		void *encode(SgAsmExecutableFileFormat::ByteOrder, SgAsmElfFileHeader::Elf64FileHeader_disk*) const;
HEADER_ELF_HEADER_END



HEADER_ELF_SECTION_TABLE_START
	public:
		SgAsmElfSectionTable(SgAsmElfFileHeader *fhdr, rose_addr_t offset) /* Non-parsing constructor */
			: SgAsmGenericSection(fhdr->get_file(), fhdr, offset, 0)
			{ctor();}
		virtual SgAsmElfSectionTable *parse();
		void add_section(SgAsmElfSection*);
		rose_addr_t calculate_sizes(size_t *entsize, size_t *required, size_t *optional, size_t *entcount) const;
		virtual bool reallocate();
		virtual void unparse(std::ostream&) const;
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
	private:
		void ctor();    
HEADER_ELF_SECTION_TABLE_END



HEADER_ELF_SECTION_TABLE_ENTRY_START
	public:
		/* Section types (host order). All other values are reserved. */
		enum SectionType {
			SHT_NULL        = 0,            /* Section header is inactive */
			SHT_PROGBITS	= 1,            /* Info defined by the program; format and meaning determined by prog */
			SHT_SYMTAB      = 2,            /* Complete symbol table */
			SHT_STRTAB      = 3,            /* String table */
			SHT_RELA        = 4,            /* Relocation entries with explicit addends (e.g., Elf32_Rela types) */
			SHT_HASH        = 5,            /* Symbol hash table (used by dynamic linking) */
			SHT_DYNAMIC     = 6,            /* Information for dynamic linking */
			SHT_NOTE        = 7,            /* Information that marks the file in some way */
			SHT_NOBITS      = 8,            /* Like SHT_PROGBITS but occupies no file space */
			SHT_REL         = 9,            /* Relocation entries without explicit addends (e.g., Elf32_Rel types) */
			SHT_SHLIB       = 10,           /* Reserved, unspecified semantics; Present only in non-conforming files */
			SHT_DYNSYM      = 11,           /* Minimal set of dynamic linking symbols */
			SHT_LOPROC      = 0x70000000,	/* Processor specific semantics */
			SHT_HIPROC      = 0x7fffffff,
			SHT_LOUSER      = 0x80000000,   /* Application specific semantics */
			SHT_HIUSER      = 0xffffffff
		};

		/* File format of an ELF Section header. Byte order of members depends on e_ident value in file header. This code
		 * comes directly from "Executable and Linkable Format (ELF)", Portable Formats Specification, Version 1.1, Tool
                 * Interface Standards (TIS) and not from any header file. The 64-bit structure is gleaned from the Linux
                 * elf(5) man page. */
		struct Elf32SectionTableEntry_disk {
			uint32_t	sh_name;	/* 0x00 Section name; index into section header string table */
			uint32_t        sh_type;        /* 0x04 Section contents and semantics (see SectionType enum) */
			uint32_t        sh_flags;       /* 0x08 Bit flags */
			uint32_t        sh_addr;        /* 0x0c Desired mapped address */
			uint32_t        sh_offset;      /* 0x10 Section location in file unless sh_type==SHT_NOBITS */
			uint32_t        sh_size;        /* 0x14 Section size in bytes */
			uint32_t        sh_link;        /* 0x18 Section ID of another section; meaning depends on section type */
			uint32_t        sh_info;        /* 0x1c Extra info depending on section type */
			uint32_t        sh_addralign;   /* 0x20 Mapped alignment (0 and 1=>byte aligned); sh_addr must be aligned*/
			uint32_t        sh_entsize;     /* 0x24 If non-zero, size in bytes of each array member in the section */
		} __attribute__((packed));              /* 0x28 */

		struct Elf64SectionTableEntry_disk {
			uint32_t	sh_name;	/* 0x00 see Elf32SectionTableEntry_disk */
			uint32_t        sh_type;	/* 0x04 */
			uint64_t        sh_flags;	/* 0x08 */
			uint64_t        sh_addr;	/* 0x10 */
			uint64_t        sh_offset;	/* 0x18 */
			uint64_t        sh_size;	/* 0x20 */
			uint32_t        sh_link;	/* 0x28 */
			uint32_t        sh_info;	/* 0x2c */
			uint64_t        sh_addralign;	/* 0x30 */
			uint64_t        sh_entsize;	/* 0x38 */
		} __attribute__((packed));		/* 0x40 */

		SgAsmElfSectionTableEntry(SgAsmExecutableFileFormat::ByteOrder sex,
			const SgAsmElfSectionTableEntry::Elf32SectionTableEntry_disk *disk);
		SgAsmElfSectionTableEntry(SgAsmExecutableFileFormat::ByteOrder sex,
			const SgAsmElfSectionTableEntry::Elf64SectionTableEntry_disk *disk);
		void *encode(SgAsmExecutableFileFormat::ByteOrder sex,
			SgAsmElfSectionTableEntry::Elf32SectionTableEntry_disk *disk) const;
		void *encode(SgAsmExecutableFileFormat::ByteOrder sex,
			SgAsmElfSectionTableEntry::Elf64SectionTableEntry_disk *disk) const;
		void update_from_section(SgAsmElfSection*);
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
	private:
		void ctor(SgAsmExecutableFileFormat::ByteOrder, const SgAsmElfSectionTableEntry::Elf32SectionTableEntry_disk*);
		void ctor(SgAsmExecutableFileFormat::ByteOrder, const SgAsmElfSectionTableEntry::Elf64SectionTableEntry_disk*);
		static const char *to_string(SectionType);
HEADER_ELF_SECTION_TABLE_ENTRY_END



HEADER_ELF_SECTION_START
	public:
		explicit SgAsmElfSection(SgAsmGenericHeader *fhdr); /*non-attached, not-parsed Elf section*/
		SgAsmElfSection *init_from_section_table(SgAsmElfSectionTableEntry*, SgAsmElfStringSection*, int id);
		SgAsmElfSection *init_from_segment_table(SgAsmElfSegmentTableEntry*, bool mmap_only=false);
		rose_addr_t calculate_sizes(size_t r32size, size_t r64size, const std::vector<size_t> &optsizes,
					    size_t *entsize, size_t *required, size_t *optional, size_t *entcount) const;
		virtual rose_addr_t calculate_sizes(size_t *entsize, size_t *required, size_t *optional, size_t *entcount) const;
		virtual bool reallocate();
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;

		/* Convenience functions */
		SgAsmElfFileHeader *get_elf_header() const;

		// DQ (8/22/2008): These are not automatically generated since one of them must be virtual.
		SgAsmElfSection* get_linked_section () const;
		virtual void set_linked_section(SgAsmElfSection*);
	private:
		void ctor();
HEADER_ELF_SECTION_END



HEADER_STORED_STRING_START
	public:
		SgAsmStoredString(SgAsmGenericStrtab *strtab, rose_addr_t offset)	/*string in string table*/
			{ctor(strtab, offset, false);}
		SgAsmStoredString(SgAsmGenericStrtab *strtab, const std::string &s)	/*new string in string table*/
			{ctor(strtab, s);}
		explicit SgAsmStoredString(class SgAsmStringStorage *storage)		/*string shares other storage*/
			{ctor(storage);}
		// virtual ~SgAsmStoredString();
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
		SgAsmGenericStrtab *get_strtab();					/*table holding the string*/

		// These are not access functions -- they do more than just getting or setting the value!
		virtual std::string get_string() const;
		virtual void set_string(const std::string&);				/*also deallocates previous value*/
		virtual rose_addr_t get_offset() const;					/*also triggers realloc*/
	private:
		// Maybe we need to supressed ROSETTA generated constructor!
		// SgAsmStoredString() {abort();}
		void ctor(class SgAsmGenericStrtab*, rose_addr_t offset, bool shared);
		void ctor(class SgAsmGenericStrtab*, const std::string&);
		void ctor(class SgAsmStringStorage*);
		void ctor(const std::string &s);

HEADER_STORED_STRING_END



HEADER_ELF_STRING_TABLE_START
	public:
		explicit SgAsmElfStrtab(class SgAsmElfSection *containing_section)
			: SgAsmGenericStrtab(containing_section)
			{ctor();}
		virtual ~SgAsmElfStrtab();
		virtual SgAsmElfStrtab *parse();
		virtual void unparse(std::ostream&) const;
		virtual SgAsmStringStorage *create_storage(addr_t offset, bool shared);
		virtual addr_t get_storage_size(const SgAsmStringStorage*);
		virtual void allocate_overlap(SgAsmStringStorage*);
	private:
		void ctor();
HEADER_ELF_STRING_TABLE_END



HEADER_ELF_STRING_SECTION_START
	public:
		explicit SgAsmElfStringSection(SgAsmElfFileHeader *fhdr);
		virtual SgAsmElfStringSection *parse();
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
		virtual void set_size(addr_t newsize);
		virtual bool reallocate();
		virtual void unparse(std::ostream&) const;
	private:
		void ctor();
		void ctor(SgAsmElfSectionTable*);
HEADER_ELF_STRING_SECTION_END



HEADER_ELF_RELA_SECTION_START
	public:
		explicit SgAsmElfRelaSection(SgAsmElfFileHeader *fhdr)
			: SgAsmElfSection(fhdr)
			{ctor();}
		using SgAsmElfSection::calculate_sizes;
		virtual SgAsmElfRelaSection *parse();
		virtual rose_addr_t calculate_sizes(size_t *total, size_t *required, size_t *optional, size_t *entcount) const;
		virtual void unparse(std::ostream&) const;
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
	private:
		void ctor();
HEADER_ELF_RELA_SECTION_END



HEADER_ELF_RELA_ENTRY_START
	public:
		struct Elf32RelaEntry_disk {
			uint32_t	r_offset;
			uint32_t	r_info;
			uint32_t	r_addend;
		} __attribute__((packed));
		struct Elf64RelaEntry_disk {
			uint64_t	r_offset;
			uint64_t	r_info;
			uint64_t	r_addend;
		} __attribute__((packed));

		SgAsmElfRelaEntry(SgAsmExecutableFileFormat::ByteOrder sex, const SgAsmElfRelaEntry::Elf32RelaEntry_disk *disk)
			: p_r_offset(0), p_r_addend(0), p_sym(0), p_type(0)
			{ctor(sex, disk);}
		SgAsmElfRelaEntry(SgAsmExecutableFileFormat::ByteOrder sex, const SgAsmElfRelaEntry::Elf64RelaEntry_disk *disk)
			: p_r_offset(0), p_r_addend(0), p_sym(0), p_type(0)
			{ctor(sex, disk);}
		//virtual ~SgAsmElfDynamicEntry() {}

		void *encode(SgAsmExecutableFileFormat::ByteOrder, SgAsmElfRelaEntry::Elf32RelaEntry_disk*) const;
		void *encode(SgAsmExecutableFileFormat::ByteOrder, SgAsmElfRelaEntry::Elf64RelaEntry_disk*) const;

		void dump(FILE *f, const char *prefix, ssize_t idx, SgAsmElfSymbolSection *symtab) const;
		virtual void dump(FILE *f, const char *prefix, ssize_t idx) const
			{dump(f, prefix, idx, NULL);}
	private:
		void ctor(SgAsmExecutableFileFormat::ByteOrder sex, const SgAsmElfRelaEntry::Elf32RelaEntry_disk *disk);
		void ctor(SgAsmExecutableFileFormat::ByteOrder sex, const SgAsmElfRelaEntry::Elf64RelaEntry_disk *disk);
HEADER_ELF_RELA_ENTRY_END



HEADER_ELF_DYNAMIC_SECTION_START
	public:
		explicit SgAsmElfDynamicSection(SgAsmElfFileHeader *fhdr)
			: SgAsmElfSection(fhdr)
			{ctor();}
		virtual SgAsmElfDynamicSection* parse();
		using SgAsmElfSection::calculate_sizes;
		virtual rose_addr_t calculate_sizes(size_t *total, size_t *required, size_t *optional, size_t *entcount) const;
		virtual void set_linked_section(SgAsmElfSection*);   /* Parsing happens here rather than in constructor */
		virtual bool reallocate();
		virtual void unparse(std::ostream&) const;
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
	private:
		void ctor();
HEADER_ELF_DYNAMIC_SECTION_END



HEADER_ELF_DYNAMIC_ENTRY_START
	public:
		enum EntryType {                /* Type    Executable SharedObj Purpose */
			DT_NULL     = 0,        /* ignored mandatory  mandatory Marks end of dynamic array */
			DT_NEEDED   = 1,      	/* value   optional   optional  Name of needed library */
			DT_PLTRELSZ = 2,    	/* value   optional   optional  Size of reloc entries associated with PLT */
			DT_PLTGOT   = 3,    	/* pointer optional   optional  PLT and/or GOT */
			DT_HASH     = 4,    	/* pointer mandatory  mandatory Symbol hash table */
			DT_STRTAB   = 5,    	/* pointer mandatory  mandatory String table for symbols, lib names, etc. */
			DT_SYMTAB   = 6,    	/* pointer mandatory  mandatory Symbol table */
			DT_RELA     = 7,    	/* pointer mandatory  optional  Relocation table */
			DT_RELASZ   = 8,    	/* value   mandatory  optional  Size of RELA relocation table */
			DT_RELAENT  = 9,    	/* value   mandatory  optional  Size of each RELA table entry */
			DT_STRSZ    = 10,   	/* value   mandatory  mandatory Size of string table */
			DT_SYMENT   = 11,   	/* value   mandatory  mandatory Size of symbol table entry */
			DT_INIT     = 12,   	/* pointer optional   optional  Initialization function */
			DT_FINI     = 13,   	/* pointer optional   optional  Termination function */
			DT_SONAME   = 14,   	/* value   ignored    optional  Name of shared object */
			DT_RPATH    = 15,   	/* value   optional   ignored   NUL-term library search path */
			DT_SYMBOLIC = 16,   	/* ignored ignored    optional  Bool determines dynamic linker symbol resolution */
			DT_REL      = 17,   	/* pointer mandatory  optional  Relocation table */
			DT_RELSZ    = 18,   	/* value   mandatory  optional  Size of REL relocation table */
			DT_RELENT   = 19,   	/* value   mandatory  optional  Size of each REL table entry */
			DT_PLTREL   = 20,   	/* value   optional   optional  Reloc type for PLT; value is DT_RELA or DT_REL */
			DT_DEBUG    = 21,   	/* pointer optional   ignored   Contents are not specified at ABI level */
			DT_TEXTREL  = 22,   	/* ignored optional   optional  presence => relocs to nonwritable segments OK */
			DT_JMPREL   = 23,   	/* pointer optional   optional  Addr of relocation entries for PLT */
			DT_BIND_NOW = 24,   	/* ignored optional   optional  Shall dynlinker do relocs before xfering control?*/
			DT_INIT_ARRAY = 25,     /* pointer optional   ?         Array with addresses of init fct */
			DT_FINI_ARRAY = 26,     /* pointer optional   ?         Array with address of fini fct */
			DT_INIT_ARRAYSZ = 27,   /* value   optional   ?         Size in bytes of DT_INIT_ARRAY */
			DT_FINI_ARRAYSZ = 28,   /* value   optional   ?         Size in bytes of DT_FINI_ARRAY */
			DT_RUNPATH  = 29,       /* ?       optional   ?         Library search path (how diff from DT_RPATH?) */
			DT_FLAGS    = 30,       /* value   optional   ?         Bit flags */
			DT_PREINIT_ARRAY = 32,  /* pointer optional   ?         Array with addrs of preinit fct (aka DT_ENCODING)*/
			DT_PREINIT_ARRAYSZ = 33,/* value   optional   ?         size in bytes of DT_PREINIT_ARRAY */
			DT_NUM      = 34,       /* ?       ?          ?         "number used"? */

			DT_GNU_PRELINKED =0x6ffffdf5,/*value ?          ?         Prelinking time stamp */
			DT_GNU_CONFLICTSZ=0x6ffffdf6,/*value ?          ?         Size of conflict section */
			DT_GNU_LIBLISTSZ=0x6ffffdf7,/*value  ?          ?         Size of library list */
			DT_CHECKSUM = 0x6ffffdf8, /* value   ?          ?         ? */
			DT_PLTPADSZ = 0x6ffffdf9, /* value   ?          ?         ? */
			DT_MOVEENT  = 0x6ffffdfa, /* value   ?          ?         ? */
			DT_MOVESZ   = 0x6ffffdfb, /* value   ?          ?         ? */
			DT_FEATURE_1= 0x6ffffdfc, /* value   ?          ?         Feature selection (DTF_*) */
			DT_POSFLAG_1= 0x6ffffdfd, /* value   ?          ?         Flag for DT_* entries affecting next entry */
			DT_SYMINSZ  = 0x6ffffdfe, /* value   ?          ?         Size of syminfo table in bytes */
			DT_SYMINENT = 0x6ffffdff, /* value   ?          ?         Size of each syminfo table entry */

			DT_GNU_HASH = 0x6ffffef5, /* pointer ?          ?         GNU-style hash table */
			DT_TLSDESC_PLT=0x6ffffef6,/* pointer ?          ?         ? */
			DT_TLSDESC_GOT=0x6ffffef7,/* pointer ?          ?         ? */
			DT_GNU_CONFLICT=0x6ffffef8,/*pointer ?          ?         Start of conflict section */
			DT_GNU_LIBLIST=0x6ffffef9,/* pointer ?          ?         Library list */
			DT_CONFIG   = 0x6ffffefa, /* pointer ?          ?         Configuration information */
			DT_DEPAUDIT = 0x6ffffefb, /* pointer ?          ?         Dependency auditing */
			DT_AUDIT    = 0x6ffffefc, /* pointer ?          ?         Object auditing */
			DT_PLTPAD   = 0x6ffffefd, /* pointer ?          ?         PLT padding */
			DT_MOVETAB  = 0x6ffffefe, /* pointer ?          ?         Move table */
			DT_SYMINFO  = 0x6ffffeff, /* pointer ?          ?         Syminfo table */

			DT_VERSYM   = 0x6ffffff0, /* pointer ?          ?         ? */
			DT_RELACOUNT= 0x6ffffff9, /* value   ?          ?         ? */
			DT_RELCOUNT = 0x6ffffffa, /* value   ?          ?         ? */
			DT_FLAGS_1  = 0x6ffffffb, /* value   ?          ?         Sun state flags */
			DT_VERDEF   = 0x6ffffffc, /* pointer ?          ?         Sun version definition table */
			DT_VERDEFNUM= 0x6ffffffd, /* value   ?          ?         Sun number of version definitions */
			DT_VERNEED  = 0x6ffffffe, /* pointer ?          ?         Sun needed versions table */
			DT_VERNEEDNUM=0x6fffffff, /* value   ?          ?         Sun number of needed versions */

			DT_AUXILIARY= 0x7ffffffd, /* pointer ?          ?         Sun shared obj to load before self */
			DT_FILTER   = 0x7fffffff, /* pointer ?          ?         Shared object ot get values from */
		};

		struct Elf32DynamicEntry_disk {
			uint32_t            d_tag;  /* Entry type, one of the DT_* constants */
			uint32_t            d_val;  /* Tag's value */
		} __attribute__((packed));

		struct Elf64DynamicEntry_disk {
			uint64_t            d_tag;  /* Entry type, one of the DT_* constants */
			uint64_t            d_val;  /* Tag's value */
		} __attribute__((packed));

		SgAsmElfDynamicEntry(SgAsmExecutableFileFormat::ByteOrder sex,
				     const SgAsmElfDynamicEntry::Elf32DynamicEntry_disk *disk)
			: p_d_tag(DT_NULL)
			{ctor(sex, disk);}
		SgAsmElfDynamicEntry(SgAsmExecutableFileFormat::ByteOrder sex,
			             const SgAsmElfDynamicEntry::Elf64DynamicEntry_disk *disk)
			: p_d_tag(DT_NULL)
			{ctor(sex, disk);}

		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
		void *encode(SgAsmExecutableFileFormat::ByteOrder, SgAsmElfDynamicEntry::Elf32DynamicEntry_disk*) const;
		void *encode(SgAsmExecutableFileFormat::ByteOrder, SgAsmElfDynamicEntry::Elf64DynamicEntry_disk*) const;
		const char *stringify_tag(EntryType) const;

		/*Override ROSETTA because set_name() needs to adjust parent pointer*/
		SgAsmGenericString *get_name() const {return p_name;}
		void set_name(SgAsmGenericString *name);

	private:
		void ctor(SgAsmExecutableFileFormat::ByteOrder sex, const SgAsmElfDynamicEntry::Elf32DynamicEntry_disk *disk);
		void ctor(SgAsmExecutableFileFormat::ByteOrder sex, const SgAsmElfDynamicEntry::Elf64DynamicEntry_disk *disk);
HEADER_ELF_DYNAMIC_ENTRY_END



HEADER_ELF_SEGMENT_TABLE_START
	public:
		SgAsmElfSegmentTable(SgAsmElfFileHeader *fhdr, rose_addr_t offset) /* Non-parsing constructor */
			: SgAsmGenericSection(fhdr->get_file(), fhdr, offset, 0)
			{ctor();}
		virtual SgAsmElfSegmentTable *parse();
		void add_section(SgAsmElfSection*);
		rose_addr_t calculate_sizes(size_t *entsize, size_t *required, size_t *optional, size_t *entcount) const;
		virtual bool reallocate();
		virtual void unparse(std::ostream&) const;
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
	private:
		void ctor();
HEADER_ELF_SEGMENT_TABLE_END



HEADER_ELF_SEGMENT_TABLE_ENTRY_START
	public:

		/* Segment types (host order). All other values are reserved. */
		enum SegmentType {
			PT_NULL         = 0,            /* entry is ignored; other values of entry are undefined */
			PT_LOAD         = 1,            /* loadable by mapping file contents into memory */
			PT_DYNAMIC      = 2,            /* dynamic linking information */
			PT_INTERP       = 3,            /* segment contains NUL-terminated path name of interpreter */
			PT_NOTE         = 4,            /* auxiliary information */
			PT_SHLIB        = 5,            /* Reserved w/unspecified semantics; such a file is nonconforming */
			PT_PHDR         = 6,            /* Segment contains the segment table itself (program header array) */

			/* OS- and Processor-specific ranges */
			PT_LOOS         = 0x60000000,   /* Values reserved for OS-specific semantics */
			PT_HIOS         = 0x6fffffff,
			PT_LOPROC       = 0x70000000,   /* Values reserved for processor-specific semantics */
			PT_HIPROC       = 0x7fffffff,

			/* OS-specific values for GNU/Linux */
			PT_GNU_EH_FRAME	= 0x6474e550,	/* GCC .eh_frame_hdr segment */
			PT_GNU_STACK    = 0x6474e551,   /* Indicates stack executability */
			PT_GNU_RELRO    = 0x6474e552,   /* Read-only after relocation */
			PT_PAX_FLAGS    = 0x65041580,   /* Indicates PaX flag markings */

			/* OS-specific values for Sun */
			PT_SUNWBSS      = 0x6ffffffa,   /* Sun Specific segment */
			PT_SUNWSTACK    = 0x6ffffffb    /* Stack segment */
		};

		/* Segment bit flags */
		enum SegmentFlags {
			PF_NONE		= 0,		/* Initial value in c'tor */
			PF_RESERVED     = 0x0ffffff8,   /* Reserved bits */
			PF_XPERM        = 0x00000001,   /* Execute permission */
			PF_WPERM        = 0x00000002,   /* Write permission */
			PF_RPERM        = 0x00000004,   /* Read permission */
			PF_PROC_MASK    = 0xf0000000    /* Processor-specific bits */
		};

		/* File format of an ELF Segment header. Byte order of members depends on e_ident value in file header. This code
		 * comes directly from "Executable and Linkable Format (ELF)", Portable Formats Specification, Version 1.1, Tool
		 * Interface Standards (TIS) and not from any header file. The 64-bit structure is gleaned from the Linux elf(5)
		 * man page. Segment table entries (a.k.a., ELF program headers) either describe process segments or give
		 * supplementary info which does not contribute to the process image. */
		struct Elf32SegmentTableEntry_disk {
			uint32_t	p_type;		/* 0x00 kind of segment */
			uint32_t        p_offset;       /* 0x04 file offset */
			uint32_t        p_vaddr;        /* 0x08 desired mapped address of segment */
			uint32_t        p_paddr;        /* 0x0c physical address where supported (unused by System V) */
			uint32_t        p_filesz;       /* 0x20 bytes in file (may be zero or other value smaller than p_memsz) */
			uint32_t        p_memsz;        /* 0x24 number of bytes when mapped (may be zero) */
			uint32_t        p_flags;	/* 0x28 */
			uint32_t        p_align;        /* 0x2c alignment for file and memory (0,1=>none); power of two */
		} __attribute__((packed));              /* 0x30 */

		struct Elf64SegmentTableEntry_disk {
			uint32_t        p_type;		/* 0x00 */
			uint32_t        p_flags;	/* 0x04 */
			uint64_t        p_offset;	/* 0x08 */
			uint64_t        p_vaddr;	/* 0x10 */
			uint64_t        p_paddr;	/* 0x18 */
			uint64_t        p_filesz;	/* 0x20 */
			uint64_t        p_memsz;	/* 0x28 */
			uint64_t        p_align;	/* 0x30 */
		} __attribute__((packed));		/* 0x38 */


		SgAsmElfSegmentTableEntry(SgAsmExecutableFileFormat::ByteOrder sex,
			const SgAsmElfSegmentTableEntry::Elf32SegmentTableEntry_disk *disk);
		SgAsmElfSegmentTableEntry(SgAsmExecutableFileFormat::ByteOrder sex,
			const SgAsmElfSegmentTableEntry::Elf64SegmentTableEntry_disk *disk);

		void *encode(SgAsmExecutableFileFormat::ByteOrder, SgAsmElfSegmentTableEntry::Elf32SegmentTableEntry_disk*) const;
		void *encode(SgAsmExecutableFileFormat::ByteOrder, SgAsmElfSegmentTableEntry::Elf64SegmentTableEntry_disk*) const;
		void update_from_section(SgAsmElfSection*);
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
		std::string stringifyType(SgAsmElfSegmentTableEntry::SegmentType  kind) const;

	private:
		void ctor(SgAsmExecutableFileFormat::ByteOrder, const SgAsmElfSegmentTableEntry::Elf32SegmentTableEntry_disk*);
		void ctor(SgAsmExecutableFileFormat::ByteOrder, const SgAsmElfSegmentTableEntry::Elf64SegmentTableEntry_disk*);
HEADER_ELF_SEGMENT_TABLE_ENTRY_END



HEADER_ELF_SEGMENT_TABLE_ENTRY_LIST_START
HEADER_ELF_SEGMENT_TABLE_ENTRY_LIST_END



HEADER_ELF_SYMBOL_SECTION_START
	public:
		explicit SgAsmElfSymbolSection(SgAsmElfFileHeader *fhdr)
			: SgAsmElfSection(fhdr)
			{ctor();}
		virtual SgAsmElfSymbolSection* parse();
		using SgAsmElfSection::calculate_sizes;
		virtual rose_addr_t calculate_sizes(size_t *total, size_t *required, size_t *optional, size_t *nentries) const;
		virtual void set_linked_section(SgAsmElfSection*);
		virtual bool reallocate();
		virtual void unparse(std::ostream&) const;
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
	private:
		void ctor();
HEADER_ELF_SYMBOL_SECTION_END



HEADER_ELF_SYMBOL_LIST_START
HEADER_ELF_SYMBOL_LIST_END

HEADER_ELF_SYMBOL_START
	public:
		enum ElfSymBinding {
			STB_LOCAL=0,
			STB_GLOBAL=1,
			STB_WEAK=2
		};

		enum ElfSymType {
			STT_NOTYPE  	= 0,	/* unspecified type */
			STT_OBJECT  	= 1,	/* data object */
			STT_FUNC    	= 2,	/* code object */
			STT_SECTION 	= 3,	/* associated with a section */
			STT_FILE    	= 4,	/* name of a file */
			STT_COMMON  	= 5,	/* common data object */
			STT_TLS		= 6	/* thread-local data object */
		};

		struct Elf32SymbolEntry_disk {
			uint32_t      st_name;  /* Name offset into string table */
			uint32_t      st_value; /* Value: absolute value, address, etc. depending on sym type */
			uint32_t      st_size;  /* Symbol size in bytes */
			unsigned char st_info;  /* Type and binding attributes */
			unsigned char st_res1;  /* Reserved; always zero */
			uint16_t      st_shndx; /* Section index or special meaning */
		} __attribute__((packed));

		struct Elf64SymbolEntry_disk {
			uint32_t      st_name;
			unsigned char st_info;
			unsigned char st_res1;
			uint16_t      st_shndx;
			uint64_t      st_value;
			uint64_t      st_size;
		} __attribute__((packed));

		SgAsmElfSymbol(SgAsmExecutableFileFormat::ByteOrder sex, const SgAsmElfSymbol::Elf32SymbolEntry_disk *disk);
		SgAsmElfSymbol(SgAsmExecutableFileFormat::ByteOrder sex, const SgAsmElfSymbol::Elf64SymbolEntry_disk *disk);
		//virtual ~SgAsmElfSymbol() {};

		void reallocate(SgAsmGenericStrtab*);
		void *encode(SgAsmExecutableFileFormat::ByteOrder, SgAsmElfSymbol::Elf32SymbolEntry_disk*,
			     SgAsmGenericStrtab*) const;
		void *encode(SgAsmExecutableFileFormat::ByteOrder, SgAsmElfSymbol::Elf64SymbolEntry_disk*,
			     SgAsmGenericStrtab*) const;
		virtual void dump(FILE *f, const char *prefix, ssize_t idx) const;
		void dump(FILE*, const char *prefix, ssize_t idx, SgAsmGenericSection*) const;
		SgAsmElfSymbol::ElfSymBinding get_elf_binding() const;
		SgAsmElfSymbol::ElfSymType get_elf_type() const;

	private:
		void ctor(SgAsmExecutableFileFormat::ByteOrder, const SgAsmElfSymbol::Elf32SymbolEntry_disk*);
		void ctor(SgAsmExecutableFileFormat::ByteOrder, const SgAsmElfSymbol::Elf64SymbolEntry_disk*);
		void ctor_common(); /* Initialization common to all constructors */
HEADER_ELF_SYMBOL_END





// ***********************************************
//          PE Binary File Format Support
// ***********************************************

HEADER_PE_RVA_SIZE_PAIR_START
     public:
       /* File format for an RVA/Size pair. Such pairs are considered to be part of the PE file header. All fields are little endian. */
          struct RVASizePair_disk
             {
               uint32_t    e_rva;
               uint32_t    e_size;
             } __attribute__((packed));

          explicit SgAsmPERVASizePair(const SgAsmPERVASizePair::RVASizePair_disk *disk);
          void *encode(SgAsmPERVASizePair::RVASizePair_disk *disk) const;

       // addr_t e_rva;
       // addr_t e_size;

HEADER_PE_RVA_SIZE_PAIR_END


HEADER_PE_RVA_SIZE_PAIR_LIST_START
HEADER_PE_RVA_SIZE_PAIR_LIST_END


HEADER_PE_FILE_HEADER_START
	public:
		/* File format of a PE File Header. All fields are little endian. */
		struct PEFileHeader_disk {
			unsigned char e_magic[4];	/* magic number "PE\0\0" */
			uint16_t    e_cpu_type;         /* e.g., 0x014c = Intel 386 */
			uint16_t    e_nsections;        /* number of sections defined in the Section Table */
			uint32_t    e_time;             /* time and date file was created or modified by the linker */
			uint32_t    e_coff_symtab;      /* offset to COFF symbol table */
			uint32_t    e_coff_nsyms;       /* number of symbols in COFF symbol table */
			uint16_t    e_nt_hdr_size;      /* num remaining bytes in the header following the 'flags' field */
			uint16_t    e_flags;            /* Bit flags: exe file, program/library image, fixed address, etc. */
		} __attribute__((packed));

		struct PE32OptHeader_disk {
			uint16_t    e_opt_magic;        /* magic number */
			uint16_t    e_lmajor;           /* linker version */
			uint16_t    e_lminor;
			uint16_t    e_code_size;        /* Size of .text or sum of all code sections */
			uint32_t    e_data_size;        /* Sum size of initialized data */
			uint32_t    e_bss_size;         /* Sum size of uninitialized data */
			uint32_t    e_entrypoint_rva;   /* RVA="relative virtual address"; relative to 'image_base', below */
			uint32_t    e_code_rva;         /* Address relative to image base for code section when memory mapped */
			uint32_t    e_data_rva;         /* Address relative to image base for data section */
			uint32_t    e_image_base;       /* Virtual base of image (first byte of file, DOS header). 64k aligned */
			uint32_t    e_section_align;    /* Alignment of sections in memory. Power of two 512<=x<=256M */
			uint32_t    e_file_align;       /* Alignment factor (in bytes) for image pages */
			uint16_t    e_os_major;         /* OS version number required to run this image */
			uint16_t    e_os_minor;
			uint16_t    e_user_major;       /* User-specified at link time for differentiating between image revs */
			uint16_t    e_user_minor;
			uint16_t    e_subsys_major;     /* Subsystem version number */
			uint16_t    e_subsys_minor;
			uint32_t    e_reserved9;
			uint32_t    e_image_size;       /* Virtual size (bytes) of the image inc. all headers; section_align */
			uint32_t    e_header_size;      /* Total header size (DOS Header + PE Header + Section table */
			uint32_t    e_file_checksum;    /* Checksum for entire file; Set to zero by the linker */
			uint16_t    e_subsystem;        /* Unknown, Native, WindowsGUI, WindowsCharacter, OS/2 Character, etc. */
			uint16_t    e_dll_flags;        /* Bit flags for library init/terminate per process or thread */
			uint32_t    e_stack_reserve_size;/* Virtual memory reserved for stack; non-committed pages are guards */
			uint32_t    e_stack_commit_size;/* Size of valid stack; other pages are guards; <= 'stack_reserve_size' */
			uint32_t    e_heap_reserve_size;/* Size (bytes) of local heap to reserve */
			uint32_t    e_heap_commit_size; /* Size (bytes) of valid local heap */
			uint32_t    e_loader_flags;     /* Reserved, must be zero */
			uint32_t    e_num_rvasize_pairs;/* Number of RVASizePair entries that follow this member; part of header */
		} __attribute__((packed));

		struct PE64OptHeader_disk {
			uint16_t    e_opt_magic;
			uint16_t    e_lmajor;
			uint16_t    e_lminor;
			uint16_t    e_code_size;
			uint32_t    e_data_size;
			uint32_t    e_bss_size;
			uint32_t    e_entrypoint_rva;
			uint32_t    e_code_rva;
			// uint32_t  e_data_rva;             /* Not present in PE32+ */
			uint64_t    e_image_base;
			uint32_t    e_section_align;
			uint32_t    e_file_align;
			uint16_t    e_os_major;
			uint16_t    e_os_minor;
			uint16_t    e_user_major;
			uint16_t    e_user_minor;
			uint16_t    e_subsys_major;
			uint16_t    e_subsys_minor;
			uint32_t    e_reserved9;
			uint32_t    e_image_size;
			uint32_t    e_header_size;
			uint32_t    e_file_checksum;
			uint16_t    e_subsystem;
			uint16_t    e_dll_flags;
			uint64_t    e_stack_reserve_size;
			uint64_t    e_stack_commit_size;
			uint64_t    e_heap_reserve_size;
			uint64_t    e_heap_commit_size;
			uint32_t    e_loader_flags;
			uint32_t    e_num_rvasize_pairs;
		} __attribute__((packed));

		/* Bit flags for the PE header 'flags' member */
		enum HeaderFlags {
			HF_PROGRAM          = 0x0000,       /* Program image (no non-reserved bits set) */
			HF_EXECUTABLE       = 0x0002,       /* Clear indicates can't load: link errors or incrementally linked */
			HF_FIXED            = 0x0200,       /* Image *must* be loaded at image_base address or error */
			HF_LIBRARY          = 0x2000,       /* Library image */
			HF_RESERVED_MASK    = 0xddfd        /* Reserved bits */
		};

		/* Values for the PE header 'subsystem' member */
		enum Subsystem {
			HF_SPEC_UNKNOWN     = 0x0000,       /* Specified as 'unknown' in the file */
			HF_NATIVE           = 0x0001,       /* Native */
			HF_WINGUI           = 0x0002,       /* Windows GUI */
			HF_WINCHAR          = 0x0003,       /* Windows character */
			HF_OS2CHAR          = 0x0005,       /* OS/2 character */
			HF_POSIX            = 0x0007        /* POSIX character */
		};

		/* Bit flags for the PE header 'dll_flags' member */
		enum DLLFlags {
			DLL_PROC_INIT       = 0x0001,       /* Per-process library initialization */
			DLL_PROC_TERM       = 0x0002,       /* Per-process library termination */
			DLL_THRD_INIT       = 0x0004,       /* Per-thread library initialization */
			DLL_THRD_TERM       = 0x0008,       /* Per-thread library termination */
			DLL_RESERVED_MASK   = 0xfff0        /* Reserved bits */
		};

	public:
		explicit SgAsmPEFileHeader(SgAsmGenericFile *f)
			: SgAsmGenericHeader(f, 0, sizeof(SgAsmPEFileHeader::PEFileHeader_disk)),
			  p_dos2_header(NULL), p_section_table(NULL), p_coff_symtab(NULL)
			{ctor();}
		virtual ~SgAsmPEFileHeader();

		virtual const char *format_name() const {return "PE";}
		static bool is_PE (SgAsmGenericFile*);
		static SgAsmPEFileHeader *parsePEFile(SgAsmGenericFile*);
		void add_rvasize_pairs();

		virtual SgAsmPEFileHeader *parse();
		virtual bool reallocate();
		virtual void unparse(std::ostream&) const;
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
		void create_table_sections();

	private:
		void ctor();
		void *encode(SgAsmPEFileHeader::PEFileHeader_disk*) const;
		void *encode(SgAsmPEFileHeader::PE32OptHeader_disk*) const;
		void *encode(SgAsmPEFileHeader::PE64OptHeader_disk*) const;
HEADER_PE_FILE_HEADER_END



HEADER_PE_SECTION_START
	public:
		explicit SgAsmPESection(SgAsmPEFileHeader *fhdr)
			: SgAsmGenericSection(fhdr->get_file(), fhdr, 0, 1), p_st_entry(NULL)
			{}
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
HEADER_PE_SECTION_END



HEADER_PE_IMPORT_DIRECTORY_START
	public:
		struct PEImportDirectory_disk {
			uint32_t ilt_rva;		/* 0x00 Import Lookup Table RVA */
			uint32_t time;			/* 0x04 Zero until the image is bound, then time stamp of the DLL */
			uint32_t forwarder_chain;	/* 0x08 Index of the first forwarder chain */
			uint32_t dll_name_rva;    	/* 0x0c address of NUL-terminated DLL name */
			uint32_t iat_rva;		/* 0x10 Import Address Table (Thunk Table) RVA */
		} __attribute__((packed));		/* 0x14 */

		SgAsmPEImportDirectory(SgAsmPEImportSection *isec, size_t idx)
			{ctor(isec,idx);}
		void *encode(SgAsmPEImportDirectory::PEImportDirectory_disk*) const;
		virtual void unparse(std::ostream&, const SgAsmPEImportSection*) const;
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
	private:
		void ctor(SgAsmPEImportSection*, size_t idx);
HEADER_PE_IMPORT_DIRECTORY_END



HEADER_PE_IMPORT_ILT_ENTRY_START
	// PE -> Import Table -> Import Lookup Table -> Entry
	public:
		enum ILTEntryType {
			ILT_ORDINAL,			/* Entry is an ordinal */
			ILT_HNT_ENTRY_RVA,		/* Entry is the RVA of a Hint/Name Pair in the Hint/Name Table */
			ILT_BOUND_RVA,			/* Entry is the actual memory address of the symbol */
		};

		SgAsmPEImportILTEntry(SgAsmPEImportSection *isec, uint64_t entry_word)
			{ctor(isec,entry_word);}
		uint64_t encode(const SgAsmPEFileHeader*) const;
		void unparse(std::ostream&, const SgAsmPEFileHeader *fhdr, rva_t rva, size_t idx) const;
		virtual void dump(FILE *f, const char *prefix, ssize_t idx) const;
	private:
		void ctor(SgAsmPEImportSection*, uint64_t);
HEADER_PE_IMPORT_ILT_ENTRY_END



HEADER_PE_IMPORT_LOOKUP_TABLE_START
	// PE -> Import Table -> Import Lookup Table   or
	// PE -> Import Table -> Import Address Table
	public:
		SgAsmPEImportLookupTable(SgAsmPEImportSection *isec, rose_rva_t table_rva, size_t idir_idx, bool is_iat=false)
			: p_entries(NULL)
			{ctor(isec, table_rva, idir_idx, is_iat);}
		void add_ilt_entry(SgAsmPEImportILTEntry*);
		virtual void unparse(std::ostream&, const SgAsmPEFileHeader*, rose_rva_t) const;
		virtual void dump(FILE *f, const char *prefix, ssize_t idx) const;
	private:
		void ctor(SgAsmPEImportSection*, rose_rva_t table_rva, size_t idir_idx, bool is_iat);
HEADER_PE_IMPORT_LOOKUP_TABLE_END



HEADER_PE_IMPORT_HNT_ENTRY_START
	// PE -> Import Table -> Hint/Name Table -> Entry
	public:
		explicit SgAsmPEImportHNTEntry(rose_rva_t offset)
			{ctor(offset);}
		void unparse(std::ostream&, rva_t rva) const;
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
	private:
		void ctor(rose_rva_t offset);
HEADER_PE_IMPORT_HNT_ENTRY_END



HEADER_PE_IMPORT_SECTION_START
	public:
		explicit SgAsmPEImportSection(SgAsmPEFileHeader *fhdr)
			: SgAsmPESection(fhdr)
			{ctor();}
		SgAsmPEImportSection *parse();
		virtual void unparse(std::ostream&) const;
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
		void add_import_directory(SgAsmPEImportDirectory*);
	private:
		void ctor();
HEADER_PE_IMPORT_SECTION_END



HEADER_PE_EXPORT_DIRECTORY_START
	public:
		/* An Export Section begins with the Export Directory */
		struct PEExportDirectory_disk {
			uint32_t res1;         /* 0x00 Reserved, must be zero */
			uint32_t timestamp;    /* 0x04 Time that export data was created */
			uint16_t vmajor;       /* 0x08 Major version number (user defined) */
			uint16_t vminor;       /* 0x0a Minor version number (user defined) */
			uint32_t name_rva;     /* 0x0c Location of name of DLL */
			uint32_t ord_base;     /* 0x10 Starting ordinal for exports in this image (usually 1) */
			uint32_t expaddr_n;    /* 0x14 Number of entries in the export address table */
			uint32_t nameptr_n;    /* 0x18 Number of entries in the name pointer table and ordinal table */
			uint32_t expaddr_rva;  /* 0x1c Location of Export Address Table */
			uint32_t nameptr_rva;  /* 0x20 Location of Export Name Pointer Table */
			uint32_t ordinals_rva; /* 0x24 Location of Ordinal Table */
		} __attribute__((packed));     /* 0x28 */

		explicit SgAsmPEExportDirectory(SgAsmPEExportSection *s)
			{ctor(s);}
		void dump(FILE *f, const char *prefix, ssize_t idx) const;
	private:
		void ctor(SgAsmPEExportSection*);
HEADER_PE_EXPORT_DIRECTORY_END



HEADER_PE_EXPORT_ENTRY_START
	public:
		SgAsmPEExportEntry(SgAsmGenericString *name, unsigned ordinal, rose_rva_t export_rva,
				   SgAsmGenericString *forwarder)
			{ctor(name, ordinal, export_rva, forwarder);}

		void dump(FILE *f,const char *prefix,ssize_t idx) const;

		/* Accessors. Override ROSETTA because we adjust parents. */
		SgAsmGenericString *get_name() const {return p_name;}
		void set_name(SgAsmGenericString*);
		SgAsmGenericString *get_forwarder() const {return p_forwarder;}
		void set_forwarder(SgAsmGenericString*);
	private:
		void ctor(SgAsmGenericString *name, unsigned ordinal, rose_rva_t export_rva, SgAsmGenericString *forwarder);
HEADER_PE_EXPORT_ENTRY_END




HEADER_PE_EXPORT_SECTION_START
	public:
		/* The PE Export Address Table is an array of expaddr_n 4-byte RVAs. If the address is not in the export section
		 * (as defined by the address and length that are indicated in the NT Optional Header) then the RVA is an actual
		 * address in code or data. Otherwise its a Forwarder RVA that names a symbol in another DLL. */
		typedef uint32_t ExportAddress_disk;

		/* The PE Export Name Pointer Table is an array of nameptr_n 4-byte RVAs pointing into the Export Name Table. The
		 * pointers are ordered lexically to allow binary searches.  An export name is defined only if the export name
		 * pointer table contains a pointer to it. */
		typedef uint32_t ExportNamePtr_disk;

		/* The PE Export Ordinal Table is an array of nameptr_n (yes) 2-byte indices into the Export Address Table biased
		 * by ord_base. In other words, the ord_base must be subtracted from the ordinals to obtain true indices into the
		 * Export Address Table. */
		typedef uint16_t ExportOrdinal_disk;

		SgAsmPEExportSection(SgAsmPEFileHeader *fhdr)
			: SgAsmPESection(fhdr)
			{ctor();}
		SgAsmPEExportSection *parse();
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
		void add_entry(SgAsmPEExportEntry*);
	private:
		void ctor();
HEADER_PE_EXPORT_SECTION_END



HEADER_PE_SECTION_TABLE_START
	public:
		explicit SgAsmPESectionTable(SgAsmPEFileHeader *fhdr)
			: SgAsmGenericSection(fhdr->get_file(), fhdr, 0, 1)
			{ctor();}
		SgAsmPESectionTable* parse();
		virtual void unparse(std::ostream&) const;
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
	private:
		void ctor();
HEADER_PE_SECTION_TABLE_END



HEADER_PE_COFF_SYMBOL_TABLE_START
	public:
		explicit SgAsmCoffSymbolTable(SgAsmPEFileHeader *fhdr);
		size_t get_nslots() const;
		virtual void unparse(std::ostream&) const;
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
	private:
		void ctor();
HEADER_PE_COFF_SYMBOL_TABLE_END



HEADER_PE_SECTION_TABLE_ENTRY_START

     public:
       /* File format of a section table entry. All fields are little endian. Sections are ordered by RVA. */
          struct PESectionTableEntry_disk {
               char        name[8];                /* NUL-padded */
               uint32_t    virtual_size;           /* virtual memory size (bytes), >= physical_size and difference is zero filled */
               uint32_t    rva;                    /* relative virtual address wrt Image Base; multiple of section_align; dense space */
               uint32_t    physical_size;          /* bytes of initialized data on disk; multiple of file_align & <= virtual_size */
               uint32_t    physical_offset;        /* location of initialized data on disk; multiple of file_align */
               uint32_t    coff_line_nums;         /* file offset of COFF line number info or zero */
               uint32_t    n_relocs;               /* number of relocation entries; should be zero for executables */
               uint32_t    n_coff_line_nums;       /* number of COFF line number entries */
               uint32_t    flags;                  /* PESectionFlags bits: code, data, caching, paging, shared, permissions, etc. */
             } __attribute__((packed));

       /* These come from the windows PE documentation and http://en.wikibooks.org/wiki/X86_Disassembly/Windows_Executable_Files */
          enum PESectionFlags {
               OF_CODE             = 0x00000020,   /* section contains code */
               OF_IDATA            = 0x00000040,   /* initialized data */
               OF_UDATA            = 0x00000080,   /* uninitialized data */
               OF_INFO             = 0x00000200,   /* comments or some other type of info */
               OF_REMOVE           = 0x00000800,   /* section will not become part of image */
               OF_COMDAT           = 0x00001000,   /* section contains comdat */
               OF_NO_DEFER_SPEC_EXC= 0x00004000,   /* reset speculative exception handling bits in the TLB entires for this section */
               OF_GPREL            = 0x00008000,   /* section content can be access relative to GP */
               OF_ALIGN_1          = 0x00100000,   /* no alignment */
               OF_ALIGN_2          = 0x00200000,   /* 2-byte alignment */
               OF_ALIGN_4          = 0x00300000,   /* 4-byte alignment */
               OF_ALIGN_8          = 0x00400000,   /* 8-byte alignment */
               OF_ALIGN_16         = 0x00500000,   /* 16-byte alignment (default if not other alignment specified) */
               OF_ALIGN_32         = 0x00600000,   /* 32-byte alignment */
               OF_ALIGN_64         = 0x00700000,   /* 64-byte alignment */
               OF_ALIGN_128        = 0x00800000,   /* 128-byte alignment */
               OF_ALIGN_256        = 0x00900000,   /* 256-byte alignment */
               OF_ALIGN_512        = 0x00a00000,   /* 512-byte alignment */
               OF_ALIGN_1k         = 0x00b00000,   /* 1024-byte alignment */
               OF_ALIGN_2k         = 0x00c00000,   /* 2048-byte alignment */
               OF_ALIGN_4k         = 0x00d00000,   /* 4096-byte alignment */
               OF_ALIGN_8k         = 0x00e00000,   /* 8192-byte alignment */
               OF_ALIGN_MASK       = 0x00f00000,   /* mask for alignment value */
               OF_NRELOC_OVFL      = 0x01000000,   /* section contains extended relocations */
               OF_DISCARDABLE      = 0x02000000,   /* can be discarded */
               OF_NO_CACHE         = 0x04000000,   /* section must not be cached */
               OF_NO_PAGING        = 0x08000000,   /* section is not pageable */
               OF_SHARED           = 0x10000000,   /* section is shared */
               OF_EXECUTABLE       = 0x20000000,   /* execute permission */
               OF_READABLE         = 0x40000000,   /* read permission */
               OF_WRITABLE         = 0x80000000,   /* write permission */
             };

          explicit SgAsmPESectionTableEntry(const SgAsmPESectionTableEntry::PESectionTableEntry_disk *disk);
       // virtual ~SgAsmPESectionTableEntry() {};

          void *encode(SgAsmPESectionTableEntry::PESectionTableEntry_disk*) const;
          virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
    
       /* These are the native-format versions of the same members described in the PESectionTableEntry_disk struct. */
       // std::string name;
       // addr_t      virtual_size, rva, physical_size, physical_offset;
       // unsigned    coff_line_nums, n_relocs, n_coff_line_nums, flags;

     private:
          void ctor(const SgAsmPESectionTableEntry::PESectionTableEntry_disk*);

HEADER_PE_SECTION_TABLE_ENTRY_END



HEADER_PE_COFF_SYMBOL_LIST_START
HEADER_PE_COFF_SYMBOL_LIST_END

HEADER_PE_COFF_SYMBOL_START
     public:

       // This was previously a #define macro in ExecPE.h (so we have to avoid the macro defining it as "static const unsigned int 18 = 18"
          static const unsigned int COFFSymbol_disk_size = 18;

          struct COFFSymbol_disk {
               union {
                   char            st_name[8];
                   struct {
                       uint32_t    st_zero;
                       uint32_t    st_offset;
                   };
               };
               uint32_t            st_value;
               int16_t             st_section_num;
               uint16_t            st_type;
               unsigned char       st_storage_class;
               unsigned char       st_num_aux_entries;
             } __attribute__((packed));

          SgAsmCoffSymbol(SgAsmPEFileHeader *fhdr, SgAsmGenericSection *symtab, SgAsmGenericSection *strtab, size_t idx);
       // virtual ~COFFSymbol() {}
          void *encode(SgAsmCoffSymbol::COFFSymbol_disk*) const;
          virtual void dump(FILE *f, const char *prefix, ssize_t idx) const;

       /* Auxilliary data for the symbol */
       // const unsigned char *get_aux_data() {return aux_data;}
       // size_t get_aux_size() {return aux_size;}

       /* Native versions of the COFFSymbol_disk members */
       // std::string         st_name;        /* The original name; super.name might be modified */
       // addr_t              st_name_offset;
       // int                 st_section_num;
       // unsigned            st_type, st_storage_class, st_num_aux_entries;
    
     private:
          void ctor(SgAsmPEFileHeader*, SgAsmGenericSection *symtab, SgAsmGenericSection *strtab, size_t idx);
       // const unsigned char *aux_data;      /* Auxilliary data from table entries that follow */
       // size_t              aux_size;       /* Size (bytes) of auxilliary data */

HEADER_PE_COFF_SYMBOL_END

HEADER_COFF_STRING_TABLE_START
	public:
		explicit SgAsmCoffStrtab(class SgAsmPESection *containing_section)
			: SgAsmGenericStrtab(containing_section)
			{}
		virtual ~SgAsmCoffStrtab();
		virtual void unparse(std::ostream&) const;
		virtual SgAsmStringStorage *create_storage(addr_t offset, bool shared);
		virtual addr_t get_storage_size(const SgAsmStringStorage*);
HEADER_COFF_STRING_TABLE_END

HEADER_PE_STRING_SECTION_START
	public:
		SgAsmPEStringSection(SgAsmPEFileHeader *fhdr, addr_t offset, addr_t size)
			: SgAsmPESection(fhdr), p_strtab(NULL)
			{set_offset(offset), set_size(size), ctor();}
		virtual ~SgAsmPEStringSection() {}
		virtual bool reallocate();
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
		virtual void set_size(addr_t newsize);
	        virtual void unparse(std::ostream&) const;
	private:
		void ctor();
HEADER_PE_STRING_SECTION_END

// ***********************************************
//          NE Binary File Format Support
// ***********************************************

HEADER_NE_FILE_HEADER_START

     public:
       // Overloaded base class virtual function
          const char *format_name() const;

          static bool is_NE (SgAsmGenericFile*);
          static SgAsmNEFileHeader *parse(SgAsmGenericFile*);

          /* File format of an NE File Header. All fields are little endian.
           *
           * NOTES
           * 
           * e_sssp: The value specified in SS is an index (1-origin) into the segment table. If SS addresses the automatic data segment
           *         and SP is zero then SP is set to the address obtained by adding the size of the automatic data segment to the size
           *         of the stack. */
          struct NEFileHeader_disk {
               unsigned char e_magic[2];           /* 0x00 magic number "NE" */
               unsigned char e_linker_major;       /* 0x02 linker major version number */
               unsigned char e_linker_minor;       /* 0x03 linker minor version number */
               uint16_t    e_entrytab_rfo;         /* 0x04 entry table offset relative to start of header */
               uint16_t    e_entrytab_size;        /* 0x06 size of entry table in bytes */
               uint32_t    e_checksum;             /* 0x08 32-bit CRC of entire file (this word is taken a zero during the calculation) */
               uint16_t    e_flags1;               /* 0x0c file-level bit flags (see HeaderFlags1) */
               uint16_t    e_autodata_sn;          /* 0x0e auto data section number if (flags & 0x3)==0; else zero */
               uint16_t    e_bss_size;             /* 0x10 num bytes added to data segment for BSS */
               uint16_t    e_stack_size;           /* 0x12 num bytes added to data segment for stack (zero of SS!=DS registers) */
               uint32_t    e_csip;                 /* 0x14 section number:offset of CS:IP */
               uint32_t    e_sssp;                 /* 0x18 section number:offset of SS:SP (see note 1 above) */
               uint16_t    e_nsections;            /* 0x1c number of entries in the section table */
               uint16_t    e_nmodrefs;             /* 0x1e number of entries in the module reference table */
               uint16_t    e_nnonresnames;         /* 0x20 number of entries in the non-resident name table */
               uint16_t    e_sectab_rfo;           /* 0x22 offset of section table relative to start of header */
               uint16_t    e_rsrctab_rfo;          /* 0x24 offset of resource table relative to start of header */
               uint16_t    e_resnametab_rfo;       /* 0x26 offset of resident name table relative to start of header */
               uint16_t    e_modreftab_rfo;        /* 0x28 offset of module reference table relative to start of header */
               uint16_t    e_importnametab_rfo;    /* 0x2a offset of imported names table relative to start of header */
               uint32_t    e_nonresnametab_offset; /* 0x2c file offset of non-resident name table */
               uint16_t    e_nmovable_entries;     /* 0x30 number of movable entries in Entry Table */
               uint16_t    e_sector_align;         /* 0x32 sector alignment shift count (log2 of segment sector size) */
               uint16_t    e_nresources;           /* 0x34 number of resource entries */
               unsigned char e_exetype;            /* 0x36 executable type (2==windows) */
               unsigned char e_flags2;             /* 0x37 additional flags (see HeaderFlags2) */
               uint16_t    e_fastload_sector;      /* 0x38 sector offset to fast-load area (only for Windows) */
               uint16_t    e_fastload_nsectors;    /* 0x3a size of fast-load area in sectors (only for Windows) */
               uint16_t    e_res1;                 /* 0x3c reserved */
               uint16_t    e_winvers;              /* 0x3e expected version number for Windows (only for Windows) */
             } __attribute__((packed));              /* 0x40 */

          /* Bit flags for the NE header 'e_flags' member.
           *
           * If HF_LIBRARY (bit 15) is set then the CS:IP registers point to an initialization procedure called with the value in the AX
           * register equal to the module handle. The initialization procedure must execute a far return to the caller. The resulting
           * value in AX is a status indicator (non-zero for success, zero for failure). */
          enum HeaderFlags1 {
               HF1_RESERVED         = 0x57f4,      /* Reserved bits */
               HF1_NO_DATA          = 0x0000,      /* (flags&0x03==0) => an exe not containing a data segment */
               HF1_SINGLE_DATA      = 0x0001,      /* Executable contains one data segment; set if file is a DLL */
               HF1_MULTIPLE_DATA    = 0x0002,      /* Exe with multiple data segments; set if a windows application */
               HF1_LOADER_SEGMENT   = 0x0800,      /* First segment contains code that loads the application */
               HF1_FATAL_ERRORS     = 0x2000,      /* Errors detected at link time; module will not load */
               HF1_LIBRARY          = 0x8000,      /* Module is a library */
             };

          /* Bit flags for the NE header 'e_flags2' member. */
          enum HeaderFlags2 {
               HF2_RESERVED         = 0xf1,        /* Reserved bits */
               HF2_PROTECTED_MODE   = 0x02,        /* Windows 2.x application that runs in 3.x protected mode */
               HF2_PFONTS           = 0x04,        /* Windows 2.x application that supports proportional fonts */
               HF2_FASTLOAD         = 0x08         /* Executable contains a fast-load area */
             };

          SgAsmNEFileHeader(SgAsmGenericFile *f, addr_t offset);
       // virtual ~NEFileHeader() {}

          virtual void unparse(std::ostream&) const;
       // virtual const char *format_name() const {return "NE";}
          virtual void dump(FILE*, const char *prefix, ssize_t idx) const;

     private:
          void ctor(SgAsmGenericFile *f, addr_t offset);
          void *encode(SgAsmNEFileHeader::NEFileHeader_disk*) const;
HEADER_NE_FILE_HEADER_END

HEADER_NE_SECTION_START
     public:
          SgAsmNESection(SgAsmNEFileHeader*, addr_t offset, addr_t size);
       // virtual ~NESection() {}

          virtual void unparse(std::ostream&) const;
          virtual void dump(FILE*, const char *prefix, ssize_t idx) const;

       /* Accessors for protected/private data */
       // NESectionTableEntry *get_st_entry() {return st_entry;}
       // void set_st_entry(NESectionTableEntry *e) {st_entry=e;}
       // NERelocTable *get_reloc_table() {return reloc_table;}
       // void set_reloc_table(NERelocTable *t) {reloc_table=t;}
  // private:
       // NESectionTableEntry *st_entry;
       // NERelocTable *reloc_table;

HEADER_NE_SECTION_END

HEADER_NE_SECTION_TABLE_START
     public:
          explicit SgAsmNESectionTable(SgAsmNEFileHeader *fhdr);
       // virtual ~NESectionTable() {}

          virtual void unparse(std::ostream&) const;
          virtual void dump(FILE*, const char *prefix, ssize_t idx) const;

     private:
          void ctor();

HEADER_NE_SECTION_TABLE_END

HEADER_NE_NAME_TABLE_START
     public:
          SgAsmNENameTable(SgAsmNEFileHeader *fhdr, addr_t offset);
       // virtual ~NENameTable() {}

          virtual void unparse(std::ostream&) const;
          virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
          std::vector<std::string> get_names_by_ordinal(unsigned ordinal);

     private:
          void ctor();
       // std::vector<std::string> names; /*first name is module name; remainder are symbols within the module*/
       // std::vector<unsigned> ordinals; /*first entry is ignored but present in file*/

HEADER_NE_NAME_TABLE_END

HEADER_NE_MODULE_TABLE_START
     public:
          SgAsmNEModuleTable(SgAsmNEFileHeader *fhdr, addr_t offset, addr_t size, SgAsmNEStringTable *strtab);
       // virtual ~NEModuleTable() {}

          virtual void unparse(std::ostream&) const;
          virtual void dump(FILE*, const char *prefix, ssize_t idx) const;

     private:
          void ctor();

       // NEStringTable *strtab;

HEADER_NE_MODULE_TABLE_END

HEADER_NE_STRING_TABLE_START
     public:
          SgAsmNEStringTable(SgAsmNEFileHeader *fhdr, addr_t offset, addr_t length);
       // virtual ~NEStringTable() {}

       // virtual void unparse(std::ostream&); /*not needed; use parent's implementation*/

          virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
          std::string get_string(addr_t offset);

     private:
          void ctor();

HEADER_NE_STRING_TABLE_END

HEADER_NE_ENTRY_TABLE_START
     public:
          SgAsmNEEntryTable(SgAsmNEFileHeader *fhdr, addr_t offset, addr_t size);
       // virtual ~NEEntryTable() {}

          void populate_entries();
          virtual void unparse(std::ostream&) const;
          virtual void dump(FILE*, const char *prefix, ssize_t idx) const;

     private:
          void ctor();

       // std::vector<size_t> bundle_sizes;
       // std::vector<NEEntryPoint> entries;

HEADER_NE_ENTRY_TABLE_END

HEADER_NE_RELOC_TABLE_START
     public:
          SgAsmNERelocTable(SgAsmNEFileHeader *fhdr, addr_t offset);
       // virtual ~NERelocTable() {}

          virtual void unparse(std::ostream&) const;
          virtual void dump(FILE*, const char *prefix, ssize_t idx) const;

     private:
          void ctor();

       // std::vector<NERelocEntry> entries;

HEADER_NE_RELOC_TABLE_END



HEADER_NE_ENTRY_POINT_START
          enum NEEntryFlags {
	       EF_ZERO		   = 0x00, /* No flags set */
               EF_RESERVED         = 0xfc, /* Reserved bits */
               EF_EXPORTED         = 0x01, /* Exported */
               EF_GLOBAL           = 0x02  /* Uses a global (shared) data section */
             };

       // SgAsmNEEntryPoint();
          SgAsmNEEntryPoint(SgAsmNEEntryPoint::NEEntryFlags flags, unsigned int3f, unsigned s_idx, unsigned s_off);

          void dump(FILE*, const char *prefix, ssize_t idx) const;

       // NEEntryFlags flags;         /* bit flags */
       // unsigned int3f;             /* always 0x3fxx */
       // unsigned section_idx;       /* zero indicates unused entry */
       // unsigned section_offset;    /* byte offset into section */

HEADER_NE_ENTRY_POINT_END

HEADER_NE_RELOC_ENTRY_START

     public:

       /* NERelocEntry_disk -- variable size with multiple levels of 'union'. It's easier to just parse it in NERelocEntry::ctor()
        * than defining it here as a struct. */

          enum NERelocSrcType {
               RF_SRCTYPE_8OFF     = 0,            /* Byte offset */
               RF_SRCTYPE_WORDSEG  = 2,            /* Word segment, 16-bit selector */
               RF_SRCTYPE_16PTR    = 3,            /* 16-bit far pointer */
               RF_SRCTYPE_16OFF    = 5,            /* 16-bit offset */
               RF_SRCTYPE_32PTR    = 6,            /* 32-bit far pointer */
               RF_SRCTYPE_32OFF    = 7,            /* 32-bit offset */
               RF_SRCTYPE_NEARCALL = 8,            /* near call or jump, WORD/DWROD based on section attribute */
               RF_SRCTYPE_48PTR    = 11,           /* 48-bit pointer */
               RF_SRCTYPE_32OFF_b  = 13            /* 32-bit offset (not sure how this differs from case 7) */
             };

          enum NERelocTgtType {
               RF_TGTTYPE_IREF     = 0,            /* Internal reference */
               RF_TGTTYPE_IORD     = 1,            /* Imported (extern) ordinal */
               RF_TGTTYPE_INAME    = 2,            /* Imported (extern) name */
               RF_TGTTYPE_OSFIXUP  = 3             /* Operating system fixup */ 
             };

          enum NERelocModifiers {
               RF_MODIFIER_SINGLE  = 1,
               RF_MODIFIER_MULTI   = 3
             };

          enum NERelocFlags {
               RF_ADDITIVE         = 0x01,         /* add target to source rather than replace source with target */
               RF_RESERVED         = 0x02,         /* reserved bits */
               RF_2EXTRA           = 0x04,         /* relocation info has size with new two bytes at end */
               RF_32ADD            = 0x08,         /* addition with 32-bits rather than 16 */
               RF_16SECTION        = 0x10,         /* 16-bit object number & module name rather than 8-bit */
               RF_8ORDINAL         = 0x20,         /* Ordinal is 8-bits rather than 16 */
             };

       // DQ (8/7/2008): At only (I hope) the risk of using more memory that required, break the union so that we can better support 
       // this in ROSETTA. One solution might be to implement a common base class of unsigned, unsigned, addr_t; and then use member 
       // functions to access the data in the base class.
          struct iref_type
             { /*tgt_type==0x00: internal reference*/
               unsigned    sect_idx;       /* section index (1-origin) */
               unsigned    res1;           /* reserved */
               addr_t      tgt_offset;
     
            // Added to support RTI support in ROSE
               friend std::ostream & operator<< ( std::ostream & os, const iref_type & x );

               iref_type();
             };

          struct iord_type { /*tgt_type==0x01: imported ordinal*/
               unsigned    modref;         /* 1-based index into import module table */
               unsigned    ordinal;
               addr_t      addend;         /* value to add (only present for flags & RF_2EXTRA) */

            // Added to support RTI support in ROSE
               friend std::ostream & operator<< ( std::ostream & os, const iord_type & x );

               iord_type();
             };

          struct iname_type { /*tgt_type==0x02: imported name*/
               unsigned    modref;         /* 1-based index into import module table */
               unsigned    nm_off;         /* offset into import procedure names */
               addr_t      addend;         /* value to add (only present for flags & RF_2EXTRA) */

            // Added to support RTI support in ROSE
               friend std::ostream & operator<< ( std::ostream & os, const iname_type & x );

               iname_type();
             };

          struct osfixup_type { /*tgt_type==0x03: operating system fixup*/
               unsigned    type;
               unsigned    res3;

            // Added to support RTI support in ROSE
               friend std::ostream & operator<< ( std::ostream & os, const osfixup_type & x );

               osfixup_type();
             };

          SgAsmNERelocEntry(SgAsmGenericSection *relocs, addr_t at, addr_t *rec_size);

          void ctor(SgAsmGenericSection*, addr_t at, addr_t *rec_size);
          addr_t unparse(std::ostream&, const SgAsmGenericSection*, addr_t spos) const;
          void dump(FILE*, const char *prefix, ssize_t idx) const;

       // NERelocSrcType      src_type;       /* low nibble of first byte of relocation record */
       // NERelocModifiers    modifier;       /* high nibble of first byte */
       // NERelocTgtType      tgt_type;       /* low two bits of second byte */
       // NERelocFlags        flags;          /* high six bits of second byte */
       // addr_t              src_offset;

       // iref_type iref;
       // iord_type iord;
       // iname_type iname;
       // osfixup_type osfixup;

HEADER_NE_RELOC_ENTRY_END

HEADER_NE_SECTION_TABLE_ENTRY_START
     public:
       /* File format of a section table entry. All fields are little endian. */
          struct NESectionTableEntry_disk {
               uint16_t    sector;                 /* 0x00 File offset (sector size defined in hdr); zero means no file data */
               uint16_t    physical_size;          /* 0x02 Length of segment in file; zero means 64k if sector is non-zero */
               uint16_t    flags;                  /* 0x04 Segment bit flags */
               uint16_t    virtual_size;           /* 0x06 Total size of segment when mapped to memory; zero means 64k */
             } __attribute__((packed));              /* 0x08 */

          enum NESectionFlags {
               SF_RESERVED         = 0x0e08,       /* these bits are reserved */

               SF_TYPE_MASK        = 0x0007,       /* segment-type field */
               SF_CODE             = 0x0000,       /* code-segment type */
               SF_DATA             = 0x0001,       /* data-segment (otherwise segment is code) */
               SF_ALLOC            = 0x0002,       /* loader allocates memory */
               SF_LOAD             = 0x0004,       /* load the segment */

               SF_MOVABLE          = 0x0010,       /* segment is not fixed */
               SF_PURE             = 0x0020,       /* segment is pure, or sharable; otherwise impure or non-sharable */
               SF_PRELOAD          = 0x0040,       /* segment will be preloaded; read-only if this is a data segment */
               SF_NOT_WRITABLE     = 0x0080,       /* code segment is execute only; data segment is read-only */
               SF_RELOCINFO        = 0x0100,       /* segment has relocation records */
               SF_DISCARDABLE      = 0x1000,       /* discardable */
               SF_DISCARD          = 0xf000        /* discard priority */
             };

          explicit SgAsmNESectionTableEntry(const SgAsmNESectionTableEntry::NESectionTableEntry_disk *disk);
       // virtual ~NESectionTableEntry() {};

          void *encode(SgAsmNESectionTableEntry::NESectionTableEntry_disk*) const;
          virtual void dump(FILE *f, const char *prefix, ssize_t idx) const {dump(f, prefix, idx, NULL);}
          void dump(FILE*, const char *prefix, ssize_t idx, SgAsmNEFileHeader *fhdr) const;

       /* These are the native-format versions of the same members described in the NESectionTableEntry_disk struct. */
       // unsigned    flags, sector;
       // addr_t      physical_size, virtual_size;

     private:
          void ctor(const SgAsmNESectionTableEntry::NESectionTableEntry_disk*);

HEADER_NE_SECTION_TABLE_ENTRY_END



// ***********************************************
//          LE Binary File Format Support
// ***********************************************

HEADER_LE_FILE_HEADER_START

     public:
       // Overloaded base class virtual function
          const char *format_name() const;

          static bool is_LE (SgAsmGenericFile*);
          static SgAsmLEFileHeader *parse(SgAsmGenericFile*);

       /* File format of an LE/LX File Header (they are identical except bytes 0x2c-0x2f) */
          struct LEFileHeader_disk {
              unsigned char e_magic[2];           /* 0x00 magic number "LX" */
              unsigned char e_byte_order;         /* 0x02 byte order (0=>little endian; otherwise big endian) */
              unsigned char e_word_order;         /* 0x03 word order (0=>little endian; otherwise big endian) */
              uint32_t    e_format_level;         /* 0x04 LX file format version number */
              uint16_t    e_cpu_type;             /* 0x08 1=>80286, 2=>80386, 3=>80486,4=80586, etc. (see ctor) */
              uint16_t    e_os_type;              /* 0x0a 0=>unknown, 1=>0S/2, 2=>Windows, 3=>DOS 4.x, 4=>Windows 386 */
              uint32_t    e_module_version;       /* 0x0c user-specified module version number */
              uint32_t    e_flags;                /* 0x10 bit flags (see LXFileHeaderFlags) */
              uint32_t    e_npages;               /* 0x14 number of physically contained pages (see e_page_size) */
              uint32_t    e_eip_section;          /* 0x18 the section number to which e_eip is relative */
              uint32_t    e_eip;                  /* 0x1c entry address relative to e_eip_section */
              uint32_t    e_esp_section;          /* 0x20 the section number to which e_esp is relative */
              uint32_t    e_esp;                  /* 0x24 starting stack address relative to e_esp_section */
              uint32_t    e_page_size;            /* 0x28 page size in bytes */
              uint32_t    e_lps_or_shift;         /* 0x2c size of last page (LE) or shift for page table's page offset field (LX) */
              uint32_t    e_fixup_sect_size;      /* 0x30 total size of fixup info in bytes (fixup page/record tables + import names) */
              uint32_t    e_fixup_sect_cksum;     /* 0x34 cryptographic checksum of all fixup info, or zero */
              uint32_t    e_loader_sect_size;     /* 0x38 size of memory resident tables (section table through per-page checksum table) */
              uint32_t    e_loader_sect_cksum;    /* 0x3c cryptographic checksum for all loader info, or zero */
              uint32_t    e_secttab_rfo;          /* 0x40 offset of section table relative to this header */
              uint32_t    e_secttab_nentries;     /* 0x44 number of entries in section table */
              uint32_t    e_pagetab_rfo;          /* 0x48 section page table offset relative to this header */
              uint32_t    e_iterpages_offset;     /* 0x4c section iterated pages offset (absolute file offset) */
              uint32_t    e_rsrctab_rfo;          /* 0x50 offset of resource table relative to this header */
              uint32_t    e_rsrctab_nentries;     /* 0x54 number of entries in the resource table */
              uint32_t    e_resnametab_rfo;       /* 0x58 offset of resident name table relative to this header */
              uint32_t    e_entrytab_rfo;         /* 0x5c offset of entry table relative to this header */
              uint32_t    e_fmtdirtab_rfo;        /* 0x60 offset of module format directives relative to this header */
              uint32_t    e_fmtdirtab_nentries;   /* 0x64 number of entries in module format directives table */
              uint32_t    e_fixup_pagetab_rfo;    /* 0x68 offset of fixup page table relative to this header */
              uint32_t    e_fixup_rectab_rfo;     /* 0x6c offset of fixup record table relative to this header */
              uint32_t    e_import_modtab_rfo;    /* 0x70 offset of import module name table relative to this header */
              uint32_t    e_import_modtab_nentries;/*0x74 number of entries in import module name table */
              uint32_t    e_import_proctab_rfo;   /* 0x78 offset of import procedure name table relative to this header */
              uint32_t    e_ppcksumtab_rfo;       /* 0x7c offset of per-page checksum table relative to this header */
              uint32_t    e_data_pages_offset;    /* 0x80 offset of data pages (absolute file offset) */
              uint32_t    e_preload_npages;       /* 0x84 number of preload pages (not respected by OS/2) */
              uint32_t    e_nonresnametab_offset; /* 0x88 offset of non-resident name table (absolute file offset) */
              uint32_t    e_nonresnametab_size;   /* 0x8c size of non-resident name table in bytes */
              uint32_t    e_nonresnametab_cksum;  /* 0x90 cryptographic checksum of the non-resident name table */
              uint32_t    e_auto_ds_section;      /* 0x94 auto data segment section number (not used by 32-bit modules) */
              uint32_t    e_debug_info_rfo;       /* 0x98 offset of debug information relative to this header */
              uint32_t    e_debug_info_size;      /* 0x9c size of debug information in bytes */
              uint32_t    e_num_instance_preload; /* 0xa0 number of instance data pages found in the preload section */
              uint32_t    e_num_instance_demand;  /* 0xa4 number of instance data pages found in the demand section */
              uint32_t    e_heap_size;            /* 0xa8 number of bytes added to auto data segment by loader (not used by 32-bit) */
          } __attribute__((packed));              /* 0xac */

          enum LEFileHeaderFlags {
              HF_RESERVED         = 0xbffc5ccb,   /* Reserved bits */
              HF_PROC_LIB_INIT    = 0x00000004,   /* Per-process library initialization; not used for executables */
              HF_IFIXUPS_APPLIED  = 0x00000010,   /* Sections have preferred load addresses and internal relocs have been applied */
              HF_EFIXUPS_APPLIED  = 0x00000020,   /* External fixups for the module have been applied */
              HF_PM_WINDOW_NO     = 0x00000100,   /* Incompatible with PM windowing */
              HF_PM_WINDOW_OK     = 0x00000200,   /* Compatible with PM windowing */
              HF_PM_WINDOW_USE    = 0x00000300,   /* Uses PM windowing API */
              HF_NOT_LOADABLE     = 0x00002000,   /* Module is not loadable (has errors or incrementally linked) */
              HF_PROC_LIB_TERM    = 0x40000000,   /* Per-process library termination; not used for executables */
    
              HF_MODTYPE_MASK     = 0x00038000,   /* Module type mask */
              HF_MODTYPE_PROG     = 0x00000000,   /* Program module (other modules cannot link to this one) */
              HF_MODTYPE_LIB      = 0x00008000,   /* Library module */
              HF_MODTYPE_PLIB     = 0x00018000,   /* Protected memory library module */
              HF_MODTYPE_PDEV     = 0x00020000,   /* Physical device driver module */
              HF_MODTYPE_VDEV     = 0x00028000,   /* Virtual device driver module */
          };

          SgAsmLEFileHeader(SgAsmGenericFile *f, addr_t offset);
       // virtual ~LEFileHeader() {}

          virtual void unparse(std::ostream&) const;
       // virtual const char *format_name() const;
          virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
     private:
          void ctor(SgAsmGenericFile *f, addr_t offset);
          void *encode(SgAsmExecutableFileFormat::ByteOrder sex, SgAsmLEFileHeader::LEFileHeader_disk*) const;
HEADER_LE_FILE_HEADER_END

HEADER_LE_SECTION_START
     public:
          SgAsmLESection(SgAsmLEFileHeader*, addr_t offset, addr_t size);
       // virtual ~LESection() {}

       // virtual void unparse(std::ostream&) const; /*nothing special to do*/
          virtual void dump(FILE*, const char *prefix, ssize_t idx) const;

       /* Accessors for protected/private data */
       // LESectionTableEntry *get_st_entry() {return st_entry;}
       // void set_st_entry(LESectionTableEntry *e) {st_entry=e;}

  // private:
       // LESectionTableEntry *st_entry;

HEADER_LE_SECTION_END

HEADER_LE_SECTION_TABLE_START
     public:
          SgAsmLESectionTable(SgAsmLEFileHeader *fhdr, addr_t offset, addr_t size);
       // virtual ~LESectionTable() {}

          virtual void unparse(std::ostream&) const;
          virtual void dump(FILE*, const char *prefix, ssize_t idx) const;

     private:
          void ctor();

HEADER_LE_SECTION_TABLE_END

HEADER_LE_NAME_TABLE_START

     public:

       /* This table contains a module name followed by the list of exported function names. Each name is associated with an "ordinal"
        * which serves as an index into the Entry Table. The ordinal for the first string (module name) is meaningless and should be
        * zero. In the non-resident name table the first entry is a module description and the functions are not always resident in
        * system memory (they are discardable). */

          SgAsmLENameTable(SgAsmLEFileHeader *fhdr, addr_t offset);
       // virtual ~LENameTable() {}

          virtual void unparse(std::ostream&) const;
          virtual void dump(FILE*, const char *prefix, ssize_t idx) const;

     private:
          void ctor();

       // std::vector<std::string> names; /*first name is module name; remainder are symbols within the module*/
       // std::vector<unsigned> ordinals; /*first entry is ignored but present in file*/

HEADER_LE_NAME_TABLE_END

HEADER_LE_PAGE_TABLE_START
     public:
          SgAsmLEPageTable(SgAsmLEFileHeader *fhdr, addr_t offset, addr_t size);
       // virtual ~LEPageTable() {}

          virtual void unparse(std::ostream&) const;
          virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
          SgAsmLEPageTableEntry *get_page(size_t idx);

     private:
          void ctor();

       // std::vector<LEPageTableEntry*> entries;

HEADER_LE_PAGE_TABLE_END

HEADER_LE_ENTRY_TABLE_START
     public:
          SgAsmLEEntryTable(SgAsmLEFileHeader *fhdr, addr_t offset);
       // virtual ~LEEntryTable() {}

          virtual void unparse(std::ostream&) const;
          virtual void dump(FILE*, const char *prefix, ssize_t idx) const;

     private:
          void ctor();

       // std::vector<size_t> bundle_sizes;
       // std::vector<LEEntryPoint> entries;

HEADER_LE_ENTRY_TABLE_END

HEADER_LE_RELOC_TABLE_START
     public:
          SgAsmLERelocTable(SgAsmLEFileHeader *fhdr, addr_t offset);
       // virtual ~LERelocTable() {}

       // virtual void unparse(std::ostream&) const;
          virtual void dump(FILE*, const char *prefix, ssize_t idx) const;

     private:
          void ctor();

       // std::vector<LERelocEntry> entries;

HEADER_LE_RELOC_TABLE_END

HEADER_LE_PAGE_TABLE_ENTRY_START
     public:
       /* The object page table provides information about a logical page in a section. A logical page may be an enumerated page, a
        * pseudo page, or an iterated page. The page table allows for efficient access to a page when a page fault occurs, while
        * still allowing the physical page to be located in the preload page, demand load page, or iterated data page sections of the
        * executable file. Entries in the page table use 1-origin indices.  This table is parallel with the Fixup Page Table (they
        * are both indexed by the logical page number). */

       /* File format for a page table entry */
          struct LEPageTableEntry_disk {
               uint16_t            pageno_hi;
               unsigned char       pageno_lo;
               unsigned char       flags;
             } __attribute__((packed));

          SgAsmLEPageTableEntry(SgAsmExecutableFileFormat::ByteOrder sex, const SgAsmLEPageTableEntry::LEPageTableEntry_disk *disk);

          void dump(FILE*, const char *prefix, ssize_t idx) const;
          void *encode(SgAsmExecutableFileFormat::ByteOrder, SgAsmLEPageTableEntry::LEPageTableEntry_disk*) const;

       // unsigned get_pageno() {return pageno;}

     private:
          void ctor(SgAsmExecutableFileFormat::ByteOrder, const SgAsmLEPageTableEntry::LEPageTableEntry_disk*);

       // unsigned    pageno;
       // unsigned    flags;

HEADER_LE_PAGE_TABLE_ENTRY_END

HEADER_LE_ENTRY_POINT_START

     public:
       /* If 0x01 bit of "flags" is clear then the remainder (next 9 bytes) of the entry point is not stored in the file and the
        * next entry point description follows immediately after the flag. */
          struct LEEntryPoint_disk {
              uint8_t     flags;          /* 0x00 Bit flags (0x01=>non-empty bundle; 0x02=>32-bit entry*/
              uint16_t    objnum;         /* 0x01 Object number */
              uint8_t     entry_type;     /* 0x03 Flags for entry type */
              uint32_t    entry_offset;   /* 0x04 Offset of entry point */
              uint16_t    res1;           /* 0x08 Reserved */
          } __attribute__((packed));      /* 0x0a */

          SgAsmLEEntryPoint(SgAsmExecutableFileFormat::ByteOrder sex, const SgAsmLEEntryPoint::LEEntryPoint_disk *disk);
          SgAsmLEEntryPoint(SgAsmExecutableFileFormat::ByteOrder sex, unsigned flags);

          addr_t unparse(std::ostream&, SgAsmExecutableFileFormat::ByteOrder, const SgAsmGenericSection*, addr_t spos) const;
          void dump(FILE*, const char *prefix, ssize_t idx) const;

     private:
          void ctor(SgAsmExecutableFileFormat::ByteOrder, const SgAsmLEEntryPoint::LEEntryPoint_disk*);

       // std::vector<LEEntryPoint> entries;
       // unsigned flags, objnum, entry_type, res1;
       // addr_t entry_offset;

HEADER_LE_ENTRY_POINT_END

HEADER_LE_SECTION_TABLE_ENTRY_START

     public:
       /* File format of a section table entry. Fields are big- or little-endian depending on file header. */
          struct LESectionTableEntry_disk {
               uint32_t    mapped_size;            /* 0x00 virtual segment size in bytes */
               uint32_t    base_addr;              /* 0x04 relocation base address */
               uint32_t    flags;                  /* 0x08 bit flags, see LESectionFlags */
               uint32_t    pagemap_index;          /* 0x0c */
               uint32_t    pagemap_nentries;       /* 0x10 number of entries in the page map */
               uint32_t    res1;                   /* 0x14 reserved */
             } __attribute__((packed));              /* 0x18 */

       /* SF_BIG_BIT: The "big/default" bit, for data segments, controls the setting of the Big bit in the segment descriptor. (The
        *             Big bit, or B-bit, determines whether ESP or SP is used as the stack pointer.) For code segments, this bit
        *             controls the setting of the Default bit in the segment descriptor. (The Default bit, or D-bit, determines
        *             whether the default word size is 32-bits or 16-bits. It also affects the interpretation of the instruction
        *             stream.) */
          enum LESectionFlags {
               SF_RESERVED         = 0xffff0800,   /* Reserved bits (FIXME) */
    
               SF_READABLE         = 0x00000001,   /* Read permission granted when mapped */
               SF_WRITABLE         = 0x00000002,   /* Write permission granted when mapped */
               SF_EXECUTABLE       = 0x00000004,   /* Execute permission granted when mapped */
    
               SF_RESOURCE         = 0x00000008,   /* Section contains resource objects */
               SF_DISCARDABLE      = 0x00000010,   /* Discardable section */
               SF_SHARED           = 0x00000020,   /* Section is shared */
               SF_PRELOAD_PAGES    = 0x00000040,   /* Section has preload pages */
               SF_INVALID_PAGES    = 0x00000080,   /* Section has invalid pages */

               SF_TYPE_MASK        = 0x00000300,
               SF_TYPE_NORMAL      = 0x00000000,
               SF_TYPE_ZERO        = 0x00000100,   /* Section has zero-filled pages */
               SF_TYPE_RESIDENT    = 0x00000200,   /* Section is resident (valid for VDDs and PDDs only) */
               SF_TYPE_RESCONT     = 0x00000300,   /* Section is resident and contiguous */
    
               SF_RES_LONG_LOCK    = 0x00000400,   /* Section is resident and "long-lockable" (VDDs and PDDs only) */
               SF_1616_ALIAS       = 0x00001000,   /* 16:16 alias required (80x86 specific) */
               SF_BIG_BIT          = 0x00002000,   /* Big/default bit setting (80x86 specific); see note above */
               SF_CODE_CONFORM     = 0x00004000,   /* Section is conforming for code (80x86 specific) */
               SF_IO_PRIV          = 0x00008000,   /* Section I/O privilege level (80x86 specific; used only for 16:16 alias objects) */
             };

          SgAsmLESectionTableEntry(SgAsmExecutableFileFormat::ByteOrder sex, const SgAsmLESectionTableEntry::LESectionTableEntry_disk *disk);
       // virtual ~LESectionTableEntry() {};

          void *encode(SgAsmExecutableFileFormat::ByteOrder, SgAsmLESectionTableEntry::LESectionTableEntry_disk*) const;
          virtual void dump(FILE *f, const char *prefix, ssize_t idx) const;
    
       /* These are the native-format versions of the same members described in the NESectionTableEntry_disk struct. */
       // unsigned    flags, pagemap_index, pagemap_nentries, res1;
       // addr_t      mapped_size, base_addr;

     private:
          void ctor(SgAsmExecutableFileFormat::ByteOrder, const SgAsmLESectionTableEntry::LESectionTableEntry_disk*);

HEADER_LE_SECTION_TABLE_ENTRY_END




// ***********************************************
//          DOS Binary File Format Support
// ***********************************************

HEADER_DOS_HEADER_START
	public:
		struct DOSFileHeader_disk {
			unsigned char e_magic[2];          /* 0x00 "MZ" */
			uint16_t      e_last_page_size;    /* 0x02 bytes used on last page of file (1 page == 512 bytes);
							    *      zero implies if last page is full */
			uint16_t      e_total_pages;       /* 0x04 number of pages (inc. last possibly partial page) in file */
			uint16_t      e_nrelocs;           /* 0x06 number of relocation entries stored after this header */
			uint16_t      e_header_paragraphs; /* 0x08 header size in paragraphs (16-byte blocks) inc. relocations */
			uint16_t      e_minalloc;          /* 0x0a number of extra paragraphs needed, similar to BSS in Unix */
			uint16_t      e_maxalloc;          /* 0x0c max paragraphs to allocate for BSS */
			uint16_t      e_ss;                /* 0x0e initial value of SS register relative to program load segment */
			uint16_t      e_sp;                /* 0x10 initial value for SP register */
			uint16_t      e_cksum;             /* 0x12 checksum; 16-bit sum of all words in file should be zero
							    *      (usually not filled in) */
			uint16_t      e_ip;                /* 0x14 initial value for IP register */
			uint16_t      e_cs;                /* 0x16 initial value for CS register relative to program load segment*/
			uint16_t      e_relocs_offset;     /* 0x18 file address of relocation table */
			uint16_t      e_overlay;           /* 0x1a overlay number (zero indicates main program) */
			unsigned char e_res1[4];           /* 0x1c unknown purpose */
		} __attribute__((packed));                 /* 0x20 */

		struct DOSRelocEntry_disk {
			uint16_t      offset;		   /* 0x00 */
			uint16_t      segment;		   /* 0x02 */
		} __attribute__((packed));		   /* 0x04 */

		explicit SgAsmDOSFileHeader(SgAsmGenericFile *f)
			: SgAsmGenericHeader(f, 0, sizeof(DOSFileHeader_disk)),
			  p_relocs(NULL), p_rm_section(NULL)
			{ctor();}
		virtual SgAsmDOSFileHeader *parse() {return parse(true);}
		SgAsmDOSFileHeader *parse(bool define_rm_section);
		virtual void unparse(std::ostream&) const;
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
		virtual const char *format_name() const {return "DOS";}
		SgAsmGenericSection *add_rm_section(addr_t max_offset=0);
		static bool is_DOS(SgAsmGenericFile*);
	private:
		void ctor();
		void *encode(SgAsmDOSFileHeader::DOSFileHeader_disk*) const;
HEADER_DOS_HEADER_END



HEADER_DOS_EXTENDED_HEADER_START
	public:
		struct DOSExtendedHeader_disk {
			unsigned char e_res1[4];  /* 0x00 reserved */
			uint16_t      e_oemid;    /* 0x04 OEM Identifier */
			uint16_t      e_oeminfo;  /* 0x06 other OEM information; oemid specific */
			uint16_t      e_res2[10]; /* 0x08 reserved */
			uint32_t      e_lfanew;   /* 0x1c file offset of new exe (PE) header */
		} __attribute__((packed));        /* 0x20 */

		explicit SgAsmDOSExtendedHeader(SgAsmDOSFileHeader *fhdr)
			: SgAsmGenericSection(fhdr->get_file(), fhdr, 0, sizeof(DOSExtendedHeader_disk))
			{ctor();}
		virtual SgAsmDOSExtendedHeader *parse();
		void *encode(SgAsmDOSExtendedHeader::DOSExtendedHeader_disk*) const;
		virtual void unparse(std::ostream&) const;
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
	private:
		void ctor();
HEADER_DOS_EXTENDED_HEADER_END





SOURCE_BINARY_FILE_SECTION_HEADER_LIST_START

#if 0
const SgAsmSectionHeaderPtrList &
SgAsmSectionHeaderList::get_section_headers() const
   {
     return p_section_headers;
   }

SgAsmSectionHeaderPtrList &
SgAsmSectionHeaderList::get_section_headers()
   {
     return p_section_headers;
   }
#endif

SOURCE_BINARY_FILE_SECTION_HEADER_LIST_END

SOURCE_BINARY_FILE_PROGRAM_HEADER_LIST_START

#if 0
const SgAsmProgramHeaderPtrList &
SgAsmProgramHeaderList::get_program_headers() const
   {
     return p_program_headers;
   }

SgAsmProgramHeaderPtrList &
SgAsmProgramHeaderList::get_program_headers()
   {
     return p_program_headers;
   }
#endif

SOURCE_BINARY_FILE_PROGRAM_HEADER_LIST_END


HEADER_BINARY_X86_INSTRUCTION_START
  public:

HEADER_BINARY_X86_INSTRUCTION_END


HEADER_BINARY_DECLARATION_START
HEADER_BINARY_DECLARATION_END


HEADER_BINARY_RET_START
   void append_dest( SgAsmStatement* instruction );	
HEADER_BINARY_RET_END


HEADER_BINARY_FUNCTION_CALL_START
HEADER_BINARY_FUNCTION_CALL_END

HEADER_BINARY_BLOCK_START
          void append_statement( SgAsmStatement* statement );
          void remove_statement( SgAsmStatement* statement );
          void remove_children (  );
HEADER_BINARY_BLOCK_END



HEADER_BINARY_OPERAND_LIST_START
          void append_operand( SgAsmExpression* operand );
HEADER_BINARY_OPERAND_LIST_END



HEADER_BINARY_FUNCTION_DECLARATION_START
	int nrOfValidInstructions(std::vector<SgNode*>& succs);
          //void append_block( SgAsmBlock* operand );
          void append_statement( SgAsmStatement* statement );
          void remove_statement( SgAsmStatement* statement );	
	  void append_dest( SgAsmStatement* instruction );		
          void remove_children (  );

       //! enum declaration as specified in proposed Sabre database schema
          enum function_kind_enum
             {
               e_unknown  = 0,
               e_standard = 1,
               e_library  = 2,
               e_imported = 3,
               e_thunk    = 4,
               e_last
             };
HEADER_BINARY_FUNCTION_DECLARATION_END

HEADER_BINARY_DATA_STRUCTURE_START
          void append_declaration( SgAsmDeclaration* declaration );

       // SgAsmDeclarationPtrList & get_declarationList();

     protected:

          SgAsmDeclarationPtrList p_declarationList;

     public:
HEADER_BINARY_DATA_STRUCTURE_END




HEADER_BINARY_EXPRESSION_START

      //! Generate the type for the expression
          virtual SgAsmType* get_type();

      //! Return the precedence of the operator (see C and C++ examples for details)
      //  virtual int get_precedence();

HEADER_BINARY_EXPRESSION_END



HEADER_BINARY_TYPE_START

       // static SgAsmType* createType();

HEADER_BINARY_TYPE_END

HEADER_BINARY_TYPE_BYTE_START
          static SgAsmTypeByte* createType();
HEADER_BINARY_TYPE_BYTE_END

HEADER_BINARY_TYPE_WORD_START
          static SgAsmTypeWord* createType();
HEADER_BINARY_TYPE_WORD_END

HEADER_BINARY_TYPE_DOUBLE_WORD_START
          static SgAsmTypeDoubleWord* createType();
HEADER_BINARY_TYPE_DOUBLE_WORD_END

HEADER_BINARY_TYPE_QUAD_WORD_START
          static SgAsmTypeQuadWord* createType();
HEADER_BINARY_TYPE_QUAD_WORD_END

HEADER_BINARY_TYPE_DOUBLE_QUAD_WORD_START
          static SgAsmTypeDoubleQuadWord* createType();
HEADER_BINARY_TYPE_DOUBLE_QUAD_WORD_END

HEADER_BINARY_TYPE_SINGLE_FLOAT_START
          static SgAsmTypeSingleFloat* createType();
HEADER_BINARY_TYPE_SINGLE_FLOAT_END

HEADER_BINARY_TYPE_DOUBLE_FLOAT_START
          static SgAsmTypeDoubleFloat* createType();
HEADER_BINARY_TYPE_DOUBLE_FLOAT_END

HEADER_BINARY_TYPE_VECTOR_START
          static SgAsmTypeVector* createType(int elementCount, SgAsmType* elementType);
HEADER_BINARY_TYPE_VECTOR_END

HEADER_BINARY_TYPE_80bit_FLOAT_START
          static SgAsmType80bitFloat* createType();
HEADER_BINARY_TYPE_80bit_FLOAT_END

HEADER_BINARY_TYPE_128bit_FLOAT_START
          static SgAsmType128bitFloat* createType();
HEADER_BINARY_TYPE_128bit_FLOAT_END

HEADER_BINARY_REGISTER_REFERENCE_EXPRESSION_START

         // Note that the auto-generated version of this is const
         virtual SgAsmType* get_type();

HEADER_BINARY_REGISTER_REFERENCE_EXPRESSION_END

HEADER_BINARY_X86_REGISTER_REFERENCE_EXPRESSION_START

             // Note that the auto-generated version of this is const
             virtual SgAsmType* get_type();

             //! Get a unique identifier for this particular register
             std::pair<X86RegisterClass, int> get_identifier() const;

HEADER_BINARY_X86_REGISTER_REFERENCE_EXPRESSION_END

HEADER_BINARY_ARM_REGISTER_REFERENCE_EXPRESSION_START

          enum arm_register_enum
             { // The exact numbers here are important
               undefined_arm_register = 0, /*!< unknown (error or unitialized value) */
               reg0 = 1,
               reg1 = 2,
               reg2 = 3,
               reg3 = 4,
               reg4 = 5,
               reg5 = 6,
               reg6 = 7,
               reg7 = 8,
               reg8 = 9,
               reg9  = 10,
               reg10 = 11,
               reg11 = 12,
               reg12 = 13,
               reg13 = 14,
               reg14 = 15,
               reg15 = 16,
               cpsr = 17,
               spsr = 18,
               cpsr_fields = 19, /* 16 values -- add arm_suffix_field_enum */
               spsr_fields = 35, /* 16 values -- add arm_suffix_field_enum */
               last_arm_register = spsr_fields + 16
             };

          enum arm_position_in_register_enum
             {
               undefined_arm_position_in_register = 0, /*!< unknown (error or unitialized value) */
               arm_dword = 1, /*!< lower 32 bit part of larger register (typically the first part of a 64 bit register) */
               arm_qword = 2, /*!< 64 bit part of 128 bit register (not in common use) */
               last_arm_position_in_register
             };

          enum arm_suffix_field_enum
             {
               undefined_position_in_suffix = 0, /*!< unknown (error or unitialized value) */
               c = 1, // control field mask bit
               x = 2, // extension field mask bit
               s = 4, // status field mask bit
               f = 8, // flags field mask bit
               last_position_in_suffix
             };

             // Note that the auto-generated version of this is const
             virtual SgAsmType* get_type();

HEADER_BINARY_ARM_REGISTER_REFERENCE_EXPRESSION_END


HEADER_BINARY_POWERPC_REGISTER_REFERENCE_EXPRESSION_START

          enum powerpc_register_enum
             { // The exact numbers here are important
               undefined_powerpc_register = 0, /*!< unknown (error or unitialized value) */
               reg0 = 1,
               reg1 = 2,
               reg2 = 3,
               reg3 = 4,
               reg4 = 5,
               reg5 = 6,
               reg6 = 7,
               reg7 = 8,
               last_powerpc_register
             };

             // Note that the auto-generated version of this is const
             virtual SgAsmType* get_type();

HEADER_BINARY_POWERPC_REGISTER_REFERENCE_EXPRESSION_END


HEADER_BINARY_MEMORY_REFERENCE_EXPRESSION_START

             // Note that the auto-generated version of this is const
             virtual SgAsmType* get_type();

HEADER_BINARY_MEMORY_REFERENCE_EXPRESSION_END



// ************************************
//           DWARF SUPPORT
// ************************************

HEADER_DWARF_INFORMATION_START
HEADER_DWARF_INFORMATION_END

HEADER_DWARF_COMPILATION_UNIT_START

     public:
          SgAsmDwarfConstructList* get_children();

HEADER_DWARF_COMPILATION_UNIT_END

HEADER_DWARF_COMPILATION_UNIT_LIST_START
HEADER_DWARF_COMPILATION_UNIT_LIST_END

HEADER_DWARF_MACRO_START
HEADER_DWARF_MACRO_END

HEADER_DWARF_LINE_START
HEADER_DWARF_LINE_END

HEADER_DWARF_MACRO_LIST_START
HEADER_DWARF_MACRO_LIST_END

HEADER_DWARF_LINE_LIST_START

       // Once the maps are setup using a valid SgAsmDwarfCompilationUnit, NULL is an acceptable value.
      //! Support for building maps to and from instruction addresses to source positions (files, line numbers, column numbers).
          static DwarfInstructionSourceMapReturnType buildInstructionAddressSourcePositionMaps( SgAsmDwarfCompilationUnit* dwarf_cu = NULL );

      //! Output information about instruction address <--> source position
          void display( const std::string & label );

          static std::pair<uint64_t,uint64_t> instructionRange();
          static std::pair<LineColumnFilePosition,LineColumnFilePosition> sourceCodeRange( int file_id );

          static uint64_t sourceCodeToAddress ( FileIdLineColumnFilePosition sourcePosition );
          static FileIdLineColumnFilePosition addressToSourceCode ( uint64_t address );

HEADER_DWARF_LINE_LIST_END

HEADER_DWARF_CONSTRUCT_START

     public:
      //! Factory pattern to build IR nodes based on the tag
          static SgAsmDwarfConstruct* createDwarfConstruct( int tag, int nesting_level, uint64_t offset, uint64_t overall_offset );

          virtual SgAsmDwarfConstructList* get_children();

HEADER_DWARF_CONSTRUCT_END

HEADER_DWARF_CONSTRUCT_LIST_START
HEADER_DWARF_CONSTRUCT_LIST_END

HEADER_DWARF_SUBPROGRAM_START

     public:
          SgAsmDwarfConstructList* get_children();

HEADER_DWARF_SUBPROGRAM_END

HEADER_DWARF_STRUCTURE_TYPE_START

     public:
          SgAsmDwarfConstructList* get_children();

HEADER_DWARF_STRUCTURE_TYPE_END

HEADER_DWARF_ARRAY_TYPE_START

     public:
          SgAsmDwarfConstructList* get_children();

HEADER_DWARF_ARRAY_TYPE_END

HEADER_DWARF_LEXICAL_BLOCK_START

     public:
          SgAsmDwarfConstructList* get_children();

HEADER_DWARF_LEXICAL_BLOCK_END


HEADER_DWARF_INLINED_SUBROUTINE_START

     public:
          SgAsmDwarfConstructList* get_children();

HEADER_DWARF_INLINED_SUBROUTINE_END

HEADER_DWARF_ENUMERATION_TYPE_START

     public:
          SgAsmDwarfConstructList* get_children();

HEADER_DWARF_ENUMERATION_TYPE_END

HEADER_DWARF_SUBROUTINE_TYPE_START

     public:
          SgAsmDwarfConstructList* get_children();

HEADER_DWARF_SUBROUTINE_TYPE_END

HEADER_DWARF_UNION_TYPE_START

     public:
          SgAsmDwarfConstructList* get_children();

HEADER_DWARF_UNION_TYPE_END

HEADER_DWARF_NAMESPACE_START

     public:
          SgAsmDwarfConstructList* get_children();

HEADER_DWARF_NAMESPACE_END

HEADER_DWARF_CLASS_TYPE_START

     public:
          SgAsmDwarfConstructList* get_children();

HEADER_DWARF_CLASS_TYPE_END

HEADER_DWARF_COMMON_BLOCK_START

     public:
          SgAsmDwarfConstructList* get_children();

HEADER_DWARF_COMMON_BLOCK_END


/* --------------------------------------------------------------------------------- */
/* --------------------------------------------------------------------------------- */
/* --------------------------------------------------------------------------------- */
/* --------------------------------------------------------------------------------- */
/* --------------------------------------------------------------------------------- */


SOURCE_BINARY_FILE_START
void
SgAsmFile::post_construction_initialization()
   {
  // Build the list IR node

  // DQ (8/16/2008): Make the SgAsmGenericFile the root of the AST for the binary executable format
  // p_headers = new SgAsmGenericHeaderList();
  // p_headers->set_parent(this);
   }

SOURCE_BINARY_FILE_END

SOURCE_BINARY_BLOCK_START
void
SgAsmBlock::append_statement( SgAsmStatement* statement )
   {
     p_statementList.push_back(statement);
   }

void
SgAsmBlock::remove_children(  )
   {
     p_statementList.clear();
   }

void
SgAsmBlock::remove_statement( SgAsmStatement* statement )
   {
     SgAsmStatementPtrList::iterator l = p_statementList.begin();
     for (;l!=p_statementList.end();l++) {
	SgAsmStatement* st = *l;
	if (st==statement) {
             break;
        }
     }	
	if (l!=p_statementList.end())
            p_statementList.erase(l);
   }

SOURCE_BINARY_BLOCK_END



SOURCE_BINARY_RET_START
void
SgAsmx86Ret::append_dest( SgAsmStatement* statement )
   {
     p_dest.push_back(statement);
   }

SOURCE_BINARY_RET_END



SOURCE_BINARY_OPERAND_LIST_START
void
SgAsmOperandList::append_operand( SgAsmExpression* operand )
   {
  /* implemented directly until we can fix how the statementList is built */
     p_operands.push_back(operand);
   }

SOURCE_BINARY_OPERAND_LIST_END


SOURCE_BINARY_DATA_STRUCTURE_START
void
SgAsmDataStructureDeclaration::append_declaration( SgAsmDeclaration* declaration )
   {
     p_declarationList.push_back(declaration);
   }

SOURCE_BINARY_DATA_STRUCTURE_END


SOURCE_BINARY_FUNCTION_DECLARATION_START
int 
SgAsmFunctionDeclaration::nrOfValidInstructions( std::vector<SgNode*>& succs  ) {
//  std::vector<SgNode*> succs = this->get_traversalSuccessorContainer();
  std::vector<SgNode*>::reverse_iterator j = succs.rbegin();
  int instructions = succs.size();
  bool foundRet=false;
  bool nodeOtherThanNopAfterRetExists=false;	
/*
  if (j!=succs.begin())
    j--;
  else
    return 0;
*/
  for (;j!=succs.rend(); j++) {
     SgAsmx86Instruction* n = isSgAsmx86Instruction(*j);
     if (n && (n->get_kind() == x86_ret || n->get_kind() == x86_hlt)) {
          foundRet=true;
          break;
    } else {
       if (n && n->get_kind() != x86_nop) {
          nodeOtherThanNopAfterRetExists= true;
       }
       instructions--;
    }
  }
  if (!foundRet)
     instructions = succs.size();
  // if we find a return and there are NOPs following it somewhere,
  // we cut off the CFG at the NOP but we keep valid instructions
  // after the RET
  if (foundRet)
    if (nodeOtherThanNopAfterRetExists)
      return succs.size();
   
  return instructions;
}

void
SgAsmFunctionDeclaration::remove_children(  )
   {
     p_statementList.clear();
   }

void
SgAsmFunctionDeclaration::append_dest( SgAsmStatement* statement )
   {
     p_dest.push_back(statement);
   }

void
SgAsmFunctionDeclaration::append_statement( SgAsmStatement* statement )
   {
     p_statementList.push_back(statement);
   }

void
SgAsmFunctionDeclaration::remove_statement( SgAsmStatement* statement )
   {
     SgAsmStatementPtrList::iterator l = p_statementList.begin();
     for (;l!=p_statementList.end();l++) {
	SgAsmStatement* st = *l;
	if (st==statement) {
             break;
        }
     }	
	if (l!=p_statementList.end())
            p_statementList.erase(l);
   }


/*
void
SgAsmFunctionDeclaration::append_block( SgAsmBlock* operand )
   {
     p_body.push_back(operand);
   }
*/

SOURCE_BINARY_FUNCTION_DECLARATION_END


SOURCE_BINARY_INSTRUCTION_START

void
SgAsmInstruction::append_sources( SgAsmInstruction* inst )
   {
     p_sources.push_back(inst);
   }

SgAsmInstruction*
SgAsmInstruction::cfgBinFlowOutEdge(const VirtualBinCFG::AuxiliaryInformation* info) {
  if (!isAsmUnconditionalBranch(this)) {
    SgAsmInstruction* next = info->getInstructionAtAddress(this->get_address() + this->get_raw_bytes().size());
    return next;
  }
  return NULL;
}

std::vector<VirtualBinCFG::CFGEdge>
SgAsmInstruction::cfgBinOutEdges(const VirtualBinCFG::AuxiliaryInformation* info) {
  //cerr << "cfgBinOutEdges: " << std::hex << this->get_address() << " " << (isSgAsmx86Instruction(this) ? "x86" : "unknown") << " " << (isSgAsmx86Instruction(this) ? toString(isSgAsmx86Instruction(this)->get_kind()) : "") << endl;
  std::vector<VirtualBinCFG::CFGEdge> result;
  uint64_t nextAddr = this->get_address() + this->get_raw_bytes().size();

  if (isAsmBranch(this)) {
    //cout << "Found branch" << endl;
    uint64_t addr = 0;
    bool knownTarget = getAsmKnownBranchTarget(this, addr);
    if (knownTarget) {
      //cout << "Has known target " << std::hex << addr << endl;
      SgAsmInstruction* tgt = info->getInstructionAtAddress(addr);
      if (tgt) {
        makeEdge(this, tgt, info, result);
      }
    } else { // Unknown target
      //cout << "Unknown target" << endl;
      const std::set<uint64_t> successorAddrs = info->getPossibleSuccessors(this);
      for (std::set<uint64_t>::const_iterator i = successorAddrs.begin(); i != successorAddrs.end(); ++i) {
        //cout << "Found succ address " << std::hex << *i << endl;
        SgAsmInstruction* tgt = info->getInstructionAtAddress(*i);
        if (tgt) {
          makeEdge(this, tgt, info, result);
        }
      }
#if 0
      if (successorAddrs.empty()) {
	// FIXME: For bug-compatibility with old version
	SgAsmInstruction* next = info->getInstructionAtAddress(nextAddr);
	if (next) makeEdge(this, next, info, result);
      }
#endif
    } // else
  } // if

  if ((!isSgAsmx86Instruction(this) || isSgAsmx86Instruction(this)->get_kind() != x86_ret && isSgAsmx86Instruction(this)->get_kind() != x86_hlt) /* || !isAsmUnconditionalBranch(this) || (isSgAsmx86Instruction(this) && isSgAsmx86Instruction(this)->get_kind() == x86_call) */ ) {
    //cout << "Next insn is at " << std::hex << nextAddr << endl;
    SgAsmInstruction* next = info->getInstructionAtAddress(nextAddr);
    //ROSE_ASSERT (next);
    if (next) makeEdge(this, next, info, result);
  }

  return result;
}


std::vector<VirtualBinCFG::CFGEdge>
SgAsmInstruction::cfgBinInEdges(const VirtualBinCFG::AuxiliaryInformation* info) {
  std::vector<VirtualBinCFG::CFGEdge> result;
  const std::set<uint64_t>& preds = info->getPossiblePredecessors(this);
  for (std::set<uint64_t>::const_iterator i = preds.begin(); i != preds.end(); ++i) {
    SgAsmInstruction* tgt = info->getInstructionAtAddress(*i);
    if (tgt) {
      makeEdge(this, tgt, info, result);
    }
  }
  return result;
}

SOURCE_BINARY_INSTRUCTION_END

SOURCE_BINARY_X86_INSTRUCTION_START

SOURCE_BINARY_X86_INSTRUCTION_END


SOURCE_BINARY_EXPRESSION_START

SgAsmType* SgAsmExpression::get_type() {
  ROSE_ASSERT (!"Cannot get the type of this SgAsmExpression");
}

SOURCE_BINARY_EXPRESSION_END

SOURCE_BINARY_TYPE_START
SOURCE_BINARY_TYPE_END

SOURCE_BINARY_TYPE_BYTE_START

$CLASSNAME* $CLASSNAME::p_builtin_type = NULL;

// This is from the version for non-asm types
$CLASSNAME* $CLASSNAME::createType() {
  if (p_builtin_type == NULL) {
    p_builtin_type = new $CLASSNAME();
    ROSE_ASSERT(p_builtin_type != NULL);
  }
  return p_builtin_type;
}

SOURCE_BINARY_TYPE_BYTE_END

SOURCE_BINARY_TYPE_WORD_START

$CLASSNAME* $CLASSNAME::p_builtin_type = NULL;

// This is from the version for non-asm types
$CLASSNAME* $CLASSNAME::createType() {
  if (p_builtin_type == NULL) {
    p_builtin_type = new $CLASSNAME();
    ROSE_ASSERT(p_builtin_type != NULL);
  }
  return p_builtin_type;
}

SOURCE_BINARY_TYPE_WORD_END

SOURCE_BINARY_TYPE_DOUBLE_WORD_START

$CLASSNAME* $CLASSNAME::p_builtin_type = NULL;

// This is from the version for non-asm types
$CLASSNAME* $CLASSNAME::createType() {
  if (p_builtin_type == NULL) {
    p_builtin_type = new $CLASSNAME();
    ROSE_ASSERT(p_builtin_type != NULL);
  }
  return p_builtin_type;
}

SOURCE_BINARY_TYPE_DOUBLE_WORD_END

SOURCE_BINARY_TYPE_QUAD_WORD_START

$CLASSNAME* $CLASSNAME::p_builtin_type = NULL;

// This is from the version for non-asm types
$CLASSNAME* $CLASSNAME::createType() {
  if (p_builtin_type == NULL) {
    p_builtin_type = new $CLASSNAME();
    ROSE_ASSERT(p_builtin_type != NULL);
  }
  return p_builtin_type;
}

SOURCE_BINARY_TYPE_QUAD_WORD_END

SOURCE_BINARY_TYPE_DOUBLE_QUAD_WORD_START

$CLASSNAME* $CLASSNAME::p_builtin_type = NULL;

// This is from the version for non-asm types
$CLASSNAME* $CLASSNAME::createType() {
  if (p_builtin_type == NULL) {
    p_builtin_type = new $CLASSNAME();
    ROSE_ASSERT(p_builtin_type != NULL);
  }
  return p_builtin_type;
}

SOURCE_BINARY_TYPE_DOUBLE_QUAD_WORD_END

SOURCE_BINARY_TYPE_SINGLE_FLOAT_START

$CLASSNAME* $CLASSNAME::p_builtin_type = NULL;

// This is from the version for non-asm types
$CLASSNAME* $CLASSNAME::createType() {
  if (p_builtin_type == NULL) {
    p_builtin_type = new $CLASSNAME();
    ROSE_ASSERT(p_builtin_type != NULL);
  }
  return p_builtin_type;
}

SOURCE_BINARY_TYPE_SINGLE_FLOAT_END

SOURCE_BINARY_TYPE_DOUBLE_FLOAT_START

$CLASSNAME* $CLASSNAME::p_builtin_type = NULL;

// This is from the version for non-asm types
$CLASSNAME* $CLASSNAME::createType() {
  if (p_builtin_type == NULL) {
    p_builtin_type = new $CLASSNAME();
    ROSE_ASSERT(p_builtin_type != NULL);
  }
  return p_builtin_type;
}

SOURCE_BINARY_TYPE_DOUBLE_FLOAT_END


SOURCE_BINARY_TYPE_80bit_FLOAT_START
$CLASSNAME* $CLASSNAME::p_builtin_type = NULL;

// This is from the version for non-asm types
$CLASSNAME* $CLASSNAME::createType() {
  if (p_builtin_type == NULL) {
    p_builtin_type = new $CLASSNAME();
    ROSE_ASSERT(p_builtin_type != NULL);
  }
  return p_builtin_type;
}
       
SOURCE_BINARY_TYPE_80bit_FLOAT_END


SOURCE_BINARY_TYPE_128bit_FLOAT_START
$CLASSNAME* $CLASSNAME::p_builtin_type = NULL;

// This is from the version for non-asm types
$CLASSNAME* $CLASSNAME::createType() {
  if (p_builtin_type == NULL) {
    p_builtin_type = new $CLASSNAME();
    ROSE_ASSERT(p_builtin_type != NULL);
  }
  return p_builtin_type;
}
       
SOURCE_BINARY_TYPE_128bit_FLOAT_END


SOURCE_BINARY_TYPE_VECTOR_START

$CLASSNAME* $CLASSNAME::createType(int elementCount, SgAsmType* elementType) {
  // This does not need to be saved during file I/O, so it doesn't need to be a
  // class member
  static std::map<std::pair<int, SgAsmType*>, SgAsmTypeVector*> cache;
  std::pair<int, SgAsmType*> vectorInfo(elementCount, elementType);
  std::map<std::pair<int, SgAsmType*>, SgAsmTypeVector*>::const_iterator i = cache.find(vectorInfo);
  if (i != cache.end()) {
    return i->second;
  } else {
    SgAsmTypeVector* tv = new SgAsmTypeVector(elementCount, elementType);
    cache.insert(std::make_pair(vectorInfo, tv));
    return tv;
  }
}

SOURCE_BINARY_TYPE_VECTOR_END


SOURCE_BINARY_NODE_START

SOURCE_BINARY_NODE_END

SOURCE_BINARY_BYTE_VALUE_EXPRESSION_START

SgAsmType* $CLASSNAME::get_type() {
  return SgAsmTypeByte::createType();
}

SOURCE_BINARY_BYTE_VALUE_EXPRESSION_END

SOURCE_BINARY_DOUBLE_FLOAT_VALUE_EXPRESSION_START

SgAsmType* $CLASSNAME::get_type() {
  return SgAsmTypeDoubleFloat::createType();
}

SOURCE_BINARY_DOUBLE_FLOAT_VALUE_EXPRESSION_END

SOURCE_BINARY_DOUBLE_WORD_VALUE_EXPRESSION_START

SgAsmType* $CLASSNAME::get_type() {
  return SgAsmTypeDoubleWord::createType();
}

SOURCE_BINARY_DOUBLE_WORD_VALUE_EXPRESSION_END

SOURCE_BINARY_QUAD_WORD_VALUE_EXPRESSION_START

SgAsmType* $CLASSNAME::get_type() {
  return SgAsmTypeQuadWord::createType();
}

SOURCE_BINARY_QUAD_WORD_VALUE_EXPRESSION_END

SOURCE_BINARY_SINGLE_FLOAT_VALUE_EXPRESSION_START

SgAsmType* $CLASSNAME::get_type() {
  return SgAsmTypeSingleFloat::createType();
}

SOURCE_BINARY_SINGLE_FLOAT_VALUE_EXPRESSION_END

SOURCE_BINARY_VECTOR_VALUE_EXPRESSION_START

// Note that the auto-generated version of this is const
SgAsmType* SgAsmVectorValueExpression::get_type() {
  return p_type;
}

SOURCE_BINARY_VECTOR_VALUE_EXPRESSION_END

SOURCE_BINARY_WORD_VALUE_EXPRESSION_START

SgAsmType* $CLASSNAME::get_type() {
  return SgAsmTypeWord::createType();
}

SOURCE_BINARY_WORD_VALUE_EXPRESSION_END

SOURCE_BINARY_REGISTER_REFERENCE_EXPRESSION_START

// Note that the auto-generated version of this is const
SgAsmType* SgAsmRegisterReferenceExpression::get_type() {
  ROSE_ASSERT (false);
}

SOURCE_BINARY_REGISTER_REFERENCE_EXPRESSION_END

SOURCE_BINARY_X86_REGISTER_REFERENCE_EXPRESSION_START

// Note that the auto-generated version of this is const
SgAsmType* SgAsmx86RegisterReferenceExpression::get_type() {
  return p_type;
}

std::pair<X86RegisterClass, int>
SgAsmx86RegisterReferenceExpression::get_identifier() const {
  return std::make_pair(this->get_register_class(), this->get_register_number());
}

SOURCE_BINARY_X86_REGISTER_REFERENCE_EXPRESSION_END

SOURCE_BINARY_ARM_REGISTER_REFERENCE_EXPRESSION_START

// Note that the auto-generated version of this is const
SgAsmType* SgAsmArmRegisterReferenceExpression::get_type() {
  return p_type;
}

SOURCE_BINARY_ARM_REGISTER_REFERENCE_EXPRESSION_END

SOURCE_BINARY_POWERPC_REGISTER_REFERENCE_EXPRESSION_START

// Note that the auto-generated version of this is const
SgAsmType*
SgAsmPowerpcRegisterReferenceExpression::get_type()
   {
     return p_type;
   }

SOURCE_BINARY_POWERPC_REGISTER_REFERENCE_EXPRESSION_END

SOURCE_BINARY_MEMORY_REFERENCE_EXPRESSION_START

// Note that the auto-generated version of this is const
SgAsmType* SgAsmMemoryReferenceExpression::get_type() {
  return p_type;
}

SOURCE_BINARY_MEMORY_REFERENCE_EXPRESSION_END










// *************************************
//      Binary File Format Support
// *************************************

SOURCE_EXECUTABLE_FILE_FORMAT_START
SOURCE_EXECUTABLE_FILE_FORMAT_END



SOURCE_GENERIC_SECTION_START
SOURCE_GENERIC_SECTION_END



SOURCE_GENERIC_HEADER_START

SgAsmGenericHeader::SgAsmGenericHeader(SgAsmGenericFile *ef, addr_t offset, addr_t size)
   : SgAsmGenericSection(ef, NULL, offset, size),
     p_exec_format(NULL), p_isa(ISA_OTHER), p_base_va(0), p_dlls(NULL), p_symbols(NULL), p_sections(NULL)
   {
     ctor(ef, offset, size);
   }

const char *
SgAsmGenericHeader::format_name() const
   {
     return "ASM_GENERIC_HEADER";
   }

SgAsmGenericSymbolPtrList & 
SgAsmGenericHeader::get_symbol_list()
   {
     ROSE_ASSERT(p_symbols != NULL);
     return p_symbols->get_symbols();
   }

SgAsmGenericFormat::ByteOrder
SgAsmGenericHeader::get_sex() const
   {
     ROSE_ASSERT(p_exec_format != NULL);
     return p_exec_format->get_sex();
   }

size_t
SgAsmGenericHeader::get_word_size() const
   {
     ROSE_ASSERT(p_exec_format != NULL);
     return p_exec_format->get_word_size();
   }

SOURCE_GENERIC_HEADER_END

SOURCE_GENERIC_FILE_START
SOURCE_GENERIC_FILE_END

SOURCE_GENERIC_FORMAT_START
SOURCE_GENERIC_FORMAT_END

SOURCE_GENERIC_ARCHITECTURE_START
SOURCE_GENERIC_ARCHITECTURE_END

SOURCE_GENERIC_SYMBOL_START
SOURCE_GENERIC_SYMBOL_END

SOURCE_GENERIC_SYMBOL_LIST_START
SOURCE_GENERIC_SYMBOL_LIST_END

SOURCE_GENERIC_DLL_START

SgAsmGenericDLL::SgAsmGenericDLL(SgAsmGenericString *s)
    : p_name(s)
    {
	s->set_parent(this);
    }

SOURCE_GENERIC_DLL_END

SOURCE_GENERIC_DLL_LIST_START
SOURCE_GENERIC_DLL_LIST_END

SOURCE_BASIC_STRING_START
SOURCE_BASIC_STRING_END

SOURCE_GENERIC_STRING_START
SOURCE_GENERIC_STRING_END

SOURCE_STRING_STORAGE_START
SOURCE_STRING_STORAGE_END

SOURCE_STORED_STRING_START
SOURCE_STORED_STRING_END

SOURCE_ELF_HEADER_START

const char *
SgAsmElfFileHeader::format_name() const
   {
     return "ELF";
   }


SOURCE_ELF_HEADER_END

SOURCE_ELF_SECTION_TABLE_START
SOURCE_ELF_SECTION_TABLE_END



SOURCE_ELF_STRING_SECTION_START
	SgAsmElfStringSection::SgAsmElfStringSection(SgAsmElfFileHeader *fhdr)
		: SgAsmElfSection(fhdr), p_strtab(NULL)
		{ctor();}
SOURCE_ELF_STRING_SECTION_END



SOURCE_ELF_SECTION_TABLE_ENTRY_START
SgAsmElfSectionTableEntry::SgAsmElfSectionTableEntry(SgAsmExecutableFileFormat::ByteOrder sex, const SgAsmElfSectionTableEntry::Elf32SectionTableEntry_disk *disk)
   {
     ctor(sex, disk);
   }

SgAsmElfSectionTableEntry::SgAsmElfSectionTableEntry(SgAsmExecutableFileFormat::ByteOrder sex, const SgAsmElfSectionTableEntry::Elf64SectionTableEntry_disk *disk)
   {
     ctor(sex, disk);
   }

SOURCE_ELF_SECTION_TABLE_ENTRY_END

SOURCE_ELF_SEGMENT_TABLE_ENTRY_LIST_START
SOURCE_ELF_SEGMENT_TABLE_ENTRY_LIST_END

SOURCE_ELF_SECTION_START
/* Constructor for a non-attached, not-parsed Elf section */
SgAsmElfSection::SgAsmElfSection(SgAsmGenericHeader *fhdr)
   : SgAsmGenericSection(fhdr->get_file(), fhdr),
     p_linked_section(NULL), p_section_entry(NULL), p_segment_entry(NULL)
   {
     ctor();
   }

// DQ (8/22/2008): These are not automatically generated since one of them must be virtual.
SgAsmElfSection* 
SgAsmElfSection::get_linked_section () const
   {
     ROSE_ASSERT (this != NULL);
     return p_linked_section;
   }

// DQ (8/22/2008): These are not automatically generated since one of them must be virtual.
void
SgAsmElfSection::set_linked_section ( SgAsmElfSection* linked_section )
   {
     ROSE_ASSERT (this != NULL);
     set_isModified(true);

#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_linked_section != NULL && linked_section != NULL && p_linked_section != linked_section)
        {
          printf ("Warning: linked_section = %p overwriting valid pointer p_linked_section = %p \n",linked_section,p_linked_section);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_linked_section != NULL && linked_section != NULL && p_linked_section != linked_section) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_linked_section = linked_section;
   }

SOURCE_ELF_SECTION_END

SOURCE_ELF_STRING_TABLE_START
SOURCE_ELF_STRING_TABLE_END

SOURCE_ELF_DYNAMIC_SECTION_START
SOURCE_ELF_DYNAMIC_SECTION_END

SOURCE_ELF_DYNAMIC_ENTRY_START
SOURCE_ELF_DYNAMIC_ENTRY_END

SOURCE_ELF_SEGMENT_TABLE_START
SOURCE_ELF_SEGMENT_TABLE_END

SOURCE_ELF_SEGMENT_TABLE_ENTRY_START
SgAsmElfSegmentTableEntry::SgAsmElfSegmentTableEntry(SgAsmExecutableFileFormat::ByteOrder sex, const SgAsmElfSegmentTableEntry::Elf32SegmentTableEntry_disk *disk)
   {
     ctor(sex, disk);
   }

SgAsmElfSegmentTableEntry::SgAsmElfSegmentTableEntry(SgAsmExecutableFileFormat::ByteOrder sex, const SgAsmElfSegmentTableEntry::Elf64SegmentTableEntry_disk *disk)
   {
     ctor(sex, disk);
   }

SOURCE_ELF_SEGMENT_TABLE_ENTRY_END

SOURCE_ELF_SEGMENT_ENTRY_START
SOURCE_ELF_SEGMENT_ENTRY_END

SOURCE_ELF_SEGMENT_ENTRY_LIST_START
SOURCE_ELF_SEGMENT_ENTRY_LIST_END

SOURCE_ELF_SYMBOL_SECTION_START
SOURCE_ELF_SYMBOL_SECTION_END

SOURCE_ELF_SYMBOL_LIST_START
SOURCE_ELF_SYMBOL_LIST_END

SOURCE_ELF_SYMBOL_START
SgAsmElfSymbol::SgAsmElfSymbol(SgAsmExecutableFileFormat::ByteOrder sex, const SgAsmElfSymbol::Elf32SymbolEntry_disk *disk)
   {
     ctor(sex, disk);
   }

SgAsmElfSymbol::SgAsmElfSymbol(SgAsmExecutableFileFormat::ByteOrder sex, const SgAsmElfSymbol::Elf64SymbolEntry_disk *disk)
   {
     ctor(sex, disk);
   }
SOURCE_ELF_SYMBOL_END


SOURCE_PE_RVA_SIZE_PAIR_START
SgAsmPERVASizePair::SgAsmPERVASizePair(const SgAsmPERVASizePair::RVASizePair_disk *disk)
   {
     p_e_rva  = le_to_host(disk->e_rva);
     p_e_size = le_to_host(disk->e_size);
   }

void*
SgAsmPERVASizePair::encode(SgAsmPERVASizePair::RVASizePair_disk *disk) const
   {
     host_to_le(p_e_rva,  &(disk->e_rva));
     host_to_le(p_e_size, &(disk->e_size));

     return disk;
   }

SOURCE_PE_RVA_SIZE_PAIR_END


SOURCE_PE_RVA_SIZE_PAIR_LIST_START
SOURCE_PE_RVA_SIZE_PAIR_LIST_END


SOURCE_PE_FILE_HEADER_START
SOURCE_PE_FILE_HEADER_END

SOURCE_PE_SECTION_START
SOURCE_PE_SECTION_END

SOURCE_PE_SECTION_TABLE_START
SOURCE_PE_SECTION_TABLE_END

SOURCE_PE_COFF_SYMBOL_TABLE_START
SgAsmCoffSymbolTable::SgAsmCoffSymbolTable(SgAsmPEFileHeader *fhdr)
   : SgAsmGenericSection(fhdr->get_file(), fhdr, fhdr->get_e_coff_symtab(),
	                 fhdr->get_e_coff_nsyms() * SgAsmCoffSymbol::COFFSymbol_disk_size)
   {
     ctor();
   }

SOURCE_PE_COFF_SYMBOL_TABLE_END

SOURCE_PE_IMPORT_HINT_NAME_START
SOURCE_PE_IMPORT_HINT_NAME_END

SOURCE_PE_IMPORT_DIRECTORY_START
SOURCE_PE_IMPORT_DIRECTORY_END

SOURCE_PE_SECTION_TABLE_ENTRY_START
SgAsmPESectionTableEntry::SgAsmPESectionTableEntry(const SgAsmPESectionTableEntry::PESectionTableEntry_disk *disk)
   {
     ctor(disk);
   }

SOURCE_PE_SECTION_TABLE_ENTRY_END

SOURCE_PE_COFF_SYMBOL_START
SgAsmCoffSymbol::SgAsmCoffSymbol(SgAsmPEFileHeader *fhdr, SgAsmGenericSection *symtab, SgAsmGenericSection *strtab, size_t idx)
   : p_st_name_offset(0), p_st_section_num(0), p_st_type(0), p_st_storage_class(0), p_st_num_aux_entries(0)
   {
     ctor(fhdr, symtab, strtab, idx);
   }

SOURCE_PE_COFF_SYMBOL_END

SOURCE_COFF_STRING_TABLE_START
SOURCE_COFF_STRING_TABLE_END

SOURCE_NE_FILE_HEADER_START

SgAsmNEFileHeader::SgAsmNEFileHeader(SgAsmGenericFile *f, addr_t offset)
   : SgAsmGenericHeader(f, offset, sizeof(SgAsmNEFileHeader::NEFileHeader_disk)), p_dos2_header(NULL), p_section_table(NULL), p_resname_table(NULL), p_nonresname_table(NULL), p_module_table(NULL), p_entry_table(NULL)
   {
     ctor(f, offset);
   }

const char *
SgAsmNEFileHeader::format_name() const
   {
     return "NE";
   }

#if 0
bool
SgAsmNEFileHeader::is_NE(SgAsmGenericFile *f)
{
    printf ("SgAsmNEFileHeader::is_PE() member function incomplete! \n");
    ROSE_ASSERT(false);

    return true;
}
#endif

#if 0
// Parses the structure of an ELF file and adds the info to the SgAsmGenericFile
SgAsmNEFileHeader *
SgAsmNEFileHeader::parse(SgAsmGenericFile *ef)
{
    ROSE_ASSERT(ef);
    
    printf ("SgAsmNEFileHeader::parse() member function incomplete! \n");
    ROSE_ASSERT(false);

    return NULL;
}
#endif

SOURCE_NE_FILE_HEADER_END

SOURCE_NE_SECTION_START
SgAsmNESection::SgAsmNESection(SgAsmNEFileHeader *fhdr, addr_t offset, addr_t size)
   : SgAsmGenericSection(fhdr->get_file(), fhdr, offset, size), p_st_entry(NULL), p_reloc_table(NULL)
   {
   }

SOURCE_NE_SECTION_END

SOURCE_NE_SECTION_TABLE_START
SgAsmNESectionTable::SgAsmNESectionTable(SgAsmNEFileHeader *fhdr)
   : SgAsmGenericSection(fhdr->get_file(), fhdr, fhdr->get_end_offset(),
                         fhdr->get_e_nsections() * sizeof(SgAsmNESectionTableEntry::NESectionTableEntry_disk))
   {
     ctor();
   }

SOURCE_NE_SECTION_TABLE_END

SOURCE_NE_NAME_TABLE_START
SgAsmNENameTable::SgAsmNENameTable(SgAsmNEFileHeader *fhdr, addr_t offset)
   : SgAsmGenericSection(fhdr->get_file(), fhdr, offset, 0)
   {
     ctor();
   }

SOURCE_NE_NAME_TABLE_END

SOURCE_NE_MODULE_TABLE_START
SgAsmNEModuleTable::SgAsmNEModuleTable(SgAsmNEFileHeader *fhdr, addr_t offset, addr_t size, SgAsmNEStringTable *strtab)
   : SgAsmGenericSection(fhdr->get_file(), fhdr, offset, size), p_strtab(strtab)
   {
     ctor();
   }

SOURCE_NE_MODULE_TABLE_END

SOURCE_NE_STRING_TABLE_START
SgAsmNEStringTable::SgAsmNEStringTable(SgAsmNEFileHeader *fhdr, addr_t offset, addr_t length)
   : SgAsmGenericSection(fhdr->get_file(), fhdr, offset, length)
   {
     ctor();
   }

SOURCE_NE_STRING_TABLE_END

SOURCE_NE_ENTRY_TABLE_START
SgAsmNEEntryTable::SgAsmNEEntryTable(SgAsmNEFileHeader *fhdr, addr_t offset, addr_t size)
   : SgAsmGenericSection(fhdr->get_file(), fhdr, offset, size)
   {
     ctor();
   }

SOURCE_NE_ENTRY_TABLE_END

SOURCE_NE_RELOC_TABLE_START
SgAsmNERelocTable::SgAsmNERelocTable(SgAsmNEFileHeader *fhdr, addr_t offset)
   : SgAsmGenericSection(fhdr->get_file(), fhdr, offset, 0)
   {
     ctor();
   }

SOURCE_NE_RELOC_TABLE_END



SOURCE_NE_ENTRY_POINT_START

//SgAsmNEEntryPoint::SgAsmNEEntryPoint()
//   : p_flags((SgAsmNEEntryPoint::EF_ZERO), p_int3f(0), p_section_idx(0), p_section_offset(0)
//   {}

SgAsmNEEntryPoint::SgAsmNEEntryPoint(SgAsmNEEntryPoint::NEEntryFlags flags, unsigned int3f, unsigned s_idx, unsigned s_off)
   : p_flags(flags), p_int3f(int3f), p_section_idx(s_idx), p_section_offset(s_off)
   {
   }

SOURCE_NE_ENTRY_POINT_END

SOURCE_NE_RELOC_ENTRY_START
SgAsmNERelocEntry::SgAsmNERelocEntry(SgAsmGenericSection *relocs, addr_t at, addr_t *rec_size)
   {
     ctor(relocs, at, rec_size);
   }

SOURCE_NE_RELOC_ENTRY_END

SOURCE_NE_SECTION_TABLE_ENTRY_START
SgAsmNESectionTableEntry::SgAsmNESectionTableEntry(const SgAsmNESectionTableEntry::NESectionTableEntry_disk *disk)
   {
     ctor(disk);
   }

SOURCE_NE_SECTION_TABLE_ENTRY_END



SOURCE_LE_FILE_HEADER_START

SgAsmLEFileHeader::SgAsmLEFileHeader(SgAsmGenericFile *f, addr_t offset)
   : SgAsmGenericHeader(f, offset, sizeof(SgAsmLEFileHeader::LEFileHeader_disk)), p_dos2_header(NULL), p_section_table(NULL), p_page_table(NULL), p_resname_table(NULL), p_nonresname_table(NULL), p_entry_table(NULL), p_reloc_table(NULL)
   {
     ctor(f, offset);
   }

#if 0
// The correct implementation is more complex than this code below and is implemented in ROSE_ExecLE.C.
const char *
SgAsmLEFileHeader::format_name() const
   {
     return "LE";
   }
#endif


#if 0
bool
SgAsmLEFileHeader::is_LE(SgAsmGenericFile *f)
{
    printf ("SgAsmLEFileHeader::is_PE() member function incomplete! \n");
    ROSE_ASSERT(false);

    return true;
}
#endif

#if 0
// Parses the structure of an ELF file and adds the info to the SgAsmGenericFile
SgAsmLEFileHeader *
SgAsmLEFileHeader::parse(SgAsmGenericFile *ef)
{
    ROSE_ASSERT(ef);
    
    printf ("SgAsmLEFileHeader::parse() member function incomplete! \n");
    ROSE_ASSERT(false);

    return NULL;
}
#endif

SOURCE_LE_FILE_HEADER_END

SOURCE_LE_SECTION_START
SgAsmLESection::SgAsmLESection(SgAsmLEFileHeader *fhdr, addr_t offset, addr_t size)
   : SgAsmGenericSection(fhdr->get_file(), fhdr, offset, size), p_st_entry(NULL)
   {
   }

SOURCE_LE_SECTION_END

SOURCE_LE_SECTION_TABLE_START
SgAsmLESectionTable::SgAsmLESectionTable(SgAsmLEFileHeader *fhdr, addr_t offset, addr_t size)
   : SgAsmGenericSection(fhdr->get_file(), fhdr, offset, size)
   {
     ctor();
   }

SOURCE_LE_SECTION_TABLE_END

SOURCE_LE_NAME_TABLE_START
SgAsmLENameTable::SgAsmLENameTable(SgAsmLEFileHeader *fhdr, addr_t offset)
   : SgAsmGenericSection(fhdr->get_file(), fhdr, offset, 0)
   {
     ctor();
   }

SOURCE_LE_NAME_TABLE_END

SOURCE_LE_PAGE_TABLE_START
SgAsmLEPageTable::SgAsmLEPageTable(SgAsmLEFileHeader *fhdr, addr_t offset, addr_t size)
   : SgAsmGenericSection(fhdr->get_file(), fhdr, offset, size)
   {
     ctor();
   }

SOURCE_LE_PAGE_TABLE_END

SOURCE_LE_ENTRY_TABLE_START
SgAsmLEEntryTable::SgAsmLEEntryTable(SgAsmLEFileHeader *fhdr, addr_t offset)
   : SgAsmGenericSection(fhdr->get_file(), fhdr, offset, 0)
   {
     ctor();
   }

SOURCE_LE_ENTRY_TABLE_END

SOURCE_LE_RELOC_TABLE_START
SgAsmLERelocTable::SgAsmLERelocTable(SgAsmLEFileHeader *fhdr, addr_t offset)
   : SgAsmGenericSection(fhdr->get_file(), fhdr, offset, 0)
   {
     ctor();
   }

SOURCE_LE_RELOC_TABLE_END

SOURCE_LE_PAGE_TABLE_ENTRY_START
SgAsmLEPageTableEntry::SgAsmLEPageTableEntry(SgAsmExecutableFileFormat::ByteOrder sex, const SgAsmLEPageTableEntry::LEPageTableEntry_disk *disk)
   : p_pageno(0), p_flags(0)
   {
     ctor(sex, disk);
   }

SOURCE_LE_PAGE_TABLE_ENTRY_END

SOURCE_LE_ENTRY_POINT_START
SgAsmLEEntryPoint::SgAsmLEEntryPoint(SgAsmExecutableFileFormat::ByteOrder sex, const SgAsmLEEntryPoint::LEEntryPoint_disk *disk)
   : p_flags(0), p_objnum(0), p_entry_type(0), p_res1(0), p_entry_offset(0)
   {
     ctor(sex, disk);
   }

SgAsmLEEntryPoint::SgAsmLEEntryPoint(SgAsmExecutableFileFormat::ByteOrder sex, unsigned flags)
   : p_flags(flags), p_objnum(0), p_entry_type(0), p_res1(0), p_entry_offset(0)
   {
   }

SOURCE_LE_ENTRY_POINT_END

SOURCE_LE_SECTION_TABLE_ENTRY_START
SgAsmLESectionTableEntry::SgAsmLESectionTableEntry(SgAsmExecutableFileFormat::ByteOrder sex, const SgAsmLESectionTableEntry::LESectionTableEntry_disk *disk)
   {
     ctor(sex, disk);
   }

SOURCE_LE_SECTION_TABLE_ENTRY_END



SOURCE_DOS_HEADER_START
SOURCE_DOS_HEADER_END



SOURCE_DWARF_INFORMATION_START
SOURCE_DWARF_INFORMATION_END

SOURCE_DWARF_COMPILATION_UNIT_START

SgAsmDwarfConstructList*
SgAsmDwarfCompilationUnit::get_children()
   {
     ROSE_ASSERT(this != NULL);

     if (p_language_constructs == NULL)
          p_language_constructs = new SgAsmDwarfConstructList();

     return p_language_constructs;
   }

SOURCE_DWARF_COMPILATION_UNIT_END

SOURCE_DWARF_COMPILATION_UNIT_LIST_START
SOURCE_DWARF_COMPILATION_UNIT_LIST_END

SOURCE_DWARF_MACRO_START
SOURCE_DWARF_MACRO_END

SOURCE_DWARF_LINE_START
SOURCE_DWARF_LINE_END

SOURCE_DWARF_MACRO_LIST_START
SOURCE_DWARF_MACRO_LIST_END

SOURCE_DWARF_LINE_LIST_START

DwarfInstructionSourceMapReturnType
SgAsmDwarfLineList::buildInstructionAddressSourcePositionMaps( SgAsmDwarfCompilationUnit* dwarf_cu )
   {
  // SgInstructionAddressSourcePositionMapPtrList* instruction_source_code_map = new SgInstructionAddressSourcePositionMapPtrList;
  // SgSourcePositionInstructionAddressMapPtrList* source_code_instruction_map = new SgSourcePositionInstructionAddressMapPtrList;

  // Build this as static local data
     static SgInstructionAddressSourcePositionMapPtrList* instruction_source_code_map = NULL;

     bool recomputeMap = false;
     if (instruction_source_code_map == NULL)
        {
          recomputeMap = true;
          instruction_source_code_map = new SgInstructionAddressSourcePositionMapPtrList;
        }

     ROSE_ASSERT(instruction_source_code_map != NULL);

     static SgSourcePositionInstructionAddressMapPtrList* source_code_instruction_map = NULL;
     if (source_code_instruction_map == NULL)
          source_code_instruction_map = new SgSourcePositionInstructionAddressMapPtrList;
     ROSE_ASSERT(source_code_instruction_map != NULL);

     if (recomputeMap == true)
        {
          ROSE_ASSERT(dwarf_cu != NULL);
          ROSE_ASSERT(dwarf_cu->get_line_info() != NULL);

          SgAsmDwarfLinePtrList & line_list = dwarf_cu->get_line_info()->get_line_list();

          int listSize = (int) line_list.size();
          for (int i = 0; i < listSize; i++)
             {
            // Loop over each of the entries in the Dwarf line section.
               uint64_t address = line_list[i]->get_address();

            // Note that file_id values are already in terms of the Sg_File_Info maps 
            // between file name integers and file name strings.
               int file_id      = line_list[i]->get_file_id();

               int line         = line_list[i]->get_line();
               int column       = line_list[i]->get_column();

            // printf ("address = 0x%lx file_id = %d line = %d  column = %d \n",address,file_id,line,column);

               FileIdLineColumnFilePosition file_info(file_id,std::pair<int,int>(line,column));

            // This works for stp::map, but for std::multimap
            // instruction_source_code_map->operator[](address)   = file_info;
            // source_code_instruction_map->operator[](file_info) = address;

            // This is the std::multiset version ...
               instruction_source_code_map->insert(AddressFileIdLineColumnFilePositionPair(address,file_info));
               source_code_instruction_map->insert(FileIdLineColumnFilePositionAddressPair(file_info,address));
             }
        }
       else
        {
       // printf ("Maps were computed previously \n");
        }

     DwarfInstructionSourceMapReturnType returnValue(instruction_source_code_map,source_code_instruction_map);

     return returnValue;
   }

SOURCE_DWARF_LINE_LIST_END

SOURCE_DWARF_CONSTRUCT_START

SgAsmDwarfConstructList*
SgAsmDwarfConstruct::get_children()
   {
     ROSE_ASSERT(this != NULL);

#if 0
     printf ("Error: base class of virtual function called by mistake: class_name = %s \n",class_name().c_str());
     ROSE_ASSERT(false);
#else
     printf ("Warning: base class of virtual function called by mistake: class_name = %s \n",class_name().c_str());
#endif
     return NULL;
   }

SOURCE_DWARF_CONSTRUCT_END

SOURCE_DWARF_CONSTRUCT_LIST_START
SOURCE_DWARF_CONSTRUCT_LIST_END

SOURCE_DWARF_SUBPROGRAM_START

SgAsmDwarfConstructList*
SgAsmDwarfSubprogram::get_children()
   {
     ROSE_ASSERT(this != NULL);

     if (p_body == NULL)
          p_body = new SgAsmDwarfConstructList();

     return p_body;
   }

SOURCE_DWARF_SUBPROGRAM_END

SOURCE_DWARF_STRUCTURE_TYPE_START

SgAsmDwarfConstructList*
SgAsmDwarfStructureType::get_children()
   {
     ROSE_ASSERT(this != NULL);

     if (p_body == NULL)
          p_body = new SgAsmDwarfConstructList();

     return p_body;
   }

SOURCE_DWARF_STRUCTURE_TYPE_END

SOURCE_DWARF_ARRAY_TYPE_START

SgAsmDwarfConstructList*
SgAsmDwarfArrayType::get_children()
   {
     ROSE_ASSERT(this != NULL);

     if (p_body == NULL)
          p_body = new SgAsmDwarfConstructList();

     return p_body;
   }

SOURCE_DWARF_ARRAY_TYPE_END


SOURCE_DWARF_LEXICAL_BLOCK_START

SgAsmDwarfConstructList*
SgAsmDwarfLexicalBlock::get_children()
   {
     ROSE_ASSERT(this != NULL);

     if (p_body == NULL)
          p_body = new SgAsmDwarfConstructList();

     return p_body;
   }

SOURCE_DWARF_LEXICAL_BLOCK_END


SOURCE_DWARF_INLINED_SUBROUTINE_START

SgAsmDwarfConstructList*
SgAsmDwarfInlinedSubroutine::get_children()
   {
     ROSE_ASSERT(this != NULL);

     if (p_body == NULL)
          p_body = new SgAsmDwarfConstructList();

     return p_body;
   }

SOURCE_DWARF_INLINED_SUBROUTINE_END


SOURCE_DWARF_ENUMERATION_TYPE_START

SgAsmDwarfConstructList*
SgAsmDwarfEnumerationType::get_children()
   {
     ROSE_ASSERT(this != NULL);

     if (p_body == NULL)
          p_body = new SgAsmDwarfConstructList();

     return p_body;
   }

SOURCE_DWARF_ENUMERATION_TYPE_END


SOURCE_DWARF_SUBROUTINE_TYPE_START

SgAsmDwarfConstructList*
SgAsmDwarfSubroutineType::get_children()
   {
     ROSE_ASSERT(this != NULL);

     if (p_body == NULL)
          p_body = new SgAsmDwarfConstructList();

     return p_body;
   }

SOURCE_DWARF_SUBROUTINE_TYPE_END


SOURCE_DWARF_UNION_TYPE_START

SgAsmDwarfConstructList*
SgAsmDwarfUnionType::get_children()
   {
     ROSE_ASSERT(this != NULL);

     if (p_body == NULL)
          p_body = new SgAsmDwarfConstructList();

     return p_body;
   }

SOURCE_DWARF_UNION_TYPE_END


SOURCE_DWARF_NAMESPACE_START

SgAsmDwarfConstructList*
SgAsmDwarfNamespace::get_children()
   {
     ROSE_ASSERT(this != NULL);

     if (p_body == NULL)
          p_body = new SgAsmDwarfConstructList();

     return p_body;
   }

SOURCE_DWARF_NAMESPACE_END


SOURCE_DWARF_CLASS_TYPE_START

SgAsmDwarfConstructList*
SgAsmDwarfClassType::get_children()
   {
     ROSE_ASSERT(this != NULL);

     if (p_body == NULL)
          p_body = new SgAsmDwarfConstructList();

     return p_body;
   }

SOURCE_DWARF_CLASS_TYPE_END


SOURCE_DWARF_COMMON_BLOCK_START

SgAsmDwarfConstructList*
SgAsmDwarfCommonBlock::get_children()
   {
     ROSE_ASSERT(this != NULL);

     if (p_body == NULL)
          p_body = new SgAsmDwarfConstructList();

     return p_body;
   }

SOURCE_DWARF_COMMON_BLOCK_END



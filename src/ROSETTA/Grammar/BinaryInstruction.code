// #########################################################
// #########################################################
//                      HEADER CODE
// #########################################################
// #########################################################



HEADER_BINARY_X86_INSTRUCTION_PREDECLARATION_START
#include "x86InstructionEnum.h"
HEADER_BINARY_X86_INSTRUCTION_PREDECLARATION_END

HEADER_BINARY_ARM_INSTRUCTION_PREDECLARATION_START
#include "armInstructionEnum.h"
HEADER_BINARY_ARM_INSTRUCTION_PREDECLARATION_END

HEADER_BINARY_START

 /*  This class forms a base class for all of the types represented in the Asm Instruction grammar.
     All Asm Instructions are derived from this class and thus contain the following functionality.
  */

  public:

HEADER_BINARY_END


HEADER_BINARY_INSTRUCTION_START
  public:
   SgAsmInstruction* cfgBinFlowOutEdge(const VirtualBinCFG::AuxiliaryInformation* info);
   std::vector<VirtualBinCFG::CFGEdge> cfgBinOutEdges(const VirtualBinCFG::AuxiliaryInformation* info);
   std::vector<VirtualBinCFG::CFGEdge> cfgBinInEdges(const VirtualBinCFG::AuxiliaryInformation* info);
   void append_sources( SgAsmInstruction* instruction );	
HEADER_BINARY_INSTRUCTION_END


HEADER_BINARY_FILE_START

       // enums for ELF header information

       // unsigned char	e_ident[EI_NIDENT]
       // typedef unsigned char magic_number_vector_type[EI_NIDENT];

       // Executable and Linking Format class kind
          enum elf_class_kind_enum
             {
               e_class_error   = 0,
               e_class_unknown = 1,
               e_class_none    = 2, // value maps to ELFCLASSNONE
               e_class_32      = 3, // value maps to ELFCLASS32
               e_class_64      = 4, // value maps to ELFCLASS64
               e_class_last
             };

          enum elf_data_encoding_enum
             {
               e_data_encoding_error                  = 0,
               e_data_encoding_unknown                = 1,
               e_data_encoding_none                   = 2, // value maps to ELFDATANONE
               e_data_encoding_least_significant_byte = 3, // value maps to ELFDATA2LSB
               e_data_encoding_most_significant_byte  = 4, // value maps to ELFDATA2MSB
               e_data_encoding_last
             };

          enum elf_version_enum
             {
               e_version_error   = 0,
               e_version_unknown = 1,
               e_version_none    = 2, // value maps to EV_NONE
               e_version_current = 3, // value maps to EV_CURRENT
               e_version_last
             };


          enum elf_OS_ABI_identification_enum
             {
               e_OS_ABI_error      = 0,
               e_OS_ABI_unknown    = 1,
               e_OS_ABI_none       = 2,
               e_OS_ABI_SYSV       = 3, // Note that ELFOSABI_SYSV == ELFOSABI_NONE (the two are alised)
               e_OS_ABI_HPUX       = 4,
               e_OS_ABI_NETBSD     = 5,
               e_OS_ABI_LINUX      = 6,
               e_OS_ABI_SOLARIS    = 7,
               e_OS_ABI_AIX        = 8,
               e_OS_ABI_IRIX       = 9,
               e_OS_ABI_FREEBSD    = 10,
               e_OS_ABI_TRU64      = 11,
               e_OS_ABI_MODESTO    = 12,
               e_OS_ABI_OPENBSD    = 13,
               e_OS_ABI_ARM        = 14,
               e_OS_ABI_STANDALONE = 15,
               e_OS_ABI_last
             };

          enum elf_object_file_type_enum
             {
               e_file_type_error       = 0,
               e_file_type_unknown     = 1,
               e_file_type_none        = 2,
               e_file_type_relocatable = 3,
               e_file_type_executable  = 4,
               e_file_type_shared      = 5,
               e_file_type_core        = 6,
               e_file_type_last
             };


       // DQ (1/8/2008): For a collection of interesting binaries go to: http://www.distributed.net/source/
          enum elf_machine_architecture_enum
             {
               e_machine_architecture_error                    = 0,
               e_machine_architecture_unknown                  = 1,
               e_machine_architecture_none                     = 2, // Maps to EM_NONE
               e_machine_architecture_ATT_WE_32100             = 3,
               e_machine_architecture_Sun_Sparc                = 4,
               e_machine_architecture_Intel_80386              = 5,
               e_machine_architecture_Motorola_m68k_family     = 6,
               e_machine_architecture_Motorola_m88k_family     = 7,
               e_machine_architecture_Intel_80860              = 8,
               e_machine_architecture_MIPS_R3000_big_endian    = 9,
               e_machine_architecture_IBM_System_370           = 10,
               e_machine_architecture_MIPS_R3000_little_endian = 11,
               e_machine_architecture_HPPA                     = 12,
               e_machine_architecture_Fujitsu_VPP500           = 13,
               e_machine_architecture_Sun_v8plus               = 14,
               e_machine_architecture_Intel_80960              = 15,
               e_machine_architecture_PowerPC                  = 16,
               e_machine_architecture_PowerPC_64bit            = 17,
               e_machine_architecture_IBM_S390                 = 18,
               e_machine_architecture_NEC_V800_series          = 19,
               e_machine_architecture_Fujitsu_FR20             = 20,
               e_machine_architecture_TRW_RH_32                = 21,
               e_machine_architecture_Motorola_RCE             = 22,
               e_machine_architecture_ARM                      = 23,
               e_machine_architecture_Digital_Alpha_fake       = 24,
               e_machine_architecture_Hitachi_SH               = 25,
               e_machine_architecture_SPARC_v9_64bit           = 26,
               e_machine_architecture_Siemens_Tricore          = 27,
               e_machine_architecture_Argonaut_RISC_Core       = 28,
               e_machine_architecture_Hitachi_H8_300           = 29,
               e_machine_architecture_Hitachi_H8_300H          = 30,
               e_machine_architecture_Hitachi_H8S              = 31,
               e_machine_architecture_Hitachi_H8_500           = 32,
               e_machine_architecture_Intel_Merced             = 33,
               e_machine_architecture_Stanford_MIPS_X          = 34,
               e_machine_architecture_Motorola_Coldfire        = 35,
               e_machine_architecture_Motorola_M68HC12         = 36,
               e_machine_architecture_Fujitsu_MMA_Multimedia_Accelerator                  = 37,
               e_machine_architecture_Siemens_PCP                                         = 38,
               e_machine_architecture_Sony_nCPU_embeeded_RISC                             = 39,
               e_machine_architecture_Denso_NDR1_microprocessor                           = 40,
               e_machine_architecture_Motorola_Start_Core_processor                       = 41,
               e_machine_architecture_Toyota_ME16_processor                               = 42,
               e_machine_architecture_STMicroelectronic_ST100_processor                   = 43,
               e_machine_architecture_Advanced_Logic_Corp_Tinyj_emb_family                = 44,
               e_machine_architecture_AMD_x86_64_architecture                             = 45,
               e_machine_architecture_Sony_DSP_Processor                                  = 46,
               e_machine_architecture_Siemens_FX66_microcontroller                        = 47,
               e_machine_architecture_STMicroelectronics_ST9_plus_8_16_micocontroler      = 48,
               e_machine_architecture_STMicroelectronics_ST7_8bit_micocontroler           = 49,
               e_machine_architecture_Motorola_MC68HC16_microcontroller                   = 50,
               e_machine_architecture_Motorola_MC68HC11_microcontroller                   = 51,
               e_machine_architecture_Motorola_MC68HC08_microcontroller                   = 52,
               e_machine_architecture_Motorola_MC68HC05_microcontroller                   = 53,
               e_machine_architecture_Silicon_Graphics_SVx                                = 54,
               e_machine_architecture_STMicroelectronics_ST19_8bit_microcontroller        = 55,
               e_machine_architecture_Digital_VAX                                         = 56,
               e_machine_architecture_Axis_Communications_32bit_embedded_processor        = 57,
               e_machine_architecture_Infineon_Technologies_32bit_embedded_processor      = 58,
               e_machine_architecture_Element_14_64bit_DSP_Processor                      = 59,
               e_machine_architecture_LSI_Logic_16bit_DSP_Processor                       = 60,
               e_machine_architecture_Donald_Knuths_educational_64bit_processor           = 61,
               e_machine_architecture_Harvard_University_machine_independent_object_files = 62,
               e_machine_architecture_SiTera_Prism                                        = 63,
               e_machine_architecture_Atmel_AVR_8bit_microcontroller                      = 64,
               e_machine_architecture_Fujitsu_FR30                                        = 65,
               e_machine_architecture_Mitsubishi_D10V                                     = 66,
               e_machine_architecture_Mitsubishi_D30V                                     = 67,
               e_machine_architecture_NEC_v850                                            = 68,
               e_machine_architecture_Mitsubishi_M32R                                     = 69,
               e_machine_architecture_Matsushita_MN10300                                  = 70,
               e_machine_architecture_Matsushita_MN10200                                  = 71,
               e_machine_architecture_picoJava                                            = 72,
               e_machine_architecture_OpenRISC_32bit_embedded_processor                   = 73,
               e_machine_architecture_ARC_Cores_Tangent_A5                                = 74,
               e_machine_architecture_Tensilica_Xtensa_Architecture                       = 75,
               e_machine_architecture_Digital_Alpha                                       = 76,
               e_machine_architecture_last
             };

       // DQ (2/11/2008): Added support for Windows binaries
          enum pe_processor_architecture_enum
             {
               e_processor_architecture_error   = 0,
               e_processor_architecture_unknown = 1,
               e_processor_architecture_none    = 2,
               e_processor_architecture_INTEL   = 3,
               e_processor_architecture_MIPS    = 4,
               e_processor_architecture_ALPHA   = 5,
               e_processor_architecture_PPC     = 6,
               e_processor_architecture_SHX     = 7,
               e_processor_architecture_ARM     = 8,
               e_processor_architecture_IA64    = 9,
               e_processor_architecture_ALPHA64 = 10,
               e_processor_architecture_MSIL    = 11,
               e_processor_architecture_AMD64   = 12,
               e_processor_architecture_UNKNOWN = 13,
               e_processor_architecture_last
             };

       // DQ (2/11/2008): Added support for Windows binaries
          enum pe_processor_type_enum
             {
               e_processor_type_error         = 0,
               e_processor_type_unknown       = 1,
               e_processor_type_none          = 2,
               e_processor_type_INTEL_386     = 3,
               e_processor_type_INTEL_486     = 4,
               e_processor_type_INTEL_PENTIUM = 5,
               e_processor_type_INTEL_860     = 6,
               e_processor_type_INTEL_IA64    = 7,
               e_processor_type_AMD_X8664     = 8,
               e_processor_type_MIPS_R2000    = 9,
               e_processor_type_MIPS_R3000    = 10,
               e_processor_type_MIPS_R4000    = 11,
               e_processor_type_ALPHA_21064   = 12,
               e_processor_type_PPC_601       = 13,
               e_processor_type_PPC_603       = 14,
               e_processor_type_PPC_604       = 15,
               e_processor_type_PPC_620       = 16,
               e_processor_type_HITACHI_SH3   = 17,
               e_processor_type_HITACHI_SH3E  = 18,
               e_processor_type_HITACHI_SH4   = 19,
               e_processor_type_MOTOROLA_821  = 20,
               e_processor_type_SHx_SH3       = 21,
               e_processor_type_SHx_SH4       = 22,
               e_processor_type_STRONGARM     = 23,
               e_processor_type_ARM720        = 24,
               e_processor_type_ARM820        = 25,
               e_processor_type_ARM920        = 26,
               e_processor_type_ARM_7TDMI     = 27,
               e_processor_type_last
             };


HEADER_BINARY_FILE_END


HEADER_BINARY_FILE_SECTION_HEADER_START

          enum elf_version_enum
             {
               e_version_error   = 0,
               e_version_unknown = 1,
               e_version_none    = 2, // value maps to EV_NONE
               e_version_current = 3, // value maps to EV_CURRENT
               e_version_last
             };

HEADER_BINARY_FILE_SECTION_HEADER_END


HEADER_BINARY_FILE_PROGRAM_HEADER_START

          enum elf_type_enum
             {
               e_type_error                = 0,
               e_type_unknown              = 1,
               e_type_null                 = 2,
               e_type_loadable_segment     = 3,
               e_type_dynamic_linking_info = 4,
               e_type_interpreter          = 5,
               e_type_note                 = 6,
               e_type_shlib_reserved       = 7,
               e_type_program_header_table = 8,
               e_type_processor_specific   = 9,
               e_type_last
             };

HEADER_BINARY_FILE_PROGRAM_HEADER_END


HEADER_BINARY_FILE_SECTION_HEADER_LIST_START
          const SgAsmSectionHeaderPtrList & get_section_headers() const;
          SgAsmSectionHeaderPtrList & get_section_headers();

HEADER_BINARY_FILE_SECTION_HEADER_LIST_END


HEADER_BINARY_FILE_PROGRAM_HEADER_LIST_START
          const SgAsmProgramHeaderPtrList & get_program_headers() const;
          SgAsmProgramHeaderPtrList & get_program_headers();

HEADER_BINARY_FILE_PROGRAM_HEADER_LIST_END

HEADER_BINARY_BYTE_VALUE_EXPRESSION_START

          virtual SgAsmType* get_type();

HEADER_BINARY_BYTE_VALUE_EXPRESSION_END

HEADER_BINARY_DOUBLE_FLOAT_VALUE_EXPRESSION_START

          virtual SgAsmType* get_type();

HEADER_BINARY_DOUBLE_FLOAT_VALUE_EXPRESSION_END

HEADER_BINARY_DOUBLE_WORD_VALUE_EXPRESSION_START

          virtual SgAsmType* get_type();

HEADER_BINARY_DOUBLE_WORD_VALUE_EXPRESSION_END

HEADER_BINARY_QUAD_WORD_VALUE_EXPRESSION_START

          virtual SgAsmType* get_type();

HEADER_BINARY_QUAD_WORD_VALUE_EXPRESSION_END

HEADER_BINARY_SINGLE_FLOAT_VALUE_EXPRESSION_START

          virtual SgAsmType* get_type();

HEADER_BINARY_SINGLE_FLOAT_VALUE_EXPRESSION_END

HEADER_BINARY_VECTOR_VALUE_EXPRESSION_START

          virtual SgAsmType* get_type();

HEADER_BINARY_VECTOR_VALUE_EXPRESSION_END

HEADER_BINARY_WORD_VALUE_EXPRESSION_START

          virtual SgAsmType* get_type();

HEADER_BINARY_WORD_VALUE_EXPRESSION_END

SOURCE_BINARY_FILE_SECTION_HEADER_LIST_START

#if 1
const SgAsmSectionHeaderPtrList &
SgAsmSectionHeaderList::get_section_headers() const
   {
     return p_section_headers;
   }

SgAsmSectionHeaderPtrList &
SgAsmSectionHeaderList::get_section_headers()
   {
     return p_section_headers;
   }
#endif

SOURCE_BINARY_FILE_SECTION_HEADER_LIST_END

SOURCE_BINARY_FILE_PROGRAM_HEADER_LIST_START

#if 1
const SgAsmProgramHeaderPtrList &
SgAsmProgramHeaderList::get_program_headers() const
   {
     return p_program_headers;
   }

SgAsmProgramHeaderPtrList &
SgAsmProgramHeaderList::get_program_headers()
   {
     return p_program_headers;
   }
#endif

SOURCE_BINARY_FILE_PROGRAM_HEADER_LIST_END


HEADER_BINARY_X86_INSTRUCTION_START
  public:

HEADER_BINARY_X86_INSTRUCTION_END


HEADER_BINARY_DECLARATION_START
HEADER_BINARY_DECLARATION_END


HEADER_BINARY_RET_START
   void append_dest( SgAsmStatement* instruction );	
HEADER_BINARY_RET_END


HEADER_BINARY_FUNCTION_CALL_START
HEADER_BINARY_FUNCTION_CALL_END

HEADER_BINARY_BLOCK_START
          void append_statement( SgAsmStatement* statement );
          void remove_statement( SgAsmStatement* statement );
          void remove_children (  );
HEADER_BINARY_BLOCK_END



HEADER_BINARY_OPERAND_LIST_START
          void append_operand( SgAsmExpression* operand );
HEADER_BINARY_OPERAND_LIST_END



HEADER_BINARY_FUNCTION_DECLARATION_START
	int nrOfValidInstructions();
          //void append_block( SgAsmBlock* operand );
          void append_statement( SgAsmStatement* statement );
          void remove_statement( SgAsmStatement* statement );	
	  void append_dest( SgAsmStatement* instruction );		
          void remove_children (  );

       //! enum declaration as specified in proposed Sabre database schema
          enum function_kind_enum
             {
               e_unknown  = 0,
               e_standard = 1,
               e_library  = 2,
               e_imported = 3,
               e_thunk    = 4,
               e_last
             };
HEADER_BINARY_FUNCTION_DECLARATION_END

HEADER_BINARY_DATA_STRUCTURE_START
          void append_declaration( SgAsmDeclaration* declaration );

       // SgAsmDeclarationPtrList & get_declarationList();

     protected:

          SgAsmDeclarationPtrList p_declarationList;

     public:
HEADER_BINARY_DATA_STRUCTURE_END




HEADER_BINARY_EXPRESSION_START

      //! Generate the type for the expression
          virtual SgAsmType* get_type();

      //! Return the precedence of the operator (see C and C++ examples for details)
      //  virtual int get_precedence();

HEADER_BINARY_EXPRESSION_END



HEADER_BINARY_TYPE_START

       // static SgAsmType* createType();

HEADER_BINARY_TYPE_END

HEADER_BINARY_TYPE_BYTE_START
          static SgAsmTypeByte* createType();
HEADER_BINARY_TYPE_BYTE_END

HEADER_BINARY_TYPE_WORD_START
          static SgAsmTypeWord* createType();
HEADER_BINARY_TYPE_WORD_END

HEADER_BINARY_TYPE_DOUBLE_WORD_START
          static SgAsmTypeDoubleWord* createType();
HEADER_BINARY_TYPE_DOUBLE_WORD_END

HEADER_BINARY_TYPE_QUAD_WORD_START
          static SgAsmTypeQuadWord* createType();
HEADER_BINARY_TYPE_QUAD_WORD_END

HEADER_BINARY_TYPE_DOUBLE_QUAD_WORD_START
          static SgAsmTypeDoubleQuadWord* createType();
HEADER_BINARY_TYPE_DOUBLE_QUAD_WORD_END

HEADER_BINARY_TYPE_SINGLE_FLOAT_START
          static SgAsmTypeSingleFloat* createType();
HEADER_BINARY_TYPE_SINGLE_FLOAT_END

HEADER_BINARY_TYPE_DOUBLE_FLOAT_START
          static SgAsmTypeDoubleFloat* createType();
HEADER_BINARY_TYPE_DOUBLE_FLOAT_END

HEADER_BINARY_TYPE_VECTOR_START
          static SgAsmTypeVector* createType(int elementCount, SgAsmType* elementType);
HEADER_BINARY_TYPE_VECTOR_END

HEADER_BINARY_TYPE_80bit_FLOAT_START
          static SgAsmType80bitFloat* createType();
HEADER_BINARY_TYPE_80bit_FLOAT_END

HEADER_BINARY_TYPE_128bit_FLOAT_START
          static SgAsmType128bitFloat* createType();
HEADER_BINARY_TYPE_128bit_FLOAT_END

HEADER_BINARY_REGISTER_REFERENCE_EXPRESSION_START

         // Note that the auto-generated version of this is const
         virtual SgAsmType* get_type();

HEADER_BINARY_REGISTER_REFERENCE_EXPRESSION_END

HEADER_BINARY_X86_REGISTER_REFERENCE_EXPRESSION_START

             // Note that the auto-generated version of this is const
             virtual SgAsmType* get_type();

             //! Get a unique identifier for this particular register
             std::pair<X86RegisterClass, int> get_identifier() const;

HEADER_BINARY_X86_REGISTER_REFERENCE_EXPRESSION_END

HEADER_BINARY_ARM_REGISTER_REFERENCE_EXPRESSION_START

          enum arm_register_enum
             { // The exact numbers here are important
               undefined_arm_register = 0, /*!< unknown (error or unitialized value) */
               reg0 = 1,
               reg1 = 2,
               reg2 = 3,
               reg3 = 4,
               reg4 = 5,
               reg5 = 6,
               reg6 = 7,
               reg7 = 8,
               reg8 = 9,
               reg9  = 10,
               reg10 = 11,
               reg11 = 12,
               reg12 = 13,
               reg13 = 14,
               reg14 = 15,
               reg15 = 16,
               cpsr = 17,
               spsr = 18,
               cpsr_fields = 19, /* 16 values -- add arm_suffix_field_enum */
               spsr_fields = 35, /* 16 values -- add arm_suffix_field_enum */
               last_arm_register = spsr_fields + 16
             };

          enum arm_position_in_register_enum
             {
               undefined_arm_position_in_register = 0, /*!< unknown (error or unitialized value) */
               arm_dword = 1, /*!< lower 32 bit part of larger register (typically the first part of a 64 bit register) */
               arm_qword = 2, /*!< 64 bit part of 128 bit register (not in common use) */
               last_arm_position_in_register
             };

          enum arm_suffix_field_enum
             {
               undefined_position_in_suffix = 0, /*!< unknown (error or unitialized value) */
               c = 1, // control field mask bit
               x = 2, // extension field mask bit
               s = 4, // status field mask bit
               f = 8, // flags field mask bit
               last_position_in_suffix
             };

             // Note that the auto-generated version of this is const
             virtual SgAsmType* get_type();

HEADER_BINARY_ARM_REGISTER_REFERENCE_EXPRESSION_END

HEADER_BINARY_MEMORY_REFERENCE_EXPRESSION_START

             // Note that the auto-generated version of this is const
             virtual SgAsmType* get_type();

HEADER_BINARY_MEMORY_REFERENCE_EXPRESSION_END





/* --------------------------------------------------------------------------------- */
/* --------------------------------------------------------------------------------- */
/* --------------------------------------------------------------------------------- */
/* --------------------------------------------------------------------------------- */
/* --------------------------------------------------------------------------------- */



SOURCE_BINARY_BLOCK_START
void
SgAsmBlock::append_statement( SgAsmStatement* statement )
   {
     p_statementList.push_back(statement);
   }

void
SgAsmBlock::remove_children(  )
   {
     p_statementList.clear();
   }

void
SgAsmBlock::remove_statement( SgAsmStatement* statement )
   {
     SgAsmStatementPtrList::iterator l = p_statementList.begin();
     for (;l!=p_statementList.end();l++) {
	SgAsmStatement* st = *l;
	if (st==statement) {
             break;
        }
     }	
	if (l!=p_statementList.end())
            p_statementList.erase(l);
   }

SOURCE_BINARY_BLOCK_END



SOURCE_BINARY_RET_START
void
SgAsmx86Ret::append_dest( SgAsmStatement* statement )
   {
     p_dest.push_back(statement);
   }

SOURCE_BINARY_RET_END



SOURCE_BINARY_OPERAND_LIST_START
void
SgAsmOperandList::append_operand( SgAsmExpression* operand )
   {
  /* implemented directly until we can fix how the statementList is built */
     p_operands.push_back(operand);
   }

SOURCE_BINARY_OPERAND_LIST_END


SOURCE_BINARY_DATA_STRUCTURE_START
void
SgAsmDataStructureDeclaration::append_declaration( SgAsmDeclaration* declaration )
   {
     p_declarationList.push_back(declaration);
   }

SOURCE_BINARY_DATA_STRUCTURE_END


SOURCE_BINARY_FUNCTION_DECLARATION_START
int 
SgAsmFunctionDeclaration::nrOfValidInstructions(  ) {
  std::vector<SgNode*> succs = this->get_traversalSuccessorContainer();
  std::vector<SgNode*>::reverse_iterator j = succs.rbegin();
  int instructions = succs.size();
  bool foundRet=false;
  bool nodeOtherThanNopAfterRetExists=false;	
/*
  if (j!=succs.begin())
    j--;
  else
    return 0;
*/
  for (;j!=succs.rend(); j++) {
     SgAsmx86Instruction* n = isSgAsmx86Instruction(*j);
     if (n && (n->get_kind() == x86_ret || n->get_kind() == x86_hlt)) {
          foundRet=true;
          break;
    } else {
       if (n->get_kind() != x86_nop) {
          nodeOtherThanNopAfterRetExists= true;
       }
       instructions--;
    }
  }
  if (!foundRet)
     instructions = succs.size();
  // if we find a return and there are NOPs following it somewhere,
  // we cut off the CFG at the NOP but we keep valid instructions
  // after the RET
  if (foundRet)
    if (nodeOtherThanNopAfterRetExists)
      return succs.size();
   
  return instructions;
}

void
SgAsmFunctionDeclaration::remove_children(  )
   {
     p_statementList.clear();
   }

void
SgAsmFunctionDeclaration::append_dest( SgAsmStatement* statement )
   {
     p_dest.push_back(statement);
   }

void
SgAsmFunctionDeclaration::append_statement( SgAsmStatement* statement )
   {
     p_statementList.push_back(statement);
   }

void
SgAsmFunctionDeclaration::remove_statement( SgAsmStatement* statement )
   {
     SgAsmStatementPtrList::iterator l = p_statementList.begin();
     for (;l!=p_statementList.end();l++) {
	SgAsmStatement* st = *l;
	if (st==statement) {
             break;
        }
     }	
	if (l!=p_statementList.end())
            p_statementList.erase(l);
   }


/*
void
SgAsmFunctionDeclaration::append_block( SgAsmBlock* operand )
   {
     p_body.push_back(operand);
   }
*/

SOURCE_BINARY_FUNCTION_DECLARATION_END


SOURCE_BINARY_INSTRUCTION_START

void
SgAsmInstruction::append_sources( SgAsmInstruction* inst )
   {
     p_sources.push_back(inst);
   }

SgAsmInstruction*
SgAsmInstruction::cfgBinFlowOutEdge(const VirtualBinCFG::AuxiliaryInformation* info) {
  if (!isAsmUnconditionalBranch(this)) {
    SgAsmInstruction* next = info->getInstructionAtAddress(this->get_address() + this->get_raw_bytes().size());
    return next;
  }
  return NULL;
}

std::vector<VirtualBinCFG::CFGEdge>
SgAsmInstruction::cfgBinOutEdges(const VirtualBinCFG::AuxiliaryInformation* info) {
  //cerr << "cfgBinOutEdges: " << std::hex << this->get_address() << " " << (isSgAsmx86Instruction(this) ? "x86" : "unknown") << " " << (isSgAsmx86Instruction(this) ? toString(isSgAsmx86Instruction(this)->get_kind()) : "") << endl;
  std::vector<VirtualBinCFG::CFGEdge> result;
  uint64_t nextAddr = this->get_address() + this->get_raw_bytes().size();

  if (isAsmBranch(this)) {
    //cout << "Found branch" << endl;
    uint64_t addr = 0;
    bool knownTarget = getAsmKnownBranchTarget(this, addr);
    if (knownTarget) {
      //cout << "Has known target " << std::hex << addr << endl;
      SgAsmInstruction* tgt = info->getInstructionAtAddress(addr);
      if (tgt) {
        makeEdge(this, tgt, info, result);
      }
    } else { // Unknown target
      //cout << "Unknown target" << endl;
      const std::set<uint64_t> successorAddrs = info->getPossibleSuccessors(this);
      for (std::set<uint64_t>::const_iterator i = successorAddrs.begin(); i != successorAddrs.end(); ++i) {
        //cout << "Found succ address " << std::hex << *i << endl;
        SgAsmInstruction* tgt = info->getInstructionAtAddress(*i);
        if (tgt) {
          makeEdge(this, tgt, info, result);
        }
      }
#if 0
      if (successorAddrs.empty()) {
	// FIXME: For bug-compatibility with old version
	SgAsmInstruction* next = info->getInstructionAtAddress(nextAddr);
	if (next) makeEdge(this, next, info, result);
      }
#endif
    } // else
  } // if

  if ((!isSgAsmx86Instruction(this) || isSgAsmx86Instruction(this)->get_kind() != x86_ret && isSgAsmx86Instruction(this)->get_kind() != x86_hlt) /* || !isAsmUnconditionalBranch(this) || (isSgAsmx86Instruction(this) && isSgAsmx86Instruction(this)->get_kind() == x86_call) */ ) {
    //cout << "Next insn is at " << std::hex << nextAddr << endl;
    SgAsmInstruction* next = info->getInstructionAtAddress(nextAddr);
    //ROSE_ASSERT (next);
    if (next) makeEdge(this, next, info, result);
  }

  return result;
}


std::vector<VirtualBinCFG::CFGEdge>
SgAsmInstruction::cfgBinInEdges(const VirtualBinCFG::AuxiliaryInformation* info) {
  std::vector<VirtualBinCFG::CFGEdge> result;
  const std::set<uint64_t>& preds = info->getPossiblePredecessors(this);
  for (std::set<uint64_t>::const_iterator i = preds.begin(); i != preds.end(); ++i) {
    SgAsmInstruction* tgt = info->getInstructionAtAddress(*i);
    if (tgt) {
      makeEdge(this, tgt, info, result);
    }
  }
  return result;
}

SOURCE_BINARY_INSTRUCTION_END

SOURCE_BINARY_X86_INSTRUCTION_START

SOURCE_BINARY_X86_INSTRUCTION_END


SOURCE_BINARY_EXPRESSION_START

SgAsmType* SgAsmExpression::get_type() {
  ROSE_ASSERT (!"Cannot get the type of this SgAsmExpression");
}

SOURCE_BINARY_EXPRESSION_END

SOURCE_BINARY_TYPE_START
SOURCE_BINARY_TYPE_END

SOURCE_BINARY_TYPE_BYTE_START

$CLASSNAME* $CLASSNAME::p_builtin_type = NULL;

// This is from the version for non-asm types
$CLASSNAME* $CLASSNAME::createType() {
  if (p_builtin_type == NULL) {
    p_builtin_type = new $CLASSNAME();
    ROSE_ASSERT(p_builtin_type != NULL);
  }
  return p_builtin_type;
}

SOURCE_BINARY_TYPE_BYTE_END

SOURCE_BINARY_TYPE_WORD_START

$CLASSNAME* $CLASSNAME::p_builtin_type = NULL;

// This is from the version for non-asm types
$CLASSNAME* $CLASSNAME::createType() {
  if (p_builtin_type == NULL) {
    p_builtin_type = new $CLASSNAME();
    ROSE_ASSERT(p_builtin_type != NULL);
  }
  return p_builtin_type;
}

SOURCE_BINARY_TYPE_WORD_END

SOURCE_BINARY_TYPE_DOUBLE_WORD_START

$CLASSNAME* $CLASSNAME::p_builtin_type = NULL;

// This is from the version for non-asm types
$CLASSNAME* $CLASSNAME::createType() {
  if (p_builtin_type == NULL) {
    p_builtin_type = new $CLASSNAME();
    ROSE_ASSERT(p_builtin_type != NULL);
  }
  return p_builtin_type;
}

SOURCE_BINARY_TYPE_DOUBLE_WORD_END

SOURCE_BINARY_TYPE_QUAD_WORD_START

$CLASSNAME* $CLASSNAME::p_builtin_type = NULL;

// This is from the version for non-asm types
$CLASSNAME* $CLASSNAME::createType() {
  if (p_builtin_type == NULL) {
    p_builtin_type = new $CLASSNAME();
    ROSE_ASSERT(p_builtin_type != NULL);
  }
  return p_builtin_type;
}

SOURCE_BINARY_TYPE_QUAD_WORD_END

SOURCE_BINARY_TYPE_DOUBLE_QUAD_WORD_START

$CLASSNAME* $CLASSNAME::p_builtin_type = NULL;

// This is from the version for non-asm types
$CLASSNAME* $CLASSNAME::createType() {
  if (p_builtin_type == NULL) {
    p_builtin_type = new $CLASSNAME();
    ROSE_ASSERT(p_builtin_type != NULL);
  }
  return p_builtin_type;
}

SOURCE_BINARY_TYPE_DOUBLE_QUAD_WORD_END

SOURCE_BINARY_TYPE_SINGLE_FLOAT_START

$CLASSNAME* $CLASSNAME::p_builtin_type = NULL;

// This is from the version for non-asm types
$CLASSNAME* $CLASSNAME::createType() {
  if (p_builtin_type == NULL) {
    p_builtin_type = new $CLASSNAME();
    ROSE_ASSERT(p_builtin_type != NULL);
  }
  return p_builtin_type;
}

SOURCE_BINARY_TYPE_SINGLE_FLOAT_END

SOURCE_BINARY_TYPE_DOUBLE_FLOAT_START

$CLASSNAME* $CLASSNAME::p_builtin_type = NULL;

// This is from the version for non-asm types
$CLASSNAME* $CLASSNAME::createType() {
  if (p_builtin_type == NULL) {
    p_builtin_type = new $CLASSNAME();
    ROSE_ASSERT(p_builtin_type != NULL);
  }
  return p_builtin_type;
}

SOURCE_BINARY_TYPE_DOUBLE_FLOAT_END


SOURCE_BINARY_TYPE_80bit_FLOAT_START
$CLASSNAME* $CLASSNAME::p_builtin_type = NULL;

// This is from the version for non-asm types
$CLASSNAME* $CLASSNAME::createType() {
  if (p_builtin_type == NULL) {
    p_builtin_type = new $CLASSNAME();
    ROSE_ASSERT(p_builtin_type != NULL);
  }
  return p_builtin_type;
}
       
SOURCE_BINARY_TYPE_80bit_FLOAT_END


SOURCE_BINARY_TYPE_128bit_FLOAT_START
$CLASSNAME* $CLASSNAME::p_builtin_type = NULL;

// This is from the version for non-asm types
$CLASSNAME* $CLASSNAME::createType() {
  if (p_builtin_type == NULL) {
    p_builtin_type = new $CLASSNAME();
    ROSE_ASSERT(p_builtin_type != NULL);
  }
  return p_builtin_type;
}
       
SOURCE_BINARY_TYPE_128bit_FLOAT_END


SOURCE_BINARY_TYPE_VECTOR_START

$CLASSNAME* $CLASSNAME::createType(int elementCount, SgAsmType* elementType) {
  // This does not need to be saved during file I/O, so it doesn't need to be a
  // class member
  static std::map<std::pair<int, SgAsmType*>, SgAsmTypeVector*> cache;
  std::pair<int, SgAsmType*> vectorInfo(elementCount, elementType);
  std::map<std::pair<int, SgAsmType*>, SgAsmTypeVector*>::const_iterator i = cache.find(vectorInfo);
  if (i != cache.end()) {
    return i->second;
  } else {
    SgAsmTypeVector* tv = new SgAsmTypeVector(elementCount, elementType);
    cache.insert(std::make_pair(vectorInfo, tv));
    return tv;
  }
}

SOURCE_BINARY_TYPE_VECTOR_END


SOURCE_BINARY_NODE_START

SOURCE_BINARY_NODE_END

SOURCE_BINARY_BYTE_VALUE_EXPRESSION_START

SgAsmType* $CLASSNAME::get_type() {
  return SgAsmTypeByte::createType();
}

SOURCE_BINARY_BYTE_VALUE_EXPRESSION_END

SOURCE_BINARY_DOUBLE_FLOAT_VALUE_EXPRESSION_START

SgAsmType* $CLASSNAME::get_type() {
  return SgAsmTypeDoubleFloat::createType();
}

SOURCE_BINARY_DOUBLE_FLOAT_VALUE_EXPRESSION_END

SOURCE_BINARY_DOUBLE_WORD_VALUE_EXPRESSION_START

SgAsmType* $CLASSNAME::get_type() {
  return SgAsmTypeDoubleWord::createType();
}

SOURCE_BINARY_DOUBLE_WORD_VALUE_EXPRESSION_END

SOURCE_BINARY_QUAD_WORD_VALUE_EXPRESSION_START

SgAsmType* $CLASSNAME::get_type() {
  return SgAsmTypeQuadWord::createType();
}

SOURCE_BINARY_QUAD_WORD_VALUE_EXPRESSION_END

SOURCE_BINARY_SINGLE_FLOAT_VALUE_EXPRESSION_START

SgAsmType* $CLASSNAME::get_type() {
  return SgAsmTypeSingleFloat::createType();
}

SOURCE_BINARY_SINGLE_FLOAT_VALUE_EXPRESSION_END

SOURCE_BINARY_VECTOR_VALUE_EXPRESSION_START

// Note that the auto-generated version of this is const
SgAsmType* SgAsmVectorValueExpression::get_type() {
  return p_type;
}

SOURCE_BINARY_VECTOR_VALUE_EXPRESSION_END

SOURCE_BINARY_WORD_VALUE_EXPRESSION_START

SgAsmType* $CLASSNAME::get_type() {
  return SgAsmTypeWord::createType();
}

SOURCE_BINARY_WORD_VALUE_EXPRESSION_END

SOURCE_BINARY_REGISTER_REFERENCE_EXPRESSION_START

// Note that the auto-generated version of this is const
SgAsmType* SgAsmRegisterReferenceExpression::get_type() {
  ROSE_ASSERT (false);
}

SOURCE_BINARY_REGISTER_REFERENCE_EXPRESSION_END

SOURCE_BINARY_X86_REGISTER_REFERENCE_EXPRESSION_START

// Note that the auto-generated version of this is const
SgAsmType* SgAsmx86RegisterReferenceExpression::get_type() {
  return p_type;
}

std::pair<X86RegisterClass, int>
SgAsmx86RegisterReferenceExpression::get_identifier() const {
  return std::make_pair(this->get_register_class(), this->get_register_number());
}

SOURCE_BINARY_X86_REGISTER_REFERENCE_EXPRESSION_END

SOURCE_BINARY_ARM_REGISTER_REFERENCE_EXPRESSION_START

// Note that the auto-generated version of this is const
SgAsmType* SgAsmArmRegisterReferenceExpression::get_type() {
  return p_type;
}

SOURCE_BINARY_ARM_REGISTER_REFERENCE_EXPRESSION_END

SOURCE_BINARY_MEMORY_REFERENCE_EXPRESSION_START

// Note that the auto-generated version of this is const
SgAsmType* SgAsmMemoryReferenceExpression::get_type() {
  return p_type;
}

SOURCE_BINARY_MEMORY_REFERENCE_EXPRESSION_END

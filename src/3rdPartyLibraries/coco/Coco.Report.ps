%!PS-Adobe-3.0
%%Title: (Report)
%%Creator: (WriteNow 4.0.2: LaserWriter 8 8.2)
%%CreationDate: (10:14 AM Monday, 15 July 1996)
%%For: (Hanspeter M\232ssenb\232ck)
%%Pages: 29
%%DocumentFonts: Helvetica Helvetica-Bold Helvetica-Oblique Helvetica-BoldOblique Times-Bold Times-Roman Symbol Courier
%%DocumentNeededFonts: Helvetica Helvetica-Bold Helvetica-Oblique Helvetica-BoldOblique Times-Bold Times-Roman Symbol Courier
%%DocumentSuppliedFonts:
%%DocumentData: Clean7Bit
%%PageOrder: Ascend
%%Orientation: Portrait
%%DocumentMedia: Default 595 842 0 () ()
%ADO_ImageableArea: 28 30 566 811
%%EndComments
userdict begin/dscInfo 5 dict dup begin
/Title(Report)def
/Creator(WriteNow 4.0.2: LaserWriter 8 8.2)def
/CreationDate(10:14 AM Monday, 15 July 1996)def
/For(Hanspeter M\232ssenb\232ck)def
/Pages 1 def
end def end
/md 208 dict def md begin/currentpacking where {pop /sc_oldpacking currentpacking def true setpacking}if
%%BeginFile: adobe_psp_basic
%%Copyright: Copyright 1990-1993 Adobe Systems Incorporated. All Rights Reserved.
/bd{bind def}bind def
/xdf{exch def}bd
/xs{exch store}bd
/ld{load def}bd
/Z{0 def}bd
/T/true
/F/false
/:L/lineto
/lw/setlinewidth
/:M/moveto
/rl/rlineto
/rm/rmoveto
/:C/curveto
/:T/translate
/:K/closepath
/:mf/makefont
/gS/gsave
/gR/grestore
/np/newpath
14{ld}repeat
/$m matrix def
/av 81 def
/por true def
/normland false def
/psb-nosave{}bd
/pse-nosave{}bd
/us Z
/psb{/us save store}bd
/pse{us restore}bd
/level2
/languagelevel where
{
pop languagelevel 2 ge
}{
false
}ifelse
def
/featurecleanup
{
stopped
cleartomark
countdictstack exch sub dup 0 gt
{
{end}repeat
}{
pop
}ifelse
}bd
/noload Z
/startnoload
{
{/noload save store}if
}bd
/endnoload
{
{noload restore}if
}bd
level2 startnoload
/setjob
{
statusdict/jobname 3 -1 roll put
}bd
/setcopies
{
userdict/#copies 3 -1 roll put
}bd
level2 endnoload level2 not startnoload
/setjob
{
1 dict begin/JobName xdf currentdict end setuserparams
}bd
/setcopies
{
1 dict begin/NumCopies xdf currentdict end setpagedevice
}bd
level2 not endnoload
/pm Z
/mT Z
/sD Z
/realshowpage Z
/initializepage
{
/pm save store mT concat
}bd
/endp
{
pm restore showpage
}def
/$c/DeviceRGB def
/rectclip where
{
pop/rC/rectclip ld
}{
/rC
{
np 4 2 roll
:M
1 index 0 rl
0 exch rl
neg 0 rl
:K
clip np
}bd
}ifelse
/rectfill where
{
pop/rF/rectfill ld
}{
/rF
{
gS
np
4 2 roll
:M
1 index 0 rl
0 exch rl
neg 0 rl
fill
gR
}bd
}ifelse
/rectstroke where
{
pop/rS/rectstroke ld
}{
/rS
{
gS
np
4 2 roll
:M
1 index 0 rl
0 exch rl
neg 0 rl
:K
stroke
gR
}bd
}ifelse
%%EndFile
%%BeginFile: adobe_psp_colorspace_level1
%%Copyright: Copyright 1991-1993 Adobe Systems Incorporated. All Rights Reserved.
/G/setgray ld
/:F/setrgbcolor ld
%%EndFile
level2 startnoload
%%BeginFile: adobe_psp_patterns_level1
%%Copyright: Copyright 1991-1993 Adobe Systems Incorporated. All Rights Reserved.
/patfreq Z
/patangle Z
/bk Z
/fg Z
/docolorscreen Z
/graystring Z
/pattransf{}def
/initQDpatterns
{
/patfreq 9.375 store
/patangle
1 0 $m defaultmatrix dtransform
exch atan
por not
{90 add}if
normland{180 add}if
store
:a
}def
/docolorscreen
/setcolorscreen where
{
pop/currentcolorscreen where
{
pop/setcmykcolor where
{
pop true
}{
false
}ifelse
}{
false
}ifelse
}{
false
}ifelse
def
/setgraypattern
{
/graystring xs
patfreq
patangle
{
1 add
4 mul
cvi
graystring
exch get
exch
1 add 4 mul
cvi
7 sub
bitshift
1 and
}setscreen
64 div setgray
}bd
/:b
{
/pattransf load settransfer
pop pop pop
setgraypattern
}bd
docolorscreen startnoload
/screensave 5 array def
/:a{currentgray currentscreen currenttransfer screensave astore pop}bd
/:e{screensave aload pop settransfer setscreen setgray}bd
/:d
{
pop pop pop
/pattransf load settransfer
setgraypattern 8{pop}repeat
}bd
/:c
/:d ld
docolorscreen endnoload docolorscreen not startnoload
/screensave 20 array def
/:a{currentcmykcolor currentcolorscreen currentcolortransfer screensave astore pop}bd
/:e{screensave aload pop setcolortransfer setcolorscreen setcmykcolor}bd
/rstring Z
/grstring Z
/blstring Z
/convroll{64 div 4 -1 roll}bd
/setcolorpattern
{
/graystring xs
/blstring xs
/grstring xs
/rstring xs
patfreq
patangle
{
1 add 4 mul cvi rstring
exch get exch 1 add 4 mul
cvi 7 sub bitshift 1 and
}
patfreq
patangle
{
1 add 4 mul cvi grstring
exch get exch 1 add 4 mul
cvi 7 sub bitshift 1 and
}
patfreq
patangle
{
1 add 4 mul cvi blstring
exch get exch 1 add 4 mul
cvi 7 sub bitshift 1 and
}
patfreq
patangle
{
1 add 4 mul cvi graystring
exch get exch 1 add 4 mul
cvi 7 sub bitshift 1 and
}
setcolorscreen
convroll convroll convroll convroll
setcmykcolor
}bd
/:d
{
pop pop pop
/pattransf load settransfer
pop pop setcolorpattern
}bd
/:c
/:d ld
docolorscreen not endnoload
%%EndFile
level2  endnoload level2 not startnoload
%%BeginFile: adobe_psp_patterns_level2
%%Copyright: Copyright 1990-1993 Adobe Systems Incorporated. All Rights Reserved.
/pmtx Z
/BGnd Z
/FGnd Z
/PaintData Z
/PatternMtx Z
/PatHeight Z
/PatWidth Z
/$d Z
/savecolor 4 array def
/savecolorspace Z
/:a{
mark 0 0 0 currentcolor savecolor astore pop cleartomark
/savecolorspace currentcolorspace store
}bd
/:e{
savecolorspace setcolorspace
mark savecolor aload pop setcolor cleartomark
}bd
/initQDpatterns
{
gS
initmatrix
mT dup 4 get exch 5 get :T
1 0 dtransform round exch round exch idtransform
dup mul exch dup mul exch add sqrt
0 1 dtransform round exch round exch idtransform
dup mul exch dup mul exch add sqrt
neg
scale
0
por not{90 add}if
normland{180 add}if
rotate
matrix currentmatrix
gR
/pmtx xs
:a
}bd
/:t
{
14 dict begin
/BGnd xdf
/FGnd xdf
/PaintData xdf
/PatternType 1 def
/PaintType 1 def
/BBox[0 0 1 1]def
/TilingType 1 def
/XStep 1 def
/YStep 1 def
/PatternMtx[24 0 0 24 0 0]def
/PaintProc
BGnd null ne
{
{
begin
BGnd aload pop :F
0 0 1 1 rF
FGnd aload pop :F
24 24 true PatternMtx PaintData imagemask
end
}
}{
{
begin
FGnd aload pop :F
24 24 true PatternMtx PaintData imagemask
end
}
}ifelse
def
currentdict
PatternMtx
end
gS $c setcolorspace pmtx setmatrix makepattern gR
}bd
/:u
{
14 dict begin
/$d 8 dict def
/PatternType 1 def
/PaintType 1 def
/BBox[0 0 1 1]def
/TilingType 1 def
/XStep 1 def
/YStep 1 def
/PaintData xdf
/PatHeight xdf
/PatWidth xdf
/PatternMtx[PatWidth 0 0 PatHeight 0 0]def
$d begin
/ImageType 1 def
/MultipleDataSource false def
/Height PatHeight def
/Width PatWidth def
/Decode[0 1 0 1 0 1]def
/ImageMatrix PatternMtx def
/DataSource PaintData def
/BitsPerComponent 8 def
end
/PaintProc
{
begin
$d image
end
}def
currentdict
PatternMtx
end
gS $c setcolorspace pmtx setmatrix makepattern gR
}bd
/bk[1 1 1]def
/fg[0 0 0]def
/:b{
:t
setpattern
pop pop
}bd
/:d{
:t
setpattern
10{pop}repeat
}bd
/:c{
:u
setpattern
10{pop}repeat
}bd
%%EndFile
level2 not endnoload
%%BeginFile: adobe_psp_uniform_graphics
%%Copyright: Copyright 1990-1993 Adobe Systems Incorporated. All Rights Reserved.
/@a
{
np :M 0 rl :L 0 exch rl 0 rl :L fill
}bd
/@b
{
np :M 0 rl 0 exch rl :L 0 rl 0 exch rl fill
}bd
/arct where
{
pop
}{
/arct
{
arcto pop pop pop pop
}bd
}ifelse
/x1 Z
/x2 Z
/y1 Z
/y2 Z
/rad Z
/@q
{
/rad xs
/y2 xs
/x2 xs
/y1 xs
/x1 xs
np
x2 x1 add 2 div y1 :M
x2 y1 x2 y2 rad arct
x2 y2 x1 y2 rad arct
x1 y2 x1 y1 rad arct
x1 y1 x2 y1 rad arct
fill
}bd
/@s
{
/rad xs
/y2 xs
/x2 xs
/y1 xs
/x1 xs
np
x2 x1 add 2 div y1 :M
x2 y1 x2 y2 rad arct
x2 y2 x1 y2 rad arct
x1 y2 x1 y1 rad arct
x1 y1 x2 y1 rad arct
:K
stroke
}bd
/@i
{
np 0 360 arc fill
}bd
/@j
{
gS
np
:T
scale
0 0 .5 0 360 arc
fill
gR
}bd
/@e
{
np
0 360 arc
:K
stroke
}bd
/@f
{
np
$m currentmatrix
pop
:T
scale
0 0 .5 0 360 arc
:K
$m setmatrix
stroke
}bd
/@k
{
gS
np
:T
0 0 :M
0 0 5 2 roll
arc fill
gR
}bd
/@l
{
gS
np
:T
0 0 :M
scale
0 0 .5 5 -2 roll arc
fill
gR
}bd
/@m
{
np
arc
stroke
}bd
/@n
{
np
$m currentmatrix
pop
:T
scale
0 0 .5 5 -2 roll arc
$m setmatrix
stroke
}bd
%%EndFile
%%BeginFile: adobe_psp_basic_text
%%Copyright: Copyright 1990-1993 Adobe Systems Incorporated. All Rights Reserved.
/S/show ld
/A{
0.0 exch ashow
}bd
/R{
0.0 exch 32 exch widthshow
}bd
/W{
0.0 3 1 roll widthshow
}bd
/J{
0.0 32 4 2 roll 0.0 exch awidthshow
}bd
/V{
0.0 4 1 roll 0.0 exch awidthshow
}bd
/fcflg true def
/fc{
fcflg{
vmstatus exch sub 50000 lt{
(%%[ Warning: Running out of memory ]%%\r)print flush/fcflg false store
}if pop
}if
}bd
/$f[1 0 0 -1 0 0]def
/:ff{$f :mf}bd
/MacEncoding StandardEncoding 256 array copy def
MacEncoding 39/quotesingle put
MacEncoding 96/grave put
/Adieresis/Aring/Ccedilla/Eacute/Ntilde/Odieresis/Udieresis/aacute
/agrave/acircumflex/adieresis/atilde/aring/ccedilla/eacute/egrave
/ecircumflex/edieresis/iacute/igrave/icircumflex/idieresis/ntilde/oacute
/ograve/ocircumflex/odieresis/otilde/uacute/ugrave/ucircumflex/udieresis
/dagger/degree/cent/sterling/section/bullet/paragraph/germandbls
/registered/copyright/trademark/acute/dieresis/notequal/AE/Oslash
/infinity/plusminus/lessequal/greaterequal/yen/mu/partialdiff/summation
/product/pi/integral/ordfeminine/ordmasculine/Omega/ae/oslash
/questiondown/exclamdown/logicalnot/radical/florin/approxequal/Delta/guillemotleft
/guillemotright/ellipsis/space/Agrave/Atilde/Otilde/OE/oe
/endash/emdash/quotedblleft/quotedblright/quoteleft/quoteright/divide/lozenge
/ydieresis/Ydieresis/fraction/currency/guilsinglleft/guilsinglright/fi/fl
/daggerdbl/periodcentered/quotesinglbase/quotedblbase/perthousand
/Acircumflex/Ecircumflex/Aacute/Edieresis/Egrave/Iacute/Icircumflex/Idieresis/Igrave
/Oacute/Ocircumflex/apple/Ograve/Uacute/Ucircumflex/Ugrave/dotlessi/circumflex/tilde
/macron/breve/dotaccent/ring/cedilla/hungarumlaut/ogonek/caron
MacEncoding 128 128 getinterval astore pop
level2 startnoload
/copyfontdict
{
findfont dup length dict
begin
{
1 index/FID ne{def}{pop pop}ifelse
}forall
}bd
level2 endnoload level2 not startnoload
/copyfontdict
{
findfont dup length dict
copy
begin
}bd
level2 not endnoload
md/fontname known not{
/fontname/customfont def
}if
/Encoding Z
/:mre
{
copyfontdict
/Encoding MacEncoding def
fontname currentdict
end
definefont :ff def
}bd
/:bsr
{
copyfontdict
/Encoding Encoding 256 array copy def
Encoding dup
}bd
/pd{put dup}bd
/:esr
{
pop pop
fontname currentdict
end
definefont :ff def
}bd
/scf
{
scalefont def
}bd
/scf-non
{
$m scale :mf setfont
}bd
/ps Z
/fz{/ps xs}bd
/sf/setfont ld
/cF/currentfont ld
/mbf
{
/makeblendedfont where
{
pop
makeblendedfont
/ABlend exch definefont
}{
pop
}ifelse
def
}def
%%EndFile
%%BeginFile: adobe_psp_derived_styles
%%Copyright: Copyright 1990-1993 Adobe Systems Incorporated. All Rights Reserved.
/wi
version(23.0)eq
{
{
gS 0 0 0 0 rC stringwidth gR
}bind
}{
/stringwidth load
}ifelse
def
/$o 1. def
/gl{$o G}bd
/ms{:M S}bd
/condensedmtx[.82 0 0 1 0 0]def
/:mc
{
condensedmtx :mf def
}bd
/extendedmtx[1.18 0 0 1 0 0]def
/:me
{
extendedmtx :mf def
}bd
/basefont Z
/basefonto Z
/dxa Z
/dxb Z
/dxc Z
/dxd Z
/dsdx2 Z
/bfproc Z
/:fbase
{
dup/FontType get 0 eq{
dup length dict begin
dup{1 index/FID ne 2 index/UniqueID ne and{def}{pop pop}ifelse}forall
/FDepVector exch/FDepVector get[exch/:fbase load forall]def
}/bfproc load ifelse
/customfont currentdict end definefont
}bd
/:mo
{
/bfproc{
dup dup length 2 add dict
begin
{
1 index/FID ne 2 index/UniqueID ne and{def}{pop pop}ifelse
}forall
/PaintType 2 def
/StrokeWidth .012 0 FontMatrix idtransform pop def
/customfont currentdict
end
definefont
8 dict begin
/basefonto xdf
/basefont xdf
/FontType 3 def
/FontMatrix[1 0 0 1 0 0]def
/FontBBox[0 0 1 1]def
/Encoding StandardEncoding def
/BuildChar
{
exch begin
basefont setfont
( )dup 0 4 -1 roll put
dup wi
setcharwidth
0 0 :M
gS
gl
dup show
gR
basefonto setfont
show
end
}def
}store :fbase
}bd
/:mso
{
/bfproc{
7 dict begin
/basefont xdf
/FontType 3 def
/FontMatrix[1 0 0 1 0 0]def
/FontBBox[0 0 1 1]def
/Encoding StandardEncoding def
/BuildChar
{
exch begin
sD begin
/dxa 1 ps div def
basefont setfont
( )dup 0 4 -1 roll put
dup wi
1 index 0 ne
{
exch dxa add exch
}if
setcharwidth
dup 0 0 ms
dup dxa 0 ms
dup dxa dxa ms
dup 0 dxa ms
gl
dxa 2. div dup ms
end
end
}def
}store :fbase
}bd
/:ms
{
/bfproc{
dup dup length 2 add dict
begin
{
1 index/FID ne 2 index/UniqueID ne and{def}{pop pop}ifelse
}forall
/PaintType 2 def
/StrokeWidth .012 0 FontMatrix idtransform pop def
/customfont currentdict
end
definefont
8 dict begin
/basefonto xdf
/basefont xdf
/FontType 3 def
/FontMatrix[1 0 0 1 0 0]def
/FontBBox[0 0 1 1]def
/Encoding StandardEncoding def
/BuildChar
{
exch begin
sD begin
/dxb .05 def
basefont setfont
( )dup 0 4 -1 roll put
dup wi
exch dup 0 ne
{
dxb add
}if
exch setcharwidth
dup dxb .01 add 0 ms
0 dxb :T
gS
gl
dup 0 0 ms
gR
basefonto setfont
0 0 ms
end
end
}def
}store :fbase
}bd
/:mss
{
/bfproc{
7 dict begin
/basefont xdf
/FontType 3 def
/FontMatrix[1 0 0 1 0 0]def
/FontBBox[0 0 1 1]def
/Encoding StandardEncoding def
/BuildChar
{
exch begin
sD begin
/dxc 1 ps div def
/dsdx2 .05 dxc 2 div add def
basefont setfont
( )dup 0 4 -1 roll put
dup wi
exch dup 0 ne
{
dsdx2 add
}if
exch setcharwidth
dup dsdx2 .01 add 0 ms
0 .05 dxc 2 div sub :T
dup 0 0 ms
dup dxc 0 ms
dup dxc dxc ms
dup 0 dxc ms
gl
dxc 2 div dup ms
end
end
}def
}store :fbase
}bd
/:msb
{
/bfproc{
7 dict begin
/basefont xdf
/FontType 3 def
/FontMatrix[1 0 0 1 0 0]def
/FontBBox[0 0 1 1]def
/Encoding StandardEncoding def
/BuildChar
{
exch begin
sD begin
/dxd .03 def
basefont setfont
( )dup 0 4 -1 roll put
dup wi
1 index 0 ne
{
exch dxd add exch
}if
setcharwidth
dup 0 0 ms
dup dxd 0 ms
dup dxd dxd ms
0 dxd ms
end
end
}def
}store :fbase
}bd
/italicmtx[1 0 -.212557 1 0 0]def
/:mi
{
italicmtx :mf def
}bd
/:v
{
[exch dup/FontMatrix get exch
dup/FontInfo known
{
/FontInfo get
dup/UnderlinePosition known
{
dup/UnderlinePosition get
2 index 0
3 1 roll
transform
exch pop
}{
.1
}ifelse
3 1 roll
dup/UnderlineThickness known
{
/UnderlineThickness get
exch 0 3 1 roll
transform
exch pop
abs
}{
pop pop .067
}ifelse
}{
pop pop .1 .067
}ifelse
]
}bd
/$t Z
/$p Z
/$s Z
/:p
{
aload pop
2 index mul/$t xs
1 index mul/$p xs
.012 mul/$s xs
}bd
/:m
{gS
0 $p rm
$t lw
0 rl stroke
gR
}bd
/:n
{
gS
0 $p rm
$t lw
0 rl
gS
gl
stroke
gR
strokepath
$s lw
/setstrokeadjust where{pop
currentstrokeadjust true setstrokeadjust stroke setstrokeadjust
}{
stroke
}ifelse
gR
}bd
/:o
{gS
0 $p rm
$t 2 div dup rm
$t lw
dup 0 rl
stroke
gR
:n
}bd
%%EndFile
/currentpacking where {pop sc_oldpacking setpacking}if end
%%EndProlog
%%BeginSetup
md begin
countdictstack[{
%%BeginFeature: *ManualFeed False
level2 {1 dict dup /ManualFeed false put setpagedevice}{statusdict begin /manualfeed false store end} ifelse
%%EndFeature
}featurecleanup
countdictstack[{
%%BeginFeature: *InputSlot Upper

%%EndFeature
}featurecleanup
countdictstack[{
%%BeginFeature: *PageRegion A4Small
level2 { 
		2 dict dup /PageSize [595 842] put dup /ImagingBBox [28 30 566 811] put setpagedevice
	}{
		a4small
	} ifelse
%%EndFeature
}featurecleanup
(Hanspeter M\232ssenb\232ck)setjob
/mT[1 0 0 -1 28 811]def
initQDpatterns
/sD 16 dict def
300 level2{1 dict dup/WaitTimeout 4 -1 roll put setuserparams}{statusdict/waittimeout 3 -1 roll put}ifelse
%%IncludeFont: Helvetica
%%IncludeFont: Helvetica-Bold
%%IncludeFont: Helvetica-Oblique
%%IncludeFont: Helvetica-BoldOblique
%%IncludeFont: Times-Bold
%%IncludeFont: Times-Roman
%%IncludeFont: Symbol
%%IncludeFont: Courier
/f0_1/Helvetica
:mre
/f0_14 f0_1 14 scf
/f0_10 f0_1 10 scf
/f0_9 f0_1 9 scf
/f1_1/Helvetica-Bold
:mre
/f1_14 f1_1 14 scf
/f1_12 f1_1 12 scf
/f1_10 f1_1 10 scf
/f1_9 f1_1 9 scf
/f3_1/Helvetica-Oblique
:mre
/f3_10 f3_1 10 scf
/f3_9 f3_1 9 scf
/f6_1/Helvetica-BoldOblique
:mre
/f6_10 f6_1 10 scf
/f7_1/Times-Bold
:mre
/f7_14 f7_1 14 scf
/f8_1/Times-Roman
:mre
/f8_10 f8_1 10 scf
/f9_1/Symbol
:bsr
240/apple pd
:esr
/f9_10 f9_1 10 scf
/f9_9 f9_1 9 scf
/f10_1/Courier
:mre
/f10_9 f10_1 9 scf
/Courier findfont[10 0 0 -10 0 0]:mf setfont
%%EndSetup
%%Page: 1 1
%%BeginPageSetup
initializepage
(Hanspeter M\232ssenb\232ck; page: 1 of 29)setjob
%%EndPageSetup
gS 0 0 538 781 rC
0 0 538 34 rC
500 28 :M
f0_9 sf
(3)S
gR
gS 0 49 538 667 rC
84 92 :M
14.915 0 rm
f1_14 sf
(Coco/)S
f7_14 sf
(R \320 )S
f1_14 sf
(A Generator for Fast Compiler Front-Ends)S
184 114 :M
f0_14 sf
-.125(H. M\232ssenb\232ck, ETH Z\237rich)A
216 132 :M
.605 0 rm
(Technical Report)S
34 161 :M
f1_10 sf
.636(Abstract)A
34 189 :M
f0_10 sf
.66 .066(Formal compiler descriptions serve two purposes: \(1\) they can be used as a reference document which)J
34 203 :M
.863 .086(specifies the syntax and the semantics of a language, and \(2\) they provide a convenient notation from)J
34 217 :M
.333 .033(which efficient compilers can be generated. Compiler generating systems put emphasis on either the one)J
34 231 :M
.089 .009(or the other of these aspects. The system described in this report mainly concentrates on the second goal.)J
34 245 :M
1.538 .154(We show that it is possible to generate compilers that are as efficient as hand-coded and carefully)J
34 259 :M
.971 .097(optimized production-quality compilers. Our system generates recursive descent parsers with a simple)J
34 273 :M
-.008(error-handling mechanism and scanners with a special buffering scheme. Almost as important as efficiency)A
34 287 :M
-.043(is the simplicity and adequacy of the system. Programmers are not willing to use a tool if it does not come in)A
34 301 :M
.061 .006(handy in their work, if it uses a cryptic notation or a multitude of options and special cases. The tool should)J
34 315 :M
-.002(make their work easier without limiting their flexibility. We used our system to generate an Oberon compiler)A
34 329 :M
-.035(that is even faster than the standard Oberon compiler used at ETH.)A
34 371 :M
f1_10 sf
.955(Contents)A
34 399 :M
f0_10 sf
.663(1.)A
48 399 :M
.16(Introduction)A
34 423 :M
.663(2.)A
48 423 :M
.08 .008(The Compiler Description Language Cocol/R)J
48 437 :M
.552(2.1)A
68 437 :M
(Overall Structure)S
48 451 :M
.552(2.2)A
68 451 :M
.436 .044(Scanner Specification)J
48 465 :M
.552(2.3)A
68 465 :M
.034 .003(Parser Specification)J
34 489 :M
.663(3.)A
48 489 :M
-.069(Using Coco/R to Generate a Compiler)A
48 503 :M
.552(3.1)A
68 503 :M
.034 .003(Scanner Interface)J
48 517 :M
.552(3.2)A
68 517 :M
-.075(Parser Interface)A
48 531 :M
.552(3.3)A
68 531 :M
-.286(Grammar Tests)A
34 555 :M
.663(4.)A
48 555 :M
-.017(Hints for Advanced Users of Coco/R)A
34 579 :M
.663(5.)A
48 579 :M
.051(Implementation)A
48 593 :M
.552(5.1)A
68 593 :M
.196 .02(Scanner Generation)J
48 607 :M
.552(5.2)A
68 607 :M
-.042(Parser Generation)A
48 621 :M
.552(5.3)A
68 621 :M
-.016(Error Recovery)A
34 645 :M
.663(6.)A
48 645 :M
.08(Measurements)A
34 669 :M
.663(7.)A
48 669 :M
-.128(Summary)A
34 697 :M
-.124(Appendix A  Cocol/R Grammar)A
34 711 :M
-.064(Appendix B  Sample Attributed Grammar in Cocol/R)A
endp
%%Page: 2 2
%%BeginPageSetup
initializepage
(Hanspeter M\232ssenb\232ck; page: 2 of 29)setjob
%%EndPageSetup
gS 0 0 538 781 rC
0 0 538 34 rC
34 28 :M
f0_9 sf
(4)S
gR
gS 0 53 538 675 rC
34 63 :M
f1_10 sf
4.406 .441(1. Introduction)J
34 91 :M
f0_10 sf
.532 .053(Coco/R is a program that takes an augmented EBNF grammar of a language and generates a recursive)J
34 105 :M
-.057(descent parser and a scanner for this language. The programmer has to supply a main module that calls the)A
34 119 :M
.213 .021(parser, as well as semantic modules that are called from within the grammar \(e.g., a symbol table handler)J
34 133 :M
-.042(and a code generator\). )A
1 G
113 165 309 96 rC
334 195 43 15 rF
0 G
334.5 195.5 42 14 rS
1 G
334 165 43 15 rF
0 G
.016 lw
334.5 165.5 42 14 rS
1 G
289 231 43 15 rF
0 G
1 lw
289.5 231.5 42 14 rS
1 G
334 231 43 15 rF
0 G
.016 lw
334.5 231.5 42 14 rS
1 G
379 231 43 15 rF
0 G
379.5 231.5 42 14 rS
342 206 :M
f0_9 sf
.1(Parser)A
346 176 :M
-.166(Main)A
294 242 :M
.082(Scanner)A
339 257 :M
(Semantic modules)S
195 222 :M
(Coco)S
122 245 :M
-.142(Compiler)A
117 256 :M
.149(description)A
-.016 -.016 310.016 231.016 .016 .016 310 222 @b
-.016 -.016 400.016 231.016 .016 .016 400 222 @b
310 222.016 -.016 .016 340.016 222 .016 310 222 @a
370 222.016 -.016 .016 400.016 222 .016 370 222 @a
113 212 309 49 rC
-.016 -.016 340.016 222.016 .016 .016 340 210 @b
gR
gS 113 165 309 96 rC
5 75 105 340 210 @k
113 212 309 49 rC
-.016 -.016 370.016 222.016 .016 .016 370 210 @b
gR
gS 113 165 309 96 rC
5 75 105 370 210 @k
113 212 309 49 rC
-.016 -.016 355.016 231.016 .016 .016 355 210 @b
gR
gS 113 165 309 96 rC
5 75 105 355 210 @k
113 182 309 79 rC
-.016 -.016 355.016 195.016 .016 .016 355 180 @b
gR
gS 113 165 309 96 rC
5 75 105 355 180 @k
-.016 -.016 118.016 231.016 .016 .016 118 195 @b
118 231.016 -.016 .016 148.016 231 .016 118 231 @a
-.016 -.016 148.016 231.016 .016 .016 148 189 @b
124 189.016 -.016 .016 148.016 189 .016 124 189 @a
-.016 -.016 118.016 195.016 .016 .016 124 189 @b
118 195.016 -.016 .016 124.016 195 .016 118 195 @a
-.016 -.016 124.016 195.016 .016 .016 124 189 @b
113 165 195 96 rC
250 201.016 -.016 .016 310.016 201 .016 250 201 @a
gR
gS 113 165 309 96 rC
5 165 195 310 201 @k
113 165 156 96 rC
250 237.016 -.016 .016 271.016 237 .016 250 237 @a
gR
gS 113 165 309 96 rC
5 165 195 271 237 @k
-.016 -.016 250.016 237.016 .016 .016 250 222 @b
-.016 -.016 250.016 216.016 .016 .016 250 201 @b
226 222.016 -.016 .016 250.016 222 .016 226 222 @a
226 216.016 -.016 .016 250.016 216 .016 226 216 @a
113 165 66 96 rC
157 219.016 -.016 .016 181.016 219 .016 157 219 @a
gR
gS 113 165 309 96 rC
5 165 195 181 219 @k
gR
gS 0 53 538 675 rC
34 289 :M
f0_10 sf
1.029 .103(The input language of Coco/R \(Cocol/R\) is based on )J
f3_10 sf
1.909 .191(attributed grammars)J
f0_10 sf
1.357 .136(. Attributed grammars were)J
34 303 :M
.686 .069(introduced by )J
f3_10 sf
.194(Knuth)A
f0_10 sf
.638 .064( [Knu68] as a formalism to specify the semantics of context-free languages. In their)J
34 317 :M
1.255 .125(original form they are static descriptions. They describe dependencies between attributes of symbols)J
34 331 :M
.284 .028(without giving an order in which the dependencies are to be evaluated. Many compiler generators stick to)J
34 345 :M
.654 .065(this notation [GaGi84, KHZ82, R\212i83]. For the implementation of efficient compilers, however, it may be)J
34 359 :M
-.013(better to look at attributed grammars as an algorithmic notation. The evaluation order of semantic actions is)A
34 373 :M
1.302 .13(then determined by the textual order of the actions in the grammar. There are also several compiler)J
34 387 :M
.072 .007(generators, including Coco/R, that use this paradigm [John75, Gro88]. )J
34 415 :M
.639 .064(Coco/R is an improvement over an older version of this program \(Coco [ReM\23289]\). The main difference)J
34 429 :M
1.092 .109(between Coco and Coco/R is that Coco/R produces recursive descent parsers instead of table-driven)J
34 443 :M
.621 .062(parsers and that it integrates the scanner description and the parser description, thus avoiding interface)J
34 457 :M
.069 .007(problems between the generated parts. A main nuisance of Coco was that all attributes had to be declared)J
34 471 :M
.638 .064(in a global scope, making it necessary to stack attribute values from time to time. This was remedied in)J
34 485 :M
-.003(Coco/R. Attributes can be declared local to productions. A similar extension of Coco, based on table-driven)A
34 499 :M
.201 .02(parsing, has recently been described in [DoPi90].)J
34 527 :M
.764 .076(The following example gives an impression of how a compiler description might look. A precise specifi-)J
34 541 :M
1.005 .101(cation of the description language follows in Section 2. The example shows the translation of variable)J
34 555 :M
1.263 .126(declarations. The task is to enter declared names into a symbol table and to compute addresses for)J
34 569 :M
-.122(variables. One starts with a context-free EBNF grammar that is usually already at hand)A
48 597 :M
-.025(VarDeclaration = Ident {"," Ident} ":" Type ";".)A
34 625 :M
-.063(By simply writing down this rule, one already gets a parser that can check variable declarations syntactically.)A
34 639 :M
.053 .005(To process them semantically as well,one has to think about how variable declarations are translated. This)J
34 653 :M
.378 .038(requires the following considerations:)J
34 681 :M
<A5>S
48 681 :M
1.292 .129(What are the semantic values of )J
f3_10 sf
.386(VarDeclaration)A
f0_10 sf
.378 .038(, )J
f3_10 sf
.363(Ident)A
f0_10 sf
.726 .073( and )J
f3_10 sf
.454(Type)A
f0_10 sf
1.265 .127(? In other words, what does the)J
48 695 :M
.168 .017(recognition of these symbols yield and what context information must be supplied in order to be able to)J
48 709 :M
.766 .077(recognize them? This leads to the so-called )J
f3_10 sf
.184(attributes)A
f0_10 sf
.598 .06( of the symbols. The attribute of an )J
f3_10 sf
.199(Ident)A
f0_10 sf
.391 .039( is its)J
48 723 :M
1.198 .12(name, while the attribute of a )J
f3_10 sf
.462(Type)A
f0_10 sf
1.26 .126( is some node with type information. )J
f3_10 sf
.392(VarDeclaration)A
f0_10 sf
1.221 .122( does not)J
endp
%%Page: 3 3
%%BeginPageSetup
initializepage
(Hanspeter M\232ssenb\232ck; page: 3 of 29)setjob
%%EndPageSetup
gS 0 0 538 781 rC
0 0 538 34 rC
500 28 :M
f0_9 sf
(5)S
gR
gS 0 47 538 687 rC
48 57 :M
f0_10 sf
.412 .041(produce an attribute. Instead, it needs an attribute from its context; i.e., it needs to know the next free)J
48 71 :M
-.02(address in the address space for variables. Attributes can be considered as \(input or output\) parameters)A
48 85 :M
-.018(of syntax symbols. They are denoted as follows:)A
62 113 :M
.144 .014(Ident <name>)J
62 127 :M
.515 .051(Type <typ>)J
62 141 :M
-.106(VarDeclaration <adr>)A
34 169 :M
<A5>S
48 169 :M
.005 0(The next question is: what actions are necessary to translate a construct? These actions are formulated)J
48 183 :M
.191 .019(in a general purpose programming language \(e.g., )J
f3_10 sf
.056(Oberon)A
f0_10 sf
.176 .018( [Wirth89]\) and are enclosed by the symbols)J
48 197 :M
.95 .095("\(." and ".\)". A semantic action may appear anywhere on the right-hand side of a production and is)J
48 211 :M
.173 .017(executed at that point during parsing.)J
34 239 :M
.232 .023(These consideration lead to an attributed production:)J
48 267 :M
-.136(VarDeclaration <VAR adr: LONGINT>)A
170 281 :M
-.106(\(.)A
181 281 :M
-.112(VAR )A
207 281 :M
-.042(obj, obj1: SymTab.Object; typ: SymTab.Type;  n, a: LONGINT; )A
181 295 :M
-1.557(  )A
207 295 :M
-.107(name: ARRAY 32 OF CHAR;.\))A
48 309 :M
(=)S
62 309 :M
.144 .014(Ident <name>)J
170 309 :M
-.106(\(.)A
181 309 :M
-.074(obj := SymTab.Find\(name\); obj.link := NIL; n := 1 .\))A
62 323 :M
-.028({ "," Ident <name>)A
170 323 :M
-.106(\(.)A
181 323 :M
-.053(obj1 := SymTab.Find\(name\);  obj1.link := obj; obj := obj1; INC\(n\) .\))A
62 337 :M
(} ":")S
62 351 :M
.515 .051(Type <typ>)J
170 351 :M
-.106(\(.)A
181 351 :M
-.15(adr := adr + n* typ.size; a := adr;)A
181 365 :M
-.128(WHILE obj # NIL DO DEC\(a, typ.size\); obj.adr := a; obj := obj.link END  .\))A
62 379 :M
.448(";".)A
34 407 :M
.214 .021(Although the format is free, it is wise to shift syntactic parts to the left and semantic parts to the right. This)J
34 421 :M
.59 .059(gives a nice separation between syntax and semantics and makes it immediately clear what actions are)J
34 435 :M
1.673 .167(executed upon recognition of a certain syntax symbol. Note that the production also contains local)J
34 449 :M
-.03(declarations of variables needed in the semantic actions. Besides, globally declared or imported names can)A
34 463 :M
(also be accessed.)S
34 491 :M
1.177 .118(An attributed grammar can be viewed as a special purpose language for writing compilers \(or similar)J
34 505 :M
.051 .005(programs\). It is a short-hand notation for the well-known recursive descent technique. Although it is not too)J
34 519 :M
-.038(hard to implement a compiler front-end by hand, a notation like the above can have advantages:)A
34 547 :M
<A5>S
48 547 :M
-.015(It is easy to read. Syntax and semantics are clearly separated. Semantic actions are not buried between)A
48 561 :M
.272 .027(parsing statements.)J
34 575 :M
<A5>S
48 575 :M
1.491 .149(Routine activities like getting the next token from the scanner, handling alternatives, options and)J
48 589 :M
-.034(iterations, or error-handling don't have to be written down explicitly but are derived from the grammar.)A
34 603 :M
<A5>S
48 603 :M
1.203 .12(It is faster and safer to implement a compiler in this high-level notation than in a general purpose)J
48 617 :M
.051 .005(programming language. During language design several alternatives of a construct can be tried out and)J
48 631 :M
.304 .03(their implementations can be prototyped.)J
34 645 :M
<A5>S
48 645 :M
1.836 .184(Irregularities in the grammar like circular productions or violations of the LL\(1\) property can go)J
48 659 :M
1.053 .105(undetected when the parser is implemented by hand. For a generator it is easy to check for these)J
48 673 :M
-.015(irregularities.)A
34 701 :M
1.48 .148(Compiler generators enable programmers who are not experienced compiler writers to process little)J
34 715 :M
.473 .047(languages. Examples for little languages are numerous in programming [Ben88], ranging from command)J
34 729 :M
-.018(languages to descriptions of data structures on a file.)A
endp
%%Page: 4 4
%%BeginPageSetup
initializepage
(Hanspeter M\232ssenb\232ck; page: 4 of 29)setjob
%%EndPageSetup
gS 0 0 538 781 rC
0 0 538 34 rC
34 28 :M
f0_9 sf
(6)S
gR
gS 0 54 538 673 rC
34 64 :M
f0_10 sf
.418 .042(The rest of this report describes the input language Cocol/R, shows how the generator can be used, and)J
34 78 :M
.374 .037(gives an overview of its implementation together with measurements. The appendix contains an example)J
34 92 :M
-.1(of a compiler description for a small language. )A
34 134 :M
f1_10 sf
3.299 .33(2. The Compiler Description Language Cocol/R)J
34 162 :M
f0_10 sf
.387 .039(A compiler description can be viewed as a module consisting of imports, declarations and grammar rules)J
34 176 :M
1.079 .108(that describe the lexical and syntactical structure of a language as well as its translation into a target)J
34 190 :M
-.026(language. The vocabulary of Cocol/R uses identifiers, strings and numbers in the usual way:)A
48 218 :M
.053 .005(ident = letter {letter|digit}.)J
48 232 :M
.284 .028(string = ')J
f8_10 sf
.092(")A
f0_10 sf
.454 .045(' {anyButQuote} ')J
f8_10 sf
.092(")A
f0_10 sf
.205 .021(' |\312")J
f8_10 sf
(')S
f0_10 sf
.547 .055(" {anyButApostrophe} ")J
f8_10 sf
(')S
f0_10 sf
.143(".)A
48 246 :M
-.009(number = digit {digit}.)A
34 274 :M
-.045(Upper case letters are distinct from lower case letters. Strings must not cross line borders. Keywords are)A
48 302 :M
f0_9 sf
-.315(ANY  CASE  CHARACTERS  CHR  COMMENTS  COMPILER  CONTEXT  END  FROM  IGNORE)A
48 316 :M
-.275(NESTED  PRAGMAS  PRODUCTIONS  SYNC  TO  TOKENS  WEAK)A
34 344 :M
f0_10 sf
-.024(The following metacharacters are used to form EBNF expressions:)A
48 372 :M
-.754(\(   \) )A
85 372 :M
.788 .079(for grouping)J
48 386 :M
-.762({   }  )A
85 386 :M
(for iterations)S
48 400 :M
-.604([   ]   )A
85 400 :M
.661 .066(for options)J
48 414 :M
-.504(< >  )A
85 414 :M
.19 .019(for attributes)J
48 428 :M
-.513(\(.   .\)  )A
85 428 :M
-.085(for semantic parts)A
48 442 :M
-.437(= . | + -)A
85 442 :M
(as explained below)S
34 470 :M
-.038(Comments are enclosed in "\(*" and "*\)" and may be nested. The semantic parts may contain declarations or)A
34 484 :M
.702 .07(statements in a general purpose programming language. The language actually used is implementation)J
34 498 :M
.603 .06(dependent. This implementation uses Oberon.)J
34 540 :M
f1_10 sf
3.802 .38(2.1 Overall Structure)J
34 568 :M
f0_10 sf
-.027(A compiler description is made up of the following parts)A
48 581 184 1 rC
48 581.016 -.016 .016 231.016 581 .016 48 581 @a
gR
gS 0 54 538 673 rC
48 596 :M
f0_10 sf
-.136(Cocol = )A
96 596 :M
.49 .049("COMPILER" ident)J
96 610 :M
f3_10 sf
-.092(arbitraryText)A
96 624 :M
f0_10 sf
.11(ScannerSpecification)A
96 638 :M
.049(ParserSpecification)A
96 652 :M
.245 .024("END" ident "." .)J
48 665 184 1 rC
48 665.016 -.016 .016 231.016 665 .016 48 665 @a
gR
gS 0 54 538 673 rC
34 694 :M
f0_10 sf
-.026(The name after the keyword COMPILER is the )A
f3_10 sf
-.03(grammar name)A
f0_10 sf
-.025( and must match the name after the keyword)A
34 708 :M
-.058(END. The grammar name also denotes the topmost nonterminal \(the start symbol\). After the grammar name)A
34 722 :M
1.036 .104(arbitrary Oberon text may follow that is not checked by Coco/R. It usually contains imports of Oberon)J
endp
%%Page: 5 5
%%BeginPageSetup
initializepage
(Hanspeter M\232ssenb\232ck; page: 5 of 29)setjob
%%EndPageSetup
gS 0 0 538 781 rC
0 0 538 34 rC
500 28 :M
f0_9 sf
(7)S
gR
gS 0 44 538 687 rC
34 54 :M
f0_10 sf
.213 .021(modules and declarations of global objects \(constants, types, variables, or procedures\) that are needed in)J
34 68 :M
1.206 .121(the semantic actions later on. The remaining parts of the compiler description specify the lexical and)J
34 82 :M
.103 .01(syntactical structure of the language to be processed.)J
34 124 :M
f1_10 sf
4.289 .429(2.2 Scanner Specification)J
34 152 :M
f0_10 sf
.478 .048(A scanner has to read source text, skip meaningless characters, and recognize tokens which have to be)J
34 166 :M
.596 .06(passed to the parser. Tokens may be classified as )J
f3_10 sf
.134(literals)A
f0_10 sf
.33 .033( and )J
f3_10 sf
.977 .098(token classes)J
f0_10 sf
.637 .064(. Literals \(e.g., "END", ":=",)J
34 180 :M
.109 .011(etc.\) are written as strings and denote themselves. They are introduced right in the productions and do not)J
34 194 :M
.837 .084(have to be declared. Token classes \(e.g., identifiers or numbers\) have a certain structure that must be)J
34 208 :M
-.044(declared by a regular expression in EBNF. There are usually many different instances of a token class \(e.g.,)A
34 222 :M
-.036(many different identifiers\) which are all recognized as the same token.)A
48 235 322 1 rC
48 235.016 -.016 .016 369.016 235 .016 48 235 @a
gR
gS 0 44 538 687 rC
48 250 :M
f0_10 sf
.473 .047(ScannerSpecification =)J
62 264 :M
-.025({ "CHARACTERS" {SetDecl})A
62 278 :M
.041 .004(| "TOKENS" {TokenDecl})J
62 292 :M
-.128(| "PRAGMAS" {PragmaDecl})A
62 306 :M
-.059(| CommentDecl)A
62 320 :M
-.106(| VariousDecl)A
62 334 :M
-.118(}.)A
48 347 322 1 rC
48 347.016 -.016 .016 369.016 347 .016 48 347 @a
gR
gS 0 44 538 687 rC
34 376 :M
f0_10 sf
-.067(A scanner specification consists of 5 optional parts that may be written in arbitrary order.)A
34 404 :M
f6_10 sf
2.14 .214(Character sets)J
f0_10 sf
1.2 .12(. This section allows the declaration of names for character sets like letters or digits.)J
34 418 :M
.024 .002(These names may be used in the other sections of the scanner specification.)J
48 431 253 1 rC
48 431.016 -.016 .016 300.016 431 .016 48 431 @a
gR
gS 0 44 538 687 rC
48 446 :M
f0_10 sf
.127 .013(SetDecl )J
96 446 :M
.317 .032(= ident "=" Set.)J
48 460 :M
.165 .016(Set )J
96 460 :M
-.061(= BasicSet { \("+"|"-"\) BasicSet}.)A
48 474 :M
-.029(BasicSet )A
96 474 :M
-.095(= ident | string | "CHR" "\(" number "\)" | "ANY".)A
48 487 253 1 rC
48 487.016 -.016 .016 300.016 487 .016 48 487 @a
gR
gS 0 44 538 687 rC
34 516 :M
f3_10 sf
-.115(SetDecl)A
f0_10 sf
-.104( associates a name with a character set. Basic character sets are denoted as)A
48 530 :M
.111(string)A
113 530 :M
-.079(a set consisting of all characters in the string)A
48 544 :M
.331(ident)A
113 544 :M
-.04(the previously declared character set with this name)A
48 558 :M
-.306(CHR\(i\))A
113 558 :M
-.077(a character set consisting of a single element with ordinal value i)A
48 572 :M
-.28(ANY)A
113 572 :M
-.098(the set of all characters)A
34 600 :M
-.075(Character sets may be formed from basic sets by the operators)A
48 614 :M
(+)S
62 614 :M
.794 .079(set union)J
48 628 :M
(-)S
62 628 :M
.863 .086(set difference)J
34 656 :M
.015(Examples)A
48 670 :M
1.2 .12(digit = "0123456789".)J
198 670 :M
-.051(the set of all digits)A
48 684 :M
.147 .015(hexdigit = digit + "ABCDEF".)J
198 684 :M
-.06(the set of all hexadecimal digits)A
48 698 :M
-.073(eol = CHR\(13\).)A
198 698 :M
.108 .011(end-of-line character)J
48 712 :M
-.098(noDigit = ANY - digit.)A
198 712 :M
-.102(Any character that is not a digit)A
endp
%%Page: 6 6
%%BeginPageSetup
initializepage
(Hanspeter M\232ssenb\232ck; page: 6 of 29)setjob
%%EndPageSetup
gS 0 0 538 781 rC
0 0 538 34 rC
34 28 :M
f0_9 sf
(8)S
gR
gS 0 49 538 645 rC
34 59 :M
f6_10 sf
.108(Tokens)A
f0_10 sf
.296 .03(. A token is a terminal symbol for the parser but a syntactically structured symbol for the scanner.)J
34 73 :M
-.031(This structure has to be described by a regular expression in EBNF.)A
48 86 361 1 rC
48 86.016 -.016 .016 408.016 86 .016 48 86 @a
gR
gS 0 49 538 645 rC
48 101 :M
f0_10 sf
.231 .023(TokenDecl )J
113 101 :M
(=)S
122 101 :M
.506 .051(Symbol ["=" TokenExpr "."].)J
48 115 :M
.463 .046(TokenExpr )J
113 115 :M
(=)S
122 115 :M
.016 .002(TokenTerm {"|" TokenTerm}.)J
48 129 :M
.06 .006(TokenTerm )J
113 129 :M
(=)S
122 129 :M
.075 .008(TokenFactor {TokenFactor} ["CONTEXT" "\(" TokenExpr "\)"].)J
48 143 :M
.049 .005(TokenFactor )J
113 143 :M
(=)S
122 143 :M
-.023(Symbol | "\(" TokenExpr "\)" |  "[" TokenExpr "]" | "{" TokenExpr "}".)A
48 157 :M
.133(Symbol)A
113 157 :M
-.618(= )A
122 157 :M
-.004(ident | string.)A
48 170 361 1 rC
48 170.016 -.016 .016 408.016 170 .016 48 170 @a
gR
gS 0 49 538 645 rC
34 199 :M
f0_10 sf
.797 .08(Tokens may be declared in any order. A token declaration defines a symbol together with its structure.)J
34 213 :M
.642 .064(Usually the symbol on the left-hand side of the declaration is an identifier. It is declared to stand for the)J
34 227 :M
.196 .02(structure described on the right-hand side of the declaration. \(For special purposes the symbol on the left-)J
34 241 :M
-.059(hand side may also be a string, in which case no right-hand side may be specified; see Section 4.\) )A
34 269 :M
1.854 .185(The right-hand side of a token declaration specifies the structure of the token by a regular EBNF)J
34 283 :M
1.965 .197(expression. This expression may contain literals denoting themselves \(e.g., "END"\) and names of)J
34 297 :M
1.032 .103(character sets \(e.g., letter\) denoting an arbitrary character from this set. It must )J
f3_10 sf
.293(not)A
f0_10 sf
1.084 .108( contain names of)J
34 311 :M
2.283 .228(previously declared tokens. The CONTEXT phrase in a )J
f3_10 sf
.694(TokenTerm)A
f0_10 sf
1.724 .172( means that the term is only)J
34 325 :M
.603 .06(recognized when its right-hand context in the input stream is the )J
f3_10 sf
.199(TokenExpr)A
f0_10 sf
.569 .057( specified in brackets. If the)J
34 339 :M
-.008(right-hand side of a declaration is missing, no scanner is generated. This gives the programmer the chance)A
34 353 :M
-.003(to provide a hand-written scanner \(see Section 4\).)A
34 381 :M
.015(Examples)A
48 395 :M
.365 .036(ident )J
91 395 :M
-.071(= letter {letter | digit}.)A
48 409 :M
-.361(real )A
91 409 :M
-.005(= digit {digit} "." {digit} ["E" ["+"|"-"] digit {digit}].)A
48 423 :M
.206 .021(number )J
91 423 :M
-.01(= digit {digit} | digit {digit}\312CONTEXT \(".."\).)A
34 451 :M
.936 .094(The CONTEXT phrase in the above example allows a distinction between reals \(e.g., 1.23\) and range)J
34 465 :M
.015 .002(constructs \(e.g., 1..2\) that could otherwise not be scanned with a single character lookahead.)J
34 493 :M
f0_9 sf
1.171 .117(Note: The scanner exports two variables, )J
f3_9 sf
.344(pos)A
f0_9 sf
.57 .057( and )J
f3_9 sf
.285(len)A
f0_9 sf
.973 .097(, which are the source position and the length of the most)J
34 507 :M
.959 .096(recently recognized token. It also exports a procedure )J
f3_9 sf
.329(GetName)A
f0_9 sf
.179<28>A
f9_9 sf
.324<AF>A
f3_9 sf
.289(pos)A
f0_9 sf
.249 .025(, )J
f9_9 sf
.324<AF>A
f3_9 sf
.239(len)A
f0_9 sf
.249 .025(, )J
f9_9 sf
.324<AD>A
f3_9 sf
.266(sourceText)A
f0_9 sf
.758 .076(\) which can be used to)J
34 521 :M
.103 .01(obtain the source text of the token at position )J
f3_9 sf
.038(pos)A
f0_9 sf
.098 .01( having the length )J
f3_9 sf
.031(len)A
f0_9 sf
.108 .011(. See also Section 3.)J
34 563 :M
f6_10 sf
.119(Pragmas)A
f0_10 sf
.315 .031(. A pragma is a token that may occur anywhere in the input stream \(e.g., end-of-line symbols or)J
34 577 :M
.126 .013(compiler options\). It would be too cumbersome to handle the many places in which they could occur in the)J
34 591 :M
.689 .069(grammar. Therefore a special mechanism is provided to process pragmas without including them in the)J
34 605 :M
.518 .052(productions. Pragmas are declared like tokens, but they may have an associated semantic action that is)J
34 619 :M
.294 .029(executed whenever they are recognized by the scanner.)J
48 632 301 1 rC
48 632.016 -.016 .016 348.016 632 .016 48 632 @a
gR
gS 0 49 538 645 rC
48 647 :M
f0_10 sf
-.178(PragmaDecl )A
108 647 :M
.498 .05(= TokenDecl [SemAction].)J
48 661 :M
.463 .046(SemAction )J
108 661 :M
-.052(= "\(." )A
f3_10 sf
-.064(arbitraryText)A
f0_10 sf
-.055( ".\)".)A
48 674 301 1 rC
48 674.016 -.016 .016 348.016 674 .016 48 674 @a
endp
%%Page: 7 7
%%BeginPageSetup
initializepage
(Hanspeter M\232ssenb\232ck; page: 7 of 29)setjob
%%EndPageSetup
gS 0 0 538 781 rC
0 0 538 34 rC
500 28 :M
f0_9 sf
(9)S
gR
gS 0 54 538 673 rC
34 64 :M
f0_10 sf
.018(Example)A
48 78 :M
-.013(option = "$" {letter} . )A
170 78 :M
-.442(\(. )A
181 78 :M
f3_10 sf
.012(Scanner)A
f0_10 sf
.012(.GetName\()A
f3_10 sf
.012(Scanner)A
f0_10 sf
.034 .003(.pos, )J
f3_10 sf
.012(Scanner)A
f0_10 sf
.026 .003(.len, str\); i := 1;)J
181 92 :M
-.088(WHILE i < )A
f3_10 sf
-.097(Scanner)A
f0_10 sf
-.104(.len DO)A
193 106 :M
-.166(IF str[i] = "A" THEN \311)A
193 120 :M
-.099(ELSIF str[i] = "B" THEN \311)A
193 134 :M
.038(END;)A
193 148 :M
-.418(INC\(i\))A
181 162 :M
-.295(END .\) )A
34 204 :M
f6_10 sf
.487(Comments)A
f0_10 sf
1.352 .135(.  Comments are difficult \(nested comments are even impossible\) to specify with regular)J
34 218 :M
.033 .003(expressions. This makes it necessary to have a special construct to express their structure. Comments are)J
34 232 :M
.636 .064(declared by specifying their opening and their closing brackets. It is possible to declare several kinds of)J
34 246 :M
-.015(comments. Comment brackets must not be longer than 2 characters.)A
48 259 367 1 rC
48 259.016 -.016 .016 414.016 259 .016 48 259 @a
gR
gS 0 54 538 673 rC
48 274 :M
f0_10 sf
.202 .02(CommentDecl = "COMMENTS" "FROM" TokenExpr "TO" TokenExpr ["NESTED"].)J
48 287 367 1 rC
48 287.016 -.016 .016 414.016 287 .016 48 287 @a
gR
gS 0 54 538 673 rC
34 316 :M
f0_10 sf
.015(Examples)A
48 330 :M
-.085(COMMENTS FROM "\(*" TO "*\)" NESTED)A
48 344 :M
-.119(COMMENTS FROM "--" TO eol)A
34 386 :M
f6_10 sf
.089(Various)A
f0_10 sf
.331 .033(. The following options serve to parameterize the generated scanner.)J
48 399 181 1 rC
48 399.016 -.016 .016 228.016 399 .016 48 399 @a
gR
gS 0 54 538 673 rC
48 414 :M
f0_10 sf
-.068(VariousDecl = "IGNORE" \("CASE" | Set\).)A
48 427 181 1 rC
48 427.016 -.016 .016 228.016 427 .016 48 427 @a
gR
gS 0 54 538 673 rC
34 456 :M
f0_10 sf
.03 .003(IGNORE CASE specifies that lower case letters are treated like upper case letters in names.  IGNORE Set)J
34 470 :M
-.003(specifies the set of meaningless characters that are to be skipped by the scanner \(e.g., tabulators and eol\).)A
34 484 :M
-.026(Blank is meaningless by default.)A
34 526 :M
f1_10 sf
4 .4(2.3 Parser Specification)J
34 554 :M
f0_10 sf
1.066 .107(The parser specification is the main part of the compiler description. It contains the productions of an)J
34 568 :M
.472 .047(attributed grammar specifying the syntax of the language to be recognized as well as its translation. The)J
34 582 :M
.076 .008(productions may be given in any order. References to yet undeclared nonterminals are allowed. Any name)J
34 596 :M
.961 .096(that is not declared as a terminal token is considered to be a nonterminal. There must be exactly one)J
34 610 :M
-.036(production for every nonterminal. There must be a production for the start symbol \(the grammar name\).)A
48 623 358 1 rC
48 623.016 -.016 .016 405.016 623 .016 48 623 @a
gR
gS 0 54 538 673 rC
48 638 :M
f0_10 sf
.034 .003(ParserSpecification )J
142 638 :M
(=)S
153 638 :M
.276 .028("PRODUCTIONS" {Production}.)J
48 652 :M
.716 .072(Production )J
142 652 :M
(=)S
153 652 :M
.195 .02(ident [FormalAttributes] [LocalDecl] "=" Expression "." .)J
48 666 :M
.045(FormalAttributes)A
142 666 :M
-.618(= )A
153 666 :M
-.014("<" )A
f3_10 sf
-.015(arbitraryText)A
f0_10 sf
-.016( ">".)A
48 680 :M
.013(LocalDecl)A
142 680 :M
(=)S
153 680 :M
-.03("\(." )A
f3_10 sf
-.04(arbitraryText)A
f0_10 sf
-.035( ".\)".)A
48 694 :M
.133(Symbol)A
142 694 :M
(=)S
153 694 :M
-.004(ident | string.)A
48 707 358 1 rC
48 707.016 -.016 .016 405.016 707 .016 48 707 @a
endp
%%Page: 8 8
%%BeginPageSetup
initializepage
(Hanspeter M\232ssenb\232ck; page: 8 of 29)setjob
%%EndPageSetup
gS 0 0 538 781 rC
0 0 538 34 rC
34 28 :M
f0_9 sf
(10)S
gR
gS 0 47 538 687 rC
34 57 :M
f6_10 sf
.184(Productions)A
f0_10 sf
.556 .056(. A production may be considered as a procedure that parses a nonterminal. It has its own)J
34 71 :M
.48 .048(scope for attributes and local objects and is made up of a left-hand side and a right-hand side which are)J
34 85 :M
.945 .095(separated by an equal sign. The left-hand side specifies the name of the nonterminal together with its)J
34 99 :M
.631 .063(formal attributes and local declarations. The right-hand side consists of a context-free EBNF expression)J
34 113 :M
-.002(that specifies the structure of the nonterminal as well as its translation. The formal attributes are written like)A
34 127 :M
.724 .072(formal parameters in Oberon. They are enclosed in angle brackets. In analogy to input parameters and)J
34 141 :M
.237 .024(output parameters \(variable parameters\) we use the terms input attributes and output attributes. The local)J
34 155 :M
-.006(declarations are arbitrary Oberon declarations enclosed in "\(." and ".\)". A production constitutes a scope for)A
34 169 :M
.105 .01(its formal attributes and its locally declared objects. Terminals and nonterminals, globally declared objects,)J
34 183 :M
-.007(and imported modules are visible in any production.)A
34 211 :M
.018(Example)A
48 225 :M
-.011(Expression <VAR x: Item>)A
227 225 :M
-.13(\(. VAR y: Item; operator: INTEGER; .\))A
48 239 :M
-.391(= \311  .)A
34 267 :M
f6_10 sf
.589(Expressions)A
f0_10 sf
1.89 .189(. An EBNF expression defines the context-free structure of some part of the source)J
34 281 :M
-.018(language together with attributes and semantic actions that specify the translation of this part into the target)A
34 295 :M
.136(language.)A
48 308 358 1 rC
48 308.016 -.016 .016 405.016 308 .016 48 308 @a
gR
gS 0 47 538 687 rC
48 323 :M
f0_10 sf
.384 .038(Expression )J
142 323 :M
(=)S
153 323 :M
-.157(Term {"|" Term}.)A
48 337 :M
-.275(Term )A
142 337 :M
(=)S
153 337 :M
-.127(Factor {Factor}.)A
48 351 :M
-.066(Factor)A
142 351 :M
(=)S
153 351 :M
.685 .068(["WEAK"] Symbol [Attributes])J
142 365 :M
(|)S
153 365 :M
.207(SemAction)A
142 379 :M
(|)S
153 379 :M
-.087("ANY" )A
142 393 :M
(|)S
153 393 :M
.024("SYNC")A
142 407 :M
(|)S
153 407 :M
-.042("\(" Expression "\)"  |  "[" Expression "]"  |  "{" Expression "}".)A
48 421 :M
.197(Attributes)A
142 421 :M
-.618(= )A
153 421 :M
-.014("<" )A
f3_10 sf
-.015(arbitraryText)A
f0_10 sf
-.016( ">".)A
48 435 :M
.207(SemAction)A
142 435 :M
(=)S
153 435 :M
-.03("\(." )A
f3_10 sf
-.04(arbitraryText)A
f0_10 sf
-.035( ".\)".)A
48 449 :M
.133(Symbol)A
142 449 :M
(=)S
153 449 :M
-.004(ident | string.)A
48 462 358 1 rC
48 462.016 -.016 .016 405.016 462 .016 48 462 @a
gR
gS 0 47 538 687 rC
34 491 :M
f0_10 sf
.341 .034(Nonterminals may have attributes. They are written like actual parameters in Oberon and are enclosed in)J
34 505 :M
.01 .001(angle brackets. If a nonterminal has formal attributes, every occurrence of this nonterminal must have a list)J
34 519 :M
.01 .001(of actual attributes that correspond to the formal attributes according to the parameter compatibility rules of)J
34 533 :M
.645 .065(Oberon. The conformance, however, is only checked when the generated parser module is compiled. A)J
34 547 :M
-.016(semantic action is an arbitrary sequence of Oberon statements enclosed in "\(." and ".\)".)A
34 575 :M
.892 .089(The symbol ANY denotes any terminal that is not an alternative of this ANY symbol. It can be used to)J
34 589 :M
.122 .012(conveniently parse structures that contain arbitrary text. For example, the translation of a Cocol/R attribute)J
34 603 :M
-.085(list looks as follows:)A
48 631 :M
-.019(Attributes <VAR pos, len: LONGINT> =)A
62 645 :M
.53("<")A
142 645 :M
-.043(\(. pos := Scanner.pos + 1 .\))A
62 659 :M
-.31({ANY})A
62 673 :M
.53(">")A
142 673 :M
-.064(\(. len := Scanner.pos - pos .\) .)A
34 701 :M
.067 .007(In this example the closing angle bracket is an implicit alternative of the ANY symbol in curly brackets. The)J
34 715 :M
.204 .02(meaning is that ANY matches any terminal except ">". )J
f3_10 sf
.062(Scanner.pos)A
f0_10 sf
.17 .017( is the source text position of the most)J
34 729 :M
.061 .006(recently recognized terminal. It is exported by the generated scanner \(see Section 3\).)J
endp
%%Page: 9 9
%%BeginPageSetup
initializepage
(Hanspeter M\232ssenb\232ck; page: 9 of 29)setjob
%%EndPageSetup
gS 0 0 538 781 rC
0 0 538 34 rC
495 28 :M
f0_9 sf
(11)S
gR
gS 0 47 538 631 rC
34 57 :M
f6_10 sf
.141(Error-handling)A
f0_10 sf
.454 .045(. The programmer has to give some hints in order to allow Coco/R to generate good and)J
34 71 :M
1.112 .111(efficient error-handling. First, )J
f3_10 sf
1.666 .167(synchronization points)J
f0_10 sf
.843 .084( have to be specified. A synchronization point is a)J
34 85 :M
1.127 .113(location in the grammar where especially safe terminals are expected that are hardly ever missing or)J
34 99 :M
.36 .036(mistyped. When the generated parser reaches such a point, it adjusts the input to the next symbol that is)J
34 113 :M
.27 .027(expected at this point. In most languages good candidates for synchronization points are the beginning of)J
34 127 :M
1.523 .152(a statement \(where IF, WHILE, etc. are expected\), the beginning of a declaration sequence \(where)J
34 141 :M
1.831 .183(CONST, VAR, etc. are expected\) and the beginning of a type \(where RECORD, ARRAY, etc. are)J
34 155 :M
.827 .083(expected\). The end-of-file symbol is always among the synchronization symbols which guarantees that)J
34 169 :M
.008 .001(synchronization terminates at least at the end of the source text. A synchronization point is specified by the)J
34 183 :M
-.091(symbol SYNC.)A
34 211 :M
.743 .074(Error-handling can further be improved by specifying which terminals are "weak" in a certain context. A)J
34 225 :M
f3_10 sf
.174 .017(weak terminal)J
f0_10 sf
.106 .011( is a symbol that is often mistyped or missing, such as the semicolon between statements. A)J
34 239 :M
.614 .061(weak terminal is denoted by preceding it with the keyword WEAK. When the generated parser does not)J
34 253 :M
.295 .03(find a terminal specified as weak, it adjusts the input to the next symbol that is either a legal successor of)J
34 267 :M
.148 .015(the weak symbol or a symbol expected at any synchronization point \(symbols expected at synchronization)J
34 281 :M
.036 .004(points are considered to be very "strong", so that it makes sense that they never be skipped\).)J
34 309 :M
.018(Example)A
48 323 :M
.848 .085(StatementSeq )J
119 323 :M
.156 .016(= Statement {WEAK ";" Statement}.)J
48 337 :M
-.122(Declaration )A
119 337 :M
-.195(= SYNC \("CONST" \311 | "TYPE" \311 | "VAR" \311 | \311\).)A
34 379 :M
f6_10 sf
2.612 .261(LL\(1\) requirements)J
f0_10 sf
1.511 .151(. Recursive descent parsing requires that the grammar of the parsed language)J
34 393 :M
.046 .005(satisfies the LL\(1\) property. This means that at any point in the grammar the parser must be able to decide)J
34 407 :M
.312 .031(on the basis of a single lookahead symbol which of several possible alternatives have to be selected. For)J
34 421 :M
.196 .02(example, the following production is not LL\(1\):)J
48 449 :M
.343 .034(Statement )J
102 449 :M
(=)S
113 449 :M
.649 .065(ident ":=" Expression)J
102 463 :M
(|)S
113 463 :M
.465 .047(ident ["\(" ExpressionList "\)"].)J
34 491 :M
1.125 .113(Both alternatives start with the symbol )J
f3_10 sf
.285(ident)A
f0_10 sf
1.142 .114( and the parser cannot distinguish between them when it)J
34 505 :M
1.871 .187(comes to a statement and )J
f3_10 sf
.516(ident)A
f0_10 sf
1.943 .194( is the next input symbol. However, the production can easily be)J
34 519 :M
.309 .031(transformed into)J
48 547 :M
-.016(Statement = ident \( ":=" Expression  |  ["\(" ExpressionList "\)"] \).)A
34 575 :M
-.066(where all alternatives start with distinct symbols. There are LL\(1\) conflicts that are not as easy to detect as in)A
34 589 :M
.15 .015(the above example. For a programmer, it can be hard to find them if he has no tool to check the grammar.)J
34 603 :M
.911 .091(The result would be a parser that in some situations selects a wrong alternative. Coco/R checks if the)J
34 617 :M
.387 .039(grammar satisfies the LL\(1\) property and gives appropriate error messages that show how to correct any)J
34 631 :M
.055(violations.)A
endp
%%Page: 10 10
%%BeginPageSetup
initializepage
(Hanspeter M\232ssenb\232ck; page: 10 of 29)setjob
%%EndPageSetup
gS 0 0 538 781 rC
0 0 538 34 rC
34 28 :M
f0_9 sf
(12)S
gR
gS 0 54 538 673 rC
34 64 :M
f1_10 sf
2.635 .264(3. Using Coco/R to Generate a Compiler)J
34 92 :M
f0_10 sf
.373 .037(The attributed grammar is the central document of a compiler implementation with Coco/R. A user has to)J
34 106 :M
-.07(perform the following tasks in order to write a compiler: )A
48 134 :M
-.058(1. )A
62 134 :M
-.143(Write an attributed grammar; )A
48 148 :M
-.058(2. )A
62 148 :M
-.079(Write semantic modules if necessary \(import them in the attributed grammar\); )A
48 162 :M
-.058(3. )A
62 162 :M
-.095(Use Coco/R to generate a scanner and a parser from the attributed grammar; )A
48 176 :M
-.058(4. )A
62 176 :M
-.148(Write a main module that calls the parser. )A
34 204 :M
.052 .005(The command)J
48 232 :M
-.035(Coco.Compile )A
f3_10 sf
-.043(name)A
f0_10 sf
-.021( [ "/" {)A
f3_10 sf
-.026(letter)A
f0_10 sf
-.031(} ])A
34 260 :M
.735 .074(translates the compiler description in file )J
f3_10 sf
.265(name)A
f0_10 sf
.652 .065( \(with the grammar name )J
f3_10 sf
.329(G)A
f0_10 sf
.691 .069(, say\) into a scanner module)J
34 274 :M
f3_10 sf
(G)S
f0_10 sf
-.026(S.Mod and a parser module )A
f3_10 sf
(G)S
f0_10 sf
-.025(P.Mod. The following options may be specified)A
48 302 :M
(S)S
62 302 :M
-.029(prints the set of start and successor symbols for every nonterminal)A
48 316 :M
(X)S
62 316 :M
-.075(prints a cross-reference list of all terminals and nonterminals)A
34 358 :M
f1_10 sf
4.107 .411(3.1 Scanner Interface)J
48 386 :M
f0_10 sf
-.121(DEFINITION )A
f3_10 sf
-.174(G)A
f0_10 sf
-.105(S;  \(*generated scanner*\))A
62 400 :M
-.129(IMPORT Files;)A
62 414 :M
.221(VAR)A
76 428 :M
-.044(src: Files.File;)A
224 428 :M
.036 .004(\(*source file; to be opened by the caller*\))J
76 442 :M
-.074(pos: LONGINT;)A
224 442 :M
.171 .017(\(*source file position of current token*\))J
76 456 :M
-.068(line, col, len: INTEGER;)A
224 456 :M
.168 .017(\(*line, column, and length of current token*\))J
76 470 :M
-.087(Error: PROCEDURE \(n: INTEGER; pos: LONGINT\);  \(*install error message procedure here*\))A
62 484 :M
.177 .018(PROCEDURE Reset;)J
62 498 :M
-.125(PROCEDURE Get\(VAR sym: INTEGER\);)A
62 512 :M
-.122(PROCEDURE GetName\(pos: LONGINT; len: INTEGER; VAR name: ARRAY OF CHAR\);)A
48 526 :M
-.162(END )A
f3_10 sf
-.211(G)A
f0_10 sf
-.256(S.)A
34 554 :M
f3_10 sf
.021(Reset)A
f0_10 sf
.061 .006( is called by the parser to initialize the scanner. Note that the main module is responsible to open the)J
34 568 :M
.467 .047(source file )J
f3_10 sf
.137(src)A
f0_10 sf
.436 .044( prior to calling the parser. The parser then calls )J
f3_10 sf
.166(Get)A
f0_10 sf
.478 .048( repeatedly to get the next token from)J
34 582 :M
.479 .048(the source text. Information about the most recently recognized token can be found in the variables )J
f3_10 sf
.152(pos)A
f0_10 sf
(,)S
34 596 :M
f3_10 sf
.296(line)A
f0_10 sf
.352 .035(, )J
f3_10 sf
.324(col)A
f0_10 sf
.732 .073(, and )J
f3_10 sf
.338(len)A
f0_10 sf
1.214 .121(. The procedure )J
f3_10 sf
.465(GetName)A
f0_10 sf
.253<28>A
f9_9 sf
.413<AF>A
f3_10 sf
.409(pos)A
f0_10 sf
.212(,)A
f9_9 sf
.413<AF>A
f3_10 sf
.876 .088( len)J
f0_10 sf
.352 .035(, )J
f9_9 sf
.413<AD>A
f3_10 sf
.476(name)A
f0_10 sf
.982 .098(\) can be used to obtain the text of the)J
34 610 :M
.18 .018(token at position )J
f3_10 sf
.061(pos)A
f0_10 sf
.141 .014( with length )J
f3_10 sf
.051(len)A
f0_10 sf
(.)S
34 638 :M
f3_10 sf
.335 .034(Error messages)J
f0_10 sf
.182 .018(. For every syntax error the parser calls the procedure variable )J
f3_10 sf
.051(Error)A
f0_10 sf
.18 .018( with an error number)J
34 652 :M
-.034(and an error position as parameters. The user can install any procedure that prints a message or that saves)A
34 666 :M
.403 .04(the error information for later output. )J
f3_10 sf
.11(Error)A
f0_10 sf
.377 .038( can also be used to report semantic errors. \(Make sure to use)J
34 680 :M
.143 .014(semantic error numbers that do not interfere with syntax error numbers; e.g., start semantic error numbers)J
34 694 :M
.252 .025(at 200.\) The error numbers together with an explanatory text are appended to the generated parser in the)J
34 708 :M
.233 .023(following form:)J
endp
%%Page: 11 11
%%BeginPageSetup
initializepage
(Hanspeter M\232ssenb\232ck; page: 11 of 29)setjob
%%EndPageSetup
gS 0 0 538 781 rC
0 0 538 34 rC
495 28 :M
f0_9 sf
(13)S
gR
gS 0 47 538 687 rC
48 57 :M
f0_10 sf
.028 .003(|  0: Msg\("EOF expected"\))J
48 71 :M
.161 .016(|  1: Msg\("ident expected"\))J
48 85 :M
.043 .004(|  2: Msg\("string expected"\))J
48 99 :M
.126 .013(|  3: Msg\("number expected"\))J
48 113 :M
<C9>S
34 141 :M
-.027(This text can be copied to a procedure that prints textual error messages.)A
34 183 :M
f1_10 sf
3.783 .378(3.2 Parser Interface)J
48 211 :M
f0_10 sf
-.15(DEFINITION )A
f3_10 sf
-.215(G)A
f0_10 sf
-.127(P;  \(*generated parser*\))A
62 225 :M
-.037(PROCEDURE Parse;)A
48 239 :M
-.162(END )A
f3_10 sf
-.211(G)A
f0_10 sf
-.256(P.)A
34 267 :M
.504 .05(The main program simply has to open the source file and call )J
f3_10 sf
.175(Parse)A
f0_10 sf
.493 .049( in order to start the compilation. An)J
34 281 :M
-.146(example of a simple main program is:)A
48 309 :M
.63 .063(Texts.OpenScanner\(s, Oberon.Par.text, Oberon.Par.pos\); Texts.Scan\(s\);)J
48 323 :M
-.167(IF s.class = Texts.Name THEN)A
62 337 :M
-.058(GS.src := Files.Old\(s.s\);)A
62 351 :M
-.017(GS.Error := )A
f3_10 sf
-.019(own error message procedure)A
f0_10 sf
(;)S
62 365 :M
-.202(IF GS.src # NIL THEN GP.Parse END;)A
48 379 :M
-.054(END)A
34 421 :M
f1_10 sf
2.772 .277(3.3 Grammar Tests)J
34 449 :M
f0_10 sf
-.059(Coco/R performs several tests to check if the grammar is well-formed. If one of the following error messages)A
34 463 :M
.028 .003(is produced, no compiler parts are generated.)J
34 491 :M
f3_10 sf
-.007(No production for X)A
48 505 :M
f0_10 sf
-.003(The nonterminal X has been used, but there is no  production for it.)A
34 519 :M
f3_10 sf
-.014(X cannot be reached)A
48 533 :M
f0_10 sf
-.045(There is a production for nonterminal X, but X cannot be derived from the start symbol.)A
34 547 :M
f3_10 sf
-.044(X cannot be derived to terminals)A
48 561 :M
f0_10 sf
-.101(For example, if there is a production X = "\(" X "\)".)A
34 575 :M
f3_10 sf
-.489(X --> Y, Y --> X)A
48 589 :M
f0_10 sf
-.125(X and Y are nonterminals with circular derivations.)A
34 603 :M
f3_10 sf
(Tokens X and Y cannot be distinguished)S
48 617 :M
f0_10 sf
-.079(The terminal symbols X and Y are declared to have the same structure, e.g.,)A
62 631 :M
.026 .003(integer = digit {digit}.)J
62 645 :M
-.058(real = digit {digit} ["." {digit}].)A
48 659 :M
-.109(In this example, a digit string can be recognized as an integer or as a real.)A
34 687 :M
.933 .093(The following messages are warnings. They may indicate an error but they may also describe desired)J
34 701 :M
.252 .025(effects. The generated compiler parts are valid. If an LL\(1\) error is reported for a construct X one must be)J
34 715 :M
-.061(aware that the generated parser will choose the first of several possible alternatives for X.)A
endp
%%Page: 12 12
%%BeginPageSetup
initializepage
(Hanspeter M\232ssenb\232ck; page: 12 of 29)setjob
%%EndPageSetup
gS 0 0 538 781 rC
0 0 538 34 rC
34 28 :M
f0_9 sf
(14)S
gR
gS 0 47 538 659 rC
34 57 :M
f3_10 sf
(X deletable)S
48 71 :M
f0_10 sf
-.079(X can be derived to the empty string, e.g., X = {Y}.)A
34 85 :M
f3_10 sf
-.123(LL\(1\) error in X: Y is start of more than one alternative)A
48 99 :M
f0_10 sf
-.057(Several alternatives in the production of X start with the terminal Y, e.g.,)A
62 113 :M
.095 .009(Statement = ident ":=" Expression | ident [ActualParameters].)J
34 127 :M
f3_10 sf
-.079(LL\(1\) error in X: Y is start and successor of deletable structure)A
48 141 :M
f0_10 sf
-.033(Deletable structures are [\311] and {\311}, e.g.,)A
62 155 :M
.422 .042(qualident = [ident "."] ident.)J
62 169 :M
.319 .032(Statement = "IF" Expression "THEN" Statement ["ELSE" Statement].)J
48 183 :M
.675 .068(The ELSE at the start of the else-part may also be a successor of a statement. This LL\(1\) conflict is)J
48 197 :M
.318 .032(known under the name "dangling else".)J
34 239 :M
f1_10 sf
2.571 .257(4. Hints for Advanced Users of Coco/R)J
34 281 :M
f3_10 sf
-.022(Providing a Hand-Written Scanner)A
34 309 :M
f0_10 sf
.254 .025(Scanning is a time-consuming task. The scanner generated by Coco/R is optimized, but it is implemented)J
34 323 :M
.985 .099(as a deterministic finite automaton, which introduces some overhead. A manual implementation of the)J
34 337 :M
-.028(scanner is slightly more efficient. For time-critical applications a programmer may want to generate a parser)A
34 351 :M
-.048(but provide a hand-written scanner. This can be done by declaring all terminal symbols \(including literals\) as)A
34 365 :M
.23 .023(tokens but without defining their structure by an EBNF expression, e.g.,)J
48 393 :M
.177(TOKENS)A
62 407 :M
.331(ident)A
62 421 :M
.222(number)A
62 435 :M
("IF")S
62 449 :M
<C9>S
34 477 :M
.263 .026(If a named token is declared without structure, no scanner is generated. Tokens are assigned numbers in)J
34 491 :M
.723 .072(the order of their declaration; i.e., the first token gets the number 1, the second the number 2, etc. The)J
34 505 :M
.744 .074(number 0 is reserved for the end-of-file symbol. The hand-written scanner has to return token numbers)J
34 519 :M
.068 .007(according to this convention. It must have the interface described in Section 3.)J
34 561 :M
f3_10 sf
-.025(Tailoring the Generated Compiler Parts to One's Needs)A
34 589 :M
f0_10 sf
.336 .034(Using a generator usually increases productivity while at the same time flexibility is decreased. There are)J
34 603 :M
.583 .058(always special cases that can be handled more efficiently in a hand-written implementation. A good tool)J
34 617 :M
.58 .058(handles routine matters in a standard way but gives the user the chance to change them if he wants to.)J
34 631 :M
-.014(Coco/R generates the scanner and the parser from source texts \(so-called frames\) stored under the names)A
34 645 :M
f3_10 sf
.31(Scanner.FRM)A
f0_10 sf
.492 .049( and )J
f3_10 sf
.298(Parser.FRM)A
f0_10 sf
.951 .095(. It does so by inserting grammar-specific parts into these frames. The)J
34 659 :M
.978 .098(programmer may edit the frames and may therefore change any of the internally used algorithms. For)J
34 673 :M
-.008(example, he can Implement a different buffering scheme for input characters.)A
endp
%%Page: 13 13
%%BeginPageSetup
initializepage
(Hanspeter M\232ssenb\232ck; page: 13 of 29)setjob
%%EndPageSetup
gS 0 0 538 781 rC
0 0 538 34 rC
495 28 :M
f0_9 sf
(15)S
gR
gS 0 49 538 631 rC
34 59 :M
f3_10 sf
.508 .051(Accessing the Lookahead Token)J
34 87 :M
f0_10 sf
.818 .082(Section 3 specified the interface of the generated scanner. This interface is not complete. Actually, the)J
34 101 :M
.089 .009(scanner also exports information about the lookahead token:)J
48 129 :M
.038 .004(nextPos: LONGINT;)J
227 129 :M
.174 .017(\(*source file position of the lookahead token*\))J
48 143 :M
.213 .021(nextLine, nextCol: INTEGER;)J
227 143 :M
.08 .008(\(*line and column number of the lookahead token*\))J
34 171 :M
.407 .041(These variables refer to the most recently )J
f3_10 sf
.133(scanned)A
f0_10 sf
.412 .041( token \(the lookahead token\), while the variables )J
f3_10 sf
.132(pos)A
f0_10 sf
(,)S
34 185 :M
f3_10 sf
(line)S
f0_10 sf
( and )S
f3_10 sf
(col)S
f0_10 sf
-.005( refer to the most recently )A
f3_10 sf
(parsed)S
f0_10 sf
( token.)S
34 227 :M
f3_10 sf
-.028(Controlling the Parser by Semantic Information)A
34 255 :M
f0_10 sf
.033 .003(Ideally, syntax analysis should be independent of semantic analysis \(symbol table handling, type checking,)J
34 269 :M
.089 .009(etc.\). Some languages like Ada and C, however, have constructs that can only be distinguished if one also)J
34 283 :M
.797 .08(considers semantic information, e.g., the type of the parsed symbols. Even Oberon has constructs that)J
34 297 :M
-.036(cannot be parsed by looking at their syntax alone. For example, a designator is defined in Oberon as)A
48 325 :M
-.059(Designator = Qualident {"." ident | "^" | "[" ExprList "]" | "\(" Qualident "\)" }.)A
34 353 :M
-.078(where x\(T\) means a type guard \(i.e., x is asserted to be of type T\). A designator may be used in a statement)A
48 381 :M
-.094(Statement = \311 | Designator ["\(" ExprList "\)"] | \311  .)A
34 409 :M
1.947 .195(Here x\(T\) can be interpreted as a designator x \(a procedure name\) and a parameter T. The two)J
34 423 :M
.713 .071(interpretations of x\(T\) can only be distinguished by looking at the type of x. If it is a procedure then the)J
34 437 :M
-.036(opening bracket is the start of a parameter list, otherwise the bracket belongs to a type guard.)A
34 465 :M
.792 .079(Cocol/R allows control of the parser from within semantic actions to a certain degree. A designator, for)J
34 479 :M
-.011(example, can be processed in the following way:)A
48 507 :M
-.07(Designator <VAR x: Item> =)A
62 521 :M
.341 .034(Qualident <x>)J
62 535 :M
-.559<7B20C9>A
62 549 :M
(|)S
198 549 :M
-.106(\(.)A
210 549 :M
-.121(IF )A
f3_10 sf
-.14(x is procedure)A
f0_10 sf
-.185( THEN RETURN END .\))A
76 563 :M
.068 .007("\(" Qualident <y> "\)")J
198 563 :M
-.442(\(. )A
210 563 :M
f3_10 sf
.022 .002(process type guard)J
f0_10 sf
( .\))S
62 577 :M
-.448(} .)A
34 605 :M
.837 .084(When an opening bracket is seen after a )J
f3_10 sf
.262(Qualident)A
f0_10 sf
.928 .093(, the alternative starting with an opening bracket is)J
34 619 :M
.043 .004(selected. The first semantic action of this alternative checks for the type of x. If x is a procedure, the parser)J
34 633 :M
.323 .032(returns from the production and continues in the Statement production.)J
endp
%%Page: 14 14
%%BeginPageSetup
initializepage
(Hanspeter M\232ssenb\232ck; page: 14 of 29)setjob
%%EndPageSetup
gS 0 0 538 781 rC
0 0 538 34 rC
34 28 :M
f0_9 sf
(16)S
gR
gS 0 49 538 682 rC
34 59 :M
f1_10 sf
4.617 .462(5. Implementation)J
34 87 :M
f0_10 sf
.808 .081(Coco/R was written in Oberon on a Ceres workstation. There is also a Modula-2 version for Macintosh)J
34 101 :M
-.01(computers. A preliminary version of Coco/R was implemented as a master's thesis \([Senn89]\). Coco/R was)A
34 115 :M
.069 .007(used for its own implementation. Like any compiler, it consists of a scanner \(CRS\), a parser \(CRP\), a table)J
34 129 :M
.225 .023(handler \(CRT\), and two  modules for output generation, one for the scanner \(CRA\) and one for the parser)J
34 143 :M
.083 .008(\(CRX\). During parsing the scanner description is transformed into a non-deterministic finite automaton and)J
34 157 :M
.179 .018(the attributed grammar is transformed into a graph. These data structures are used for grammar tests and)J
34 171 :M
.21 .021(for the generation of the two source modules.)J
.016 lw
198 189 113 103 rC
256.5 189.5 28 12 rS
260 198 :M
f0_9 sf
(Coco)S
198.5 279.5 25 12 rS
202 288 :M
-.499(CRS)A
258.5 219.5 25 12 rS
262 228 :M
-.499(CRP)A
258.5 279.5 24 12 rS
262 288 :M
-.746(CRT)A
285.5 249.5 25 12 rS
289 258 :M
-.499(CRA)A
231.5 249.5 25 12 rS
235 258 :M
-.499(CRX)A
198 234 113 58 rC
-.016 -.016 270.016 280.016 .016 .016 270 232 @b
gR
gS 198 189 113 103 rC
5 75 105 270 232 @k
-.016 -.016 243.016 249.016 .016 .016 243 244 @b
243 244.016 -.016 .016 264.016 244 .016 243 244 @a
-.016 -.016 300.016 249.016 .016 .016 300 244 @b
276 244.016 -.016 .016 300.016 244 .016 276 244 @a
198 234 113 58 rC
-.016 -.016 276.016 244.016 .016 .016 276 232 @b
gR
gS 198 189 113 103 rC
5 75 105 276 232 @k
198 234 113 58 rC
-.016 -.016 264.016 244.016 .016 .016 264 232 @b
gR
gS 198 189 113 103 rC
5 75 105 264 232 @k
-.016 -.016 264.016 279.016 .016 .016 264 274 @b
243 274.016 -.016 .016 264.016 274 .016 243 274 @a
198 264 113 28 rC
-.016 -.016 243.016 274.016 .016 .016 243 262 @b
gR
gS 198 189 113 103 rC
5 75 105 243 262 @k
-.016 -.016 276.016 279.016 .016 .016 276 274 @b
276 274.016 -.016 .016 297.016 274 .016 276 274 @a
198 264 113 28 rC
-.016 -.016 297.016 274.016 .016 .016 297 262 @b
gR
gS 198 189 113 103 rC
5 75 105 297 262 @k
-.016 -.016 210.016 279.016 .016 .016 210 214 @b
210 274.016 -.016 .016 237.016 274 .016 210 274 @a
198 264 113 28 rC
-.016 -.016 237.016 274.016 .016 .016 237 262 @b
gR
gS 198 189 113 103 rC
5 75 105 237 262 @k
210 241.016 -.016 .016 258.016 241 .016 210 241 @a
198 234 113 58 rC
-.016 -.016 258.016 241.016 .016 .016 258 232 @b
gR
gS 198 189 113 103 rC
5 75 105 258 232 @k
198 204 113 88 rC
-.016 -.016 270.016 219.016 .016 .016 270 202 @b
gR
gS 198 189 113 103 rC
5 75 105 270 202 @k
210 214.016 -.016 .016 264.016 214 .016 210 214 @a
198 204 113 88 rC
-.016 -.016 264.016 214.016 .016 .016 264 202 @b
gR
gS 198 189 113 103 rC
5 75 105 264 202 @k
gR
gS 0 49 538 682 rC
34 334 :M
f1_10 sf
4.224 .422(5.1 Scanner Generation)J
34 362 :M
f0_10 sf
.402 .04(During parsing of the compiler description, the token declarations are translated into a syntax graph from)J
34 376 :M
1.681 .168(which a non-deterministic finite automaton is generated. In a second step, this automaton is made)J
34 390 :M
.676 .068(deterministic. The algorithms for the manipulation of the automaton are described in [M\232ss86]. Figure 1)J
34 404 :M
.402 .04(sketches this process.)J
1 G
85 422 367 253 rC
268 548 184 127 rF
0 G
.016 lw
268.5 548.5 183 126 rS
1 G
85 548 184 127 rF
0 G
85.5 548.5 183 126 rS
1 G
179 593 15 12 rC
18 12 185 599 @j
0 G
17 11 185 599 @f
gR
1 G
gS 368 590 15 12 rC
18 12 374 596 @j
0 G
.016 lw
17 11 374 596 @f
gR
gS 169 633 12 15 rC
12 18 175 639 @j
0 G
.016 lw
11 17 175 639 @f
gR
gS 358 632 12 15 rC
12 18 364 638 @j
0 G
.016 lw
11 17 364 638 @f
gR
gS 85 422 367 253 rC
85 422 184 127 rF
0 G
.016 lw
85.5 422.5 183 126 rS
1 G
268 422 184 127 rF
0 G
268.5 422.5 183 126 rS
95 463 :M
f0_9 sf
-.333(CHARACTERS)A
95 474 :M
-.095(   digit = "0123456789".)A
95 485 :M
-.049(   octdigit = "01234567".)A
95 507 :M
-.201(TOKENS)A
95 518 :M
-.068(   decimal = digit {digit}.)A
95 529 :M
.031 .003(   octal = octdigit {octdigit} "B".)J
380 475 :M
.125(digit)A
335 475 :M
.125(digit)A
335 517 :M
.214(octdigit)A
386 517 :M
.214(octdigit)A
391 538 :M
-.196("B")A
284 475 :M
(decimal :)S
137 436 :M
f3_9 sf
.367 .037(regular expression)J
332 436 :M
.707 .071(syntax graph)J
116 562 :M
.412 .041(non-deterministic automaton)J
311 562 :M
.465 .047(deterministic automaton)J
284 517 :M
f0_9 sf
.622 .062(octal :)J
85 422 289 253 rC
355 472.016 -.016 .016 376.016 472 .016 355 472 @a
gR
0 G
gS 85 422 367 253 rC
5 165 195 376 472 @k
400 472.016 -.016 .016 409.016 472 .016 400 472 @a
-.016 -.016 409.016 472.016 .016 .016 409 460 @b
364 460.016 -.016 .016 409.016 460 .016 364 460 @a
85 422 367 48 rC
-.016 -.016 364.016 472.016 .016 .016 364 460 @b
gR
gS 85 422 367 253 rC
5 -105 -75 364 472 @k
85 422 367 63 rC
-.016 -.016 388.016 487.016 .016 .016 388 478 @b
gR
gS 85 422 367 253 rC
5 -105 -75 388 487 @k
386 495 :M
f9_9 sf
(e)S
85 422 295 253 rC
367 514.016 -.016 .016 382.016 514 .016 367 514 @a
gR
gS 85 422 367 253 rC
5 165 195 382 514 @k
418 514.016 -.016 .016 430.016 514 .016 418 514 @a
-.016 -.016 430.016 514.016 .016 .016 430 502 @b
370 502.016 -.016 .016 430.016 502 .016 370 502 @a
85 422 367 90 rC
-.016 -.016 370.016 514.016 .016 .016 370 502 @b
gR
gS 85 422 367 253 rC
5 -105 -75 370 514 @k
85 422 367 105 rC
-.016 -.016 397.016 529.016 .016 .016 397 520 @b
gR
gS 85 422 367 253 rC
5 -105 -75 397 529 @k
1 G
121.5 599.5 6.5 @i
0 G
.016 lw
121.5 599.5 6 @e
1 G
310.5 596.5 6.5 @i
0 G
310.5 596.5 6 @e
1 G
175.5 599.5 6.5 @i
0 G
1 lw
175.5 599.5 6 @e
1 G
364.5 596.5 6.5 @i
0 G
364.5 596.5 6 @e
1 G
175.5 629.5 6.5 @i
0 G
.016 lw
175.5 629.5 6 @e
1 G
217.5 629.5 6.5 @i
0 G
1 lw
217.5 629.5 6 @e
1 G
406.5 626.5 6.5 @i
0 G
406.5 626.5 6 @e
119 603 :M
f0_9 sf
(1)S
308 600 :M
(1)S
137 598 :M
.125(digit)A
326 595 :M
({8, 9})S
365 613 :M
({8, 9})S
190 628 :M
(B)S
383 626 :M
(B)S
128 628 :M
.214(octdigit)A
317 625 :M
.214(octdigit)A
161 657 :M
.214(octdigit)A
350 656 :M
.214(octdigit)A
195 603 :M
.125(digit)A
384 600 :M
.125(digit)A
173 603 :M
(2)S
362 600 :M
(2)S
173 633 :M
(3)S
215 633 :M
(4)S
404 630 :M
(4)S
85 422 82 253 rC
127 599.016 -.016 .016 169.016 599 .016 127 599 @a
gR
gS 85 422 367 253 rC
5 165 195 169 599 @k
85 422 271 253 rC
316 596.016 -.016 .016 358.016 596 .016 316 596 @a
gR
gS 85 422 367 253 rC
5 165 195 358 596 @k
85 422 82 253 rC
121 629.016 -.016 .016 169.016 629 .016 121 629 @a
gR
gS 85 422 367 253 rC
5 165 195 169 629 @k
85 422 262 253 rC
310 626.016 -.016 .016 349.016 626 .016 310 626 @a
gR
gS 85 422 367 253 rC
5 165 195 349 626 @k
-.016 -.016 121.016 629.016 .016 .016 121 605 @b
-.016 -.016 310.016 626.016 .016 .016 310 602 @b
85 422 124 253 rC
181 629.016 -.016 .016 211.016 629 .016 181 629 @a
gR
gS 85 422 367 253 rC
5 165 195 211 629 @k
85 422 313 253 rC
376 626.016 -.016 .016 400.016 626 .016 376 626 @a
gR
gS 85 422 367 253 rC
5 165 195 400 626 @k
181 422 271 253 rC
-.016 -.016 179.016 595.016 .016 .016 181 594 @b
gR
gS 85 422 367 253 rC
5 -41 -11 179 595 @k
370 422 82 253 rC
-.016 -.016 368.016 592.016 .016 .016 370 591 @b
gR
gS 85 422 367 253 rC
5 -41 -11 368 592 @k
85 635 367 40 rC
-.016 -.016 169.016 636.016 .016 .016 171 633 @b
gR
gS 85 422 367 253 rC
5 109 139 171 633 @k
85 634 367 41 rC
-.016 -.016 358.016 635.016 .016 .016 360 632 @b
gR
gS 85 422 367 253 rC
5 109 139 360 632 @k
1 G
350 620 378 633 6 @q
0 G
350.5 620.5 377.5 632.5 5.5 @s
353 630 :M
f0_9 sf
.661 .066([2, 3])J
85 604 367 71 rC
-.016 -.016 364.016 620.016 .016 .016 364 602 @b
gR
gS 85 422 367 253 rC
5 75 105 364 602 @k
.5 G
85 422 188 253 rC
231 615 -2 2 281 613 2 231 613 @a
gR
.5 G
gS 85 422 367 253 rC
15 165 195 280 614 @k
85 422 188 253 rC
231 495 -2 2 281 493 2 231 493 @a
gR
gS 85 422 367 253 rC
15 165 195 280 494 @k
85 422 367 140 rC
-2 -2 251 570 2 2 282 535 @b
gR
gS 85 422 367 253 rC
15 -60 -30 250 569 @k
gR
gS 0 49 538 682 rC
106 698 :M
2.732 0 rm
0 G
f1_9 sf
(Fig. 1)S
f0_9 sf
(   Transformation of regular expressions into a deterministic finite automaton)S
34 726 :M
f0_10 sf
.136 .014(The automaton is not generated directly from the regular expressions but from a syntax graph. This allows)J
endp
%%Page: 15 15
%%BeginPageSetup
initializepage
(Hanspeter M\232ssenb\232ck; page: 15 of 29)setjob
%%EndPageSetup
gS 0 0 538 781 rC
0 0 538 34 rC
495 28 :M
f0_9 sf
(17)S
gR
gS 0 49 538 632 rC
34 59 :M
f0_10 sf
.294 .029(making it more deterministic from the beginning, thus simplifying the later algorithms. Figure 1 shows that)J
34 73 :M
1.511 .151(tokens may have very similar structures, differing only in their last characters. These structures are)J
34 87 :M
.951 .095(automatically stripped of any disambiguity. The programmer does not have to take care of making the)J
34 101 :M
.205 .021(beginnings of tokens distinct. Even very complicated structures can be processed like the various kinds of)J
34 115 :M
-.032(numeric constants in Modula-2 \(Figure 2; final states are denoted by bold circles\):)A
1 G
48 133 389 249 rC
np 216 198 :M
222 204 :L
222 207 :L
219 210 :L
216 210 :L
210 204 :L
.016 lw
eofill
0 G
216 198.016 -.016 .016 222.016 204 .016 216 198 @a
-.016 -.016 222.016 207.016 .016 .016 222 204 @b
-.016 -.016 219.016 210.016 .016 .016 222 207 @b
216 210.016 -.016 .016 219.016 210 .016 216 210 @a
210 204.016 -.016 .016 216.016 210 .016 210 204 @a
1 G
393 333 12 9 rC
15 9 397.5 337.5 @j
0 G
14 8 397.5 337.5 @f
gR
1 G
gS 48 133 389 249 rC
np 282 195 :M
291 186 :L
291 183 :L
288 180 :L
285 180 :L
276 189 :L
.016 lw
eofill
0 G
-.016 -.016 282.016 195.016 .016 .016 291 186 @b
-.016 -.016 291.016 186.016 .016 .016 291 183 @b
288 180.016 -.016 .016 291.016 183 .016 288 180 @a
285 180.016 -.016 .016 288.016 180 .016 285 180 @a
-.016 -.016 276.016 189.016 .016 .016 285 180 @b
1 G
np 273 240 :M
264 231 :L
261 231 :L
257 235 :L
257 237 :L
266 246 :L
eofill
0 G
264 231.016 -.016 .016 273.016 240 .016 264 231 @a
261 231.016 -.016 .016 264.016 231 .016 261 231 @a
-.016 -.016 257.016 235.016 .016 .016 261 231 @b
-.016 -.016 257.016 237.016 .016 .016 257 235 @b
257 237.016 -.016 .016 266.016 246 .016 257 237 @a
52 146 :M
f0_9 sf
-.033(integer =)A
52 157 :M
-.068(   digit {digit})A
52 168 :M
-.108(|  digit {digit} CONTEXT \(".."\))A
52 179 :M
-.079(|  digit {hexdigit} "H")A
52 190 :M
.113 .011(|  octdigit {octdigit} "B".)J
52 212 :M
-.051(char =)A
52 223 :M
.012 .001(   octdigit {octdigit} "C".)J
52 245 :M
-.151(real =)A
52 256 :M
-.053(   digit {digit} "." {digit})A
52 267 :M
-.008(   ["E" ["+"|"-"] digit [digit]].)A
1 G
209 145 8 @i
0 G
209 145 7.5 @e
1 G
209 197 8 @i
0 G
1 lw
209 197 7.5 @e
1 G
275 197 8 @i
0 G
275 197 7.5 @e
1 G
275 248 8 @i
0 G
.016 lw
275 248 7.5 @e
1 G
326 248 8 @i
0 G
1 lw
326 248 7.5 @e
1 G
343 338 8 @i
0 G
343 338 7.5 @e
1 G
386 338 8 @i
0 G
386 338 7.5 @e
1 G
386 296 8 @i
0 G
.016 lw
386 296 7.5 @e
1 G
386 254 8 @i
0 G
1 lw
386 254 7.5 @e
1 G
386 212 8 @i
0 G
386 212 7.5 @e
1 G
428 254 8 @i
0 G
.016 lw
428 254 7.5 @e
1 G
343 374 8 @i
0 G
1 lw
343 374 7.5 @e
1 G
275 308 8 @i
0 G
275 308 7.5 @e
1 G
242 278 8 @i
0 G
242 278 7.5 @e
211 171 :M
.214(octdigit)A
238 230 :M
.142(hexdigit)A
243 296 :M
.142(hexdigit)A
229 263 :M
.142(hexdigit)A
211 308 :M
(C)S
211 275 :M
(B)S
292 248 :M
(H)S
316 220 :M
(H)S
292 308 :M
(H)S
292 277 :M
(H)S
355 317 :M
(E)S
387 323 :M
(E)S
354 338 :M
.125(digit)A
387 281 :M
.125(digit)A
387 239 :M
.125(digit)A
403 294 :M
-.053({+, -})A
399 253 :M
.125(digit)A
406 341 :M
.125(digit)A
336 356 :M
f1_12 sf
(.)S
213 337 :M
(.)S
345 242 :M
(.)S
211 326 :M
f0_9 sf
(H)S
222 215 :M
.214(octdigit)A
287 180 :M
.125(digit)A
207 148 :M
(1)S
207 200 :M
(2)S
273 200 :M
(3)S
272 251 :M
(4)S
324 251 :M
(5)S
273 311 :M
(7)S
240 281 :M
(6)S
341 341 :M
(8)S
341 377 :M
(9)S
381 341 :M
(10)S
381 299 :M
(11)S
381 257 :M
(12)S
423 257 :M
(13)S
381 215 :M
(14)S
227 195 :M
.12({8,9})A
210 247 :M
.061({A,D,E,F})A
277 222 :M
.081({A,B,C})A
277 233 :M
({D,E,F})S
233 142 :M
.12({8,9})A
48 133 217 249 rC
216 196.016 -.016 .016 267.016 196 .016 216 196 @a
gR
0 G
gS 48 133 389 249 rC
5 165 195 267 196 @k
48 133 389 105 rC
-.016 -.016 275.016 240.016 .016 .016 275 204 @b
gR
gS 48 133 389 249 rC
5 -105 -75 275 240 @k
48 133 389 111 rC
263 243.016 -.016 .016 266.016 246 .016 263 243 @a
gR
gS 48 133 389 249 rC
5 210 240 266 246 @k
-.016 -.016 208.016 339.016 .016 .016 208 204 @b
48 133 217 249 rC
208 249.016 -.016 .016 267.016 249 .016 208 249 @a
gR
gS 48 133 389 249 rC
5 165 195 267 249 @k
48 133 217 249 rC
208 308.016 -.016 .016 267.016 308 .016 208 308 @a
gR
gS 48 133 389 249 rC
5 165 195 267 308 @k
48 257 389 125 rC
-.016 -.016 275.016 300.016 .016 .016 275 255 @b
gR
gS 48 133 389 249 rC
5 75 105 275 255 @k
208 327.016 -.016 .016 325.016 327 .016 208 327 @a
48 133 268 249 rC
282 248.016 -.016 .016 318.016 248 .016 282 248 @a
gR
gS 48 133 389 249 rC
5 165 195 318 248 @k
48 257 389 125 rC
-.016 -.016 325.016 327.016 .016 .016 325 255 @b
gR
gS 48 133 389 249 rC
5 75 105 325 255 @k
48 133 274 249 rC
282 308.016 -.016 .016 324.016 308 .016 282 308 @a
gR
gS 48 133 389 249 rC
5 165 195 324 308 @k
282 198.016 -.016 .016 325.016 198 .016 282 198 @a
48 133 389 105 rC
-.016 -.016 325.016 240.016 .016 .016 325 198 @b
gR
gS 48 133 389 249 rC
5 -105 -75 325 240 @k
48 133 389 54 rC
-.016 -.016 276.016 189.016 .016 .016 279 186 @b
gR
gS 48 133 389 249 rC
5 -60 -30 276 189 @k
48 133 284 249 rC
208 339.016 -.016 .016 334.016 339 .016 208 339 @a
gR
gS 48 133 389 249 rC
5 165 195 334 339 @k
282 196.016 -.016 .016 342.016 196 .016 282 196 @a
48 133 389 194 rC
-.016 -.016 342.016 329.016 .016 .016 342 196 @b
gR
gS 48 133 389 249 rC
5 -105 -75 342 329 @k
48 133 389 230 rC
-.016 -.016 342.016 365.016 .016 .016 342 345 @b
gR
gS 48 133 389 249 rC
5 -105 -75 342 365 @k
48 133 328 249 rC
350 339.016 -.016 .016 378.016 339 .016 350 339 @a
gR
gS 48 133 389 249 rC
5 165 195 378 339 @k
48 305 389 77 rC
-.016 -.016 385.016 330.016 .016 .016 385 303 @b
gR
gS 48 133 389 249 rC
5 75 105 385 303 @k
48 302 389 80 rC
-.016 -.016 348.016 330.016 .016 .016 378 300 @b
gR
gS 48 133 389 249 rC
5 120 150 378 300 @k
48 263 389 119 rC
-.016 -.016 385.016 288.016 .016 .016 385 261 @b
gR
gS 48 133 389 249 rC
5 75 105 385 261 @k
48 221 389 161 rC
-.016 -.016 385.016 246.016 .016 .016 385 219 @b
gR
gS 48 133 389 249 rC
5 75 105 385 219 @k
395 133 42 249 rC
393 254.016 -.016 .016 420.016 254 .016 393 254 @a
gR
gS 48 133 389 249 rC
5 -15 15 393 254 @k
393 296.016 -.016 .016 427.016 296 .016 393 296 @a
48 263 389 119 rC
-.016 -.016 427.016 296.016 .016 .016 427 261 @b
gR
gS 48 133 389 249 rC
5 75 105 427 261 @k
48 206 389 176 rC
210 204.016 -.016 .016 213.016 207 .016 210 204 @a
gR
gS 48 133 389 249 rC
5 30 60 210 204 @k
48 133 389 53 rC
-.016 -.016 208.016 188.016 .016 .016 208 152 @b
gR
gS 48 133 389 249 rC
5 -105 -75 208 188 @k
216 144.016 -.016 .016 273.016 144 .016 216 144 @a
48 133 389 54 rC
-.016 -.016 273.016 189.016 .016 .016 273 144 @b
gR
gS 48 133 389 249 rC
5 -105 -75 273 189 @k
48 133 183 249 rC
208 277.016 -.016 .016 233.016 277 .016 208 277 @a
gR
gS 48 133 389 249 rC
5 165 195 233 277 @k
48 257 389 125 rC
-.016 -.016 249.016 273.016 .016 .016 267 255 @b
gR
gS 48 133 389 249 rC
5 120 150 267 255 @k
48 133 274 249 rC
249 277.016 -.016 .016 324.016 277 .016 249 277 @a
gR
gS 48 133 389 249 rC
5 165 195 324 277 @k
395 133 42 249 rC
393 333.016 -.016 .016 396.016 333 .016 393 333 @a
gR
gS 48 133 389 249 rC
5 -15 15 393 333 @k
gR
gS 0 49 538 632 rC
48 410 :M
f1_9 sf
.057(Fig.2)A
f0_9 sf
.197 .02(   Automaton for the various kinds of numeric constants in Modula-2)J
34 438 :M
f0_10 sf
.357 .036(If speed is important, a finite automaton is not the best possible implementation of a scanner. It would be)J
34 452 :M
-.003(more efficient to implement the recognition of tokens as ordinary procedures like in a hand-written scanner.)A
34 466 :M
.952 .095(However, if one looks at the Figure 2, one can imagine that it is not easy to generate such a scanner)J
34 480 :M
.468 .047(automatically. On the other hand, an automaton is space-efficient. Therefore we decided to generate the)J
34 494 :M
1.387 .139(scanner as an automaton. To make it as efficient as possible, the automaton is not table-driven but)J
34 508 :M
.153 .015(implemented in code. For the token declarations)J
48 536 :M
.053 .005(ident = letter {letter|digit}.)J
48 550 :M
-.009(number = digit {digit}.)A
34 578 :M
.117 .012(and the occurrence of the literals "IF", "THEN", "END", "<", and "<=" in the productions of the grammar the)J
34 592 :M
.405 .04(automaton of Figure 3 is generated. The textual representation of token classes like )J
f3_10 sf
.101(ident)A
f0_10 sf
.141 .014( or )J
f3_10 sf
.132(number)A
f0_10 sf
.34 .034( can)J
34 606 :M
2.593 .259(be obtained via the procedure )J
f3_10 sf
.939(GetName)A
f0_10 sf
.511<28>A
f9_9 sf
.833<AF>A
f3_10 sf
.825(pos)A
f0_10 sf
.711 .071(, )J
f9_9 sf
.833<AF>A
f3_10 sf
.683(len)A
f0_10 sf
.711 .071(, )J
f9_9 sf
.833<AD>A
f3_10 sf
.76(sourceText)A
f0_10 sf
1.981 .198(\) where )J
f3_10 sf
.825(pos)A
f0_10 sf
1.366 .137( and )J
f3_10 sf
.683(len)A
f0_10 sf
1.929 .193( are the)J
34 620 :M
1.824 .182(position and length of the token in the source file. Note, that keywords cannot be handled by the)J
34 634 :M
-.014(automaton since they have the same structure as identifiers. This fact is taken into account by Coco/R: Any)A
34 648 :M
.524 .052(literal that matches a declared token is stored in a literal list. Later, when an identifier is recognized, it is)J
34 662 :M
.458 .046(checked whether it is a literal \()J
f3_10 sf
.147(CheckLiteral)A
f0_10 sf
.526 .053(\), and if so, the literal's token number is returned. Comments)J
34 676 :M
-.004(are not handled by the automaton. They are recognized by a special procedure.)A
endp
%%Page: 16 16
%%BeginPageSetup
initializepage
(Hanspeter M\232ssenb\232ck; page: 16 of 29)setjob
%%EndPageSetup
gS 0 0 538 781 rC
0 0 538 34 rC
34 28 :M
f0_9 sf
(18)S
gR
1 G
gS 152 55 12 9 rC
15 9 156.5 59.5 @j
0 G
.016 lw
14 8 156.5 59.5 @f
gR
gS 152 85 12 9 rC
15 9 156.5 89.5 @j
0 G
.016 lw
14 8 156.5 89.5 @f
gR
gS 34 49 443 235 rC
145 60 8 @i
0 G
145 60 7.5 @e
1 G
145 90 8 @i
0 G
145 90 7.5 @e
1 G
157 120 8 @i
0 G
157 120 7.5 @e
1 G
121 120 8 @i
0 G
.016 lw
121 120 7.5 @e
1 G
88 60 8 @i
0 G
88 60 7.5 @e
168 60 :M
f0_9 sf
.2(letter)A
168 71 :M
.125(digit)A
168 93 :M
.125(digit)A
102 58 :M
.2(letter)A
246 58 :M
-.05(Get\(VAR sym: INTEGER\))A
246 280 :M
-.072(END Get;)A
102 88 :M
.125(digit)A
99 118 :M
(<)S
132 118 :M
(=)S
86 64 :M
(0)S
141 64 :M
(1)S
141 94 :M
(2)S
117 124 :M
(3)S
83 136 :M
<C9>S
153 124 :M
(4)S
255 69 :M
<C9>S
255 80 :M
.408 .041(state := startState[ch]; pos := chPos; len := 0;)J
255 91 :M
(LOOP)S
255 102 :M
-.079(   NextCh; INC\(len\);)A
255 113 :M
-.134(   CASE state OF)A
255 124 :M
-.151(     1: IF \(ch>="A"\) & \(ch<="Z"\) OR \(ch>="a"\) & \(ch<="z"\) )A
255 135 :M
-.189(         OR \(ch>="0"\) & \(ch<="9"\) THEN state := 1)A
255 146 :M
-.133(         ELSE sym := ident; CheckLiteral; RETURN)A
255 157 :M
-.5(         END)A
255 168 :M
-.136(   | 2: IF \(ch>="0"\) & \(ch<="9"\) THEN state := 2)A
255 179 :M
-.243(         ELSE sym := number; RETURN)A
255 190 :M
-.5(         END)A
255 201 :M
-.177(   | 3: IF ch = "=" THEN state := 4)A
255 212 :M
-.218(         ELSE sym := lss; RETURN)A
255 223 :M
-.5(         END)A
255 234 :M
-.204(   | 4: sym := leq; RETURN)A
255 245 :M
-.5(   \311)A
255 256 :M
-.5(   END)A
255 267 :M
-.499(END)A
34 49 100 235 rC
95 60.016 -.016 .016 136.016 60 .016 95 60 @a
gR
0 G
gS 34 49 443 235 rC
5 165 195 136 60 @k
34 49 100 235 rC
88 90.016 -.016 .016 136.016 90 .016 88 90 @a
gR
gS 34 49 443 235 rC
5 165 195 136 90 @k
34 49 76 235 rC
88 120.016 -.016 .016 112.016 120 .016 88 120 @a
gR
gS 34 49 443 235 rC
5 165 195 112 120 @k
34 49 112 235 rC
128 120.016 -.016 .016 148.016 120 .016 128 120 @a
gR
gS 34 49 443 235 rC
5 165 195 148 120 @k
153 49 324 235 rC
151 62.016 -.016 .016 154.016 63 .016 151 62 @a
gR
gS 34 49 443 235 rC
5 3 33 151 62 @k
153 49 324 235 rC
151 92.016 -.016 .016 154.016 93 .016 151 92 @a
gR
gS 34 49 443 235 rC
5 3 33 151 92 @k
-.016 -.016 88.016 127.016 .016 .016 88 67 @b
gR
gS 0 49 538 534 rC
85 298 :M
f1_9 sf
.272 .027(Fig. 3)J
f0_9 sf
.275 .027(   Implementation of an automaton)J
34 326 :M
f0_10 sf
.744 .074(The most time-consuming task in scanning is reading the source text. The scanner can be speeded up)J
34 340 :M
.338 .034(significantly if reading can be made faster. To read a text character by character is usually slower than to)J
34 354 :M
-.038(read it in blocks that correspond to disk sectors. With the large memories available today, it is even possible)A
34 368 :M
.718 .072(to read the whole source text into memory at once. In the Oberon system this is more than three times)J
34 382 :M
.605 .061(faster than reading it character by character. Even large Oberon programs rarely exceed 40 kilobytes in)J
34 396 :M
.499 .05(source code. With several megabytes of memory available, this "waste" of 40 kilobytes seems justified if)J
34 410 :M
-.047(scanning speed can be improved so drastically \(the overall run time of the compiler is improved by 30%\).)A
34 438 :M
-.047(Having the whole source text in memory has yet another advantage: the source text can be used as a name)A
34 452 :M
.476 .048(list. The text of token classes, like identifiers, no longer has to be copied to a separate name list but can)J
34 466 :M
.197 .02(remain where it is. One simply has to remember its position and its length. This idea is in accordance with)J
34 480 :M
.043 .004(the principle that during scanning every input character should be "touched" as little as possible [Waite86].)J
34 508 :M
1.155 .116(Another advantage of this technique is that it permits the backup of the input pointer to any previous)J
34 522 :M
.342 .034(position. This is useful for handling tokens with CONTEXT phrases in Cocol/R. To recognize such tokens)J
34 536 :M
.806 .081(the right-hand context has to be analyzed, too. After the token and its context have been scanned, the)J
34 550 :M
-.013(input pointer is simply decreased by the length of the CONTEXT phrase, so that this text will be read by the)A
34 564 :M
-.044(scanner again.)A
endp
%%Page: 17 17
%%BeginPageSetup
initializepage
(Hanspeter M\232ssenb\232ck; page: 17 of 29)setjob
%%EndPageSetup
gS 0 0 538 781 rC
0 0 538 34 rC
495 28 :M
f0_9 sf
(19)S
gR
gS 0 49 538 670 rC
34 59 :M
f1_10 sf
3.911 .391(5.2 Parser Generation)J
34 87 :M
f0_10 sf
.63 .063(The productions of the attributed grammar are translated into procedures of a recursive descent parser.)J
34 101 :M
-.059(However, it is not possible to generate the parser on the fly while the grammar is analyzed since certain sets)A
34 115 :M
.646 .065(of terminal symbols are required at various locations in the parsing procedures. These sets can only be)J
34 129 :M
.636 .064(computed when the whole grammar is known. Therefore, the productions are first translated into syntax)J
34 143 :M
.812 .081(graphs, then the symbol sets are computed, and finally the parsing procedures are generated from the)J
34 157 :M
-.023(graphs. The syntax graphs are also used for grammar tests \(completeness, redundancy, LL\(1\) property\).)A
34 185 :M
f3_10 sf
1.317 .132(Syntax graphs)J
f0_10 sf
.748 .075(. A node is generated for every symbol in the grammar and for every semantic action. A)J
34 199 :M
.134 .013(sequence of symbols and actions is translated into a sequence of nodes. A semantic action node contains)J
34 213 :M
1.647 .165(the position and the length of the action in the source text. Alternatives, options and iterations are)J
34 227 :M
.083 .008(modelled by special nodes of the following form)J
1 G
48 245 385 65 rC
57 272 31 13 rF
0 G
.016 lw
57.5 272.5 30 12 rS
1 G
258 272 31 13 rF
0 G
258.5 272.5 30 12 rS
1 G
57 284 31 13 rF
0 G
57.5 284.5 30 12 rS
1 G
57 296 31 13 rF
0 G
57.5 296.5 30 12 rS
1 G
258 284 31 13 rF
0 G
258.5 284.5 30 12 rS
106 281 :M
f0_9 sf
1.186 .119(to successor)J
307 281 :M
1.186 .119(to successor)J
256 254 :M
f3_9 sf
.165(option,)A
256 265 :M
.125(iteration)A
52 263 :M
.149(alternative)A
106 294 :M
f0_9 sf
.294 .029(to start node of alternative)J
106 306 :M
.297 .03(to next branch)J
307 294 :M
.244 .024(to start node of inner structure)J
48 245 49 65 rC
81 278.016 -.016 .016 99.016 278 .016 81 278 @a
gR
gS 48 245 385 65 rC
5 165 195 99 278 @k
48 245 250 65 rC
282 278.016 -.016 .016 300.016 278 .016 282 278 @a
gR
gS 48 245 385 65 rC
5 165 195 300 278 @k
48 245 49 65 rC
81 290.016 -.016 .016 99.016 290 .016 81 290 @a
gR
gS 48 245 385 65 rC
5 165 195 99 290 @k
48 245 49 65 rC
81 302.016 -.016 .016 99.016 302 .016 81 302 @a
gR
gS 48 245 385 65 rC
5 165 195 99 302 @k
48 245 250 65 rC
282 290.016 -.016 .016 300.016 290 .016 282 290 @a
gR
gS 48 245 385 65 rC
5 165 195 300 290 @k
gR
gS 0 49 538 670 rC
34 338 :M
f0_10 sf
.304 .03(A production like)J
48 366 :M
-.026(Expression <VAR x: OGT.Item>)A
204 366 :M
-.106(\(.)A
215 366 :M
-.145(VAR y: OGT.Item; op: INTEGER .\))A
48 380 :M
(=)S
62 380 :M
-.023(SimExpr <x>)A
62 394 :M
([)S
76 394 :M
.688 .069(Relop <op>)J
204 394 :M
-.106(\(.)A
215 394 :M
-.098(IF x.typ.form = Bool THEN OGE.MOp\(op, x\) END .\))A
76 408 :M
-.023(SimExpr <y>)A
204 408 :M
-.106(\(.)A
215 408 :M
-.062(OGE.Op\(op, x, y\) .\))A
62 422 :M
(|)S
76 422 :M
-.074("IN" SimExpr <y>)A
204 422 :M
-.106(\(.)A
215 422 :M
-.174(OGE.In\(x, y\) .\))A
62 436 :M
(|)S
76 436 :M
-.082("IS" )A
204 436 :M
-.106(\(.)A
215 436 :M
-.123(IF x.mode >= Typ THEN err\(112\) END .\))A
76 450 :M
.441 .044(qualident <y>)J
204 450 :M
-.106(\(.)A
215 450 :M
-.096(IF y.mode = Typ THEN OGE.TypTest\(x, y\) ELSE err\(52\) END .\))A
62 464 :M
.443(].)A
34 492 :M
-.013(is translated into the following graph)A
48 510 370 162 rC
209 519 :M
f3_9 sf
.247(opt)A
230 558 :M
.249(alt)A
230 597 :M
.249(alt)A
230 636 :M
.249(alt)A
136 535 :M
f0_9 sf
(SimExpr)S
52 534 :M
.166(Expression)A
103 534 :M
f9_9 sf
<DE>S
343 579 :M
f0_9 sf
(SimExpr)S
292 615 :M
(SimExpr)S
328 654 :M
.061(qualident)A
265 579 :M
-.125(RelOp)A
307 579 :M
f3_9 sf
(sem)S
292 654 :M
(sem)S
397 579 :M
(sem)S
346 615 :M
(sem)S
382 654 :M
(sem)S
265 615 :M
f0_9 sf
(IN)S
265 654 :M
.497(IS)A
48 510 148 162 rC
177 530.016 -.016 .016 198.016 530 .016 177 530 @a
gR
gS 48 510 370 162 rC
5 165 195 198 530 @k
48 510 253 162 rC
291 575.016 -.016 .016 303.016 575 .016 291 575 @a
gR
gS 48 510 370 162 rC
5 165 195 303 575 @k
48 510 289 162 rC
327 575.016 -.016 .016 339.016 575 .016 327 575 @a
gR
gS 48 510 370 162 rC
5 165 195 339 575 @k
48 510 274 162 rC
312 650.016 -.016 .016 324.016 650 .016 312 650 @a
gR
gS 48 510 370 162 rC
5 165 195 324 650 @k
48 510 238 162 rC
276 611.016 -.016 .016 288.016 611 .016 276 611 @a
gR
gS 48 510 370 162 rC
5 165 195 288 611 @k
48 510 238 162 rC
276 650.016 -.016 .016 288.016 650 .016 276 650 @a
gR
gS 48 510 370 162 rC
5 165 195 288 650 @k
48 510 343 162 rC
381 575.016 -.016 .016 393.016 575 .016 381 575 @a
gR
gS 48 510 370 162 rC
5 165 195 393 575 @k
48 510 292 162 rC
330 611.016 -.016 .016 342.016 611 .016 330 611 @a
gR
gS 48 510 370 162 rC
5 165 195 342 611 @k
48 510 328 162 rC
366 650.016 -.016 .016 378.016 650 .016 366 650 @a
gR
gS 48 510 370 162 rC
5 165 195 378 650 @k
1 G
201 524 28 10 rF
0 G
.016 lw
201.5 524.5 27 9 rS
1 G
213 560 28 10 rF
0 G
213.5 560.5 27 9 rS
1 G
213 599 28 10 rF
0 G
213.5 599.5 27 9 rS
1 G
213 638 28 10 rF
0 G
213.5 638.5 27 9 rS
1 G
201 533 28 10 rF
0 G
201.5 533.5 27 9 rS
1 G
213 569 28 10 rF
0 G
213.5 569.5 27 9 rS
1 G
213 608 28 10 rF
0 G
213.5 608.5 27 9 rS
1 G
213 647 28 10 rF
0 G
213.5 647.5 27 9 rS
1 G
213 578 28 10 rF
0 G
213.5 578.5 27 9 rS
1 G
213 617 28 10 rF
0 G
213.5 617.5 27 9 rS
1 G
213 656 28 10 rF
0 G
213.5 656.5 27 9 rS
222 529.016 -.016 .016 234.016 529 .016 222 529 @a
234 565.016 -.016 .016 246.016 565 .016 234 565 @a
234 604.016 -.016 .016 246.016 604 .016 234 604 @a
234 643.016 -.016 .016 246.016 643 .016 234 643 @a
-.016 -.016 234.016 532.016 .016 .016 234 526 @b
-.016 -.016 246.016 568.016 .016 .016 246 562 @b
-.016 -.016 246.016 607.016 .016 .016 246 601 @b
-.016 -.016 246.016 646.016 .016 .016 246 640 @b
48 510 370 45 rC
-.016 -.016 215.016 557.016 .016 .016 215 539 @b
gR
gS 48 510 370 162 rC
5 -105 -75 215 557 @k
48 510 370 84 rC
-.016 -.016 227.016 596.016 .016 .016 227 584 @b
gR
gS 48 510 370 162 rC
5 -105 -75 227 596 @k
48 510 370 123 rC
-.016 -.016 227.016 635.016 .016 .016 227 623 @b
gR
gS 48 510 370 162 rC
5 -105 -75 227 635 @k
48 510 208 162 rC
234 574.016 -.016 .016 258.016 574 .016 234 574 @a
gR
gS 48 510 370 162 rC
5 165 195 258 574 @k
48 510 208 162 rC
234 613.016 -.016 .016 258.016 613 .016 234 613 @a
gR
gS 48 510 370 162 rC
5 165 195 258 613 @k
48 510 208 162 rC
234 652.016 -.016 .016 258.016 652 .016 234 652 @a
gR
gS 48 510 370 162 rC
5 165 195 258 652 @k
-.016 -.016 227.016 671.016 .016 .016 227 662 @b
224 671.016 -.016 .016 230.016 671 .016 224 671 @a
gR
gS 0 49 538 670 rC
48 686 :M
f1_9 sf
.297 .03(Fig. 4)J
f0_9 sf
.31 .031(  Syntax graph for the generation of parsing procedures)J
endp
%%Page: 18 18
%%BeginPageSetup
initializepage
(Hanspeter M\232ssenb\232ck; page: 18 of 29)setjob
%%EndPageSetup
gS 0 0 538 781 rC
0 0 538 34 rC
34 28 :M
f0_9 sf
(20)S
gR
gS 0 49 538 673 rC
34 59 :M
f0_10 sf
.658 .066(Note that this kind of graphs is different from the syntax graphs used for scanner generation \(Figure 1\).)J
34 73 :M
.168 .017(Alternatives, options and iterations are represented by special nodes. This makes the graphs better suited)J
34 87 :M
1.161 .116(for the generation of recursive descent parsers. Having the graphs and the symbol sets, it is easy to)J
34 101 :M
.703 .07(generate parsing procedures. A sequence of nodes is translated into a sequence of parsing constructs.)J
34 115 :M
.562 .056(Semantic actions are simply copied from the source text without modification. The following table shows)J
34 129 :M
-.074(that every grammar item can be replaced mechanically by the equivalent parsing item.)A
159 157 :M
f3_10 sf
-.241(grammar item)A
255 157 :M
-.041(parsing item)A
48 171 :M
f0_10 sf
-.166(terminal )A
159 171 :M
(t)S
255 171 :M
.125(Expect\(t\))A
48 185 :M
(nonterminal )S
159 185 :M
-.059(nt <a, b>)A
255 185 :M
-.095(nt\(a, b\))A
48 199 :M
-.082(semantic action )A
159 199 :M
-.074(\(. )A
f3_10 sf
-.127(anyText)A
f0_10 sf
-.111( .\))A
255 199 :M
f3_10 sf
.073(anyText)A
34 227 :M
f0_10 sf
.046 .005(Terminals are recognized by the procedure)J
48 255 :M
-.059(PROCEDURE Expect\(s: INTEGER\);)A
48 269 :M
-.216(BEGIN IF sym = s THEN Get ELSE Error\(s\) END)A
48 283 :M
.384 .038(END Expect;)J
34 311 :M
1.231 .123(The procedure )J
f3_10 sf
.332(Get)A
f0_10 sf
.956 .096( requests the next input token from the scanner and stores it in the global variable)J
34 325 :M
f3_10 sf
-.109(sym)A
f0_10 sf
-.074(. It is also responsible for filtering out pragmas.)A
48 353 :M
-.043(PROCEDURE Get;)A
48 367 :M
-.279(BEGIN)A
62 381 :M
.176 .018(LOOP Scanner.Get\(sym\);)J
76 395 :M
-.157(IF )A
f3_10 sf
-.202(sym is pragma)A
f0_10 sf
-.22( THEN )A
f3_10 sf
-.177(Handle it)A
f0_10 sf
-.24( ELSE EXIT END)A
62 409 :M
-.054(END)A
48 423 :M
-.112(END Get;)A
34 451 :M
.738 .074(Alternatives, options and iterations are translated into control structures. Whenever possible, redundant)J
34 465 :M
-.003(checks are eliminated. The following procedure is generated from the graph in Figure 4.)A
48 493 :M
-.055(PROCEDURE Expression \(VAR x: OGT.Item\);)A
62 507 :M
-.115(VAR y: OGT.Item; op: INTEGER;)A
48 521 :M
-.379(BEGIN )A
62 535 :M
-.021(SimExpr\(x\);)A
62 549 :M
-.116(IF sym IN {eql, neq, lss, leq, gtr, geq, in, is} THEN)A
76 563 :M
-.112(IF sym IN {eql, neq, lss, leq, gtr, geq} THEN)A
91 577 :M
-.052(Relop\(op\); IF x.typ.form = Bool THEN OGE.MOp\(op, x\) END;)A
91 591 :M
-.035(SimExpr\(y\); OGE.Op\(op, x, y\);)A
76 605 :M
-.17(ELSIF sym = in THEN)A
91 619 :M
-.103(Get; SimExpr\(y\); OGE.In\(x, y\);)A
76 633 :M
.477(ELSE)A
91 647 :M
-.103(Get; IF x.mode >= Typ THEN err\(112\) END;)A
91 661 :M
-.061(qualident\(y\); IF y.mode = Typ THEN OGE.TypTest\(x, y\) ELSE err\(52\) END;)A
76 675 :M
-.054(END)A
62 689 :M
-.054(END)A
48 703 :M
.367 .037(END Expression;)J
endp
%%Page: 19 19
%%BeginPageSetup
initializepage
(Hanspeter M\232ssenb\232ck; page: 19 of 29)setjob
%%EndPageSetup
gS 0 0 538 781 rC
0 0 538 34 rC
495 28 :M
f0_9 sf
(21)S
gR
gS 0 54 538 672 rC
34 64 :M
f0_10 sf
1.655 .165(A more interesting example is the following production, which also contains iterations. \(For brevity,)J
34 78 :M
-.037(semantic actions are not shown.\))A
48 106 :M
-.125(FormalParameters = "\(" [ FormPar { ";" FormPar} ] "\)"   [":" qualident]. )A
34 134 :M
.088 .009(The corresponding syntax graph is)J
48 152 384 121 rC
206 161 :M
f3_9 sf
.247(opt)A
353 161 :M
.247(opt)A
275 217 :M
.168(iter)A
166 174 :M
f0_9 sf
<28>S
256 174 :M
<29>S
211 228 :M
-.165(FormPar)A
313 269 :M
-.165(FormPar)A
391 212 :M
.061(qualident)A
280 267 :M
(;)S
358 210 :M
(:)S
52 173 :M
-.033(FormalParameters)A
133 173 :M
f9_9 sf
<DE>S
48 152 145 121 rC
174 171.016 -.016 .016 195.016 171 .016 174 171 @a
gR
gS 48 152 384 121 rC
5 165 195 195 171 @k
48 152 292 121 rC
264 171.016 -.016 .016 342.016 171 .016 264 171 @a
gR
gS 48 152 384 121 rC
5 165 195 342 171 @k
48 152 211 121 rC
249 225.016 -.016 .016 261.016 225 .016 249 225 @a
gR
gS 48 152 384 121 rC
5 165 195 261 225 @k
48 152 253 121 rC
291 264.016 -.016 .016 303.016 264 .016 291 264 @a
gR
gS 48 152 384 121 rC
5 165 195 303 264 @k
48 152 331 121 rC
369 207.016 -.016 .016 381.016 207 .016 369 207 @a
gR
gS 48 152 384 121 rC
5 165 195 381 207 @k
1 G
198 166 28 10 rF
0 G
.016 lw
198.5 166.5 27 9 rS
1 G
345 166 28 10 rF
0 G
345.5 166.5 27 9 rS
1 G
267 220 28 10 rF
0 G
267.5 220.5 27 9 rS
1 G
198 175 28 10 rF
0 G
198.5 175.5 27 9 rS
1 G
345 175 28 10 rF
0 G
345.5 175.5 27 9 rS
1 G
267 229 28 10 rF
0 G
267.5 229.5 27 9 rS
366 171.016 -.016 .016 378.016 171 .016 366 171 @a
:a
32<AAAAAAAAAAAAAAAA><AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA>fg bk
:b
288 225.016 -.016 .016 300.016 225 .016 288 225 @a
:e
0 G
-.016 -.016 378.016 174.016 .016 .016 378 168 @b
48 152 384 63 rC
-.016 -.016 212.016 217.016 .016 .016 212 181 @b
gR
gS 48 152 384 121 rC
5 -105 -75 212 217 @k
48 152 384 45 rC
-.016 -.016 359.016 199.016 .016 .016 359 181 @b
gR
gS 48 152 384 121 rC
5 -105 -75 359 199 @k
48 152 384 99 rC
-.016 -.016 281.016 253.016 .016 .016 281 235 @b
gR
gS 48 152 384 121 rC
5 -105 -75 281 253 @k
48 152 193 121 rC
219 171.016 -.016 .016 243.016 171 .016 219 171 @a
gR
gS 48 152 384 121 rC
5 165 195 243 171 @k
:a
32<AAAAAAAAAAAAAAAA><AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA>fg bk
:b
351 265.016 -.016 .016 363.016 265 .016 351 265 @a
32<FF00FF00FF00FF00><FFFFFF000000FFFFFF000000FFFFFF000000FFFFFF000000>fg bk
:b
-.016 -.016 363.016 265.016 .016 .016 363 232 @b
32<AAAAAAAAAAAAAAAA><AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA>fg bk
:b
299 152 133 121 rC
297 232.016 -.016 .016 363.016 232 .016 297 232 @a
gR
:a
32<AAAAAAAAAAAAAAAA><AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA>fg bk
:b
gS 48 152 384 121 rC
5 -15 15 297 232 @k
32<FF00FF00FF00FF00><FFFFFF000000FFFFFF000000FFFFFF000000FFFFFF000000>fg bk
:b
-.016 -.016 300.016 225.016 .016 .016 300 199 @b
32<AAAAAAAAAAAAAAAA><AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA>fg bk
:b
255 199.016 -.016 .016 300.016 199 .016 255 199 @a
32<FF00FF00FF00FF00><FFFFFF000000FFFFFF000000FFFFFF000000FFFFFF000000>fg bk
:b
48 183 384 90 rC
-.016 -.016 255.016 199.016 .016 .016 255 181 @b
gR
32<FF00FF00FF00FF00><FFFFFF000000FFFFFF000000FFFFFF000000FFFFFF000000>fg bk
:b
gS 48 152 384 121 rC
5 75 105 255 181 @k
gR
:e
gS 0 54 538 672 rC
34 287 :M
0 G
f0_10 sf
.282 .028(Dotted arrows denote pointers to the successors of inner structures. They help in the computation of start)J
34 301 :M
.047 .005(and successor sets. The graph is translated into the following procedure:)J
48 329 :M
-.085(PROCEDURE FormalParameters;)A
48 343 :M
-.279(BEGIN)A
62 357 :M
.081(Expect\(leftpar\);)A
62 371 :M
-.244(IF sym IN {ident, var} THEN)A
76 385 :M
-.094(FormPar;)A
76 399 :M
-.154(WHILE sym = semicolon DO Get; FormPar END)A
62 413 :M
.038(END;)A
62 427 :M
.069(Expect\(rightpar\);)A
62 441 :M
-.113(IF sym = colon THEN Get; qualident END)A
48 455 :M
-.122(END FormalParameters;)A
34 497 :M
f1_10 sf
3.538 .354(5.3 Error Recovery)J
34 525 :M
f0_10 sf
.418 .042(Good and efficient error recovery is difficult in recursive descent parsers since little information about the)J
34 539 :M
-.093(parsing process is available when an error occurs. What has to be done in case of an error:)A
34 567 :M
.663(1.)A
48 567 :M
-.015(Find all symbols with which parsing can be resumed at a certain location in the grammar reachable from)A
48 581 :M
-.027(the error location \(recovery symbols\).)A
34 595 :M
.663(2.)A
48 595 :M
-.02(Skip the input up to the first symbol that is in the recovery set.)A
34 609 :M
.663(3.)A
48 609 :M
-.018(Drive the parser to the location where the recovery symbol can be recognized. )A
34 623 :M
.663(4.)A
48 623 :M
.019 .002(Resume parsing from there.)J
34 651 :M
.724 .072(In recursive descent parsers, information about the parsing location and about the expected symbols is)J
34 665 :M
.574 .057(only implicitly contained in the parser code \(and in the procedure call stack\) and cannot be exploited for)J
34 679 :M
.392 .039(error recovery.  One method to overcome this is to compute the recovery set dynamically during parsing.)J
34 693 :M
.283 .028(Then, when an error occurs, the recovery symbols are already known and all that one has to do is to skip)J
34 707 :M
1.665 .167(erroneous input and to "unroll" the procedure stack up to a legal continuation point [Wirth76]. This)J
34 721 :M
.258 .026(technique, although systematically applicable, slows down error-free parsing and inflates the parser code.)J
endp
%%Page: 20 20
%%BeginPageSetup
initializepage
(Hanspeter M\232ssenb\232ck; page: 20 of 29)setjob
%%EndPageSetup
gS 0 0 538 781 rC
0 0 538 34 rC
34 28 :M
f0_9 sf
(22)S
gR
gS 0 44 538 666 rC
34 54 :M
f0_10 sf
1.583 .158(Another technique has therefore been suggested in [Wirth86]. Recovery takes place only at certain)J
34 68 :M
.251 .025(synchronization points in the grammar. Errors at other points are reported but cause no recovery. Parsing)J
34 82 :M
.363 .036(simply continues up to the next synchronization point where the grammar and the input are synchronized)J
34 96 :M
.513 .051(again. This requires the designer of the grammar to specify synchronization points explicitly \320 not a very)J
34 110 :M
-.003(difficult task if one thinks for a moment. The advantage is that no recovery sets have to be computed at run)A
34 124 :M
-.133(time. This makes the parser small and fast.)A
34 152 :M
f3_10 sf
2.842 .284(Synchronization points)J
f0_10 sf
1.557 .156(. In Cocol/R a synchronization point is specified by the keyword SYNC \(see)J
34 166 :M
-.039(Section 2.3\). A good synchronization point is a location in the grammar where particularly safe symbols \(like)A
34 180 :M
.434 .043(keywords\) are expected and that is often visited by the parser. Typical candidates are the beginning of a)J
34 194 :M
.363 .036(statement, the beginning of a declaration or the beginning of a structured type. A synchronization point is)J
34 208 :M
.161 .016(translated into a loop that skips all symbols not expected at this point \(except end-of-file\). The set of these)J
34 222 :M
.035 .003(symbols can be precomputed at parser generation time. The following example shows two synchronization)J
34 236 :M
.112 .011(points and their counterparts in the generated parser.)J
45 264 :M
f3_10 sf
.258(production)A
215 264 :M
.572 .057(generated parsing procedure)J
45 285 :M
f0_10 sf
-.091(Declarations =)A
57 299 :M
-.259(SYNC)A
215 299 :M
-.064(WHILE ~\(sym IN {const, type, var, proc, begin, end, eof}\) DO)A
227 313 :M
-.128(Error\(\311\); Get)A
215 327 :M
.038(END;)A
57 341 :M
-.948({  )A
215 341 :M
-.143(WHILE sym IN {const, type, var, proc} DO)A
68 355 :M
-.018(\( "CONST" {ConstDecl ";"})A
227 355 :M
-.212(IF sym = const THEN Get; \311 )A
68 369 :M
-.042(| "TYPE" {TypeDecl ";"})A
227 369 :M
-.134(ELSIF sym = type THEN Get; \311)A
68 383 :M
-.085(| "VAR" {VarDecl ";"})A
227 383 :M
-.216(ELSIF sym = var THEN Get; \311)A
68 397 :M
-.103(| ProcDecl)A
227 397 :M
.499 .05(ELSE ProcDecl)J
68 411 :M
<29>S
227 411 :M
.038(END;)A
57 425 :M
-1.557(  )A
68 425 :M
-.259(SYNC)A
227 425 :M
-.064(WHILE ~\(sym IN {const, type, var, proc, begin, end, eof}\) DO)A
238 439 :M
-.128(Error\(\311\); Get)A
227 453 :M
-.054(END)A
57 467 :M
-.118(}.)A
215 467 :M
-.054(END)A
34 495 :M
1.175 .117(To avoid spurious error messages, an error is only reported when a certain amount of text has been)J
34 509 :M
-.051(correctly parsed since the last error.)A
34 537 :M
f3_10 sf
2.105 .211(Weak symbols)J
f0_10 sf
1.299 .13(. The knowledge of synchronization points is already sufficient to recover from errors.)J
34 551 :M
-.007(However, recovery can be improved if the parser also knows about "weak" symbols that are often mistyped)A
34 565 :M
-.025(or missing \(like semicolon\). These symbols are marked in the grammar by the keyword WEAK \(see Section)A
34 579 :M
-.071(2.3\). If the parser tries to recognize a weak symbol and finds it missing, it reports an error and skips the input)A
34 593 :M
-.043(until a legal successor of the symbol is found \(or a symbol that is expected at any synchronization point; this)A
34 607 :M
.408 .041(is a useful heuristic that avoids skipping safe symbols\). The following example shows the translation of a)J
34 621 :M
-.051(weak symbol.)A
227 649 :M
f3_10 sf
.479 .048(generated parsing code)J
48 663 :M
f0_10 sf
.406 .041(Statement =)J
62 677 :M
.365 .036(ident )J
227 677 :M
.179(Expect\(ident\);)A
62 691 :M
.096 .01(WEAK ":=" )J
227 691 :M
-.025(Weak\(becomes, {)A
f3_10 sf
-.022(start symbols of Expression)A
f0_10 sf
(}\);)S
62 705 :M
.472 .047(Expression .)J
227 705 :M
.172(Expression)A
endp
%%Page: 21 21
%%BeginPageSetup
initializepage
(Hanspeter M\232ssenb\232ck; page: 21 of 29)setjob
%%EndPageSetup
gS 0 0 538 781 rC
0 0 538 34 rC
495 28 :M
f0_9 sf
(23)S
gR
gS 0 54 538 673 rC
34 64 :M
f0_10 sf
-.024(The procedure )A
f3_10 sf
-.031(Weak)A
f0_10 sf
-.023( is implemented as follows)A
48 92 :M
-.033(PROCEDURE Weak\(s: INTEGER; expected: Set\);)A
48 106 :M
-.279(BEGIN)A
62 120 :M
-.293(IF sym = s THEN Get)A
62 134 :M
.466 .047(ELSE )J
76 148 :M
-.054(Error\(s\); WHILE sym )A
f9_10 sf
-.081<CF>A
f0_10 sf
-.052( expected )A
f9_10 sf
-.087<C8>A
f0_10 sf
-.035( {)A
f3_10 sf
-.052(symbols expected at synchronization points)A
f0_10 sf
-.066(} DO Get END)A
62 162 :M
-.054(END)A
48 176 :M
-.153(END Weak;)A
34 204 :M
1.429 .143(Weak symbols give the parser another chance to synchronize in case of an error. Again, the set of)J
34 218 :M
.009 .001(expected symbols can be precomputed at parser generation time and cause no run time overhead in error-)J
34 232 :M
.198 .02(free parsing.)J
34 260 :M
.543 .054(When an iteration starts with a weak symbol, this symbol is called a )J
f3_10 sf
1.023 .102(weak separator)J
f0_10 sf
.452 .045( and is handled in a)J
34 274 :M
.477 .048(special way. If it cannot be recognized, the input is skipped until a symbol that is contained in one of the)J
34 288 :M
.27 .027(following three sets is found:)J
48 316 :M
f9_10 sf
(a)S
62 316 :M
f0_10 sf
-.095(symbols that may follow the weak separator)A
48 330 :M
f9_10 sf
(b)S
62 330 :M
f0_10 sf
-.059(symbols that may follow the iteration)A
48 344 :M
f9_10 sf
(g)S
62 344 :M
f0_10 sf
.132 .013(symbols expected at any synchronization point \(including eof\))J
34 372 :M
-.06(The following example shows the translation of a weak separator)A
227 400 :M
f3_10 sf
.572 .057(generated parsing procedure)J
48 414 :M
f0_10 sf
1.118 .112(StatSequence =)J
62 428 :M
.071(Stat)A
227 428 :M
.109(Stat;)A
62 442 :M
-.057({ WEAK ";" Stat}.)A
227 442 :M
-.088(WHILE WeakSep\(semicolon, )A
f9_10 sf
-.105(a)A
f0_10 sf
-.046(, )A
f9_10 sf
-.092(b)A
f0_10 sf
-.091(\) DO Stat END)A
34 470 :M
.871 .087(In this example, )J
f9_10 sf
.355(a)A
f0_10 sf
.777 .078( is the set of start symbols of a statement \(ident, IF, WHILE, etc.\) and )J
f9_10 sf
.309(b)A
f0_10 sf
.572 .057( is the set of)J
34 484 :M
.345 .035(successors of a statement sequence \(END, ELSE, UNTIL, etc.\). Both sets can be precomputed at parser)J
34 498 :M
-.005(generation time. )A
f3_10 sf
(WeakSep)S
f0_10 sf
-.005( is implemented as follows:)A
48 526 :M
-.006(PROCEDURE WeakSep\(s: INTEGER; sySucc, iterSucc: Set\): BOOLEAN;)A
48 540 :M
-.279(BEGIN)A
62 554 :M
-.241(IF sym = s THEN Get; RETURN TRUE)A
62 568 :M
-.089(ELSIF sym )A
f9_10 sf
-.123<CE>A
f0_10 sf
-.098( iterSucc THEN RETURN FALSE)A
62 582 :M
-.104(ELSE Error\(s\); WHILE sym )A
f9_10 sf
-.15<CF>A
f0_10 sf
-.099( sySucc )A
f9_10 sf
-.161<C8>A
f0_10 sf
-.087( iterSucc )A
f9_10 sf
-.161<C8>A
f0_10 sf
-.058( )A
f9_10 sf
-.086(g)A
f0_10 sf
-.116(  DO Get END;)A
76 596 :M
-.121(RETURN sym )A
f9_10 sf
-.145<CE>A
f0_10 sf
-.097( sySucc  \(*TRUE means "s inserted"*\))A
62 610 :M
-.054(END)A
48 624 :M
(END WeakSep;)S
34 652 :M
.087 .009(The observant reader may have noticed that the set )J
f9_10 sf
(b)S
f0_10 sf
.095 .009( contains the successors of a statement sequence in)J
34 666 :M
1.68 .168(any possible context. This set may be too large. If the statement sequence occurs within a repeat)J
34 680 :M
-.018(statement, only UNTIL is a legal successor, but not END or ELSE. We accept this fault, since it allows us to)A
34 694 :M
.697 .07(precompute the set )J
f9_10 sf
.212(b)A
f0_10 sf
.603 .06( at parser generation time. The occurrence of END or ELSE is very unlikely in this)J
34 708 :M
-.009(context and can only lead to incorrect synchronization, causing the parser to synchronize again.)A
endp
%%Page: 22 22
%%BeginPageSetup
initializepage
(Hanspeter M\232ssenb\232ck; page: 22 of 29)setjob
%%EndPageSetup
gS 0 0 538 781 rC
0 0 538 34 rC
34 28 :M
f0_9 sf
(24)S
gR
gS 0 45 538 647 rC
34 55 :M
f0_10 sf
1.606 .161(The following example demonstrates that our method yields good error recovery. We generated an)J
34 69 :M
2.031 .203(Oberon compiler and compiled the following erroneous program taken from [Wirth86]. The parser)J
34 83 :M
.095 .01(recovered surprisingly well.)J
71 109 :M
f10_9 sf
-.432(MODULE Error;)A
71 119 :M
-.412(CONST M := 10, N = 100  X = 10;)A
48 129 :M
-.598(***)A
71 129 :M
-.418(        ^ "=" expected)A
48 139 :M
-.598(***)A
71 139 :M
-.414(             ^ ";" expected)A
48 149 :M
-.598(***)A
71 149 :M
-.409(                        ^ ";" expected)A
71 159 :M
-.429(VAR , a, b, c;)A
48 169 :M
-.598(***)A
71 169 :M
-.412(    ^ unexpected symbol in Block)A
71 189 :M
-.435(PROCEDURE P;)A
71 199 :M
-.498(BEGIN)A
71 209 :M
-.413(  s := 0; a = 5 * \(b - 1 END;)A
48 219 :M
-.598(***)A
71 219 :M
-.414(            ^ error in Stat)A
48 229 :M
-.598(***)A
71 229 :M
-.41(                     ^ error in Stat)A
48 239 :M
-.598(***)A
71 239 :M
-.408(                            ^ ident expected)A
71 259 :M
-.498(BEGIN)A
71 269 :M
-.443(  > a > b;)A
48 279 :M
-.598(***)A
71 279 :M
-.413(  ^ unexpected symbol in Stat)A
48 289 :M
-.598(***)A
71 289 :M
-.419(      ^ error in Stat)A
71 299 :M
-.435(  WHILE a DO)A
71 309 :M
-.416(    BEGIN > b; - c := 0;)A
48 319 :M
-.598(***)A
71 319 :M
-.412(    ^ unexpected symbol in Stat)A
48 329 :M
-.598(***)A
71 329 :M
-.41(          ^ unexpected symbol in Stat)A
48 339 :M
-.598(***)A
71 339 :M
-.408(               ^ unexpected symbol in Stat)A
71 349 :M
-.419(    WHILE a > 0 BEGIN)A
48 359 :M
-.598(***)A
71 359 :M
-.412(                ^ "DO" expected)A
71 369 :M
-.413(      IF ODD a c := c * - b;)A
48 379 :M
-.598(***)A
71 379 :M
-.412(             ^ error in Factor)A
48 389 :M
-.598(***)A
71 389 :M
-.412(               ^ error in Stat)A
48 399 :M
-.598(***)A
71 399 :M
-.409(                        ^ error in Factor)A
71 409 :M
-.414(      b := 2 * b a := a / 2)A
48 419 :M
-.598(***)A
71 419 :M
-.411(                 ^ error in Factor)A
71 429 :M
-.456(    END;)A
71 439 :M
-.421(    P := 0; P; 666;)A
48 449 :M
-.598(***)A
71 449 :M
-.408(               ^ unexpected symbol in Stat)A
71 459 :M
-.465(  END .)A
48 469 :M
-.598(***)A
71 469 :M
-.42(      ^ ";" expected)A
48 479 :M
-.598(***)A
71 479 :M
-.417(       ^ "END" expected)A
34 505 :M
f0_10 sf
-.008(The error messages are kept short and simple. This is due to our conviction that experienced programmers)A
34 519 :M
.125 .012(do not need a detailed explanation of what actions the parser performed in order to recover from the error.)J
34 533 :M
-.073(In almost all cases it is sufficient to point to the error location and to give a rough hint.)A
34 561 :M
.347 .035(The proposed error recovery technique is cheap. It costs only a check at every synchronization point and)J
34 575 :M
.275 .027(therefore does not slow down error-free parsing. The code for error handling makes up 10% of the parser)J
34 589 :M
.034 .003(code \(without semantic actions\).)J
48 617 :M
-.025(Oberon parser without error handling  )A
249 617 :M
1.041 .104(3019 Bytes)J
306 617 :M
.552 .055(\(object code\))J
48 631 :M
-.012(Error handling procedures \(fixed size\) )A
255 631 :M
.854 .085(248 Bytes)J
48 645 :M
.04 .004(Synchronization points, weak symbols )J
261 645 :M
.645 .064(81 Bytes)J
endp
%%Page: 23 23
%%BeginPageSetup
initializepage
(Hanspeter M\232ssenb\232ck; page: 23 of 29)setjob
%%EndPageSetup
gS 0 0 538 781 rC
0 0 538 34 rC
495 28 :M
f0_9 sf
(25)S
gR
gS 0 54 538 673 rC
34 64 :M
f1_10 sf
4.95 .495(6. Measurements)J
34 92 :M
f0_10 sf
.483 .048(We compared an Oberon compiler generated by Coco/R with a manually implemented Oberon compiler.)J
34 106 :M
.193 .019(The back-end modules of both compilers are the same. Only the scanner and the parser are different. We)J
34 120 :M
.074 .007(measured the time to compile a 867-line Oberon program \(7169 tokens or 24254 characters\) on a Ceres-2)J
34 134 :M
-.015(workstation with a NS32532 processor running at 25 MHz.)A
48 162 :M
-.062(Original compiler)A
165 162 :M
.479 .048(3.9 sec)J
48 176 :M
.078 .008(Generated compiler)J
165 176 :M
.479 .048(3.0 sec)J
34 204 :M
.139 .014(The generated compiler is 23 % faster than the original compiler. This is due to the fact that the generated)J
34 218 :M
.233 .023(compiler reads the source text into main memory at once, while the original compiler reads it character by)J
34 232 :M
.775 .077(character. Without this improvement the generated compiler is about 10% slower than the original one.)J
34 246 :M
-.006(Scanning and parsing contribute to the overall run time of the generated compiler in the following way:)A
48 274 :M
.188(Scanning)A
188 274 :M
.71 .071(0.61 sec)J
261 274 :M
.165 .016(20 %)J
48 288 :M
.018(Parsing)A
188 288 :M
.71 .071(0.12 sec)J
267 288 :M
-.113(4 %)A
34 316 :M
-.025(This gives a compilation speed of)A
48 344 :M
.188(Scanning)A
169 344 :M
.442 .044(11 625  tokens/sec)J
48 358 :M
.018(Parsing)A
169 358 :M
.442 .044(51 127  tokens/sec)J
48 372 :M
.101 .01(Total compilation speed)J
175 372 :M
.356 .036(2 395  tokens/sec)J
34 400 :M
.039 .004(Comparing the object code of the two compilers yields the following measures:)J
156 428 :M
-.062(Original compiler)A
266 428 :M
.078 .008(Generated compiler)J
48 442 :M
.128(Scanner)A
167 442 :M
.4 .04(3 672 Bytes)J
286 442 :M
.4 .04(3 944 Bytes)J
385 442 :M
-.022(+ 7%)A
48 456 :M
-.089(Parser)A
161 456 :M
.529 .053(11 740 Bytes)J
280 456 :M
.529 .053(12 236 Bytes)J
385 456 :M
-.022(+ 4%)A
48 470 :M
-.072(\(incl. semantic actions\))A
34 512 :M
f1_10 sf
3.326 .333(7. Summary)J
34 540 :M
f0_10 sf
-.04(Attributed grammars, when regarded as an algorithmic notation, are a special purpose language to describe)A
34 554 :M
.234 .023(translation processes. They serve three purposes:)J
34 582 :M
<A5>S
45 582 :M
f3_10 sf
.45(Specification)A
f0_10 sf
1.607 .161(. A translator can be specified and designed this way before it is implemented in a)J
45 596 :M
.286 .029(conventional programming language.)J
34 610 :M
<A5>S
45 610 :M
f3_10 sf
.093(Documentation)A
f0_10 sf
.319 .032(. An attributed grammar is a concise documentation of a translation process. It contains)J
45 624 :M
-.063(the same information as the program that implements the translator but in more compact form.)A
34 638 :M
<A5>S
45 638 :M
f3_10 sf
.004(Implementation)A
f0_10 sf
.014 .001(. If a tool like Coco/R is available, an attributed grammar is already the implementation of)J
45 652 :M
-.009(the translator.)A
34 680 :M
-.018(Attributed grammars can be used to specify all kinds of programs that process a single stream of structured)A
34 694 :M
.211 .021(input data. They can be applied not only to proper compilers but also to compiler-like programs like cross-)J
34 708 :M
1.197 .12(reference generators, pretty printers or complexity analyzers and even to tasks that do not fall in the)J
34 722 :M
.121 .012(traditional scope of compiler construction, like the processing of data files that describe pictures, formatted)J
endp
%%Page: 24 24
%%BeginPageSetup
initializepage
(Hanspeter M\232ssenb\232ck; page: 24 of 29)setjob
%%EndPageSetup
gS 0 0 538 781 rC
0 0 538 34 rC
34 28 :M
f0_9 sf
(26)S
gR
gS 0 45 538 113 rC
34 55 :M
f0_10 sf
-.025(text or database information.)A
34 83 :M
.333 .033(Among the advantages of using a tool like Coco/R are a fast and safe implementation of translators, high)J
34 97 :M
.62 .062(flexibility in experimenting with a language design, and a translator description that is more concise and)J
34 111 :M
.684 .068(more readable than an implementation in a conventional programming language. The effort to learn the)J
34 125 :M
.772 .077(description language is small, since semantic parts are written in a familiar programming language and)J
34 139 :M
.43 .043(syntactic parts are based on the well-known formalism of EBNF grammars. The translators generated by)J
34 153 :M
.11 .011(Coco/R are fast enough to compete with production-quality compilers.)J
endp
%%Page: 25 25
%%BeginPageSetup
initializepage
(Hanspeter M\232ssenb\232ck; page: 25 of 29)setjob
%%EndPageSetup
gS 0 0 538 781 rC
0 0 538 34 rC
495 28 :M
f0_9 sf
(27)S
gR
gS 0 49 538 533 rC
34 59 :M
f1_10 sf
1.963 .196(Appendix A   Cocol/R Grammar)J
34 101 :M
f0_10 sf
-.067(Cocol )A
113 101 :M
-.618(= )A
125 101 :M
.49 .049("COMPILER" ident)J
34 115 :M
-.934(      )A
125 115 :M
-.466({ ANY })A
34 129 :M
-.934(      )A
125 129 :M
-.2({ Declaration })A
34 143 :M
-.934(      )A
125 143 :M
("PRODUCTIONS")S
34 157 :M
-.934(      )A
125 157 :M
.215 .022({ ident [Attributes] [SemText] "=" Expression "."} )J
34 171 :M
-.934(      )A
125 171 :M
.544 .054("END" ident ".".)J
34 185 :M
-.122(Declaration )A
113 185 :M
-.618(= )A
125 185 :M
-.074( "CHARACTERS" { SetDecl })A
34 199 :M
-1.038(    )A
113 199 :M
(|)S
125 199 :M
-.125("TOKENS"     { TokenDecl })A
34 213 :M
-1.038(    )A
113 213 :M
-1.376(| )A
125 213 :M
-.21("PRAGMAS"    { PragmaDecl })A
34 227 :M
-1.038(    )A
113 227 :M
-1.376(| )A
125 227 :M
.321 .032("COMMENTS" "FROM" TokenExpr "TO" TokenExpr ["NESTED"])J
34 241 :M
-1.038(    )A
113 241 :M
-1.376(| )A
125 241 :M
-.112("IGNORE" \( "CASE" | Set \).)A
34 269 :M
.127 .013(SetDecl )J
113 269 :M
(=)S
125 269 :M
.508 .051(ident "=" Set ".".)J
34 283 :M
.165 .016(Set )J
113 283 :M
-.618(= )A
125 283 :M
-.075(SimSet { "+" SimSet | "-" SimSet }.)A
34 297 :M
(SimSet )S
113 297 :M
(=)S
125 297 :M
-.086(ident | string | "CHR" "\(" number "\)" | "ANY".)A
34 325 :M
.231 .023(TokenDecl )J
113 325 :M
(=)S
125 325 :M
.506 .051(Symbol ["=" TokenExpr "."].)J
34 339 :M
.463 .046(TokenExpr )J
113 339 :M
(=)S
125 339 :M
-.055(TokenTerm { "|" TokenTerm }.)A
34 353 :M
.06 .006(TokenTerm )J
113 353 :M
-.618(= )A
125 353 :M
-.027(TokenFactor { TokenFactor} [ "CONTEXT" "\(" TokenExpr "\)" ].)A
34 367 :M
.088(TokenFactor)A
113 367 :M
(=)S
125 367 :M
-.073(\( Symbol |  "\(" TokenExpr "\)" |  "[" TokenExpr "]" |  "{" TokenExpr "}" \).)A
34 395 :M
-.111(PragmaDecl)A
113 395 :M
(=)S
125 395 :M
.724 .072(TokenDecl [SemText].)J
34 423 :M
.384 .038(Expression )J
113 423 :M
-.618(= )A
125 423 :M
-.23(Term { "|" Term }.)A
34 437 :M
-.275(Term )A
113 437 :M
-.618(= )A
125 437 :M
-.167(Factor { Factor}.)A
34 451 :M
-.185(Factor )A
113 451 :M
-.698(=  )A
125 451 :M
-.942( \( )A
136 451 :M
.685 .068(["WEAK"] Symbol [Attributes])J
34 465 :M
-1.167(   )A
113 465 :M
-1.376(| )A
125 465 :M
.166(SemText)A
34 479 :M
-1.167(   )A
113 479 :M
-1.376(| )A
125 479 :M
.085("ANY")A
34 493 :M
-1.167(   )A
113 493 :M
-1.376(| )A
125 493 :M
.024("SYNC")A
34 507 :M
-1.167(   )A
113 507 :M
-1.376(| )A
125 507 :M
-.058("\(" Expression "\)"  |  "[" Expression "]"  |  "{" Expression "}" )A
34 521 :M
-1.167(   )A
113 521 :M
-.106(\).)A
34 535 :M
-.019(Symbol )A
113 535 :M
-.618(= )A
125 535 :M
-.055( ident | string.)A
34 549 :M
.496 .05(Attributes )J
113 549 :M
-.618(= )A
125 549 :M
-.134("<" { ANY } ">".)A
34 563 :M
.129 .013(SemText )J
113 563 :M
-.618(= )A
125 563 :M
-.149("\(." { ANY } ".\)".)A
endp
%%Page: 26 26
%%BeginPageSetup
initializepage
(Hanspeter M\232ssenb\232ck; page: 26 of 29)setjob
%%EndPageSetup
gS 0 0 538 781 rC
0 0 538 34 rC
34 28 :M
f0_9 sf
(28)S
gR
gS 0 49 538 597 rC
34 59 :M
f1_10 sf
2.232 .223(Appendix B   Sample Attributed Grammar in Cocol/R)J
34 87 :M
f0_10 sf
-.061(The following attributed grammar describes a compiler for a simple programming language. It uses a symbol)A
34 101 :M
-.003(table handler \(TL\) and a code generator \(TC\) that generates code for a stack machine. These two modules)A
34 115 :M
.997 .1(are not described further. The purpose of this grammar is to give a coherent example of an attributed)J
34 129 :M
.008 .001(grammar. It is not necessary for the reader to understand the translation process in all details, although the)J
34 143 :M
-.118(semantic actions in this grammar are rather similar to actions contained in any compiler.)A
34 180 :M
f0_9 sf
-.077(COMPILER Taste)A
34 202 :M
.054 .005(\(*-------------------------------------- imports and global declarations -----------------------------------------*\))J
34 213 :M
-.02(IMPORT TL \(*table handler*\), TC \(*code generator*\);)A
34 235 :M
-.374(CONST)A
34 246 :M
-1.001(  )A
45 246 :M
-.041(plus = 0; minus = 1; times = 2; slash = 3; equ = 4; lss = 5; gtr = 6; \(*operators*\))A
34 257 :M
-1.001(  )A
45 257 :M
-.021(undef = 0; int = 1; bool = 2;  \(*types*\))A
34 268 :M
-1.001(  )A
45 268 :M
.126 .013(vars = 0; procs = 1;  \(*object kinds*\))J
34 279 :M
-1.001(  )A
45 279 :M
-.107(ADD = 0; SUB = 1; MUL = 2; DIVI = 3; EQU = 4; LSS = 5; GTR = 6; \(*machine instructions*\))A
34 290 :M
-1.001(  )A
45 290 :M
-.177(LOAD = 7; LIT = 8; STO = 9; CALL = 10; RET = 11; RES = 12;)A
34 301 :M
-1.001(  )A
45 301 :M
-.165(JMP = 13; FJMP = 14; HALTc = 15; NEG = 16; READ = 17; WRITE = 18;)A
34 323 :M
-.169(TYPE)A
45 334 :M
-.272(Name = ARRAY 32 OF CHAR;)A
34 356 :M
-.134(PROCEDURE Err\(nr: INTEGER\);)A
34 367 :M
-.016(BEGIN TasteS.Error\(100 + nr, TasteS.pos\) END Err;)A
34 389 :M
-.131(PROCEDURE StringToVal\(s: ARRAY OF CHAR; VAR val: INTEGER\);)A
45 400 :M
-.107(VAR i: INTEGER;)A
34 411 :M
(BEGIN)S
34 422 :M
-1.001(  )A
45 422 :M
.109 .011(val:=0; i := 0;)J
34 433 :M
-1.001(  )A
45 433 :M
-.108(WHILE s[i] # 0X DO val := 10 * val + ORD\(s[i]\) - ORD\("0"\); INC\(i\) END)A
34 444 :M
-.067(END StringToVal;)A
34 455 :M
-1.001(  )A
34 477 :M
.233 .023(\(*------------------------------------------ scanner specification ---------------------------------------------------*\))J
34 488 :M
-.333(CHARACTERS)A
34 499 :M
-1.001(  )A
45 499 :M
-.018(letter = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".)A
34 510 :M
-1.001(  )A
45 510 :M
-.034(digit = "0123456789".)A
34 521 :M
-1.001(  )A
45 521 :M
-.173(eol = CHR\(13\).)A
34 532 :M
( )S
45 532 :M
-.173( tab = CHR\(9\).)A
34 554 :M
-.201(TOKENS)A
34 565 :M
-1.001(  )A
45 565 :M
.047 .005(ident = letter {letter | digit}.)J
34 576 :M
-1.001(  )A
45 576 :M
-.055(number  = digit {digit}.)A
34 598 :M
-.118(IGNORE eol + tab)A
34 620 :M
-.258(COMMENTS FROM "\(*" TO "*\)" NESTED)A
endp
%%Page: 27 27
%%BeginPageSetup
initializepage
(Hanspeter M\232ssenb\232ck; page: 27 of 29)setjob
%%EndPageSetup
gS 0 0 538 781 rC
0 0 538 34 rC
495 28 :M
f0_9 sf
(29)S
gR
gS 0 49 538 650 rC
34 57 :M
f0_9 sf
.183 .018(\(*------------------------------------------------------- parser specification ----------------------------------------------------------*\))J
34 68 :M
-.249(PRODUCTIONS)A
34 90 :M
-.435(Taste                                  )A
181 90 :M
(\(. )S
193 90 :M
-.047(VAR name, progName: Name; obj: TL.Object; .\))A
34 101 :M
-.756(= )A
45 101 :M
-.265("PROGRAM" )A
45 112 :M
-.189(Ident<progName> ";"        )A
181 112 :M
(\(. )S
193 112 :M
-.011(TC.progStart := TC.pc .\))A
34 123 :M
-1.001(  )A
45 123 :M
.164(Body)A
34 134 :M
-1.001(  )A
45 134 :M
-.317(Ident<name> "."                      )A
181 134 :M
(\(. )S
193 134 :M
-.141(IF name # progName THEN Err\(0\) END; TC.Emit\(HALTc\) .\).)A
34 145 :M
.012(\(*-----------------------------------------------------------------------------------------------------------------------------------------------*\))A
34 156 :M
-.448(Body                                   )A
181 156 :M
-.008(\(. VAR name, name1; Name; fix, type: INTEGER; obj: TL.Object; .\))A
34 167 :M
-.507(=                                      )A
181 167 :M
-.018(\(. TL.EnterScope;   fix := TC.pc + 1; TC.Emit2\(JMP,0\) .\))A
34 178 :M
-1.001(  )A
45 178 :M
-.506({ )A
57 178 :M
-.279("VAR" )A
34 189 :M
-.667(    )A
57 189 :M
-.298({  Ident<name> ":"                  )A
181 189 :M
-.038(\(. obj := TL.NewObj\(name, vars\) .\))A
34 200 :M
-.601(      )A
57 200 :M
-.199(   TypeId<obj^.type> ";"             )A
34 211 :M
-.667(    )A
57 211 :M
(})S
45 233 :M
-.838(| )A
57 233 :M
-.308("PROCEDURE" )A
57 244 :M
-.201(Ident<name> ";"        )A
181 244 :M
-.041(\(. obj := TL.NewObj\(name, procs\);  obj^.adr := TC.pc .\))A
57 255 :M
(Body )S
57 266 :M
-.292(Ident<name1> ";"                   )A
181 266 :M
-.166(\(. TC.Emit\(RET\);  IF name # name1 THEN Err\(0\) END .\))A
45 277 :M
(})S
34 288 :M
-1.001(  )A
45 288 :M
-.428("BEGIN"                              )A
181 288 :M
(\(. TC.Fixup\(fix\); TC.Emit2\(RES, TL.DataSpace\(\)\) .\))S
34 299 :M
-1.001(  )A
45 299 :M
.284 .028(StatSeq )J
34 310 :M
-1.001(  )A
45 310 :M
-.483("END"                                )A
181 310 :M
.38 .038(\(. TL.LeaveScope .\).)J
34 321 :M
.012(\(*-----------------------------------------------------------------------------------------------------------------------------------------------*\))A
34 332 :M
-.043(TypeId<VAR type: INTEGER>)A
34 343 :M
-.628(=  )A
45 343 :M
-.424("INTEGER"                          )A
181 343 :M
(\(. )S
193 343 :M
.172 .017(type := int .\))J
34 354 :M
-.838(| )A
45 354 :M
-.409("BOOLEAN"                          )A
181 354 :M
(\(. )S
193 354 :M
.163 .016(type := bool .\).)J
34 365 :M
.012(\(*-----------------------------------------------------------------------------------------------------------------------------------------------*\))A
34 376 :M
.201 .02(StatSeq = Stat {";" Stat}.)J
34 387 :M
.012(\(*-----------------------------------------------------------------------------------------------------------------------------------------------*\))A
34 398 :M
-.435(Stat                                   )A
181 398 :M
(\(. )S
193 398 :M
.082 .008(VAR name: Name; type, fix, fix2, loopstart: INTEGER; obj: TL.Object;  )J
34 409 :M
-.756(= )A
45 409 :M
([)S
57 409 :M
-.358( Ident<name>                        )A
181 409 :M
.505(\(.)A
193 409 :M
-.06(obj := TL.Obj\(name\) .\))A
34 420 :M
-.667(    )A
57 420 :M
-.495(\( )A
68 420 :M
-.439(":" "="                          )A
181 420 :M
(\(. )S
193 420 :M
-.1(IF obj^.kind # vars THEN Err\(4\) END .\))A
34 431 :M
-.601(      )A
68 431 :M
.566 .057(Expression<type> )J
181 431 :M
(\(. )S
193 431 :M
-.078(IF type # obj^.type THEN Err\(2\) END;)A
34 442 :M
-.513(                                          )A
193 442 :M
.006 .001(TC.Emit3\(STO, TL.curLevel - obj^.level, obj^.adr\) .\))J
34 453 :M
-.667(    )A
57 453 :M
-.51(|                                  )A
181 453 :M
(\(. )S
193 453 :M
-.089(IF obj^.kind # procs THEN Err\(5\) END;)A
34 464 :M
-.513(                                          )A
193 464 :M
.005 .001(TC.Emit3\(CALL, TL.curLevel - obj^.level, obj^.adr\) .\))J
34 475 :M
-.667(    )A
57 475 :M
<29>S
45 486 :M
-.838(| )A
57 486 :M
.143 .014("IF" Expression<type> )J
181 486 :M
(\(. )S
193 486 :M
-.094(IF type # bool THEN Err\(3\) END; fix := TC.pc + 1; TC.Emit2\(FJMP, 0\) .\))A
34 497 :M
-1.001(  )A
45 497 :M
-1.001(  )A
57 497 :M
-.108("THEN" StatSeq)A
34 508 :M
-1.001(  )A
45 508 :M
-1.001(  )A
57 508 :M
([ )S
68 508 :M
-.435("ELSE"                           )A
181 508 :M
(\(. )S
193 508 :M
.015 .001(fix2 := TC.pc + 1; TC.Emit2\(JMP, 0\); TC.Fixup\(fix\); fix := fix2 .\))J
34 519 :M
-.751(   )A
45 519 :M
-.751(   )A
57 519 :M
-1.001(  )A
68 519 :M
.284 .028(StatSeq )J
34 530 :M
-.751(   )A
45 530 :M
( )S
57 530 :M
(])S
34 541 :M
-.751(   )A
45 541 :M
( )S
57 541 :M
-.482("END"                              )A
181 541 :M
(\(. )S
193 541 :M
.208 .021(TC.Fixup\(fix\) .\))J
45 552 :M
-.838(| )A
57 552 :M
-.438("WHILE"                            )A
181 552 :M
(\(. )S
193 552 :M
.148 .015(loopstart := TC.pc .\))J
34 563 :M
-.751(   )A
45 563 :M
( )S
57 563 :M
-.222(Expression<type>                   )A
181 563 :M
(\(. )S
193 563 :M
-.1(IF type # bool THEN Err\(3\) END;  fix := TC.pc + 1; TC.Emit2\(FJMP, 0\) .\))A
34 574 :M
-.667(    )A
57 574 :M
-.135("DO" StatSeq "END")A
181 574 :M
(\(. )S
193 574 :M
.215 .022(TC.Emit2\(JMP, loopstart\); TC.Fixup\(fix\) .\))J
45 585 :M
-.838(| )A
57 585 :M
-.113("READ" Ident<name>)A
181 585 :M
(\(. )S
193 585 :M
-.081(obj := TL.Obj\(name\); IF obj^.type # int THEN Err\(1\) END;)A
34 596 :M
-.513(                                          )A
193 596 :M
-.008(TC.Emit3\(READ, TL.curLevel - obj^.level, obj^.adr\) .\))A
45 607 :M
-.838(| )A
57 607 :M
-.036("WRITE" Expression<type>  )A
181 607 :M
-.117(\(.  IF type # int THEN Err\(1\) END; TC.Emit\(WRITE\) .\))A
45 618 :M
.999(].)A
34 629 :M
.012(\(*-----------------------------------------------------------------------------------------------------------------------------------------------*\))A
34 640 :M
(Expression<VAR type: INTEGER>)S
181 640 :M
-.018(\(. VAR type1, op: INTEGER; .\))A
34 651 :M
-.756(= )A
45 651 :M
.04(SimExpr<type>)A
34 662 :M
-1.001(  )A
45 662 :M
-.042([ RelOp<op> SimExpr<type1>)A
181 662 :M
-.06(\(. IF type # type1 THEN Err\(2\) END; TC.Emit\(op\); type := bool .\))A
34 673 :M
-.667(    )A
45 673 :M
.999(].)A
34 684 :M
.012(\(*-----------------------------------------------------------------------------------------------------------------------------------------------*\))A
endp
%%Page: 28 28
%%BeginPageSetup
initializepage
(Hanspeter M\232ssenb\232ck; page: 28 of 29)setjob
%%EndPageSetup
gS 0 0 538 781 rC
0 0 538 34 rC
34 28 :M
f0_9 sf
(30)S
gR
gS 0 49 538 455 rC
34 57 :M
f0_9 sf
-.144(RelOp<VAR op: INTEGER>)A
34 68 :M
(=)S
45 68 :M
-.49("="                                )A
181 68 :M
(\(. )S
193 68 :M
-.07(op := equ .\))A
34 79 :M
-.838(| )A
45 79 :M
-.49("<"                                )A
181 79 :M
(\(. )S
193 79 :M
.059 .006(op := lss .\))J
34 90 :M
-.838(| )A
45 90 :M
-.49(">"                                )A
181 90 :M
(\(. )S
193 90 :M
.058 .006(op := gtr .\).)J
34 101 :M
.012(\(*-----------------------------------------------------------------------------------------------------------------------------------------------*\))A
34 112 :M
-.061(SimExpr<VAR type: INTEGER>)A
181 112 :M
-.018(\(. VAR type1, op: INTEGER; .\))A
34 123 :M
-.756(= )A
45 123 :M
-.057(Term<type>)A
34 134 :M
-1.001(  )A
45 134 :M
-.093({ AddOp<op> Term<type1>)A
181 134 :M
-.083(\(. IF \(type # int\) OR \(type1 # int\) THEN Err\(1\) END; TC.Emit\(op\) .\))A
34 145 :M
-.667(    )A
45 145 :M
.494(}.)A
34 156 :M
.012(\(*-----------------------------------------------------------------------------------------------------------------------------------------------*\))A
34 167 :M
-.121(AddOp<VAR op: INTEGER>)A
34 178 :M
-.756(= )A
45 178 :M
-.49("+"                                )A
181 178 :M
.225 .022(\(. op:=plus .\))J
34 189 :M
-.613(  | )A
45 189 :M
-.482("-"                                )A
181 189 :M
.213 .021(\(. op:=minus .\).)J
34 200 :M
.012(\(*-----------------------------------------------------------------------------------------------------------------------------------------------*\))A
34 211 :M
-.114(Term<VAR type: INTEGER>)A
181 211 :M
(\(. )S
193 211 :M
-.021(VAR type1, op: INTEGER; .\))A
34 222 :M
-.756(= )A
45 222 :M
.089(Factor<type>)A
34 233 :M
-1.001(  )A
45 233 :M
-.506({ )A
57 233 :M
-.082(MulOp<op> Factor<type1>   )A
181 233 :M
-.083(\(. IF \(type # int\) OR \(type1 # int\) THEN Err\(1\) END; TC.Emit\(op\) .\))A
34 244 :M
-1.001(  )A
45 244 :M
.494(}.)A
34 255 :M
.012(\(*-----------------------------------------------------------------------------------------------------------------------------------------------*\))A
34 266 :M
-.144(MulOp<VAR op: INTEGER>)A
34 277 :M
-.756(= )A
45 277 :M
-.468("*"                                )A
181 277 :M
-.016(\(. op := times .\))A
34 288 :M
-.838(| )A
45 288 :M
-.468("/"                                )A
181 288 :M
.13 .013(\(. op := slash .\).)J
34 299 :M
.012(\(*-----------------------------------------------------------------------------------------------------------------------------------------------*\))A
34 310 :M
-.043(Factor<VAR type: INTEGER>)A
181 310 :M
-.165( \(. )A
193 310 :M
-.03(VAR name: Name; val, n: INTEGER; obj: TL.Object; .\))A
34 321 :M
-.756(= )A
45 321 :M
<28>S
57 321 :M
-.048( Ident<name>)A
181 321 :M
-.165( \(. )A
193 321 :M
.085 .008(obj := TL.Obj\(name\); type := obj^.type;)J
34 332 :M
-.513(                                          )A
193 332 :M
-.119(IF obj^.kind = vars THEN  )A
204 343 :M
.006 .001(TC.Emit3\(LOAD, TL.curLevel - obj^.level, obj^.adr\))J
34 354 :M
-.513(                                          )A
193 354 :M
-.05(ELSE Err\(4\))A
34 365 :M
-.513(                                          )A
193 365 :M
-.199(END .\))A
34 376 :M
-1.001(  )A
45 376 :M
-.838(| )A
57 376 :M
-.482("TRUE"                             )A
181 376 :M
(\(. )S
193 376 :M
-.008(TC.Emit2\(LIT, 1\); type := bool .\))A
34 387 :M
-1.001(  )A
45 387 :M
-.838(| )A
57 387 :M
-.439("FALSE"                            )A
181 387 :M
(\(. )S
193 387 :M
-.008(TC.Emit2\(LIT, 0\); type := bool .\))A
34 398 :M
-1.001(  )A
45 398 :M
-.838(| )A
57 398 :M
-.432(number                        )A
181 398 :M
.505(\(.)A
193 398 :M
.329 .033(TasteS.GetName\(TasteS.pos, TasteS.len, name\); )J
193 409 :M
.022 .002(StringToVal\(name, n\);  TC.Emit2\(LIT, n\); type:=int .\))J
34 420 :M
-1.001(  )A
45 420 :M
-.838(| )A
57 420 :M
-.277("-" Factor<type>                   )A
181 420 :M
.505(\(.)A
193 420 :M
-.073(IF type # int THEN Err\(1\); type := int END; TC.Emit\(NEG\) .\))A
34 431 :M
-1.001(  )A
45 431 :M
.505(\).)A
34 442 :M
.012(\(*-----------------------------------------------------------------------------------------------------------------------------------------------*\))A
34 453 :M
-.143(Ident <VAR name: Name> =)A
45 464 :M
.123(ident)A
181 464 :M
.505(\(.)A
193 464 :M
.386 .039(TasteS.GetName\(TasteS.pos, TasteS.len, name\) .\).)J
34 486 :M
-.056(END Taste.)A
endp
%%Page: 29 29
%%BeginPageSetup
initializepage
(Hanspeter M\232ssenb\232ck; page: 29 of 29)setjob
%%EndPageSetup
gS 0 0 538 781 rC
0 0 538 34 rC
495 28 :M
f0_9 sf
(31)S
gR
gS 0 49 538 561 rC
34 59 :M
f1_10 sf
1.011(References)A
34 87 :M
f0_10 sf
.423([Ben88])A
85 87 :M
.179 .018(J.Bentley: More Programming Pearls. Addison-Wesley 1988)J
34 115 :M
.237([DoPi90])A
85 115 :M
.132 .013(H.Dobler, K.Pirklbauer: Coco-2 \320 A New Compiler-Compiler. Technical Report TR 90/1, Institut)J
85 129 :M
-.072(f\237r Informatik, Universit\212t Linz)A
34 157 :M
-.224([GaGi84] )A
85 157 :M
.348 .035(H.Ganzinger, R.Giegerich: Attribute Coupled Grammars. SIGPLAN Notices 19 \(1984\), 6, 157-)J
85 171 :M
.661(170)A
34 199 :M
-.017([Gro88] )A
85 199 :M
.951 .095(J.Grosch: Generators for High-Speed Front-Ends. Lecture Notes in Computer Science 371,)J
85 213 :M
.438 .044(Springer Verlag, 1988)J
34 241 :M
.323 .032([KHZ82] )J
85 241 :M
.953 .095(U.Kastens, B.Hutt, E.Zimmermann: GAG: A Practical Compiler Generator. Lecture Notes in)J
85 255 :M
.381 .038(Computer Science 141, Springer Verlag, 1982)J
34 283 :M
1.039 .104([John75] )J
85 283 :M
.437 .044(S.C.Johnson: YACC \320 Yet another Compiler-Compiler. Tech.Report No 32, Bell Laboratories,)J
85 297 :M
.671 .067(July 1975)J
34 325 :M
.35 .035([Knu68]  )J
85 325 :M
.915 .092(D.E.Knuth: Semantics of Context-Free Languages. Mathematical Systems Theory 2 \(1968\),)J
85 339 :M
.386(127-145)A
34 367 :M
.205([M\232ss86])A
85 367 :M
1.253 .125(H.M\232ssenb\232ck: Compilererzeugende Systeme f\237r Mikrocomputer. Ph.D. thesis, Universit\212t)J
85 381 :M
.984 .098(Linz, 1986)J
34 409 :M
-.154([R\212i83]  )A
85 409 :M
.5 .05(K.-J. R\212ih\212, et al.: Revised Report on the Compiler Writing System HLP78. Report A-1983-1,)J
85 423 :M
.028 .003(Department of Computer Science, University of Helsinki)J
34 451 :M
.237([ReM\23289])A
85 451 :M
.118 .012(P.Rechenberg, H.M\232ssenb\232ck: A Compiler Generator for Microcomputers. Prentice Hall 1989)J
34 479 :M
.425([Senn89])A
85 479 :M
(R.Sennhauser: \206bersetzung attributierter Grammatiken. Diploma thesis, ETH Zurich, 1989)S
34 507 :M
.096([Waite86])A
85 507 :M
-.042(W.M.Waite: The Cost of Lexical Analysis. Software \320 Practice and Experience 16 \(1986\), 5, )A
85 521 :M
.386(473-488)A
34 549 :M
.125([Wirth76])A
85 549 :M
-.048(N.Wirth: Algorithms + Data Structures = Programs. Prentice-Hall, 1976)A
34 577 :M
.125([Wirth86])A
85 577 :M
.491 .049(N.Wirth: Compilerbau. 4th edition. Teubner Studienb\237cher, 1986)J
34 605 :M
.125([Wirth89])A
85 605 :M
.176 .018(N.Wirth: The Programming Language Oberon. Report 111, ETH Zurich, September 1989)J
endp
%%Trailer
end
%%EOF

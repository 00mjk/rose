%{
#include <stdio.h>
#include <string.h>

#include "crsh.hpp"

void yyerror(const char *str)
{
  fprintf(stderr,"error: %s\n",str);
}

int yywrap()
{
  return 1;
}

int yylex();

%}

%error-verbose

%union {
  int                 m_num;
  char*               m_str;
  Crsh::EnvValue*     m_env;
  Environment*        m_environment;
  std::string*        m_arg;
  Arguments*          m_arguments;
  InvocationDesc*     m_invoke;
}

%token DBCONNECT
%token DBCREATE
%token DBCLOSE
%token EQUAL
%token EXIT
%token EXPORT
%token LBLK
%token NOTE
%token RBLK
%token RUN
%token QUAL
%token <m_str> QUOTSTR
%token SHELL
%token SPECIMEN
%token <m_num> NUM
%token <m_str> SQLLITE
%token <m_str> STRING
%token VAR

%type <m_num>         num num_opt
%type <m_str>         filename ident string specimen testsuite_opt
%type <m_str>         simple_string quoted_string annotation_opt
%type <m_env>         export
%type <m_environment> environ_opt
%type <m_arg>         argument
%type <m_arguments>   arguments_opt
%type <m_invoke>      test_invoke

%start crush

%%
num              : NUM                          { $$ = $1; }
                 ;

filename         : SQLLITE                      { $$ = $1; }
                 ;

ident            : STRING                       { $$ = $1; }
                 ;

simple_string    : STRING                       { $$ = $1; }
                 ;

quoted_string    : QUOTSTR                      { $$ = crsh().unquoteString($1); }
                 ;

string           : simple_string                { $$ = $1; }
                 | quoted_string                { $$ = $1; }
                 ;

export           : EXPORT ident EQUAL string    { $$ = crsh().envvar($2, $4); }

environ_opt      : /* empty */                  { $$ = crsh().environment();       }
                 | environ_opt export           { $$ = crsh().environment($1, $2); }
                 ;

argument         : string                       { $$ = crsh().arg($1); }
                 ;

arguments_opt    : /* empty */                  { $$ = crsh().args();       }
                 | arguments_opt argument       { $$ = crsh().args($1, $2); }
                 ;

specimen         : string                       { $$ = $1; }
                 ;

annotation_opt   : /* empty */                  { $$ = NULL; }
                 | NOTE string                  { $$ = $2;      }
                 ;

test_invoke      : annotation_opt
                   specimen arguments_opt       { $$ = crsh().invoke($1, $2, $3); }
                 ;

test_cmd         : ident QUAL ident
                   annotation_opt
                   LBLK
                     environ_opt
                     test_invoke
                   RBLK                         { crsh().test($1, $3, $4, $6, $7); }
                 ;

testsuite_opt    : /* empty */                  { $$ = NULL; }
                 | ident QUAL                   { $$ = $1; }
                 ;

num_opt          : /* empty */                  { $$ = -1; }
                 | num                          { $$ = $1; }
                 ;

exectest_cmd     : testsuite_opt
                   RUN num_opt annotation_opt   { crsh().runTest($1, $3, $4); }
                 ;

shell_cmd        : SHELL test_invoke            { crsh().execute($2); }

dbconnect_cmd    : DBCONNECT
                     filename annotation_opt    { crsh().connectdb($2, $3); }
                 ;

dbcreate_cmd     : DBCREATE filename            { crsh().createdb($2); }
                 | DBCREATE filename QUAL ident { crsh().createdb($2, $4); }
                 ;

dbclose_cmd      : DBCLOSE                      { crsh().closedb(); }
                 ;

exit_cmd         : EXIT
                 ;

cmd              : test_cmd
                 | exectest_cmd
                 | shell_cmd
                 | dbconnect_cmd
                 | dbcreate_cmd
                 | dbclose_cmd
                 | exit_cmd
                 ;

cmds_opt         : /* empty */
                 | cmd cmds_opt
                 ;

crush            : cmds_opt
                 ;

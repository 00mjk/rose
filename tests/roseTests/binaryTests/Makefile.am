include $(top_srcdir)/config/Makefile.for.ROSE.includes.and.libs

SUBDIRS = SemanticVerification libraryIdentification_tests Dwarf_tests Pin_tests

EXTRA_DIST = runTest.C arm-ctrlaltdel.ans runExecFormatsTest testShiftResizeSection.sh test_findConstants.ans \
		test_disassemble.ans testSampleBinary.sh testSampleBinaries.conf testFunctionDetection.pl \
		functionBoundaries_1.ans functionBoundaries_2.ans functionBoundaries_3.ans test_findConstantsABI.ans

BINARY_SAMPLES = $(top_srcdir)/binaries/samples

if USE_BINARY_ANALYSIS_TESTS

# To keep compile commands tidy, please ONLY put required include flags here.
INCLUDES = $(ROSE_INCLUDES) -I$(top_srcdir)/src/midend/binaryAnalyses/libraryIdentification


###############################################################################################################################
# The executables...
###############################################################################################################################

# Each executable will have a test_*.result target for testing and a demo_* target for interactive demo. The former is the
# name of a file that is created when the test is successful (unsuccessful results are usually saved in *.result.tmp), the later
# is a phony target.
noinst_PROGRAMS = execFormatsTest testBinCFG testBinCG testElfStrtab testElfByteOrder testElfWordSize testElfSchulz \
		testElfConstruct testPeConstruct shiftResizeSection findConstants disassemble testEtherInsns \
		expandCoreDump functionBoundaries findConstantsABI rot13

# Parses an executable to produce a dump file (*.dump), an assembly file (rose_*.s), and a new executable created by unparsing
# the AST (*.new). The *.new file is typically identical to the original executable.
execFormatsTest_SOURCES = execFormatsTest.C
execFormatsTest_LDADD = $(ROSE_LIBS_WITH_PATH) $(ROSE_SEPARATE_LIBS) $(RT_LIBS)

#Test the binary control flow graph that uses the semantic representation to perform an accurate analysis
testBinCFG_SOURCES = testBinCFG.C
testBinCFG_LDADD   = $(ROSE_LIBS_WITH_PATH) $(ROSE_SEPARATE_LIBS) $(RT_LIBS)

#Test the binary call graph that uses the semantic representation to perform an accurate analysis
testBinCG_SOURCES = testBinCG.C
testBinCG_LDADD   = $(ROSE_LIBS_WITH_PATH) $(ROSE_SEPARATE_LIBS) $(RT_LIBS)


# Tests ELF string table reallocation functions by changing some strings.  At first glance this would appear to be something
# quite easy to do, but it turns out to involve lots of details.
testElfStrtab_SOURCES = testElfStrtab.C
testElfStrtab_LDADD   = $(ROSE_LIBS_WITH_PATH) $(ROSE_SEPARATE_LIBS) $(RT_LIBS)

# Reads in an ELF executable and changes the byte order from little-endian to big-endian or vice versa and writes out a new
# file. Note that the byte order change affects the ELF file format but not the executable described by that format.
testElfByteOrder_SOURCES = testElfByteOrder.C
testElfByteOrder_LDADD   = $(ROSE_LIBS_WITH_PATH) $(ROSE_SEPARATE_LIBS) $(RT_LIBS)

# Reads in an ELF executable and changes the word size from eight to four bytes or vice versa and writes out a new file. Note
# that the word size change affects the ELF file format but not the executable described by that format.
testElfWordSize_SOURCES = testElfWordSize.C
testElfWordSize_LDADD   = $(ROSE_LIBS_WITH_PATH) $(ROSE_SEPARATE_LIBS) $(RT_LIBS)

# Demonstrates how to change names of dynamically-linked functions. This example reads an ELF executable dynamically linked to
# the MPI library and changes all calls to PMPI_* functions with calls to XMPI_* functions. See the top of the source file
# for more details.
testElfSchulz_SOURCES = testElfSchulz.C
testElfSchulz_LDADD   = $(ROSE_LIBS_WITH_PATH) $(ROSE_SEPARATE_LIBS) $(RT_LIBS)

# Demonstrates how to build an ELF executable from scratch. Lots of comments in the source code. The resulting file is executable
# on an x86 Linux using syscall 1 to exit with a particular value.
testElfConstruct_SOURCES = testElfConstruct.C
testElfConstruct_LDADD   = $(ROSE_LIBS_WITH_PATH) $(ROSE_SEPARATE_LIBS) $(RT_LIBS)

# Demonstrates how to build a PE executable from scratch. This demo is not as complete at the ELF version, but does show how to
# create a file that contains multiple format headers (a DOS header and a PE header).
testPeConstruct_SOURCES = testPeConstruct.C
testPeConstruct_LDADD   = $(ROSE_LIBS_WITH_PATH) $(ROSE_SEPARATE_LIBS) $(RT_LIBS)

# Changes the size and/or location of a section in an executable file.
shiftResizeSection_SOURCES = shiftResizeSection.C
shiftResizeSection_LDADD   = $(ROSE_LIBS_WITH_PATH) $(ROSE_SEPARATE_LIBS) $(RT_LIBS)

# Finds constant values and propagates them across instructions
findConstants_SOURCES = findConstants.C
findConstants_LDADD = $(ROSE_LIBS_WITH_PATH) $(ROSE_SEPARATE_LIBS) $(RT_LIBS)

# Finds constant values and propagates them across instructions using an ABI
findConstantsABI_SOURCES = findConstantsABI.C
findConstantsABI_LDADD = $(ROSE_LIBS_WITH_PATH) $(ROSE_SEPARATE_LIBS) $(RT_LIBS)

# Disassembles an executable according to various command-line switches.
disassemble_SOURCES = disassemble.C
disassemble_LDADD = $(ROSE_LIBS_WITH_PATH) $(ROSE_SEPARATE_LIBS) $(RT_LIBS)

testEtherInsns_SOURCES = testEtherInsns.C
testEtherInsns_LDADD = $(ROSE_LIBS_WITH_PATH) $(ROSE_SEPARATE_LIBS) $(RT_LIBS)

# Program to show function boundary information for a binary executable
functionBoundaries_SOURCES=functionBoundaries.C
functionBoundaries_LDADD=$(ROSE_LIBS_WITH_PATH) $(ROSE_SEPARATE_LIBS) $(RT_LIBS)

# Program to add read-only data to ELF core dumps.
expandCoreDump_SOURCES=expandCoreDump.C
expandCoreDump_LDADD=$(ROSE_LIBS_WITH_PATH) $(ROSE_SEPARATE_LIBS) $(RT_LIBS)

# Program that encodes/decodes data similar to ROT-13 but acceping binary data
rot13_SOURCES=rot13.C

###############################################################################################################################
# DEMOS
#
# These demonstrate various aspects of ROSE's binary executable abilities. They are meant to be run sequentially (regardless
# of make's "-j" switch) and produce output for human consumption.
###############################################################################################################################
DEMO_PHONY_TARGETS=$(patsubst %,demo_%,$(noinst_PROGRAMS))

demos: demos-local

demos-local: $(DEMO_PHONY_TARGETS)

demo_execFormatsTest: execFormatsTest
	@echo; echo; echo "Demo for $<"; echo
	./execFormatsTest $(BINARY_SAMPLES)/buffer2.bin
	@echo "See file buffer2.bin.dump for information regarding the executable format"
	@echo "See file rose-buffer2.bin.s for disassembly of instructions"

demo_testElfStrtab: testElfStrtab demo_execFormatsTest
	@echo; echo; echo "Demo for $<"; echo
	./testElfStrtab $(BINARY_SAMPLES)/arm-poweroff

demo_testElfByteOrder: testElfByteOrder demo_testElfStrtab
	@echo; echo; echo "Demo for $<"; echo
	./testElfByteOrder $(BINARY_SAMPLES)/arm-poweroff

demo_testElfWordSize: testElfWordSize demo_testElfByteOrder
	@echo; echo; echo "Demo for $<"; echo
	./testElfWordSize $(BINARY_SAMPLES)/arm-poweroff

demo_testElfSchulz: testElfSchulz demo_testElfWordSize
	@echo; echo; echo "Demo for $<"; echo
	./testElfSchulz $(BINARY_SAMPLES)/schulz-sample1.so
	./testElfSchulz $(BINARY_SAMPLES)/schulz-sample2.so

demo_testElfConstruct: testElfConstruct demo_testElfSchulz
	@echo; echo; echo "Demo for $<"; echo
	./testElfConstruct

demo_testPeConstruct: testPeConstruct demo_testElfConstruct
	@echo; echo; echo "Demo for $<"; echo
	./testPeConstruct

demo_shiftResizeSection: shiftResizeSection demo_testPeConstruct
	@echo; echo; echo "Demo for $<"; echo
	$(srcdir)/testShiftResizeSection.sh $(BINARY_SAMPLES)/arm-ctrlaltdel >arm-ctrlaltdel.ans

demo_findConstants: findConstants demo_shiftResizeSection
	@echo; echo; echo "Demo for $<"; echo
	./findConstants $(BINARY_SAMPLES)/i686-test1.O3.bin

demo_findConstantsABI: findConstantsABI demo_findConstants
	@echo; echo; echo "Demo for $<"; echo
	./findConstantsABI $(BINARY_SAMPLES)/i686-test1.O3.bin

demo_disassemble: disassemble demo_findConstantsABI
	@echo; echo; echo "Demo for $<"; echo
	./disassemble -rose:disassembler_search following,immediate,words,allbytes,unused,nonexe,deadend,unknown $(BINARY_SAMPLES)/i686-test1.O0.bin
	@echo "output has been dumped to i686-test1.O0.bin.dump"

demo_testBinCFG: testBinCFG demo_disassemble
	: no demo yet for testBinCFG

demo_expandCoreDump: expandCoreDump demo_testBinCFG
	: no demo yet for expandCoreDump

demo_functionBoundaries: functionBoundaries demo_exapndCoreDump
	@echo; echo; echo "Demo for $<";
	@echo "The functionBoundaries tool prints information about what binary functions were detected and why."
	./functionBoundaries $(BINARY_SAMPLES)/i686-test1.O3.bin

demo_rot13: rot13
	: no demo yet for rot13

###############################################################################################################################
# TESTS
#
# These are pretty much the same as the demos except they compare the new output with expected output and fail if there
# are any differences.
#
# Each passing test creates a *.result file so that a subsequent "make" doesn't need to rerun the test.
#
#------------------------------------------------------------------------------------------------------------------------------
# -- NOTICE -- NOTICE -- NOTICE -- NOTICE -- NOTICE -- NOTICE -- NOTICE -- NOTICE -- NOTICE -- NOTICE -- NOTICE -- NOTICE --
#
# SOME OF THE TARGETS DEPEND ON OTHER TESTS BECAUSE ROSE SHOULD NOT EXECUTE CONCURRENTLY IN THE SAME WORKING DIRECTORY FOR
# SPECIMEN BINARIES HAVING THE SAME NAMES DUE TO ROSE CREATING FILES IN THE CWD BASED ON THE BASE NAME OF THE SPECIMEN.
# ------------------------------------------------------------------------------------------------------------------------------
#
###############################################################################################################################

# Static tests start here and are individually defined below.
STATIC_TEST_TARGETS = $(patsubst %,test_%.result,$(noinst_PROGRAMS)) test_assembler.result
test_static.result: $(STATIC_TEST_TARGETS)
	@touch $@

# Dynamicly-generated tests start here and their definitions are inserted below by the "build" script.  We make the
# dynamic tests depend on the static test because we're not sure what output files will be generated and we don't want
# the output of dynamic tests causing havoc for the static tests.
test_dynamic.result: test_static.result
	@$(MAKE) test_sample_binaries.result
	@touch $@

test_execFormatsTest.result: execFormatsTest
	@echo "  TESTING $@ (not currently tested)"
	@touch $@

test_testBinCFG.result: testBinCFG
	@echo "  TESTING $@"
	@if $(VALGRIND) ./testBinCFG $(BINARY_SAMPLES)/libm-2.3.6.so >$@.tmp 2>&1; then mv $@.tmp $@; \
	else sed 's/^/$@> /' < $@.tmp; exit 1; fi

test_testBinCG.result: testBinCG test_testBinCFG.result
	@echo "  TESTING $@"
	@if $(VALGRIND) ./testBinCG $(BINARY_SAMPLES)/libm-2.3.6.so >$@.tmp 2>&1; then mv $@.tmp $@; \
	else sed 's/^/$@> /' < $@.tmp; exit 1; fi

test_testElfStrtab.result: testElfStrtab
	@echo "  TESTING $@"
	@if $(VALGRIND) ./testElfStrtab $(BINARY_SAMPLES)/arm-poweroff >$@.tmp 2>&1; then mv $@.tmp $@; \
	else sed 's/^/$@> /' < $@.tmp; exit 1; fi

# cannot run in parallel with testElfStrtab
test_testElfByteOrder.result: testElfByteOrder test_testElfStrtab.result
	@echo "  TESTING $@"
	@$(VALGRIND) ./testElfByteOrder $(BINARY_SAMPLES)/arm-poweroff >$@.tmp 2>&1; \
	 [ $$? -eq 0 ] && $(VALGRIND) ./execFormatsTest ./arm-poweroff.new >>$@.tmp 2>&1; \
	 [ $$? -eq 0 ] && diff -u ./arm-poweroff.new{,.new} >>$@.tmp 2>&1; \
	 if [ $$? -eq 0 ]; then mv $@.tmp $@; \
	 else sed 's/^/$@> /' < $@.tmp; exit 1; fi

# cannot run in parallel with testElfStrtab or testElfByteOrder
test_testElfWordSize.result: testElfWordSize test_testElfStrtab.result test_testElfByteOrder.result
	@echo "  TESTING $@"
	@$(VALGRIND) ./testElfWordSize -rose:read_executable_file_format_only $(BINARY_SAMPLES)/arm-poweroff >$@.tmp 2>&1; \
	 [ $$? -eq 0 ] && $(VALGRIND) ./execFormatsTest -rose:read_executable_file_format_only ./arm-poweroff.new >>$@.tmp 2>&1; \
	 [ $$? -eq 0 ] && diff -u ./arm-poweroff.new{,.new} >>$@.tmp 2>&1; \
	 if [ $$? -eq 0 ]; then mv $@.tmp $@; \
	 else sed 's/^/$@> /' < $@.tmp; exit 1; fi

test_testElfSchulz.result: test_testElfSchulz-1.result test_testElfSchulz-2.result
	@echo "  TESTING $@ (not currently tested)"
	@touch $@

test_testElfSchulz-1.result: testElfSchulz
	@echo "  TESTING $@"
	@$(VALGRIND) ./testElfSchulz $(BINARY_SAMPLES)/schulz-sample1.so >$@.tmp 2>&1; \
	 [ $$? -eq 0 ] && $(VALGRIND) ./execFormatsTest ./schulz-sample1.so.new >>$@.tmp 2>&1; \
	 [ $$? -eq 0 ] && $(VALGRIND) ./execFormatsTest $(BINARY_SAMPLES)/schulz-sample1-p.so >>$@.tmp 2>&1; \
	 [ $$? -eq 0 ] && diff -u schulz-sample1{-p.so,.so.new}.dump >>$@.tmp 2>&1; \
	 [ $$? -eq 0 ] && diff $(BINARY_SAMPLES)/schulz-sample1-p.so schulz-sample1.so.new >>$@.tmp 2>&1; \
	 if [ $$? -eq 0 ]; then mv $@.tmp $@; \
	 else sed 's/^/$@> /' <$@.tmp; exit 1; fi

test_testElfSchulz-2.result: testElfSchulz
	@echo "  TESTING $@"
	@$(VALGRIND) ./testElfSchulz $(BINARY_SAMPLES)/schulz-sample2.so >$@.tmp 2>&1; \
	 [ $$? -eq 0 ] && $(VALGRIND) ./execFormatsTest ./schulz-sample2.so.new >>$@.tmp 2>&1; \
	 [ $$? -eq 0 ] && $(VALGRIND) ./execFormatsTest $(BINARY_SAMPLES)/schulz-sample2-p.so >>$@.tmp 2>&1; \
	 [ $$? -eq 0 ] && diff -u schulz-sample2{-p.so,.so.new}.dump >>$@.tmp 2>&1; \
	 [ $$? -eq 0 ] && diff $(BINARY_SAMPLES)/schulz-sample2-p.so schulz-sample2.so.new >>$@.tmp 2>&1; \
	 if [ $$? -eq 0 ]; then mv $@.tmp $@; \
	 else sed 's/^/$@> /' <$@.tmp; exit 1; fi

test_so_file: test_testBinCFG.result test_testBinCG.result
	@echo "  TESTING $@"
	@if $(VALGRIND) ./execFormatsTest $(BINARY_SAMPLES)/libm-2.3.6.so >$@.tmp 2>&1; \
	 then mv $@.tmp $@; \
	 else sed 's/^/$@> /' <$@.tmp; exit 1; fi

test_testElfConstruct.result: testElfConstruct
	@echo "  TESTING $@"
	@if $(VALGRIND) ./testElfConstruct >$@.tmp 2>&1; \
	 then mv $@.tmp $@; \
	 else sed 's/^/$@> /' <$@.tmp; exit 1; fi

test_testPeConstruct.result: testPeConstruct
	@echo "  TESTING $@"
	@if $(VALGRIND) ./testPeConstruct >$@.tmp 2>&1; \
	 then mv $@.tmp $@; \
	 else sed 's/^/$@> /' <$@.tmp; exit 1; fi

test_shiftResizeSection.result: shiftResizeSection
	@echo "  TESTING $@"
	@$(srcdir)/testShiftResizeSection.sh $(BINARY_SAMPLES)/arm-ctrlaltdel >arm-ctrlaltdel.ans 2>$@.tmp; \
	 [ $$? -eq 0 ] && diff -u {$(srcdir),.}/arm-ctrlaltdel.ans >>$@.tmp 2>&1; \
	 if [ $$? -eq 0 ]; then mv $@.tmp $@; \
	 else sed 's/^/$@> /' <$@.tmp; exit 1; fi

# This test is *very* sensitive to changes to the Disassembler and Partitioner classes because they and this test all use
# the findConstants instruction semantics. If the Disassembler or Partitioner is even slightly changed, it could make a
# different number of calls to the instruction semantics, which changes the sequence number used to generate constant
# names. Therefore, when comparing the test output with the answer, we will change all constant names from "v[0-9]+" to
# "vXXX".  Any problems in the semantic analysis should still be caught since they would presumably affect lots of
# other output too.  The test is still sensitive to minor formatting changes in unparseInstruction().
FIND_CONSTANTS_DIFF=diff -u <(sed "s/v[0-9][0-9]*/vXXX/g" $(srcdir)/test_findConstants.ans) \
                            <(sed "s/v[0-9][0-9]*/vXXX/g" test_findConstants.ans)
test_findConstants.result: findConstants
	@echo "  TESTING $@"
	@$(VALGRIND) ./findConstants $(BINARY_SAMPLES)/i686-test1.O3.bin >test_findConstants.ans 2>$@.tmp;
	@bash -c 'if $(FIND_CONSTANTS_DIFF) >/dev/null; \
          then \
	      mv $@.tmp $@; \
	  else \
              echo "*** $@: Result (test_findConstants.ans) differs from expected answer in $(srcdir)"; \
	      echo "    (You should compare the files manually to verify the result, then copy it to"; \
	      echo "     $(srcdir) if it looks OK.) First 100 lines of the difference are:"; \
	      $(FIND_CONSTANTS_DIFF) |head -n100 |sed "s/^/findConstants> /"; \
	      exit 1 ; \
	fi'

test_findConstantsABI.result: findConstantsABI
	@echo "  TESTING $@"
	@$(VALGRIND) ./findConstantsABI $(BINARY_SAMPLES)/i686-test1.O3.bin >test_findConstantsABI.ans 2>$@.tmp; \
	 [ $$? -eq 0 ] && diff -u {$(srcdir),.}/test_findConstantsABI.ans >>$@.tmp 2>&1; \
	 if [ $$? -eq 0 ]; then mv $@.tmp $@; \
	 else sed 's/^/$@> /' <$@.tmp; exit 1; fi

test_disassemble.result: disassemble
	@echo "  TESTING $@ (commented out by DQ on 10/24/09)"
#	@$(VALGRIND) ./disassemble --quiet -rose:disassembler_search following,immediate,words,-allbytes,unused,nonexe,deadend,-unknown $(BINARY_SAMPLES)/i686-test1.O0.bin >$@.tmp 2>&1; \
#	 [ $$? -eq 0 ] && mv i686-test1.O0.bin.dump test_disassemble.ans; \
#	 [ $$? -eq 0 ] && diff -u {$(srcdir),.}/test_disassemble.ans >>$@.tmp 2>&1; \
#	 if [ $$? -eq 0 ]; then mv $@.tmp $@; \
#	 else sed 's/^/$@> /' <$@.tmp; exit 1; fi

# disassemble will exit non-zero if the assembly doesn't result in an encoding identical to the original
# We're using the buffer2.bin from projects/BinQ for now because it's 64-bit; the one in our own srcdir is 32-bit and
# the assembler isn't completely working yet for 32-bit. [RPM 2009-07-21]
test_assembler.result: disassemble
	@echo "  TESTING $@"
	@$(VALGRIND) ./disassemble --quiet --reassemble --show-bad $(top_srcdir)/projects/BinQ/buffer2.bin >$@.tmp 2>&1; \
	 if [ $$? -eq 0 ]; then mv $@.tmp $@; \
	 else sed 's/^/$@> /' <$@.tmp; exit 1; fi

test_testEtherInsns.result: testEtherInsns
	@echo "  TESTING $@ (cannot be run automatically; requires human interaction)"
	@touch $@

test_expandCoreDump.result: expandCoreDump
	@echo "  TESTING $@ (not currently tested)"
	@touch $@

test_rot13.result: rot13
	@echo "  TESTING $@"
	@./rot13 --encode <$(BINARY_SAMPLES)/i686-test1.O0.bin |./rot13 --decode >test_rot13.ans 2>$@.tmp; \
	 [ $$? -eq 0 ] && diff $(BINARY_SAMPLES)/i686-test1.O0.bin test_rot13.ans >>$@.tmp 2>&1; \
	 if [ $$? -eq 0 ]; then mv $@.tmp $@; \
	 else sed 's/^/$@> /' <$@.tmp; exit 1; fi

# Tests for detecting the locations of functions, written this way for parallelism.
test_functionBoundaries_1.result: functionBoundaries $(BINARY_SAMPLES)/i686-test1.O0.bin test_disassemble.result
	@echo "  TESTING $@"
	@./functionBoundaries $(BINARY_SAMPLES)/i686-test1.O0.bin >functionBoundaries_1.ans 2>$@.tmp; \
	 [ $$? -eq 0 ] && diff -u {$(srcdir),.}/functionBoundaries_1.ans >>$@.tmp 2>&1; \
	 if [ $$? -eq 0 ]; then mv $@.tmp $@; \
	 else sed 's/^/$@> /' <$@.tmp; exit 1; fi
test_functionBoundaries_2.result: functionBoundaries $(BINARY_SAMPLES)/i686-test1.O3.bin test_findConstants.result test_findConstantsABI.result
	@echo "  TESTING $@"
	@./functionBoundaries $(BINARY_SAMPLES)/i686-test1.O3.bin >functionBoundaries_2.ans 2>$@.tmp; \
	 [ $$? -eq 0 ] && diff -u {$(srcdir),.}/functionBoundaries_2.ans >>$@.tmp 2>&1; \
	 if [ $$? -eq 0 ]; then mv $@.tmp $@; \
	 else sed 's/^/$@> /' <$@.tmp; exit 1; fi
test_functionBoundaries_3.result: functionBoundaries $(BINARY_SAMPLES)/i686-test1.O3-stripped.bin
	@echo "  TESTING $@"
	@./functionBoundaries $(BINARY_SAMPLES)/i686-test1.O3-stripped.bin >functionBoundaries_3.ans 2>$@.tmp; \
	 [ $$? -eq 0 ] && diff -u {$(srcdir),.}/functionBoundaries_3.ans >>$@.tmp 2>&1; \
	 if [ $$? -eq 0 ]; then mv $@.tmp $@; \
	 else sed 's/^/$@> /' <$@.tmp; exit 1; fi
test_functionBoundaries.result: test_functionBoundaries_1.result test_functionBoundaries_2.result test_functionBoundaries_3.result
	@touch $@

# The rules in this section of the makefile are generated by the "build" script based on the selection of binary samples
# (usually from the binaries/samples directory) available at that time.  We do it this way for a number of reasons:
#
#  1. Some of the samples have licenses that restrict their distribution.
#  2. Some developers work with malicious software samples that we don't wish to distribute
#  3. ROSE generates file names in the current working directory based on basenames of samples. If the sample directories
#     contain files with duplicate basenames then the tests will fail if those to files happen to be tested in parallel. These
#     dependencies must be represented in the makefile rules.
#
# See scripts/sample_binary_rules.pl for more documentation.

# All sample binary tests have these additional dependencies
SAMPLE_TEST_DEPS = execFormatsTest disassemble

INSERT_SAMPLE_RULES_HERE:



###############################################################################################################################
# Miscellaneous....
###############################################################################################################################

# Don't delete things indiscriminately--sometimes developers have other related files that should not be touched!
MOSTLYCLEANFILES = \
	$(STATIC_TEST_TARGETS) $(addsuffix .tmp, $(STATIC_TEST_TARGETS)) \
	test_testElfSchulz-{1,2}.result test_{static,dynamic}.result \
	a.out arm-ctrlaltdel.ans arm-ctrlaltdel.dump-{1,2,3} arm-ctrlaltdel.new.new \
	arm-poweroff.{new.dump,new.new} rose_arm-ctrlaltdel.new.s rose_arm-poweroff.new.s \
	rose_schulz-sample{1,2}.so.new.s schulz-sample{1,2}.so.{new.dump,new.new} test_findConstants.ans \
	test_disassemble.ans test_rot13.ans\
	test_functionBoundaries_{1,2,3}.result functionBoundaries_{1,2,3}.ans test_findConstantsABI.ans

mostlyclean-local: mostlyclean-binarysamples


###############################################################################################################################
# The older part of this makefile...
###############################################################################################################################

## Don't use the repository in ../src
#CXX_TEMPLATE_REPOSITORY_PATH = .

if ROSE_USE_SQLITE_DATABASE

# This test program does not require the rest of ROSE so it can be handled locally
bin_PROGRAMS  = runTest testLibraryDb

testLibraryDb_SOURCES = testLibraryDb.C
# testCallGraph_LDADD = $(LIBS_WITH_RPATH) $(ROSE_LIBS)
testLibraryDb_LDADD = $(LIBS_WITH_RPATH) $(ROSE_SEPARATE_LIBS) 

test1: testLibraryDb
	./testLibraryDb
	rm test.db
else

bin_PROGRAMS  = runTest
test1:
	: $@ is only for ROSE_USE_SQLITE_DATABASE

endif
runTest_SOURCES = runTest.C

# testCallGraph_LDADD = $(LIBS_WITH_RPATH) $(ROSE_LIBS)
runTest_LDADD = $(LIBS_WITH_RPATH) $(ROSE_SEPARATE_LIBS)

#TESTCODES = buffer2.bin

# Build the list of object files
#TEST_Objects = ${TESTCODES:.C=.o}

ROSE_FLAGS = -g -rose:verbose 0
# ROSE_FLAGS = 

TEST_TRANSLATOR = ./runTest all $(ROSE_FLAGS)
TESTCODE_INCLUDES =

# DQ (7/12/2004): Modified to run with make -j4 options
#$(TEST_Objects): runTest $(TESTCODES) 
#	@echo "Compiling test code using $(TEST_TRANSLATOR) ..."
#	env SRCDIR="$(srcdir)" $(TEST_TRANSLATOR)

CLEANFILES = unparsed.s callgraph.gml output _binary_tree.dot cfg.dot dfg.dot Templates.DB 

# DQ (3/21/2009): These tests don't appear to run under Cygwin.
if ROSE_BUILD_OS_IS_CYGWIN
check-local:
	@echo "*****************************************************************************************"
	@echo "*** ROSE/tests/roseTests/binaryTests: (commented out for Cygwin) ***"
	@echo "*****************************************************************************************"
else

# DQ (4/8/2009): I have removed the requirement to run rule: test_so_file (added by Thomas)
# I have left the rule in place so that we can have it availalbe for testing (but it only 
# works if BinQ is built which is not the default configuration).
# check-local: runTest test1 $(TEST_RESULT_TARGETS) test_so_file
# Caution: runTest generates the same output files as some $(TEST_RESULT_TARGETS) [RPM 2009-07-21]
check-local: runTest test1 test_static.result test_dynamic.result
	@echo "*********************************************************************"
	@echo "*** ROSE/tests/roseTests/binaryTests: passed ***"
	@echo "*********************************************************************"
endif

# Don't delete things indiscriminately!
clean-local:
	rm -rf $(CXX_TEMPLATE_OBJECTS) ii_files ti_files DATABASE DATABASE.dot cfg_x86.dot  cg_x86.dot

distclean-local:
	rm -rf Templates.DB 

else

check-local:
	@echo "**********************************************************************"
	@echo "*** ROSE/tests/roseTests/binaryTests: skipped ***"
	@echo "**********************************************************************"

endif

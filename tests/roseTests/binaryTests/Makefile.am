include $(top_srcdir)/config/Makefile.for.ROSE.includes.and.libs

SUBDIRS = SemanticVerification libraryIdentification_tests Dwarf_tests Pin_tests

EXTRA_DIST = runTest.C arm-ctrlaltdel.ans runExecFormatsTest testShiftResizeSection.sh test_findConstants.ans \
		test_disassemble.ans testSampleBinary.sh testSampleBinaries.conf testFunctionDetection.pl \
		functionBoundaries_1.ans functionBoundaries_2.ans functionBoundaries_3.ans test_findConstantsABI.ans \
		test_disassembleBuffer.ans bincfg.h test_virtualMachineSemantics.ans test_testAssembler.ans \
		test_symbolicSemantics.ans test_yicesSemanticsExe.ans

BINARY_SAMPLES = $(top_srcdir)/binaries/samples

if USE_BINARY_ANALYSIS_TESTS

# To keep compile commands tidy, please ONLY put required include flags here.
INCLUDES = $(ROSE_INCLUDES) -I$(top_srcdir)/src/midend/binaryAnalyses/libraryIdentification


###############################################################################################################################
# The executables...
###############################################################################################################################

# Each executable will have a test_*.result target for testing and a demo_* target for interactive demo. The former is the
# name of a file that is created when the test is successful (unsuccessful results are usually saved in *.result.tmp), the later
# is a phony target.
noinst_PROGRAMS = execFormatsTest testBinCFG testBinCG testElfStrtab testElfByteOrder testElfWordSize testElfSchulz \
		testElfConstruct testPeConstruct shiftResizeSection findConstants disassemble disassembleBuffer testEtherInsns \
		expandCoreDump functionBoundaries findConstantsABI rot13 virtualMachineSemantics testAssembler testAstIO \
		symbolicSemantics yicesSemanticsExe yicesSemanticsLib testRegisters

# Parses an executable to produce a dump file (*.dump), an assembly file (rose_*.s), and a new executable created by unparsing
# the AST (*.new). The *.new file is typically identical to the original executable.
execFormatsTest_SOURCES = execFormatsTest.C
execFormatsTest_LDADD = $(ROSE_LIBS_WITH_PATH) $(ROSE_SEPARATE_LIBS) $(RT_LIBS)

#Test the binary control flow graph that uses the semantic representation to perform an accurate analysis
testBinCFG_SOURCES = testBinCFG.C
testBinCFG_LDADD   = $(ROSE_LIBS_WITH_PATH) $(ROSE_SEPARATE_LIBS) $(RT_LIBS)

#Test the binary call graph that uses the semantic representation to perform an accurate analysis
testBinCG_SOURCES = testBinCG.C
testBinCG_LDADD   = $(ROSE_LIBS_WITH_PATH) $(ROSE_SEPARATE_LIBS) $(RT_LIBS)

# Tests ELF string table reallocation functions by changing some strings.  At first glance this would appear to be something
# quite easy to do, but it turns out to involve lots of details.
testElfStrtab_SOURCES = testElfStrtab.C
testElfStrtab_LDADD   = $(ROSE_LIBS_WITH_PATH) $(ROSE_SEPARATE_LIBS) $(RT_LIBS)

# Reads in an ELF executable and changes the byte order from little-endian to big-endian or vice versa and writes out a new
# file. Note that the byte order change affects the ELF file format but not the executable described by that format.
testElfByteOrder_SOURCES = testElfByteOrder.C
testElfByteOrder_LDADD   = $(ROSE_LIBS_WITH_PATH) $(ROSE_SEPARATE_LIBS) $(RT_LIBS)

# Reads in an ELF executable and changes the word size from eight to four bytes or vice versa and writes out a new file. Note
# that the word size change affects the ELF file format but not the executable described by that format.
testElfWordSize_SOURCES = testElfWordSize.C
testElfWordSize_LDADD   = $(ROSE_LIBS_WITH_PATH) $(ROSE_SEPARATE_LIBS) $(RT_LIBS)

# Demonstrates how to change names of dynamically-linked functions. This example reads an ELF executable dynamically linked to
# the MPI library and changes all calls to PMPI_* functions with calls to XMPI_* functions. See the top of the source file
# for more details.
testElfSchulz_SOURCES = testElfSchulz.C
testElfSchulz_LDADD   = $(ROSE_LIBS_WITH_PATH) $(ROSE_SEPARATE_LIBS) $(RT_LIBS)

# Demonstrates how to build an ELF executable from scratch. Lots of comments in the source code. The resulting file is executable
# on an x86 Linux using syscall 1 to exit with a particular value.
testElfConstruct_SOURCES = testElfConstruct.C
testElfConstruct_LDADD   = $(ROSE_LIBS_WITH_PATH) $(ROSE_SEPARATE_LIBS) $(RT_LIBS)

# Demonstrates how to build a PE executable from scratch. This demo is not as complete at the ELF version, but does show how to
# create a file that contains multiple format headers (a DOS header and a PE header).
testPeConstruct_SOURCES = testPeConstruct.C
testPeConstruct_LDADD   = $(ROSE_LIBS_WITH_PATH) $(ROSE_SEPARATE_LIBS) $(RT_LIBS)

# Changes the size and/or location of a section in an executable file.
shiftResizeSection_SOURCES = shiftResizeSection.C
shiftResizeSection_LDADD   = $(ROSE_LIBS_WITH_PATH) $(ROSE_SEPARATE_LIBS) $(RT_LIBS)

# Finds constant values and propagates them across instructions
findConstants_SOURCES = semantics.C
findConstants_CPPFLAGS = -DPOLICY_SELECTOR=1
findConstants_LDADD = $(ROSE_LIBS_WITH_PATH) $(ROSE_SEPARATE_LIBS) $(RT_LIBS)

# Finds constant values and propagates them across instructions using an ABI
findConstantsABI_SOURCES = semantics.C
findConstantsABI_CPPFLAGS = -DPOLICY_SELECTOR=2
findConstantsABI_LDADD = $(ROSE_LIBS_WITH_PATH) $(ROSE_SEPARATE_LIBS) $(RT_LIBS)

# Uses VirtualMachineSemantics semantic analysis policy
virtualMachineSemantics_SOURCES = semantics.C
virtualMachineSemantics_CPPFLAGS = -DPOLICY_SELECTOR=3
virtualMachineSemantics_LDADD = $(ROSE_LIBS_WITH_PATH) $(ROSE_SEPARATE_LIBS) $(RT_LIBS)

# Use SymbolicSemantics semantic analysis policy
symbolicSemantics_SOURCES = semantics.C
symbolicSemantics_CPPFLAGS = -DPOLICY_SELECTOR=4 -DSOLVER_SELECTOR=0
symbolicSemantics_LDADD = $(ROSE_LIBS_WITH_PATH) $(ROSE_SEPARATE_LIBS) $(RT_LIBS)

# Use SymbolicSemantics with YicesSolver, invoking "yices" executable
yicesSemanticsExe_SOURCES = semantics.C
yicesSemanticsExe_CPPFLAGS = -DPOLICY_SELECTOR=4 -DSOLVER_SELECTOR=1
yicesSemanticsExe_LDADD = $(ROSE_LIBS_WITH_PATH) $(ROSE_SEPARATE_LIBS) $(RT_LIBS)

# Use SymbolicSemantics with YicesSolver, linked to Yikes library
yicesSemanticsLib_SOURCES = semantics.C
yicesSemanticsLib_CPPFLAGS = -DPOLICY_SELECTOR=4 -DSOLVER_SELECTOR=2
yicesSemanticsLib_LDADD = $(ROSE_LIBS_WITH_PATH) $(ROSE_SEPARATE_LIBS) $(RT_LIBS)

# Disassembles an executable according to various command-line switches.
disassemble_SOURCES = disassemble.C
disassemble_LDADD = $(ROSE_LIBS_WITH_PATH) $(ROSE_SEPARATE_LIBS) $(RT_LIBS)

# Disassemble a file containing bare instructions
disassembleBuffer_SOURCES = disassembleBuffer.C
disassembleBuffer_LDADD = $(ROSE_LIBS_WITH_PATH) $(ROSE_SEPARATE_LIBS) $(RT_LIBS)

testEtherInsns_SOURCES = testEtherInsns.C
testEtherInsns_LDADD = $(ROSE_LIBS_WITH_PATH) $(ROSE_SEPARATE_LIBS) $(RT_LIBS)

# Program to show function boundary information for a binary executable
functionBoundaries_SOURCES=functionBoundaries.C
functionBoundaries_LDADD=$(ROSE_LIBS_WITH_PATH) $(ROSE_SEPARATE_LIBS) $(RT_LIBS)

# Program to add read-only data to ELF core dumps.
expandCoreDump_SOURCES=expandCoreDump.C
expandCoreDump_LDADD=$(ROSE_LIBS_WITH_PATH) $(ROSE_SEPARATE_LIBS) $(RT_LIBS)

# Program that encodes/decodes data similar to ROT-13 but acceping binary data
rot13_SOURCES=rot13.C

# Program to test the assembler (see also "disassemble --assemble")
testAssembler_SOURCES=testAssembler.C
testAssembler_LDADD=$(ROSE_LIBS_WITH_PATH) $(ROSE_SEPARATE_LIBS) $(RT_LIBS)

# Program to test that we can write and then read an AST for a binary executable
testAstIO_SOURCES=testAstIO.C
testAstIO_LDADD=$(ROSE_LIBS_WITH_PATH) $(ROSE_SEPARATE_LIBS) $(RT_LIBS)

# Program to test the RegisterDescriptor and RegisterDictionary classes.
testRegisters_SOURCES=testRegisters.C
testRegisters_LDADD=$(ROSE_LIBS_WITH_PATH) $(ROSE_SEPARATE_LIBS) $(RT_LIBS)

###############################################################################################################################
# DEMOS
#
# These demonstrate various aspects of ROSE's binary executable abilities. They are meant to be run sequentially (regardless
# of make's "-j" switch) and produce output for human consumption.
###############################################################################################################################
DEMO_PHONY_TARGETS=$(patsubst %,demo_%,$(noinst_PROGRAMS))

demos: demos-local

demos-local: $(DEMO_PHONY_TARGETS)

demo_execFormatsTest: execFormatsTest
	@echo; echo; echo "Demo for $<"; echo
	./execFormatsTest $(BINARY_SAMPLES)/buffer2.bin
	@echo "See file buffer2.bin.dump for information regarding the executable format"
	@echo "See file rose-buffer2.bin.s for disassembly of instructions"

demo_testElfStrtab: testElfStrtab demo_execFormatsTest
	@echo; echo; echo "Demo for $<"; echo
	./testElfStrtab $(BINARY_SAMPLES)/arm-poweroff

demo_testElfByteOrder: testElfByteOrder demo_testElfStrtab
	@echo; echo; echo "Demo for $<"; echo
	./testElfByteOrder $(BINARY_SAMPLES)/arm-poweroff

demo_testElfWordSize: testElfWordSize demo_testElfByteOrder
	@echo; echo; echo "Demo for $<"; echo
	./testElfWordSize $(BINARY_SAMPLES)/arm-poweroff

demo_testElfSchulz: testElfSchulz demo_testElfWordSize
	@echo; echo; echo "Demo for $<"; echo
	./testElfSchulz $(BINARY_SAMPLES)/schulz-sample1.so
	./testElfSchulz $(BINARY_SAMPLES)/schulz-sample2.so

demo_testElfConstruct: testElfConstruct demo_testElfSchulz
	@echo; echo; echo "Demo for $<"; echo
	./testElfConstruct

demo_testPeConstruct: testPeConstruct demo_testElfConstruct
	@echo; echo; echo "Demo for $<"; echo
	./testPeConstruct

demo_shiftResizeSection: shiftResizeSection demo_testPeConstruct
	@echo; echo; echo "Demo for $<"; echo
	$(srcdir)/testShiftResizeSection.sh $(BINARY_SAMPLES)/arm-ctrlaltdel >arm-ctrlaltdel.ans

demo_findConstants: findConstants demo_shiftResizeSection
	@echo; echo; echo "Demo for $<"; echo
	./findConstants $(BINARY_SAMPLES)/i686-test1.O3.bin

demo_findConstantsABI: findConstantsABI demo_findConstants
	@echo; echo; echo "Demo for $<"; echo
	./findConstantsABI $(BINARY_SAMPLES)/i686-test1.O3.bin

demo_virtualMachineSemantics: virtualMachineSemantics demo_findConstantsABI
	@echo; echo; echo "Demo for $<"; echo
	./virtualMachineSemantics $(BINARY_SAMPLES)/i686-test1.O3.bin

demo_symbolicSemantics: symbolicSemantics demo_virtualMachineSemantics
	: no demo yet for symbolicSemantics

demo_yicesSemanticsExe: yicesSemanticsExe demo_symbolicSemantics
	: no demo yet for yicesSemanticsExe

demo_yicesSemanticsLib: yicesSemanticsLib demo_yicesSemanticsLib
	: no demo yet for yicesSemanticsLib

demo_disassemble: disassemble demo_yicesSemanticsLib
	@echo; echo; echo "Demo for $<"; echo
	./disassemble -rose:disassembler_search following,immediate,words,allbytes,unused,nonexe,deadend,unknown $(BINARY_SAMPLES)/i686-test1.O0.bin
	@echo "output has been dumped to i686-test1.O0.bin.dump"

demo_disassembleBuffer: disassembleBuffer demo_disassemble
	@echo; echo; echo "Demo for $<"; echo
	./disassembleBuffer $(BINARY_SAMPLES)/buffer2.raw 0x8048310

demo_testAssembler: testAssembler demo_disassembleBuffer
	@echo; echo; echo "Demo for $<"; echo
	./testAssembler $(BINARY_SAMPLES)/buffer2.bin

demo_testBinCFG: testBinCFG demo_testAssembler
	: no demo yet for testBinCFG

demo_expandCoreDump: expandCoreDump demo_testBinCFG
	: no demo yet for expandCoreDump

demo_functionBoundaries: functionBoundaries demo_exapndCoreDump
	@echo; echo; echo "Demo for $<";
	@echo "The functionBoundaries tool prints information about what binary functions were detected and why."
	./functionBoundaries $(BINARY_SAMPLES)/i686-test1.O3.bin

demo_rot13: rot13
	: no demo yet for rot13

demo_testAstIO: testAstIO
	: no demo yet for $<

demo_testRegisters: testRegisters
	: no demo yet for $<


###############################################################################################################################
# TESTS
#
# These are pretty much the same as the demos except they compare the new output with expected output and fail if there
# are any differences.
#
# Each passing test creates a *.result file so that a subsequent "make" doesn't need to rerun the test.
#
#------------------------------------------------------------------------------------------------------------------------------
# -- NOTICE -- NOTICE -- NOTICE -- NOTICE -- NOTICE -- NOTICE -- NOTICE -- NOTICE -- NOTICE -- NOTICE -- NOTICE -- NOTICE --
#
# SOME OF THE TARGETS DEPEND ON OTHER TESTS BECAUSE ROSE SHOULD NOT EXECUTE CONCURRENTLY IN THE SAME WORKING DIRECTORY FOR
# SPECIMEN BINARIES HAVING THE SAME NAMES DUE TO ROSE CREATING FILES IN THE CWD BASED ON THE BASE NAME OF THE SPECIMEN.
# ------------------------------------------------------------------------------------------------------------------------------
#
###############################################################################################################################

# Static tests start here and are individually defined below.
STATIC_TEST_TARGETS = $(patsubst %,test_%.result,$(noinst_PROGRAMS)) test_assembler.result
test_static.result: $(STATIC_TEST_TARGETS)
	@touch $@

# Dynamicly-generated tests start here and their definitions are inserted below by the "build" script.  We make the
# dynamic tests depend on the static test because we're not sure what output files will be generated and we don't want
# the output of dynamic tests causing havoc for the static tests.  The test_sample_binaries.result (along with a whole
# slew of other targets) is created by the "build" script and placed in the generated Makefile.in.
test_dynamic.result: test_static.result
	@$(MAKE) test_sample_binaries.result
	@touch $@

# Static tests...

test_testAstIO.result: testAstIO
	@echo "  TESTING $@"
	@if $(VALGRIND) ./testAstIO $(BINARY_SAMPLES)/i686-test1.O0.bin >$@.tmp 2>&1; \
	  then mv $@.tmp $@; \
	  else sed 's/^/$@> /' <$@.tmp; exit 1; \
         fi

test_execFormatsTest.result: execFormatsTest
	@echo "  TESTING $@ (not currently tested)"
	@touch $@

test_testBinCFG.result: testBinCFG
	@echo "  TESTING $@"
	@if $(VALGRIND) ./testBinCFG $(BINARY_SAMPLES)/libm-2.3.6.so >$@.tmp 2>&1; then mv $@.tmp $@; \
	else sed 's/^/$@> /' < $@.tmp; exit 1; fi

test_testBinCG.result: testBinCG test_testBinCFG.result
	@echo "  TESTING $@"
	@if $(VALGRIND) ./testBinCG $(BINARY_SAMPLES)/libm-2.3.6.so >$@.tmp 2>&1; then mv $@.tmp $@; \
	else sed 's/^/$@> /' < $@.tmp; exit 1; fi

test_testElfStrtab.result: testElfStrtab
	@echo "  TESTING $@"
	@if $(VALGRIND) ./testElfStrtab $(BINARY_SAMPLES)/arm-poweroff >$@.tmp 2>&1; then mv $@.tmp $@; \
	else sed 's/^/$@> /' < $@.tmp; exit 1; fi

# cannot run in parallel with testElfStrtab
test_testElfByteOrder.result: testElfByteOrder test_testElfStrtab.result
	@echo "  TESTING $@"
	@$(VALGRIND) ./testElfByteOrder $(BINARY_SAMPLES)/arm-poweroff >$@.tmp 2>&1; \
	 [ $$? -eq 0 ] && $(VALGRIND) ./execFormatsTest ./arm-poweroff.new >>$@.tmp 2>&1; \
	 [ $$? -eq 0 ] && diff -u ./arm-poweroff.new{,.new} >>$@.tmp 2>&1; \
	 if [ $$? -eq 0 ]; then mv $@.tmp $@; \
	 else sed 's/^/$@> /' < $@.tmp; exit 1; fi

# cannot run in parallel with testElfStrtab or testElfByteOrder
test_testElfWordSize.result: testElfWordSize test_testElfStrtab.result test_testElfByteOrder.result
	@echo "  TESTING $@"
	@$(VALGRIND) ./testElfWordSize -rose:read_executable_file_format_only $(BINARY_SAMPLES)/arm-poweroff >$@.tmp 2>&1; \
	 [ $$? -eq 0 ] && $(VALGRIND) ./execFormatsTest -rose:read_executable_file_format_only ./arm-poweroff.new >>$@.tmp 2>&1; \
	 [ $$? -eq 0 ] && diff -u ./arm-poweroff.new{,.new} >>$@.tmp 2>&1; \
	 if [ $$? -eq 0 ]; then mv $@.tmp $@; \
	 else sed 's/^/$@> /' < $@.tmp; exit 1; fi

test_testElfSchulz_flags = -rose:partitioner_search -leftovers
test_testElfSchulz.result: test_testElfSchulz-1.result test_testElfSchulz-2.result
	@echo "  TESTING $@ (not currently tested)"
	@touch $@

test_testElfSchulz-1.result: testElfSchulz
	@echo "  TESTING $@"
	@$(VALGRIND) ./testElfSchulz $(test_testElfSchulz_flags) \
                              $(BINARY_SAMPLES)/schulz-sample1.so >$@.tmp 2>&1; \
	 [ $$? -eq 0 ] && $(VALGRIND) ./execFormatsTest $(test_testElfSchulz_flags) \
                              ./schulz-sample1.so.new >>$@.tmp 2>&1; \
	 [ $$? -eq 0 ] && $(VALGRIND) ./execFormatsTest $(test_testElfSchulz_flags) \
                              $(BINARY_SAMPLES)/schulz-sample1-p.so >>$@.tmp 2>&1; \
	 [ $$? -eq 0 ] && diff -u schulz-sample1{-p.so,.so.new}.dump >>$@.tmp 2>&1; \
	 [ $$? -eq 0 ] && diff $(BINARY_SAMPLES)/schulz-sample1-p.so schulz-sample1.so.new >>$@.tmp 2>&1; \
	 if [ $$? -eq 0 ]; then mv $@.tmp $@; \
	 else sed 's/^/$@> /' <$@.tmp; exit 1; fi

test_testElfSchulz-2.result: testElfSchulz
	@echo "  TESTING $@"
	@$(VALGRIND) ./testElfSchulz $(test_testElfSchulz_flags) \
                              $(BINARY_SAMPLES)/schulz-sample2.so >$@.tmp 2>&1; \
	 [ $$? -eq 0 ] && $(VALGRIND) ./execFormatsTest $(test_testElfSchulz_flags) \
                              ./schulz-sample2.so.new >>$@.tmp 2>&1; \
	 [ $$? -eq 0 ] && $(VALGRIND) ./execFormatsTest $(test_testElfSchulz_flags) \
                              $(BINARY_SAMPLES)/schulz-sample2-p.so >>$@.tmp 2>&1; \
	 [ $$? -eq 0 ] && diff -u schulz-sample2{-p.so,.so.new}.dump >>$@.tmp 2>&1; \
	 [ $$? -eq 0 ] && diff $(BINARY_SAMPLES)/schulz-sample2-p.so schulz-sample2.so.new >>$@.tmp 2>&1; \
	 if [ $$? -eq 0 ]; then mv $@.tmp $@; \
	 else sed 's/^/$@> /' <$@.tmp; exit 1; fi

test_so_file: test_testBinCFG.result test_testBinCG.result
	@echo "  TESTING $@"
	@if $(VALGRIND) ./execFormatsTest $(BINARY_SAMPLES)/libm-2.3.6.so >$@.tmp 2>&1; \
	 then mv $@.tmp $@; \
	 else sed 's/^/$@> /' <$@.tmp; exit 1; fi

test_testElfConstruct.result: testElfConstruct
	@echo "  TESTING $@"
	@if $(VALGRIND) ./testElfConstruct >$@.tmp 2>&1; \
	 then mv $@.tmp $@; \
	 else sed 's/^/$@> /' <$@.tmp; exit 1; fi

test_testPeConstruct.result: testPeConstruct
	@echo "  TESTING $@"
	@if $(VALGRIND) ./testPeConstruct >$@.tmp 2>&1; \
	 then mv $@.tmp $@; \
	 else sed 's/^/$@> /' <$@.tmp; exit 1; fi

test_shiftResizeSection.result: shiftResizeSection
	@echo "  TESTING $@"
	@$(srcdir)/testShiftResizeSection.sh $(BINARY_SAMPLES)/arm-ctrlaltdel >arm-ctrlaltdel.ans 2>$@.tmp; \
	 [ $$? -eq 0 ] && diff -u {$(srcdir),.}/arm-ctrlaltdel.ans >>$@.tmp 2>&1; \
	 if [ $$? -eq 0 ]; then mv $@.tmp $@; \
	 else sed 's/^/$@> /' <$@.tmp; exit 1; fi

# This test is *very* sensitive to changes to the Disassembler and Partitioner classes because they and this test all use
# the findConstants instruction semantics. If the Disassembler or Partitioner is even slightly changed, it could make a
# different number of calls to the instruction semantics, which changes the sequence number used to generate constant
# names. Therefore, when comparing the test output with the answer, we will renumber all constant names sequentially.
# The test is still sensitive to minor formatting changes in unparseInstruction().
FIND_CONSTANTS_FILTER=perl -p -e '/====/ && ($$seq=0); s/\bv(\d+)\b/$$map{$$1} ||= "V" . ++$$seq/ge'
test_findConstants.result: findConstants
	@echo "  TESTING $@"
	@($(VALGRIND) ./findConstants $(BINARY_SAMPLES)/i686-test1.O3.bin |\
	    $(FIND_CONSTANTS_FILTER) >test_findConstants.ans) 2>$@.tmp; \
	 [ $$? -eq 0 ] && diff -u {$(srcdir),.}/test_findConstants.ans >>$@.tmp 2>&1 ;\
	 if [ $$? -eq 0 ]; then mv $@.tmp $@; \
	 else sed 's/^/$@> /' <$@.tmp; exit 1; fi

test_findConstantsABI.result: findConstantsABI
	@echo "  TESTING $@"
	@($(VALGRIND) ./findConstantsABI $(BINARY_SAMPLES)/i686-test1.O3.bin |\
	    $(FIND_CONSTANTS_FILTER) >test_findConstantsABI.ans) 2>$@.tmp; \
	 [ $$? -eq 0 ] && diff -u {$(srcdir),.}/test_findConstantsABI.ans >>$@.tmp 2>&1; \
	 if [ $$? -eq 0 ]; then mv $@.tmp $@; \
	 else sed 's/^/$@> /' <$@.tmp; exit 1; fi

test_virtualMachineSemantics.result: virtualMachineSemantics
	@echo "  TESTING $@"
	@($(VALGRIND) ./virtualMachineSemantics $(BINARY_SAMPLES)/i686-test1.O3.bin |\
	    $(FIND_CONSTANTS_FILTER) >test_virtualMachineSemantics.ans) 2>$@.tmp; \
	 [ $$? -eq 0 ] && diff -uw {$(srcdir),.}/test_virtualMachineSemantics.ans >>$@.tmp 2>&1; \
	 if [ $$? -eq 0 ]; then mv $@.tmp $@; \
	 else sed 's/^/$@> /' <$@.tmp; exit 1; fi

test_symbolicSemantics.result: symbolicSemantics
	@echo "  TESTING $@"
	@($(VALGRIND) ./symbolicSemantics $(BINARY_SAMPLES)/i686-test1.O3.bin |\
	    $(FIND_CONSTANTS_FILTER) >test_symbolicSemantics.ans) 2>$@.tmp; \
	 [ $$? -eq 0 ] && diff -u {$(srcdir),.}/test_symbolicSemantics.ans >>$@.tmp 2>&1; \
	 if [ $$? -eq 0 ]; then mv $@.tmp $@; \
	 else sed 's/^/$@> /' <$@.tmp; exit 1; fi

test_yicesSemanticsExe.result: yicesSemanticsExe
if HAVE_YICES
	@echo "  TESTING $@"
	@($(VALGRIND) ./yicesSemanticsExe $(BINARY_SAMPLES)/i686-test1.O3.bin |\
	    $(FIND_CONSTANTS_FILTER) >test_yicesSemanticsExe.ans) 2>$@.tmp; \
	 [ $$? -eq 0 ] && diff -u {$(srcdir),.}/test_yicesSemanticsExe.ans >>$@.tmp 2>&1; \
	 if [ $$? -eq 0 ]; then mv $@.tmp $@; \
	 else sed 's/^/$@> /' <$@.tmp; exit 1; fi
else
	@echo "  TESTING $@ (the Yices SMT-solver is not supported for this configuration; test skipped)"
endif

# The yicesSemanticsLib results should be identical to the yicesSemanticsExe results
test_yicesSemanticsLib.result: yicesSemanticsLib
if HAVE_LIBYICES
	@echo "  TESTING $@"
	@($(VALGRIND) ./yicesSemanticsLib $(BINARY_SAMPLES)/i686-test1.O3.bin |\
	    $(FIND_CONSTANTS_FILTER) >test_yicesSemanticsLib.ans) 2>$@.tmp; \
	 [ $$? -eq 0 ] && diff -u $(srcdir)/test_yicesSemanticsExe.ans ./test_yicesSemanticsLib.ans >>$@.tmp 2>&1; \
	 if [ $$? -eq 0 ]; then mv $@.tmp $@; \
	 else sed 's/^/$@> /' <$@.tmp; exit 1; fi
else
	@echo "  TESTING $@ (the Yices SMT-solver is not supported for this configuration; test skipped)"
endif

test_disassemble.result: disassemble
	@echo "  TESTING $@"
	@$(VALGRIND) ./disassemble --show-functions -rose:disassembler_search following,immediate,words,-allbytes,unused,nonexe,deadend,-unknown -rose:partitioner_search -leftovers $(BINARY_SAMPLES)/i686-test1.O0.bin >test_disassemble.ans 2>$@.tmp; \
	 [ $$? -eq 0 ] && diff -u {$(srcdir),.}/test_disassemble.ans >>$@.tmp 2>&1; \
	 if [ $$? -eq 0 ]; then mv $@.tmp $@; \
	 else sed 's/^/$@> /' <$@.tmp; exit 1; fi

test_disassembleBuffer.result: disassembleBuffer
	@echo "  TESTING $@"
	@$(VALGRIND) ./disassembleBuffer $(BINARY_SAMPLES)/buffer2.raw 0x8048310 >test_disassembleBuffer.ans 2>$@.tmp; \
	 [ $$? -eq 0 ] && diff -u {$(srcdir),.}/test_disassembleBuffer.ans >>$@.tmp 2>&1; \
	 if [ $$? -eq 0 ]; then mv $@.tmp $@; \
	 else sed 's/^/$@> /' <$@.tmp; exit 1; fi

# disassemble will exit non-zero if the assembly doesn't result in an encoding identical to the original
# We're using the buffer2.bin from projects/BinQ for now because it's 64-bit; the one in our own srcdir is 32-bit and
# the assembler isn't completely working yet for 32-bit. [RPM 2009-07-21]
test_assembler.result: disassemble
	@echo "  TESTING $@"
	@$(VALGRIND) ./disassemble --quiet --reassemble --show-bad $(top_srcdir)/projects/BinQ/buffer2.bin >$@.tmp 2>&1; \
	 if [ $$? -eq 0 ]; then mv $@.tmp $@; \
	 else sed 's/^/$@> /' <$@.tmp; exit 1; fi

# another assembler test
test_testAssembler.result: testAssembler
	@echo "  TESTING $@"
	@$(VALGRIND) ./testAssembler $(BINARY_SAMPLES)/buffer2.bin >test_testAssembler.ans 2>$@.tmp; \
	 [ $$? -eq 0 ] && diff -u {$(srcdir),.}/test_testAssembler.ans >>$@.tmp 2>&1; \
	 if [ $$? -eq 0 ]; then mv $@.tmp $@; \
	 else sed 's/^/$@> /' <$@.tmp; exit 1; fi

test_testEtherInsns.result: testEtherInsns
	@echo "  TESTING $@ (cannot be run automatically; requires human interaction)"
	@touch $@

test_expandCoreDump.result: expandCoreDump
	@echo "  TESTING $@ (not currently tested)"
	@touch $@

test_rot13.result: rot13
	@echo "  TESTING $@"
	@./rot13 --encode <$(BINARY_SAMPLES)/i686-test1.O0.bin |./rot13 --decode >test_rot13.ans 2>$@.tmp; \
	 [ $$? -eq 0 ] && diff $(BINARY_SAMPLES)/i686-test1.O0.bin test_rot13.ans >>$@.tmp 2>&1; \
	 if [ $$? -eq 0 ]; then mv $@.tmp $@; \
	 else sed 's/^/$@> /' <$@.tmp; exit 1; fi

test_testRegisters.result: testRegisters
	@echo "  TESTING $@"
	@./testRegisters
	@touch $@

# Tests for detecting the locations of functions, written this way for parallelism.
test_functionBoundaries_1.result: functionBoundaries $(BINARY_SAMPLES)/i686-test1.O0.bin test_disassemble.result
	@echo "  TESTING $@"
	@./functionBoundaries $(BINARY_SAMPLES)/i686-test1.O0.bin >functionBoundaries_1.ans 2>$@.tmp; \
	 [ $$? -eq 0 ] && diff -u {$(srcdir),.}/functionBoundaries_1.ans >>$@.tmp 2>&1; \
	 if [ $$? -eq 0 ]; then mv $@.tmp $@; \
	 else sed 's/^/$@> /' <$@.tmp; exit 1; fi
test_functionBoundaries_2.result: functionBoundaries $(BINARY_SAMPLES)/i686-test1.O3.bin test_findConstants.result test_findConstantsABI.result
	@echo "  TESTING $@"
	@./functionBoundaries $(BINARY_SAMPLES)/i686-test1.O3.bin >functionBoundaries_2.ans 2>$@.tmp; \
	 [ $$? -eq 0 ] && diff -u {$(srcdir),.}/functionBoundaries_2.ans >>$@.tmp 2>&1; \
	 if [ $$? -eq 0 ]; then mv $@.tmp $@; \
	 else sed 's/^/$@> /' <$@.tmp; exit 1; fi
test_functionBoundaries_3.result: functionBoundaries $(BINARY_SAMPLES)/i686-test1.O3-stripped.bin
	@echo "  TESTING $@"
	@./functionBoundaries $(BINARY_SAMPLES)/i686-test1.O3-stripped.bin >functionBoundaries_3.ans 2>$@.tmp; \
	 [ $$? -eq 0 ] && diff -u {$(srcdir),.}/functionBoundaries_3.ans >>$@.tmp 2>&1; \
	 if [ $$? -eq 0 ]; then mv $@.tmp $@; \
	 else sed 's/^/$@> /' <$@.tmp; exit 1; fi
test_functionBoundaries.result: test_functionBoundaries_1.result test_functionBoundaries_2.result test_functionBoundaries_3.result
	@touch $@



# The rules in this section of the makefile are generated by the "build" script based on the selection of binary samples
# (usually from the binaries/samples directory) available at that time.  We do it this way for a number of reasons:
#
#  1. Some of the samples have licenses that restrict their distribution.
#  2. Some developers work with malicious software samples that we don't wish to distribute
#  3. ROSE generates file names in the current working directory based on basenames of samples. If the sample directories
#     contain files with duplicate basenames then the tests will fail if those to files happen to be tested in parallel. These
#     dependencies must be represented in the makefile rules.
#
# See scripts/sample_binary_rules.pl for more documentation.

# All sample binary tests have these additional dependencies
SAMPLE_TEST_DEPS = execFormatsTest disassemble

INSERT_SAMPLE_RULES_HERE:



###############################################################################################################################
# Miscellaneous....
###############################################################################################################################

# Don't delete things indiscriminately--sometimes developers have other related files that should not be touched!
MOSTLYCLEANFILES = \
	$(STATIC_TEST_TARGETS) $(addsuffix .tmp, $(STATIC_TEST_TARGETS)) \
	test_testElfSchulz-{1,2}.result test_{static,dynamic}.result \
	a.out arm-ctrlaltdel.ans arm-ctrlaltdel.dump-{1,2,3} arm-ctrlaltdel.new.new \
	arm-poweroff.{new.dump,new.new} rose_arm-ctrlaltdel.new.s rose_arm-poweroff.new.s \
	rose_schulz-sample{1,2}.so.new.s schulz-sample{1,2}.so.{new.dump,new.new} test_findConstants.ans \
	test_disassemble.ans test_disassembleBuffer.ans test_rot13.ans \
	test_functionBoundaries_{1,2,3}.result functionBoundaries_{1,2,3}.ans test_findConstantsABI.ans \
	test_virtualMachineSemantics.ans test_testAssembler.ans test_symbolicSemantics.ans test_yicesSemanticsExe.ans \
	test_yicesSemanticsLib.ans

# mostlyclean-binarysamples is defined by scripts/sample_binary_rules.pl invoked from "build"
mostlyclean-local: mostlyclean-binarysamples

###############################################################################################################################
# The older part of this makefile...
###############################################################################################################################

## Don't use the repository in ../src
#CXX_TEMPLATE_REPOSITORY_PATH = .

if ROSE_USE_SQLITE_DATABASE

# This test program does not require the rest of ROSE so it can be handled locally
bin_PROGRAMS  = runTest testLibraryDb

testLibraryDb_SOURCES = testLibraryDb.C
# testCallGraph_LDADD = $(LIBS_WITH_RPATH) $(ROSE_LIBS)
testLibraryDb_LDADD = $(LIBS_WITH_RPATH) $(ROSE_SEPARATE_LIBS) 

test1: testLibraryDb
	./testLibraryDb
	rm test.db
else

bin_PROGRAMS  = runTest
test1:
	: $@ is only for ROSE_USE_SQLITE_DATABASE

endif
runTest_SOURCES = runTest.C

# testCallGraph_LDADD = $(LIBS_WITH_RPATH) $(ROSE_LIBS)
runTest_LDADD = $(LIBS_WITH_RPATH) $(ROSE_SEPARATE_LIBS)

#TESTCODES = buffer2.bin

# Build the list of object files
#TEST_Objects = ${TESTCODES:.C=.o}

ROSE_FLAGS = -g -rose:verbose 0
# ROSE_FLAGS = 

TEST_TRANSLATOR = ./runTest all $(ROSE_FLAGS)
TESTCODE_INCLUDES =

# DQ (7/12/2004): Modified to run with make -j4 options
#$(TEST_Objects): runTest $(TESTCODES) 
#	@echo "Compiling test code using $(TEST_TRANSLATOR) ..."
#	env SRCDIR="$(srcdir)" $(TEST_TRANSLATOR)

CLEANFILES = unparsed.s callgraph.gml output _binary_tree.dot cfg.dot dfg.dot Templates.DB 

# DQ (3/21/2009): These tests don't appear to run under Cygwin.
if ROSE_BUILD_OS_IS_CYGWIN
check-local:
	@echo "*****************************************************************************************"
	@echo "*** ROSE/tests/roseTests/binaryTests: (commented out for Cygwin) ***"
	@echo "*****************************************************************************************"
else

# DQ (4/8/2009): I have removed the requirement to run rule: test_so_file (added by Thomas)
# I have left the rule in place so that we can have it availalbe for testing (but it only 
# works if BinQ is built which is not the default configuration).
# check-local: runTest test1 $(TEST_RESULT_TARGETS) test_so_file
# Caution: runTest generates the same output files as some $(TEST_RESULT_TARGETS) [RPM 2009-07-21]

check-local: runTest test1 
check-local: runTest test1 test_static.result test_dynamic.result
	@echo "*********************************************************************"
	@echo "*** ROSE/tests/roseTests/binaryTests: passed ***"
	@echo "*********************************************************************"
endif

# Don't delete things indiscriminately!
clean-local:
	rm -rf $(CXX_TEMPLATE_OBJECTS) ii_files ti_files DATABASE DATABASE.dot cfg_x86.dot  cg_x86.dot

distclean-local:
	rm -rf Templates.DB 

else

check-local:
	@echo "**********************************************************************"
	@echo "*** ROSE/tests/roseTests/binaryTests: skipped ***"
	@echo "**********************************************************************"

endif

#include "rose.h"
#include <CallGraph.h>

using namespace std;

#if 0
bool filter ( SgNode *n )
    {
   // false will filter out ALL nodes
      bool filterNode = true;
#if 0
      SgFunctionDeclaration *fct = isSgFunctionDeclaration( n );
      if ( fct != NULL )
         {
           bool ignoreFunction = (fct->get_file_info()->isCompilerGenerated() == true);
           if ( ignoreFunction == true )
                filterNode = false;
         }
#endif
      return filterNode;
    }
#endif

struct filterNodes : public unary_function<CallGraphNode*,bool>{
    public:
      bool operator()(CallGraphNode* test){

              bool returnValue = false;
              SgFunctionDeclaration* CallGraphNode2 = test->functionDeclaration;

              string filename = CallGraphNode2->get_file_info()->get_filename();
              if( filename.find("g++_HEADERS")!=string::npos ||
                  filename.find("/usr/include")!=string::npos){
//               std::cout << "Filter out STL headers " << test->ToString()<<std::endl;
                returnValue= true;
              }
              if(test->ToString().find(string("_"))!=string::npos)
                returnValue = true;
              if(filename.find("rose_edg_macros_and_functions_required_for_gnu.h")!=string::npos)
                 returnValue = true;
         if(CallGraphNode2->get_file_info()->isCompilerGenerated()==true)
            returnValue=true;

         return returnValue;
      }
};



int
main( int argc, char * argv[] ) {
   RoseTestTranslator test;
   //  r = test.translate(argc,argv); // returns an error if any of the ends fails
   SgProject* project = new SgProject(argc, argv);

   CallGraphBuilder CGBuilder( project );
   CGBuilder.buildCallGraph();

   // Classify subgraphs within call graph
   cout << "Classifying...\n";
   CGBuilder.classifyCallGraph();
   cout << "Done classifying\n";
   //  GenerateDotGraph(CGBuilder.getGraph(),"callgraph.dot");

   ClassHierarchyWrapper hier( project );
#ifdef USE_ROSE_SQL_DATABASE_SUPPORT
   hier.setDBName( "ClassHierarchy" );
   hier.createHierarchySchema();
   hier.writeHierarchyToDB();
#endif

   // Use the information in the graph to output a dot file for the call graph

   CallGraphDotOutput output( *(CGBuilder.getGraph()) );

#ifdef USE_ROSE_SQL_DATABASE_SUPPORT
   output.writeToDB( 1, "DATABASE" );
   output.filterNodesByDirectory( "DATABASE", "/export" );
   output.filterNodesByDB( "DATABASE", "__filter.db" );

#ifdef SOLVE_FUNCTION_CALLS_IN_DB
   output.solveVirtualFunctions( "DATABASE", "ClassHierarchy" );
   output.solveFunctionPointers( "DATABASE" );
#endif // SOLVE...

   cout << "Loading from DB...\n";
   CallGraphCreate *newGraph = output.loadGraphFromDB( "DATABASE" );
   cout << "Loaded\n";
#else
   // Not SQL Database case
   printf ("Not using the SQLite Database ... \n");
   CallGraphCreate *newGraph = CGBuilder.getGraph();
#endif // USE_ROSE...

   ostringstream st;
   st << "DATABASE.dot";
   cout << "Generating DOT...\n";

   filterGraph(*newGraph,filterNodes());

   generateDOT( *project );
   cout << "Done with DOT\n";
   GenerateDotGraph(newGraph, st.str());

   printf ("\nLeaving main program ... \n");

   return 0; // backend(project);
}
